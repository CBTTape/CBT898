/*--------------------------ooo00 REXX 00ooo--------------------------*/
/* $DATEMAN: DATEs MANipulation routine.                              */
/*                                                                    */
/* For further details invoke with a parameter of ?.                  */
/* BR is required for help presentation.                              */
/*--------------------------------------------------------------------*/
    dm_ver='V1.19'        /* $DATEMAN version                         */
    bind=0                /* Bind output (box in '*'), 1 or 0         */
    basey2k=45            /* Base year. If yy < basey2k then Y2K date */
    y2kl=mark(-1)         /* Dynamically mark prev source line        */

    Parse source opsys env xcmd . xdsn .
    Parse Arg parm#,parm2l
    Parse Upper ARG functn +3 t_i,parm2,parm3,parm4,parm5,parm6,parm7
    If Word(parm2l,1)='Error' Then Return parm2l
    If env='COMMAND' Then Do
        If Index(parm#,"'")>0 Then parm#=$Cstring(parm#,"'",,1,'*','Y')
        If Index(parm#,',')>0 Then,
            Parse Upper VAR parm# functn ',' parm2 ',' parm3 ',' parm4 ',',
                parm5 ',' parm6 ',' parm7
        Else
             Parse Upper VAR parm# functn parm2 parm3 parm4 parm5 parm6 parm7
        If Wordpos(functn,'HELP ? /? ??')=0 Then Parse VAR functn functn +3 t_i
    End
    If t_i='T' Then #tr=Trace('r')
    ispf=Sysvar(Sysispf)
    If ispf='ACTIVE' Then Do
        Address ISPEXEC;"CONTROL ERRORS RETURN"
    End

ini1:
/*  "CONTROL ERRORS CANCEL"                                           */
    zedsmsg=
    If xcmd/='$DATEMAN' Then Do
        zedlmsg='"$DATEMAN" by any other name is NOT "$DATEMAN". It has',
                'to be called "$DATEMAN" as it explicitly calls itself',
                'for data validation/processing.'
        If ispf='ACTIVE' Then "SETMSG MSG(ISRZ001)"
        Else Say zedlmsg
        If env='FUNCTION' Then Return 'Error :' zedlmsg
        Else Do;Say 'Error :' zedlmsg;Exit;End
    End
    val_USA='U-U U-N UMC U2D U2J U2M U2N J2U M2U NUD T4U VUR RUV SUP'

    functn=Translate(functn);If functn='' Then functn='?'
    If Wordpos(functn,val_USA)>0 Then Do
        yank_f=1;x=U2E('parm2 parm3 parm4 parm5 parm6 parm7')
        functn=Translate(functn,'E','U')
    End
    Else yank_f=0

    Call date_today
    If parm2='' Then Do
       ch1=Substr(functn,1,1)
       Select
           When functn='CAL' Then Parse VAR todaye . '/' . '/' parm2
           When Wordpos(ch1,'E V R')>0 Then parm2=todaye
           When ch1='J' Then parm2=todayj
           Otherwise Nop
       End
    End
    If Wordpos(functn,'HELP ? /? ??')>0 Then Signal help

    Select
        When (functn='J2E') Then Do
            parm2=ver_date(parm2)
            If Word(parm2,1)/='Error' Then,
                date=ddd_ddmm(parm2,parm3)
            Else date=parm2
        End
        When (functn='E2J') Then Do
            parm2=ver_date(parm2)
            If Word(parm2,1)/='Error' Then,
                date=ddmm_ddd(parm2,parm3,parm4)
            Else date=parm2
        End
        When (functn='E-E') Then Do
            parm2=ver_date(parm2)
            If Word(parm2,1)/='Error' Then Do
                ddd1=ddmm_ddd(parm2,4)
                If parm3='' Then parm3=todaye
                parm3=ver_date(parm3)
                If Word(parm3,1)/='Error' Then Do
                    ddd2=ddmm_ddd(parm3,4)
                    date=ddd_l_ddd(ddd1,ddd2,parm4)
                End
                Else date=parm3
            End
            Else date=parm2
        End
        When (functn='J-J') Then Do
            If parm3='' Then parm3=todayj
            parm2=ver_date(parm2)
            If Word(parm2,1)/='Error' Then Do
                parm3=ver_date(parm3)
                If Word(parm3,1)/='Error' Then Do
                    date=ddd_l_ddd(parm2,parm3,parm4)
                End
                Else date=parm3
            End
            Else date=parm2
        End
        When (functn='M-M') Then Do
            m_m_rc=
            If parm2='' Then m_m_rc=ddmm_mmm(todaye,4)
            Else Do
                m_m_rc=ver_date(parm2)
                If Word(m_m_rc,1)/='Error' Then
                    m_m_rc=ddmmm_ddmm(m_m_rc)
            End
            If Word(m_m_rc,1)/='Error' Then Do
                ddd1=ddmm_ddd(m_m_rc,4)
                If parm3='' Then m_m_rc=todaye
                Else Do
                    m_m_rc=ver_date(parm3)
                    If Word(m_m_rc,1)/='Error' Then
                        m_m_rc=ddmmm_ddmm(m_m_rc)
                End
            End
            If Word(m_m_rc,1)/='Error' Then Do
                ddd2=ddmm_ddd(m_m_rc,4)
                date=ddd_l_ddd(ddd1,ddd2,parm4)
            End
            Else date=m_m_rc
        End
        When (functn='E-N') Then Do
            parm2=ver_date(parm2)
            If Word(parm2,1)/='Error' Then Do
                If parm3/=2 Then parm3=4
                If parm4='' Then parm4=-1
                ddd1=ddmm_ddd(parm2,4)
                date=ddd_l_num(ddd1,parm4,4)
                date=ddd_ddmm(date,parm3)
            End
            Else date=parm2
        End
        When (functn='E2M') Then Do
            parm2=ver_date(parm2)
            If Word(parm2,1)/='Error' Then Do
                date=ddmm_mmm(parm2,parm3,parm4,parm5)
            End
            Else date=parm2
        End
        When (functn='J2M') Then Do
            date=ddd_ddmm(parm2,parm3)
            date=ddmm_mmm(date,parm3,parm4)
        End
        When (functn='M2E'| functn='M2J') Then Do
            parm2=ver_date(parm2)
            If Word(parm2,1)/='Error' Then Do
                date=ddmmm_ddmm(parm2,parm3)
                If (functn='M2J') Then date=ddmm_ddd(date,parm3,parm    4)
            End
            Else date=parm2
        End
        When (functn='REV') Then Do
            date=ver_date(parm2,parm3,parm5)
            If Word(date,1)/='Error' Then Do
                If parm3='' Then parm3=Length(yy)
                date=reverse_f(parm2,parm3,parm4,parm5)
            End
            yank_f=0
        End
        When (functn='RJV') Then Do
            date=reverse_j(parm2)
            yank_f=0
        End
        When (functn='N2Y') Then,
            date=days_yydd(parm2,parm3)
        When (functn='E2D' | functn='E2N') Then Do
            date = ver_date(parm2)
            If Word(date,1) /= 'Error' Then,
                date = dow_ddmm(parm2,parm3,parm4)
        End
        When (functn='J2D' | functn='J2N') Then Do
            ddd1 = ddd_ddmm(parm2,parm3)
            date = dow_ddmm(ddd1,parm3,parm4)
        End
        When (functn='EMC') Then Do
            Parse VAR parm2 dd '/' mm '/' yy
            If dd=0 Then Do
                mark=' ';parm2='01/'mm'/'yy
            End
            Else mark='*'
            parm2=ver_date(parm2)
            If Word(parm2,1)/='Error' Then date=ddmm_cal(parm2,parm3)
            Else date=parm2
        End
        When (functn='CAL') Then Do
            If Index(parm2,'.') > 0 | Index(parm2,'/') > 0 Then Do
                zedlmsg = 'Invalid year "'parm2'" for calendar.'
                Signal ext1
            End
            If parm2/='' Then yy=parm2;Else Parse VAR todaye dd '/' mm '/' yy
            If \Datatype(yy,'W') Then Return 8
            If parm4='M' Then date=show_cal(yy,parm3,dd,mm)
            Else              date=show_cal(yy,parm3)
        End
        When (functn='VER') Then,
            date=ver_date(parm2,parm3,parm4,parm5)
        When (functn='T4Y') Then Do
            Parse VAR todaye dd '/' mm '/' yy
            yy=date2t4(yy);date=dd'/'mm'/'yy
        End
        When (functn='T4U') Then Do
            Parse VAR todaye dd '/' mm '/' yy
            yy=date2t4(yy);date=mm'/'dd'/'yy
        End
        When (functn='E2U') Then Do
            date=ver_date(parm2)
            If Word(date,1)='Error' Then Signal ret1
            Parse VAR date dd '/' mm '/' yy
            If parm3/=2 Then yy=date2t4(yy)
            Else If Length(yy)=4 Then yy=Substr(yy,3)
            date=mm'/'dd'/'yy
        End
        When (functn='U2E') Then Do
            If parm2='' Then Parse VAR todaye dd '/' mm '/' yy
            Else Do
                x=U2E('parm2')
                date=ver_date(parm2)
                If Word(date,1)='Error' Then Signal ret1
                Parse VAR date dd '/' mm '/' yy
            End
            If parm3/=2 Then yy=date2t4(yy)
            Else If Length(yy)=4 Then yy=Substr(yy,3)
            date=dd'/'mm'/'yy
        End
        When (functn='NED') Then Do
            If parm2='' Then parm2=todaye
            date=ver_date(parm2)
            If Word(date,1)='Error' Then Signal ret1
            date=Next_E_DOW(date,parm3,parm4,parm5,parm6)
        End
        When (functn='SEP') Then Do
            If parm2='' Then parm2=todaye
            parm2=ver_date(Translate(parm2,'/','-'),parm4)
            If yank_f Then x=E2U('parm2')
            If parm3='-' Then date=Translate(parm2,'-','/')
            Else date=Translate(parm2,'/','-')
            yank_f=0
        End
        Otherwise Do
            zedlmsg='Invalid function type "'functn'" used.'
            Signal ext1
        End
    End

ret1:
    If yank_f Then,
        If Word(date,1)/='Error' Then x=E2U('date')
    If env='FUNCTION' Then Return date;Else Do;Say date;Exit;End


/*--------------------------------------------------------------------*/
/* Conver Toggle USA/European date format                             */
/*--------------------------------------------------------------------*/
U2E:
E2U: Parse Arg xxx
    Do While xxx/=''
        Parse VAR xxx xx xxx
        zz=Value(xx)
        If zz='' | Index(zz,'/')=0 Then Iterate
        Parse VAR zz p1 '/' p2 '/' p3
        zz=p2"/"p1
        If p3<>'' Then zz=zz'/'p3
        Interpret xx'="'zz'"'
    End
    Return 0

/*--------------------------------------------------------------------*/
/* Calculate format dd/mm/yyyy from Julian date                       */
/*--------------------------------------------------------------------*/
ddd_ddmm:Arg dater,datel
    Parse VAR dater yy '.' ddd
    If ddd = '' Then Do
        If Length(dater) = 7 Then Parse VAR dater yy 5 ddd
        Else                      Parse VAR dater yy 3 ddd
    End
    yy = date2t4(yy)
    m#.2  = days_in_feb(yy)
    Do i=1 To 12

        y = m#.i
        If y >= ddd Then Do
            mm = Right(i,2,'0')
            dd = Right(ddd,2,'0')
            Leave
        End
        ddd = ddd - y
    End
    If datel = 2 & Length(yy) = 4 Then yy = Substr(yy,3,2)
    dater = dd'/'mm'/'yy

    Return dater

/*--------------------------------------------------------------------*/
/* Reverse format (std. date)                                         */
/*--------------------------------------------------------------------*/
reverse_f:Arg dater,datel,digits,revi
    If digits='S' Then digits='D'           /* Used to be "S"         */
    If revi /= 'R' Then Parse VAR dater dd '/' mm '/' yy
    Else                Parse VAR dater yy '/' mm '/' dd
    If revi = 'R' Then dater = dater '(reverse date)'
    If yy = '' Then yy = yy#
    yy = date2t4(yy)
    If datel = 2 & Length(yy) = 4 Then yy = Substr(yy,3,2)

    If digits /= 'D' Then Return yy'/'Right(mm,2,'0')'/'Right(dd,2,'0')
    Else                  Return yy||Right(mm,2,'0')||Right(dd,2,'0')

/*--------------------------------------------------------------------*/
/* Reverse format (Julian)                                            */
/*--------------------------------------------------------------------*/
reverse_j: Arg dater
    Parse VAR dater p1 '.' p2;Return p2'.'p1

/*--------------------------------------------------------------------*/
/* Conver format dd/mm/yy to yyyy.ddd                                 */
/*--------------------------------------------------------------------*/
ddmm_ddd:Arg dater,datel,dotr
    If yy = '' Then yy = yy#
    yy = date2t4(yy)
    m#.2 = days_in_feb(yy)
    ddd = 0
    Do i=1 To mm
        j = i -1
        ddd = ddd + m#.j
    End
    ddd   = Right(ddd + dd,3,'0')
    If datel = 2 & Length(yy) = 4 Then yy = Substr(yy,3,2)

    If dotr = 'N' Then Return yy || ddd
    Else               Return yy'.'ddd

/*--------------------------------------------------------------------*/
/* Translate mm to Month name                                         */
/*--------------------------------------------------------------------*/
ddmm_mmm:Arg dater,datel,mthl,case
    Months = set_months()
    Parse VAR dater dd '/' mm '/' yy
    If mm = '' Then mm = Substr(todaye,4,2)
    mmm = Word(months,mm)
    If mthl = '' Then mthl = 3
    If mthl = '*' Then mthl = ''
    Else If Datatype(mthl) = 'NUM' & mthl > 0 Then mmm = Substr(mmm,1,mthl)
    If yy = '' Then yy = yy#
    yy = date2t4(yy)
    If datel = 2 & Length(yy) = 4 Then yy = Substr(yy,3,2)
    If Wordpos(case,'M F')=0 Then mmm=Translate(mmm)
    If case='F' Then Do
        Select
            When dd=1 Then dd=01st.
            When dd=2 Then dd=02nd.
            When dd=3 Then dd=03rd.
            Otherwise  dd=dd'th.'
        End
        mmm=mmm','
    End
    If case/='S' Then dater=dd mmm yy
    Else dater=Substr(yy,Length(yy)-1)mmm||dd

    Return dater

/*--------------------------------------------------------------------*/
/* Translate Month name to mm. Var 'mm' set in 'VER' (military)       */
/*--------------------------------------------------------------------*/
ddmmm_ddmm:Arg dater,datel
    Parse Upper VAR dater dd . yy

    If yy = '' Then yy = yy#
    yy = date2t4(yy)
    If datel = 2 & Length(yy) = 4 Then yy = Substr(yy,3,2)

    Return dd'/'Right(mm,2,'0')'/'yy

/*--------------------------------------------------------------------*/
/* Calculate new Julian date from Julian date an pos/neg displacement */
/*--------------------------------------------------------------------*/
ddd_l_num:Arg dater,dif,datel
    Parse VAR dater yy '.' ddd
    If ddd='' Then Do
        If Length(dater)=7 Then Parse VAR dater yy 5 ddd
        Else                    Parse VAR dater yy 3 ddd
    End
    yy=date2t4(yy);diy=days_in_year(yy)
    ddd=ddd+dif
    Select
        When ddd>diy Then Do While ddd>diy
            ddd=ddd-diy;yy=yy+1;diy=days_in_year(yy)
        End
        When ddd<0 Then Do While ddd<0
            yy=yy-1;diy=days_in_year(yy);ddd=ddd+diy
        End
        Otherwise Nop
    End
    If ddd=0 Then ddd=diy;ddd=Right(ddd,3,'0')
    If datel=2 & Length(yy)=4 Then yy=Substr(yy,3,2)
    dater=yy'.'ddd

    Return dater

/*--------------------------------------------------------------------*/
/* Calculate new Julian date from Julian date an pos/neg displacement */
/*--------------------------------------------------------------------*/
ddd_l_ddd:Arg datet,datef,datel
    If datef > datet Then Do
        x_x   = datet
        datet = datef
        datef = x_x
        sign = -1
    End
    Else sign = 1
    Parse VAR datet yy2 '.' ddd2
    If ddd2 = '' Then Do
        If Length(datet) = 7 Then Parse VAR datet yy2 5 ddd2
        Else                      Parse VAR datet yy2 3 ddd2
    End
    Parse VAR datef yy1 '.' ddd1
    If ddd1 = '' Then Do
        If Length(datef) = 7 Then Parse VAR datef yy1 5 ddd1
        Else                      Parse VAR datef yy1 3 ddd1
    End
    yy1 = date2t4(yy1)
    yy2 = date2t4(yy2)
    Do while yy1 +1 <= yy2
        diy = days_in_year(yy1)
        ddd2 = ddd2 + diy
        yy1 = yy1 +1
    End
    dif = (ddd2 - ddd1) * sign

    Return dif

/*--------------------------------------------------------------------*/
/* Calculate number of years & days from number of days               */
/*--------------------------------------------------------------------*/
days_yydd:Arg dater
    y4=366+(3*365);yt=(dater%y4)*4;dl=dater//y4;yt=yt+(dl%365)
    dt=dl//365

    Return  yt'/'dt

/*--------------------------------------------------------------------*/
/* Calculate day of week from a known model. The model used is        */
/* 30/04/90 which is a Monday.                                        */
/*--------------------------------------------------------------------*/
dow_ddmm:Arg dater,datel,uctran
    diff=$DATEMAN('E-E',dater,'30/04/90',4)    /* Model date 30/04/90 */
    dow#=diff//7
    If dow#<0 Then dow#=dow#+7
    If functn='E2D' | functn='J2D' Then Do
        dow=,
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday',
            'Saturday',
            'Sunday'
        If datel='' Then date=Word(dow,dow#+1)
        Else date=Substr(Word(dow,dow#+1),1,datel)
    End
    Else date=dow#+1

    If uctran='' Then Return Strip(date)
    Else Return Translate(Strip(date))

/*--------------------------------------------------------------------*/
/* Create a monthly callendar for the month from dd/mm/yy             */
/*--------------------------------------------------------------------*/
ddmm_cal:Arg dater,retdata
    Parse VAR dater dd '/' mm '/' yy
    yy=date2t4(yy);m#.2=days_in_feb(yy)
    d1='01/'mm'/'yy;x=dow_ddmm(d1)
    Months=set_months()
    mm=mm+0;month=Word(months,mm)
    dlm='+-'Copies('-',26)'-+'
    line1=0
    myl='¦ 'Centre(Strip(month) Right(yy,4,'0'),26)' ¦'
    If retdata/='R' Then Do
        Address TSO 'CLEAR'
        Say dlm
        Say myl
        Say '¦  S   M   T   W   T   F   S ¦'
        Say dlm
    End
    Else Do
        line1=dlm||myl
        line1=line1||'¦  S   M   T   W   T   F   S ¦'
        line1=line1||dlm
    End
    dow#=dow#+2
    If dow#>7 Then Do
        dow#=1;dayline=
    End
    Else dayline=Substr(' ',1,(dow#-1)*4)
    Do i=1 To m#.mm
        If dow#>7 Then Do
            If retdata/='R' Then Say '¦'dayline'¦'
            Else line1=line1 || '¦'dayline'¦'
            dow#=1;dayline=
        End
        If i=dd Then markit=mark;Else markit=' '
        dayline=dayline  Right(i,2) || markit
        dow#=dow#+1
    End
    If retdata/='R' Then Do
        Say '¦'Substr(dayline,1,28)'¦'
        Say dlm
        If ispf='ACTIVE' Then "CONTROL DISPLAY REFRESH"
        line1='End'
    End
    Else line1=line1||'¦'Substr(dayline,1,28)'¦'||dlm

    Return line1

/*--------------------------------------------------------------------*/
/* Build (show) yearly calendar                                       */
/*--------------------------------------------------------------------*/
show_cal:Arg yy,showhere,ddm,mmm
    cols=2;rows=12%cols
    dlm='+-'Copies('-',26)'-+';liner=
    Do i=1 To rows
        Do j=1 To cols
            k=((i-1)*2)+j
            If k/=mmm Then,
                m.k=$DATEMAN('EMC','00/'Right(k,2,'0')'/'yy,'R')
            Else,
                m.k=$DATEMAN('EMC',ddm'/'Right(mmm,2,'0')'/'yy,'R')
            liner=liner||Substr(m.k,1,Length(m.k)-30)
        End
    End
    If parm5=1 & showhere='R' Then Return liner||dlm

    line2=
    If showhere/='R' Then Address TSO 'CLEAR'
    Do i=1 To 6
        j=((i-1)*2)+1
        xx=m.j;j=j+1;yy=m.j
        Do k=1 To 10
            Parse VAR xx c1 31 xx
            Parse VAR yy c2 31 yy
            If k>4 Then Do
                Select
                    When (c1 = dlm & c1 = c2) Then Iterate
                    When (c2 = dlm & c1 = c2) Then Iterate
                    When (c1 = ''  & c1 = c2) Then Iterate
                    When (c2 = ''  & c1 = c2) Then Iterate
                    When (c1 = dlm & c2 = '') Then Iterate
                    When (c2 = dlm & c1 = '') Then Iterate
                    Otherwise Do
                        If c1 = dlm Then c1 = '¦'Copies(' ',28)'¦'
                        If c2 = dlm Then c2 = '¦'Copies(' ',28)'¦'
                    End
                End
            End
            If showhere/='R' Then,
                Say Substr(c1,1,29) || Substr(c2,1,30)
            Else line2=line2||Substr(c1,1,29)||Substr(c2,1,30)
            If xx='' & yy='' Then Leave
        End
    End
    If showhere/='R' Then Do
        Say Substr(dlm,1,29) || Substr(dlm,1,30)
        If ispf='ACTIVE' Then "CONTROL DISPLAY REFRESH"
/*      line2='End'                                                   */
        line2='***'
    End
    Else line2=line2||Substr(dlm,1,29)||Substr(dlm,1,30)

    Return line2

/*--------------------------------------------------------------------*/
/* Calculate the next day of week                                     */
/*--------------------------------------------------------------------*/
Next_E_DOW:Arg dater,datel,dow,#weeks,qual
    If \Datatype(#weeks,'w') Then #weeks=1;If #weeks<1 Then #weeks=#weeks+1
    #weeks=#weeks-1
    Parse VAR dow ch1 +1 1 dow +2 .
    dow_l='MO TU WE TH FR SA SU'
    dow_n=Wordpos(dow,'. TU . TH . SA SU')
    If dow_n=0 Then Do
        dow_n=Wordpos(ch1,'M . W . F')
        If dow_n=0 Then Return 'Error : Invalid DOW parameter.'
    End
    dow_s=$DATEMAN('E2N',dater)
    diff=dow_n-dow_s
    If diff=0 & qual/='M' Then #weeks=#weeks+1
    Else If diff<0 Then diff=diff+7
    diff=1*(diff+(#weeks*7))
    Return $DATEMAN('E-N',dater,,diff)

/*--------------------------------------------------------------------*/
err1:
    If ispf='ACTIVE' Then "SETMSG MSG(ISRZ001)";Else Say zedlmsg
    Exit
/*--------------------------------------------------------------------*/
/* Verify date...                                                     */
/*--------------------------------------------------------------------*/
ver_date:Arg dater,datel,revi,digit,seperator
    If Index(dater,'.') > 0 Then Signal ver_julian
    dl = Length(dater)
    If Index(dater,'/') = 0 & (dl = 5 | dl = 7) Then Signal ver_julian
    w2 = Word(dater,2)
    If Datatype(w2) = 'CHAR' & w2 /= '' Then Signal ver_military
    If digit = 'D' Then dlm = ''
    Else                dlm = '/'
    If revi /= 'R' Then Do
        If Index(dater,'/') > 0 Then Parse VAR dater dd '/' mm '/' yy
        Else Do
            Parse VAR dater dd +2 mm +2 yy
            If datel/=4 & Length(yy)=4 Then Parse VAR yy 3 yy
        End
    End
    Else Do
        If Index(dater,'/') > 0 Then Parse VAR dater yy '/' mm '/' dd
        Else Do
            If datel = 4 Then Parse VAR dater yy +4 mm +2 dd +2
            Else              Parse VAR dater yy +2 mm +2 dd +2
        End
        dater = dater '(reverse date)'
    End
    If mm = '' Then mm = Substr(todaye,4,2)
    If yy = '' Then yy = Substr(todaye,7,2)

/*--------------------------------------------------------------------*/
/* Test 'YY' for numeric format.                                      */
/*--------------------------------------------------------------------*/
    xx=ver_yy(yy);If Word(xx,1)='Error' Then Return xx

/*--------------------------------------------------------------------*/
/* Test 'MM' for numeric 1 to 12.                                     */
/*--------------------------------------------------------------------*/
    If Datatype(mm)='CHAR' Then Signal err4
    If mm>12 | mm<1 Then Signal err4

/*--------------------------------------------------------------------*/
/* Test 'DD' according to the month and leap year                     */
/*--------------------------------------------------------------------*/
    If Datatype(dd) = 'CHAR' Then Signal err3

    mm=mm+0;If mm=2 Then mm_c=days_in_feb(yy);Else mm_c=m#.mm
    If dd<1 | dd>mm_c Then Signal err3f

    If revi/='R' Then
         Return Right(dd,2,'0') || dlm || Right(mm,2,'0') || dlm || yy
    Else Return yy || dlm || Right(mm,2,'0') || dlm || Right(dd,2,'0')

/*--------------------------------------------------------------------*/
/* Parse and test Julian date format                                  */
/*--------------------------------------------------------------------*/
ver_julian:
    Select
        When dl=5 Then Parse VAR dater yy +2 ddd
        When dl=7 Then Parse VAR dater yy +4 ddd
        Otherwise      Parse VAR dater yy '.' ddd
    End
    If ddd='' Then Do
        If Length(dater)=7 Then Parse VAR dater yy 5 ddd
        Else                    Parse VAR dater yy 3 ddd
    End
    xx=ver_yy(yy);If Word(xx,1)='Error' Then Return xx
/*--------------------------------------------------------------------*/
/* Test 'DDD' according to year                                       */
/*--------------------------------------------------------------------*/
    If Datatype(ddd)='CHAR' Then Signal err3
    If days_in_feb(yy)=29 Then dddmax=366;Else dddmax=365
    If ddd>dddmax Then Do
        dd=ddd;Signal err3
    End
    If digit='D' Then dlm=;Else dlm='.'
    Return yy||dlm||Right(ddd,3,'0')

/*--------------------------------------------------------------------*/
/* Parse and test Military date format                                */
/*--------------------------------------------------------------------*/
ver_military:
    Parse Upper VAR dater dd mmm yy

/*--------------------------------------------------------------------*/
/* Test 'YY' for numeric format.                                      */
/*--------------------------------------------------------------------*/
    If yy='' Then yy=Substr(todaye,7,2)
    xx=ver_yy(yy);If Word(xx,1)='Error' Then Return xx

/*--------------------------------------------------------------------*/
/* Test 'MMM' is valid 3 character month name                         */
/*--------------------------------------------------------------------*/
    If Length(mmm)<3 Then Signal err4m;Else Parse VAR mmm mm3 +3
    mm=Wordpos(mm3,'JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC')
    If mm=0 Then Signal err4m

/*--------------------------------------------------------------------*/
/* Test 'DD' according to the month and leap year                     */
/*--------------------------------------------------------------------*/
    If Datatype(dd)='CHAR' Then Signal err3

    If mm3='FEB' Then mm_c=days_in_feb(yy);Else mm_c=m#.mm
    If dd<1 | dd>mm_c Then Signal err3f

    If digit='M' Then Months=set_months()
    Else Months=Translate(set_months())
    mmm=Word(months,mm);
    If revi/='*' Then Do
        If \Datatype(revi,'W') Then revi=3
        mmm=Substr(mmm,1,revi)
    End
    Return Right(dd,2,'0') mmm yy

/*--------------------------------------------------------------------*/
/* Test 'YY' for numeric format.                                      */
/*--------------------------------------------------------------------*/
ver_yy:
    If Datatype(yy)='CHAR' Then Signal err2
    yy=date2t4(yy);If datel=2 & Length(yy)=4 Then yy=Substr(yy,3,2)
    Return 0

/*--------------------------------------------------------------------*/
/* Expand yy if length < 4.                                           */
/*--------------------------------------------------------------------*/
date2t4:Arg yy
    If Length(yy)<=2 Then Do
        If yy-basey2k>=0 Then yy=1900+yy;Else yy=2000+yy
    End
    If Length(yy)=3 Then yy='0'yy
    Return Right(yy,4,'0')

/*--------------------------------------------------------------------*/
/* Calculate days in Feb.                                             */
/*--------------------------------------------------------------------*/
days_in_feb:Arg yy
    ly=estab_leap_Y(yy)
    If ly='Y' Then Return 29;Else Return 28

/*--------------------------------------------------------------------*/
/* Calculate days in year                                             */
/*--------------------------------------------------------------------*/
days_in_year:Arg yy
    ly=estab_leap_Y(yy)
    If ly='Y' Then Return 366;Else Return 365

/*--------------------------------------------------------------------*/
/* Establish leap year.                                               */
/*--------------------------------------------------------------------*/
estab_leap_Y:Arg yy
    Select
        When (yy // 400  = 0) Then ly='Y'
        When (yy // 100  = 0) Then ly='N'
        When (yy // 4    = 0) Then ly='Y'
        Otherwise ly='N'
    End
    Return ly

/*--------------------------------------------------------------------*/
/* Errors.....                                                        */
/*--------------------------------------------------------------------*/
err2:
    If yank_f Then  x=E2U('dater')
    zedlmsg='YY - Invalid year format "'yy'" entered ->' dater'.'
    Signal ext1

err3:
    If yank_f Then  x=E2U('dater')
    zedlmsg='DD - Invalid day format "'dd'" entered ->' dater'.'
    Signal ext1

err3f:
    If dd/=29 Then Signal err3
    zedlmsg='DD - Invalid day format "'dd'" entered for February.'
    Signal ext1

err4:
    If yank_f Then  x=E2U('dater')
    zedlmsg='MM - Invalid month format "'mm'" entered ->' dater'.'
    Signal ext1

err4m:
    If yank_f Then  x=E2U('dater')
    zedlmsg='MMM - Invalid month format "'mmm'" entered ->' dater'.'

ext1:
    zedlmsg=zedlmsg 'Enter command "'TSO BR $DATEMAN ?'" to get help on',
            'format and parameter values.'
    If env='FUNCTION' Then Return 'Error :' zedlmsg
    Else Do;Say 'Error :' zedlmsg;Exit;End

/*--------------------------------------------------------------------*/
/* Set up variables first time thru                                   */
/*--------------------------------------------------------------------*/
date_today:
    Parse VALUE Date('j') WITH yy# +2 ddd#
    Parse Value '00 31 28 31 30 31 30 31 31 30 31 30 31' With,
        m#.0 m#.1 m#.2 m#.3 m#.4 m#.5 m#.6 m#.7 m#.8 m#.9 m#.10 m#.11 m#.12
    m#.2=days_in_feb(yy#)
    todayj=yy#'.'ddd#;todaye=Date('e')

    Return 0

/*--------------------------------------------------------------------*/
/* Return the months names                                            */
/*--------------------------------------------------------------------*/
set_months: Return,
           'January   ' ||,
           'February  ' ||,
           'March     ' ||,
           'April     ' ||,
           'May       ' ||,
           'June      ' ||,
           'July      ' ||,
           'August    ' ||,
           'September ' ||,
           'October   ' ||,
           'November  ' ||,
           'December  '

/*--------------------------------------------------------------------*/
/* Help instructions.                                                 */
/* Us TF76 to maximise line output without truncation.                */
/* Variable substitution is permitted using REXX wariable between a   */
/* &. (ampersand-dot) delimiters.                                     */
/*--------------------------------------------------------------------*/
help:
    chgchar='&'                              /* Variable substitute   */
    If todaye=parm2 Then when='Todays';Else when='Supplied'
    n_st=mark(2)                            /* Mark next line         */
/*

   Good &TOD. &CNAME..

   $DATEMAN (DATE MANipulation routine) version &DM_VER..
   --------------------------------------------------

   $DATEMAN is a generic routine that manipulates dates in every shape and
   form according to the function parameter (1st.)  passed.

   Parameters must be comma (,) seperated except when used as a command,
   (TSO %$DATEMAN ...) whereby space seperators are permitted.  However, if
   used as a command, no imbedded spaces are permitted and all parameters
   must be entered and NOT defaulted.  Also, in command format, you may not
   use military format dates.  Consequently it is recommended that comma
   seperators be used as both function or command invocation.

   Any error detected will return a message with 'Error' being the 1st. word
   as follows&ERR01.

        &ERR02.

   Note - &WHEN. date (&TODAYE.) is used as the base for most examples.

   You may invoke this help passing a valid European date after the '?' to
   be used in examples.  Please use a space seperator rather than the
   traditional comma.  All dates in this tutorial will use the European date
   format.

   The two digit Y2K indicator is set to year "&BASEY2K." and is set using
   the REXX variable "BASEY2K" whereby,
        If yy < basey2k Then Say 'yy is a Y2K date'
   If this routine survives the passage of time you may need to up this
   value by editting the $DATEMAN source code and changing line '&Y2KL.'
   accordingly.

   ==================================================================
   Permissable functional parameters (in short):
      CAL : Calendar.
      E-E : European date less European date.
      E-N : European date less number.
      EMC : European Monthly Calendar.
      E2D : European to day of week (literal).
      E2J : European to Julian.
      E2M : European to military.
      E2N : European to day of week (numeric).
      E2U : European to USA
      J-J : Julian date less Julian date.
      J2D : Julian to day of week (literal).
      J2E : Julian to European.
      J2M : Julian to military.
      J2N : Julian to day of week (numeric).
      M-M : Military date less Militay date.
      M2E : Military to European.
      M2J : Military to Julian.
      NED : Next European Day-Of-Week date.
      N2Y : Number of days to years and days left (approximation).
      REV : Reverse European format.
      RJV : Reverse Julian format.
      SEP : Change seperator for European date.
      T4Y : Today's date in 4 Year European format.
      U2E : USA to European.
      VER : Verify date.

    For USA (American) date format replace the 'E' with an 'U' (with the
    exceptions of U2E and E2U as these are unique European functions):
      U-U : USA date less USA date.
      U-N : USA date less number.
      UMC : USA Monthly Calendar (as 'EMC' with USA input date).
      U2D : USA to day of week (literal).
      U2J : USA to Julian.
      U2M : USA to military.
      U2N : USA to day of week (numeric).
      J2U : Julian to USA.
      M2U : Military to USA.
      NUD : Next USA Day-Of-Week date.
      RUV : Reverse USA format (generates sortable values).
      SUP : Change seperator for USA date.
      T4U : Today's date in 4 Year USA format.
      VUR : Verify date.

    USA workarounds:
      REV - Use "date_in_revs=$DATEMAN('REV',$DATEMAN('U2E',date))"
            (This was before 'RUV' was developed, however sample left in to
            provide example of creating workaround for other functions not
            available.)

    Other workarounds:
     1. Only E-E, J-J, M-M and U-U are catered for. For any other format do
        a pre-conversion to have both the same format.  Suggest convert the
        second to the first as missing 1st. dates default to todays date,
        formatted to 1st. function character.
        Eg., for an "E-J" calculation use the following command
           dif=$DATEMAN('E-E',date1E,$DATEMAN('J2E',date2J))
        and for an "J-M" calculation use the following command
           dif=$DATEMAN('J-J',,$DATEMAN('M2J',date2M))
        Note in the second example above, the missing date1 will have
        today's date ( &TODAYJ. ) automatically inserted.

    Valid input date formats:
    1. European.
       dd/mm/yyyy, dd/mm/yy, d/m/y, dd/mm, d/m, ddmmyyyy, ddmmyy, ddmm and
       dd will all be interpreted as dd/mm/yyyy (using 4 digit year).  With
       '/' used as sepertors, leading zeros can be dropped for 'dd' and
       'mm'.
    2. USA.
       mm/dd/yyyy, mm/dd/yy, m/d/y, mm/dd, m/d, mmddyyyy, mmddyy, mmdd and
       dd will all be interpreted as mm/dd/yyyy (using 4 digit year).  With
       '/' used as sepertors, leading zeros can be dropped for 'mm' and
       'dd'.
    3. Julian.
       yyyy.ddd, yy.ddd, yyyyddd and yyddd will all be interpreted as
       yyyy.ddd (using 4 digit year).
    4. Military.
       dd mmm yyyy and dd mmm yy will all be interpreted as dd mmm yyyy
       (using 4 digit year). 'mmm' can be full month name, however, will be
       processed as per supplementary parameters.

    Miscellaneous:
     1. DO NOT rename $DATEMAN. $DATEMAN Calls itself for validation and
        specific conversions and as such the routine's name is hard coded in
        the member.
     2. For new users, it is suggested that you set up a test REXX driver
        and invoke the required function ising default date and user
        supplied dates and toy with the parameters to ensure what you get is
        what you want.  Also consider that output from $DATEMAN may be
        included in $DATEMAN commands, eg.
         newdate=$DATEMAN('REV',$DATEMAN('E-N',dd'/'mm'/'yy,7*altr_#,2),2,'S')
     3. For debugging, you may append a 'T' to the function to turn trace on,
         eg. $DATEMAN('M2NT','&TODAYM.')
                         ~
        However, it is not recommended unless you are familiar with REXX and
        do expect heaps of output. If "BR" function is available, suggest
        you use it to make the display manageable, eg.
           TSO %BR %$DATEMAN 'M2NT','&TODAYM.'
                - or -
           TSO %BR x=$DATEMAN('M2NT','&TODAYM.')
        Notes (on above command):
          - Absence of brackets for the command format.
          - Use of comma seperator as date has imbedded spaces making
            parameter identification based on words difficult.
          - Quotes left in for readability. Quotes (') will automatically be
            removed.

     4. Passed dates will automatically be verified for valid format.  The
        VER (VUR) functions are provided to specifically verify dates and
        return expanded date/value. If the date is invalid, 'Error' will be
        returned as the first word.
     5. RJV (reverse Julian) is the same for both European and USA formats.


   ==================================================================

   Permissable parameters (in detail):
      parm1 - Function id. Mandatory value to determine action required:

                CAL : Calendar. Reinvokes itself using the 'EMC' function
                      code to build a calendar month by month.
                      The following are positional parms:
                        2nd. - Year, as 2 or 4 bytes (default this year).
                        3rd. - Literal 'R' to indicate return of the full
                               calendar in one contiguous string to the
                               caller.  Without this parameter, the calendar
                               will be displayed on a cleared screen.
                        4th. - Literal 'M' if you want the current date
                               marked on the calendar.  If you 'M' a non
                               current year, the calendar will indicate what
                               day todays date would fall.
                        5th. - 1/2 to indicate the number of columns
                               (months) per line. The default is 2 (or more
                               specifically NOT 1 as the default output is
                               to the screen). Value of 1 without the 'R'
                               parameter is ignored.
                      If the 'R' option is used, you may parse the returned
                      string as follows:
                        1 col  - 30 bytes.
                        2 cols - 59 bytes.
                      Example of use (see "EMC" below):
                          $DATEMAN('CAL',&YY.,'R',,1)

                E-E : Date less date. Both dates in European, 'dd/mm/yy'
                      format. (Default missing date is today.)
                        2nd. - European date.
                        3rd. - European date.
                      Eg.,
                          $DATEMAN('E-E','&TODAYE.','29/02/2000') -> &DF0.

                E-N : Date less number (date in 'dd/mm/yy' format).
                        2nd. - European date.
                        3rd. - Optional output year length. Default is 4.
                        4rd. - positive or negative integer.
                      Number can be either a positive or negative integer
                      (default todays date and -1). Eg.
                          $DATEMAN('E-N','&TODAYE.',,-185) -> &DF1.
                          $DATEMAN('E-N','&TODAYE.',,+185) -> &DF2.

                      NOTEs:
                       - This is not literaly LESS but rather number
                         'displacement' from date. The number is either a
                         +/- offset from the date.
                       - There is no Julian format of this function.  If the
                         format is considered problematic, convert the
                         Julian date to European using $DATEMAN, establish
                         offset and convert back to Julian format.

                EMC : European Monthly Calendar.
                        2nd. - European date.
                        3rd. - Optional 'R'.
                      Creates/displays a month calendar including the date
                      passed. It will tag the day passed with an '*'. You
                      can bypass the tagging by using day 00 (only time when
                      day 00 will pass verification).  This is a handy
                      feature when you want to generate your own calendar by
                      using parameter 'R' (return data) which can then be
                      subsequently broken down into 30 byte line elements.
                      Eg., after parsing:

                          $DATEMAN('EMC','&TODAYE.','R')
                          ->  &C11.
                              &C12.
                              &C13.
                              &C14.
                              &C15.
                              &C16.
                              &C17.
                              &C18.
                              &C19.
                              &C110.
                              &C111.

                          $DATEMAN('EMC','&DATE1.','R')  <- Next month
                          ->  &C21.
                              &C22.
                              &C23.
                              &C24.
                              &C25.
                              &C26.
                              &C27.
                              &C28.
                              &C29.
                              &C210.
                              &C211.
                E2D : Day of week in lower case with first char capital.
                        2nd. - European date.
                        3rd. - Optional returned length. Default is full
                               literal length.
                        4th. - Optional upper case translation (non blank).
                      Returns a literal, eg.,
                          $DATEMAN('E2D','&TODAYE.')       -> &DOW..
                          $DATEMAN('E2D','&TODAYE.',3   )  -> &DOW1..
                          $DATEMAN('E2D','&TODAYE.',4,'U') -> &DOW2..

                E2J : European to Julian.
                        2nd. - European date.
                        3rd. - Optional output year length. Default is 4.
                        4th. - Optional 'N' to indicate no '.'.
                      Output is in yy.ddd or yyyy.ddd format.
                          $DATEMAN('E2J','&T4Y1.')     -> &E2J1..
                          $DATEMAN('E2J','&T4Y1.',2,N) -> &E2J2..

                E2M : European to military.
                        2nd. - European date.
                        3rd. - Optional output year length. Default is 4.
                        4th. - Optional output month length. Default is 3.
                               For full month length use parameter of "*".
                        5th. - Optional 'M' to indicate mixed case month,
                               (ie. Lower case with first capital).
                               Use 'F' to indicate mixed case month and append
                               the day text (eg. 1st., 2nd., 3rd. or 10th.)
                               Use 'S' to return sortable format of yymmmdd.
                      Returns 'dd mmm yyyy' (with the exception of 'S' 5th.
                      parm).
                      You may send truncated european format for apropriate
                      expansion. Eg.,
                          $DATEMAN('E2M',&D1.)           -> &DD. &MM1. &YY.
                          $DATEMAN('E2M','&D21./&M2.',,,'M') -> &D2. &MM2. &YY.
                          $DATEMAN('E2M',&D1.,2,'*','M') -> &DD. &MMM. &Y2.
                          $DATEMAN('E2M',&D1.,2,'*','F') -> &MIL3.
                          $DATEMAN('E2M',&D1.,2,,'S')    -> &MIL4.

                E2N : Returns the day of week as a number in the range of 1
                      to 7 representing Monday to Sunday respectively. Eg.,
                          $DATEMAN('E2N','&TODAYE.') -> &DON. (for &DOW.)


                E2U : European to USA, 'dd/mm/yy' format. (Default missing
                      date is today.)
                        2nd. - Earopean date (default is today).
                        3rd. - Optional output year length. Default is 4.
                      Eg.,
                          $DATEMAN('E2U','&T4Y1.') -> &E2U1.
                      NOTE - While "E2U" and "U2E" both toggle the 'p1' and
                      'p2' parts of date "p1/p2/p3" the difference with the
                      two functions is in the verification process.

                J-J : Date less date. Both dates in Julian, 'yy.ddd' format.
                      (Default missing date is today.)
                        2nd. - Julian date.
                        3rd. - Julian date.

                J2D : Day of week (date in Julian format).
                        2nd. - Julian date.
                        3rd. - Optional returned length. Default is full
                               literal length.
                      literal, eg.,
                          $DATEMAN('J2D','&TODAYJ.') -> &DOW.

                J2E : Julian to European. Reverse of E2J.
                        2nd. - Julian date.
                        3rd. - Optional output year length. Default is 4.

                J2M : Julian to military format.
                      Similar to 'E2D', however, there are no shorcuts for
                      Julian date format.

                J2N : Returns the day of week as a number in the range of 1
                      to 7 representing Monday to Sunday respectively. Eg.,
                          $DATEMAN('J2N','&TODAYJ.') -> &DON. (for &DOW.)

                M-M : Date less date. Both dates in Military 'dd mmm yy'
                      format. (Default missing date is today.)
                        2nd. - Military date (3 char month).
                        3rd. - Military date (3 char month).

                M2E : Military to European.
                        2nd. - European date.
                        3rd. - Optional output year length. Default is 4.
                      Input must be in format 'dd mmm yyyy'. 'mmm' must be
                      the three character month (not case sensitive) and
                      'yyyy' can be optional 2 or 4 digits. Eg.,
                          $DATEMAN('M2E','&MIL0.')   -> &MIL1.
                          $DATEMAN('M2E','&MIL0.',2) -> &MIL2.

                M2J : Military to Julian. Same rules as for M2E.
                        4th. - Optional 'N' to indicate no '.'.

                NED : Next European Day-Of-Week date.
                        2nd. - European date.
                        3rd. - Optional output year length. Default is 4.
                        4rd. - Day of week literal. 1 or 2 uniquely
                               identifiable character for each day of week
                               literal.
                        5th. - Number of "weeks" in the future. The default
                               is 1 (next day of week match).
                               You can use this option, for example, to
                               return the 3rd. SUnday of a month by setting
                               the source date as 01/mm/yyyy (watch the
                               setting of parm5 as it may conflict with your
                               wishes as default is ignore today if day
                               matches).
                               Blank, non-digit or 0 will default to 1.
                        6th. - Match indicator.
                               'M' - Return date if it matches.
                               'N' - Ignore date if matches and return NEXT
                                     date. This is the default.
                               This parameter is not applicable if the DOW
                               is NOT today (or the data entered).
                               Negative numbers are acceptable.
                      Returns a literal, eg.,
                          $DATEMAN('NED',,'W')                   -> &NED0..
                          $DATEMAN('NED','&TODAYE.',,'&DW.')     -> &NED1..
                          $DATEMAN('NED','&TODAYE.',,'&DW.',,'M')-> &NED2..
                          $DATEMAN('NED','&TODAYE.',,'&DW.',4,'M')
                                                                 -> &NED3..
                          $DATEMAN('NED','&TODAYE.',,'&DW.',-4,'M')
                                                                 -> &NED4..

                N2Y : Number of days to years (and days left).  Input is
                      days, output is in format 'yy/dd'.  Will make
                      compensation for leap years ever 4 years and should
                      only be used to estimate number of years for large
                      number of days. Eg.,
                          $DATEMAN('N2Y',1825) -> &N2Y..
                      P.S. If you used your birthday as the tutorial date,
                           you should be roughly,
                               &URAGE. months old.
                           (Assuming you didn't forget the '19' otherwise
                           you are not yet born.)

                REV : Reverse European format.
                        2nd. - European date.
                        3rd. - Optional year returned length. Default is 4.
                        4th. - Optional 'D' to indicate Digits only.
                        5th. - Optional 'R' already in reverse order.
                      Input dd/mm/yy, output is yy/mm/dd with dd and mm zero
                      padded if applicable. Use parameter 3 to indicate YY
                      length.
                      Use 'D' as positional 4th.  parameter to indicate
                      'Sorting' sequence of digits only and the '/' will be
                      omitted. (This parameter used to be 'S' and is backward
                      compatible. However, I suggest you use 'D' only.)

                      Use 'R' as positional 5th.  parameter to
                      indicate that dates are already in reverse order
                      (required for date verification purposes) and usually
                      combined with the 'D' parameter to remove '/'. Also
                      handy for padding out already reversed date.

                      Eg.,
                          $DATEMAN('REV','&D1./&M1.')            -> &REV1..
                          $DATEMAN('REV','&D1./&M1.',2,'D')      -> &REV2..
                      Note: The USA version would generate,
                          $DATEMAN('RUV','&T4U.')      -> &RUV1..
                      Note: The special affects,
                          $DATEMAN('REV','1/2/3',4)         -> 2003/02/01
                          $DATEMAN('REV','1/2/3',4,'D')     -> 20030201
                          $DATEMAN('REV','1/2/3',4,'D','R') -> 20010203

                RJV : Reverse Julian format.
                        2nd. - Julian date.
                        3rd. - Optional 'D' to indicate Digits only.
                      Input ddd.yy, ddd.yyy, yy.ddd or yyyy.ddd only and it
                      must have the '.' seperator.
                      The days and years are toggled. Consequently year
                      length is meaningless.
                      Once the date is reversed using  be 'D' option it then
                      cannot be reversed as it would be difficult to evaluate
                      format.

                      Eg.,
                          $DATEMAN('RJV','&TODAYJ.')           -> &RJV1 ..

                SEP : Change seperator European.
                        2nd. - European date (default today).
                        3rd. - Desired seperator.
                      Use this function to change seperators between '/' and
                      '-'.  The defaulr is to change to '/'.
                      Use this feature to verify or process hyphen seperated
                      dates.  Eg.,
                          jd=$DATEMAN('E2J',$DATEMAN('SEP','&HYPSEP.'),'/')
                      NOTE - This function and it's USA "SUP" counterpart are
                             the only ones that will accept dates of the
                             format nn-nn-nn.  Furthermore it only accepts it
                             to perform a conversion.  If the dates you
                             process are in the hyphenated format, convert
                             them to slash, process and convert back.

                SUP : Change seperator USA.
                        2nd. - USA date (default today).
                        3rd. - Desired seperator.
                      Same process as "SEP" except that date defaults to USA
                      format of today.

                T4U : Today's date in 4 Year USA format. Output is
                      'mm/dd/yyyy'. For 2 digit 'yy' use the normal
                      "date('u')" function.
                          Date('U')      -> &DTU..       - but -
                          $DATEMAN('T4U') -> &T4YU..

                T4Y : Today's date in 4 Year European format. Output is
                      'dd/mm/yyyy'. For 2 digit 'yy' use the normal
                      "date('e')" function.
                          Date('E')      -> &DTE..       - but -
                          $DATEMAN('T4Y') -> &T4Y1..

                U2E : USA to European, 'mm/dd/yy' format. (Default missing
                      date is today.)
                        2nd. - USA date (default is today).
                        3rd. - Optional output year length. Default is 4.
                      Eg.,
                          $DATEMAN('U2E','&E2U1.')   -> &T4Y1.
                          $DATEMAN('U2E','&E2U1.',2) -> &DTE.
                      NOTE - While "E2U" and "U2E" both toggle the 'p1' and
                      'p2' parts of date "p1/p2/p3" the difference with the
                      two functions is in the verification process.

                VER : Verify date.
                        2nd. - European/Julian date. (May be truncated.)
                        3rd. - Optional return year length. Default is 4.
                        4th. - Optional 'R' to indicate that date is in
                               reverse (yy/mm/dd) format. (May NOT be
                               truncated.
                        5th. - Optional 'D' to indicate that date is to be
                               returned in Digits only and not to be edited
                               with the '.' for Julian or '/' for European
                               fromats.
                        For Militay dates:
                        4th. - Optional output month length. Default is 3.
                               For full month length use parameter of "*".
                        5th. - Optional 'M' to indicate mixed case month,
                               (ie. Lower case with first capital).
                      Date must be in 'dd/mm/yy', 'ddmmyy', 'yy.ddd',
                      'yyddd', 'dd mmm yy', or 'yy/mm/dd' (for reverse)
                      format. The year can be either 'yy' or 'yyyy'.  Dates
                      without delimiters and 5 or 7 digits long will be
                      assumed to be yyddd or yyyyddd respectively.

                      Word 1 of result contains date (zero padded) or value
                      'Error'. If in error Word 3 will contain the value YY,
                      MM or DD depending on offending initial type
                      encountered.  For military format the month must be
                      three bytes.

                      If the date supplied is incomplete, the European
                      format will be assumed and the expanded date returned,
                      eg.,
                        &D1.              -> &DD./&MM./&YY.
                        &D1.,,,D          -> &DD.&MM.&YY.
                        &D1.&M1.             -> &DD./&MM./&YY.
                        &D1./&M1.            -> &DD./&MM./&YY.
                        &VR1.,,R   -> &VR1R.
                        &VR1.,,R,D -> &VR2R.
                        &D1./0@ -> &ERR1..
                      It is recommended that truncated dates without '/'
                      delimeters be zero padded.
                      For reverse format, all the yy, mm and dd must be
                      supplied

                ?   : This tutorial
                        2nd. - European date to be used as the examples
                               base. (Sorry Yanks, no USA format.)

      parm2 - Date in 'dd/mm/yy', 'ddmmyy', 'yyddd' or 'yy.ddd' format for
              all functions except N2Y where the format is 'dddddd' and CAL
              where the value is 'yy'.
              In all cases year may be specified as 'yyyy'.

      parm3 - In MOST cases where applicalbe this is an optional year length
              value either 2 or 4. (Default is 4.) Otherwise refer 'parmX'
              below.

      parmX - Remaining parameters and format are function dependant and are
              discussed in detail under each fubction.

*/
    n_en=mark(-2)                           /* Mark prev 2 line       */
/*  Parse VAR parm# . parm2 .                                         */
    Parse Value Time() With hh ':' 1 time +5
    Select
        When hh<12 Then tod='morning'
        When hh<18 Then tod='afternoon'
        Otherwise tod='evening'
    End

    If parm2='' Then parm2=todaye
    If functn/= '??' Then Do
        x=BR( '%$DATEMAN ??' parm2 '/NC')
        Exit
    End
    err02='Error : error_text';err01=':'
    If parm2/='' Then Do
        x=$DATEMAN('VER',parm2);If Word(x,1)/='Error' Then todaye=x
        Else Do
            err01=' from YOUR invalid input:';err02=x;when='Todays'
        End
    End
    xx=$DATEMAN('N2Y',$DATEMAN('E-E',,todaye))
    Parse VAR xx vv '/' zz;urage=vv 'years' Format(zz/30.42,,0)
    Parse VAR todaye dd '/' mm '/' y1;Parse Var y1 3 y2
    todayj=$DATEMAN('E2J',todaye)
    todaym=$DATEMAN('E2M',todaye)
    rjv1=$DATEMAN('RJV',todayj)
    t4u=$DATEMAN('E2U',todaye)
    mm1 = Word('JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC',mm)
    mmm = Word(set_months(),mm)
    mil0= Date()
    mil0= $DATEMAN('E2M',todaye,,,'M')
    mil1= $DATEMAN('M2E',mil0)
    mil2= $DATEMAN('M2E',mil0,2)
    mil3= $DATEMAN('E2M',todaye,2,'*','F')
    mil4= $DATEMAN('E2M',todaye,2,,'S')
    yy4 = date2t4(y1)
    d1=dd+0;m1=mm+0;m2=mm+1;If m2>12 Then m2=1
    Parse Value $DATEMAN('E-N',d1'/'m1,,m#.m1) With d2 '/' .
    rev1= $DATEMAN('REV',d1'/'m1'/'y1)
    rev2= $DATEMAN('REV',d1'/'m1'/'y1,2,'D')
    ruv1= $DATEMAN('RUV',t4u)
    t4y1=$DATEMAN('VER',todaye,4);t4yu=$DATEMAN('E2U',t4y1)
    dte=$DATEMAN('VER',t4y1,2);dtu=$DATEMAN('E2U',dte,2)
    hypsep=$DATEMAN('SEP',todaye,'-')
    d21 = d2+0
    mm2 = Substr(Word(set_months(),m2),1,3)
    ned0=$DATEMAN('NED',Date('e'),,'W')
    dw=$DATEMAN('E2D',,2,'U')
    ned1=$DATEMAN('NED',todaye,,dw)
    ned2=$DATEMAN('NED',todaye,,dw,,'M')
    ned3=$DATEMAN('NED',todaye,,dw,4,'M')
    ned4=$DATEMAN('NED',todaye,,dw,-4,'M')
    dow = $DATEMAN('E2D',todaye)
    dow1= $DATEMAN('E2D',todaye,3)
    dow2= $DATEMAN('E2D',todaye,4,'U')
    don = $DATEMAN('E2N',todaye)
    df0 = $DATEMAN('E-E',todaye,'29/02/2000')
    df1 = $DATEMAN('E-N',todaye,,-185)
    df2 = $DATEMAN('E-N',todaye,,185)
    cal = $DATEMAN('EMC',todaye,'R')
    n2y = $DATEMAN('N2Y',1825)
    e2j1= $DATEMAN('E2J',t4y1)
    e2j2= $DATEMAN('E2J',t4y1,2,'N')
    err1= $DATEMAN('VER',d1'/0@')
    vr1 = $DATEMAN('REV',t4y1)
    vr1r= $DATEMAN('VER',vr1,,R)
    vr2r= $DATEMAN('VER',vr1r,,R,D)
    e2u1= $DATEMAN('E2U',t4y1)
    Do i=1 To 11
        Parse VAR cal xx +30 cal
        Interpret 'c1'i '= xx'
    End
    xx=mm+1;vv=yy4
    If xx=13 Then Do
        xx=1;vv=vv+1
    End
    date1='00/'Right(xx,2,'0')'/'vv
    cal=$DATEMAN('EMC',date1,'R')
    Do i=1 To 11
        Parse VAR cal xx +30 cal;Interpret 'c2'i'=xx'
    End

    "CONTROL ERRORS RETURN"
    Signal On Syntax Name ret_syntax_1
    cname='there';cname=$Whoami('C')
ret_syntax_1:

    If parm3/='/NC' Then Address TSO "CLEAR"
    If bind Then Say Centre(' ooo000OOOO000ooo ',79,'*')
    Do i=n_st To n_en
        line=Sourceline(i)
        Do While Index(line,chgchar)>0
            Interpret "Parse VAR line p1 '"chgchar"' var '.' p2"
            Interpret 'line=p1||'var'||p2'
        End
        If bind Then Say '*'Substr(line,1,77)'*'
        Else Say Substr(line,1,79)
    End
    If bind Then Say Centre(' End ',79,'*')
    Exit 0

Mark: Arg diff;If Datatype(diff)/='NUM' Then diff=1;Return sigl+diff
