/*--------------------------ooo00 REXX 00ooo--------------------------*/
/*                                                                    */
/* BFI (Bms map from Ispf panel):    V2.02                            */
/*                                                                    */
/* Macro to create a BMS map from an ISPF panel.                      */
/* This panel should have been tested under option 7.2.               */
/*                                                                    */
/* The following additions are required to successfully generate a    */
/* BMS map:                                                           */
/*  1 - ZVARS                                                         */
/*      In the )INIT section syntactically correct .ZVARS definition  */
/*      for each Z variable placeholder. (This should not be an issue */
/*      as the panel will fail if this is incorrect.)                 */
/*  2 - FSET                                                          */
/*      Follows the same format as the .ZVARS except that &FSET is    */
/*      used in the equate field. As this is not an ISPF feature, any */
/*      invalid format may not generate an ISPF dialogue error.  This */
/*      value is used to contrrol the modified data tag using the     */
/*      FSET attribute identifier.                                    */
/*  3 - INITx                                                         */
/*      Follows the same format as the &FSET above. This value is used*/
/*      to set 'INITIAL=...' entries for I/O variables. (By default,  */
/*      I/O fields are left to the processing program for             */
/*      initialisation.                                               */
/*  4 - CURSOR                                                        */
/*      In the )INIT or first hit in any other section any .CURSOR    */
/*      assignment will be identified and an IC value will be         */
/*      included in the attribute parameter for the appropriate       */
/*      field. (If multiple .CURSOR equates are found, the first      */
/*      occurance will be used.)                                      */
/*                                                                    */
/* The expand feature of the )BODY section is catered for. However,   */
/* it may be prudent to check output.                                 */
/*                                                                    */
/* The following equates should be set up after the ')END' panel      */
/* command to ensure you do not get a panel error. (These equates are */
/* generated when using the BTI feature.)                             */
/*   &I_var = 'input_picture'                                         */
/*   &O_var = 'output_picture'                                        */
/*   &N_var = 'alternale_COBOL_name'                                  */
/*                                                                    */
/* Parameters:                                                        */
/*   parm1  - ISPF panel name (must be in the same directory for PC). */
/*   parm2  - 'PC' if running on a PC. This is required as certain    */
/*            syntax differ from mainframe to PC.                     */
/*                                                                    */
/* GOTCHAs:                                                           */
/*  1. Do not use variables in the )ATTR section.                     */
/*  2. Do not use use panel build logic in the )INIT section.         */
/*  3. Confirm EXPAND(..) logic generates desired results.            */
/*  4. Initialisation of I/O fields should be defined after the )END  */
/*     section using &I_* and &O_* variables as well as in the )INIT  */
/*     section against the original variable name.                    */
/*  5. Using macro while editing original panel will cream it with    */
/*     the BMS map.                                                   */
/*  6. Translation 'TRNK' will truncate initial values by removing    */
/*     trailing blanks. This requires a clear screen before map       */
/*     display.                                                       */
/*                                                                    */
/*  Members needed to fully package this processing:                  */
/*   REXX:                                                            */
/*     BFI      - BMS from ISPF main driver. Use this to:             */
/*                 1. Generate BMS macro from ISPF panel.             */
/*                 2. Assemble BMS macro.                             */
/*                 3. Set up COBOL/PL1 name equates at end of panel.  */
/*     BFIDH    - Dynamic tutorial. (Requires access to HELPDRVR).    */
/*     BFIMR    o COBOL copy-book source redefine generator. Requires */
/*                COBOL name generator flag to be on in BFI process.  */
/*     BFIMRO   o BFIMR Occurs evaluation.                            */
/*     BFIPSYS  o Dedicated BFI extension for PaySys P/L....          */
/*     BTI      o BMS to ISPF main driver. Use this to reverse        */
/*                engineer a BMS macro and convert it to an ISPF panel*/
/*                for modifications and subsequent BFIing.            */
/*     HELPDRVR o Dynamic tutorial driver.  See HELPDRVR for its      */
/*                dedicated packaging details.                        */
/*     TP       o Routine to permit panel testing during edit session.*/
/*                properly generated.                                 */
/*     XD       o Exclude duplicates macro.                           */
/*     ZVARS    o Quick dirty to ensure the ZVARS ISPF command is     */
/*                properly generated.                                 */
/*     $WORDAT  - Subroutine to identify word at column position.     */
/*                (Required if you use include/ignore line range      */
/*                 "1-n2"feature.)                                    */
/*   Panels:                                                          */
/*     BFIP     - BMS from ISPF parameter entry panel.                */
/*     BTIP     - BMS to ISPF parameter entry panel.                  */
/*     BFIMRP   - COBOL source redines copy-book generator.           */
/*     BFIH*    - Obsolete - Help panels for BFI and BTI.             */
/*                                                                    */
/*   Skeletons:                                                       */
/*     BFIS     - JCL to generate DSECT and loadmodule.               */
/*                                                                    */
/*--------------------------------------------------------------------*/
bfi_ver='2.01'
    Address ISPEXEC;"CONTROL ERRORS RETURN";ima_macro=0
    Arg parm#;If parm#/='' Then Signal byp1
    "ISREDIT MACRO (parm#) NOPROCESS";If rc=0 Then ima_macro=1

byp1:
/*  "CONTROL ERRORS CANCEL"                                           */

ini1:
    Parse Upper VAR parm# parm1 parm2 parm3
    If parm1="?" Then Signal TSO_help

ini2:
    zerrhm  ='*';zerralrm='NO';zedsmsg=
    identify= 'Y'                           /* Who wrote this thing?  */
    PaySys  = 'N'                           /* PaySys indicator       */
    audit   = 'N'                           /* Audit trace for debug  */
    septor  = 'N'                           /* Use '*' seperator/spacr*/
    mapset  = 'MAPSET'
    mapname = 'MAPNAME'
    mapmode = 'INOUT'
    maplang = 'COBOL'
    maprecn = 'N'
    mapCprf = 'MAP-'                        /* COBOL name prefix      */
    storage = 'AUTO'
    tioapfx = 'YES'
    mapatts = '(COLOR,HILIGHT)'

/*  ctrl    = 'FREEKB'                                                */
    ctrl    = ''
/*  ctrli   = '(PRINT,FREEKB)'                                        */
    ctrli   = '(FRSET,FREEKB)'
/*  extatt  = 'MAPONLY'                                               */
    extatt  =

    white   = 'DEFAULT'
    term    = '3270'
    data    = 'FIELD'
    nol     = '24'                          /* Number of lines        */
    noc     = '80'                          /* Number of columns      */
/*  parm1 = '!1.PAN'                                                  */
/*  parm2 = 'PC'                                                      */
    sysuid  = Userid()
    profvar = "MAPSET MAPNAME ISPPLIB MAPTRAN MAPMODE MAPLANG BMSMLIB",
              "BMSLLIB MAPPANL MAPASM MAPCOBN MAPXATR MAPTRNK",
              "MAPPLNS,MAPDIND,MAPSEQN",
              "MAPNGEN,MAPBPF,MAPHPF,MAPHLNS,MAPBLNS,MAPPICIO"

    "CONTROL ERRORS RETURN"
    "VGET ("profvar") PROFILE"
    If mapngen ='' Then mapngen ='N'
    If mapdind ='' Then mapdind ='M'
    If mapplns ='' Then mapplns ='*'
    If mappicio='' Then mappicio='Y'
    If mapseqn ='' Then mapseqn ='N'
    maptrnk = 'B'     /* B=both L=lead T=trail                        */
    member  = mappanl
    csr     = ''
    edjcl   = 'Y'
    skel    = 'BFIS'
    amode   = '31'
    rmode   = 'ANY'
    xcl     = 'C'                           /* Execution class        */
    mcl     = 'P'                           /* Message class          */
    sdfhmac=$alkcics('sdfhmac')

    Address ISREDIT
    "(status)=USER_STATE";If rc=0 Then i_macro=1;Else i_macro=0
    "(dataset)=DATASET";copylib=dataset

    If Substr(parm1,1,3)='COB' Then Do
        maprecn='Y';mapasm='N'
        zedlmsg="COBOL name reconciliation flag set. Hit <ENTER>",
                "if/when all other fields OK."
        Address ISPEXEC "SETMSG MSG(ISRZ001)"
        Signal scr1

    End
    If parm1/='' Then Do
        mapngen='N';vputit='N';mapset=;mapname=
        Signal proc
    End

scr1:
    zcmd=
    Address ISPEXEC "DISPLAY PANEL(BFIP) CURSOR(&CSR)"
    If rc/=0 Then Do
        Call build_noteline_2
        Signal us_exit
    End
    Parse Upper VAR zcmd cmd cmdp1 cmdp2
    If cmd='TRACE' Then Do
        #tr=TRace()
        Select
            When cmdp1='OFF' Then x=Trace('N')
            When cmdp1='ON' Then x=Trace('R')
            Otherwise Do
                If Verify(#tr,'NO')=0 Then x=Trace('R');Else x=Trace('N')
            End
        End
        Signal scr1
    End
    Parse VAR cmd cmd1 +1 1 cmd2 +2 1 cmd3 +3 1 cmd4 +4
    If Wordpos(cmd4,'HELP ?')>0 Then Do
        Call TSO_Help
        Signal scr1
    End

    If cmd='CAN' Then Signal us_exit
    If Wordpos(cmd,'E V B /E /V /B')>0 Then Do
        cmd=Substr(cmd,Length(cmd))
        Select
            When (cmd='E') Then act='EDIT'
            When (cmd='V') Then act='VIEW'
            Otherwise act='BROWSE'
        End
        Address ISPEXEC "&ACT DATASET('&DATASET')"
        Signal scr1
    End

    If mapasm='Y' Then Do
        Call create_sub_jcl
        Signal scr1
    End

    "(me)=MEMBER"
    If strip(me)=Strip(member) & maprecn/='Y' Then Do
        zedsmsg=
        zedlmsg="Running macro against ISPF panel would destroy it.",
                "Pick another member."
        Address ISPEXEC "SETMSG MSG(ISRZ001)";Signal scr1
    End
    "(last)=LINENUM .ZLAST"
    If last=0 Then Do
        "COPY" member "AFTER .ZLAST"
        If rc/=0 Then Do
            Address ISPEXEC "SETMSG MSG(ISRZ001)"
            Signal scr1
        End
    End
    parm1=member

proc:
    #mapplns=Translate(mapplns,' ',',')
    If Index(#mapplns,'-')>0 Then Do
        #mapplns=Expand_Range(#mapplns,'#mapplns')
        If #mapplns='Error' Then Signal scr1
    End
    #maphlns=Translate(maphlns,' ',',')
    If Index(#maphlns,'-')>0 Then Do
        #maphlns=Expand_Range(#maphlns,'#maphlns')
        If #maphlns='Error' Then Signal scr1
    End
    #mapblns=Translate(mapblns,' ',',')
    If Index(#mapblns,'-')>0 Then Do
        #mapblns=Expand_Range(#mapblns,'#mapblns')
        If #mapblns='Error' Then Signal scr1
    End
    #mapilns=Translate(mapilns,' ',',')
    If Index(#mapilns,'-')>0 Then Do
        #mapilns=Expand_Range(#mapilns,'#mapilns')
        If #mapilns='Error' Then Signal scr1
    End

    If parm1/='' & maprecn/='Y' Then Do
        "RESET";"DEL ALL NX"
        If parm2='PC' Then "COPY" parm1
        Else "COPY" parm1 "AFTER .ZLAST"
    End

    "(llast)=LINENUM .ZLAST"
/*--------------------------------------------------------------------*/
/*  "(changed)=DATA_CHANGED";If changed="YES" Then "SAVE"             */
    "(scan#)=SCAN";"SCAN=OFF"
    If mapset='' |  mapname='' Then Call Get_mapset_mapname
    "SCAN=(scan#)"
/*--------------------------------------------------------------------*/
    attr#=0;body#=0;init#=0;rini#=0;proc#=0;end#=0;exp=
    orig_fld.=
    "F ')ATTR ' FIRST";If rc=0 Then "(attr#)=LINENUM .ZCSR"
    "F ')BODY ' FIRST"
    If rc=0 Then Do
        "(body#)=LINENUM .ZCSR";"(line)=LINE .ZCSR"
        Parse VAR line 'EXPAND(' exp ')'
        exp=Substr(exp,1,1)
    End
    "F ')INIT ' FIRST";If rc=0 Then "(init#)=LINENUM .ZCSR"
    "F ')REINIT ' FIRST";If rc=0 Then "(rini#)=LINENUM .ZCSR"
    "F ')PROC ' FIRST";If rc=0 Then "(proc#)=LINENUM .ZCSR"
    "F ')END ' FIRST";If rc=0 Then "(end#)=LINENUM .ZCSR"

    atrs='%THWOYN' ||,
         '+TLBOYN' ||,
         '_IHROYN'
    al=Length(atrs) % 3
    If attr#=0 Then Signal exp_attr
    "(line)=LINE" attr#
    Parse VAR line . 'DEFAULT(' ab ')' .
    If ab/='' Then atrs=Substr(ab,1,1)'THWOYN' ||,
                        Substr(ab,2,1)'TLBOYN' ||,
                        Substr(ab,3,1)'IHROYN'
    If attr#+1 >= body# Then Signal exp_attr
    Do i_s=attr#+1 To body#-1
        "(line)=LINE" i_S
        Parse VAR line ab .
        If ab = '/*' Then Iterate
        Parse VAR line . 'TYPE(' tp ')' .
        Parse VAR line . 'INTENS(' it ')' .
        Parse VAR line . 'COLOR(' cl ')' .
        Parse VAR line . 'HILITE(' hi ')' .
        Parse VAR line . 'SKIP(' sk ')' .
        Parse VAR line . 'NUMERIC(' nu ')' .
        If tp = ''    Then tp = 'T'
        If it = ''    Then it = 'L'
        If cl = ''    Then cl = 'B'
        If hi = ''    Then hi = 'O'
        If sk = 'ON'  Then sk = 'Y'
        Else               sk = 'N'
        If nu = 'ON'  Then nu = 'Y'
        Else               nu = 'N'
        na = ab || Substr(tp,1,1) || Substr(it,1,1) || Substr(cl,1,1) ||,
             Substr(hi,1,1) || sk || nu
        ap = Index(atrs,ab)
        If ap = 0 Then atrs = atrs || na
        Else Do
            If ap = 1 Then atrs = na || Substr(atrs,al+1)
            Else atrs = Substr(atrs,1,ap-1) || na || ,
                        Substr(atrs,ap+al)
        End
    End
    If audit='Y' Then "LINE_AFTER .ZLAST=(atrs)"

/*--------------------------------------------------------------------*/
/* Expand attribute bytes.                                            */
/*--------------------------------------------------------------------*/
exp_attr:
    lim# = Length(atrs) % al
    ja = ''                                 /* Just Attributes        */
    Do i_s=1 To lim#
        ja = ja || Substr(atrs,(i_s-1)*al +1,1)
        tp = Substr(atrs,(i_s-1)*al +2,1)
        it = Substr(atrs,(i_s-1)*al +3,1)
        cl = Substr(atrs,(i_s-1)*al +4,1)
        hi = Substr(atrs,(i_s-1)*al +5,1)
        sk = Substr(atrs,(i_s-1)*al +6,1)
        nu = Substr(atrs,(i_s-1)*al +7,1)
        If sk = 'Y' & tp /= 'I' Then atb = ',ASKIP'
        Else                         atb = ''
        If tp = 'O' Then atb = ',ASKIP'
        If tp = 'I' Then atb = atb || ',UNPROT'
        If nu = 'Y' Then atb = atb || ',NUM'
        Select
            When (it = 'N') Then atb = atb || ',DRK'
            When (it = 'H') Then atb = atb || ',BRT'
            Otherwise            atb = atb || ',NORM'
        End
        Select
            When (cl = 'Y') Then clr = 'YELLOW'
            When (cl = 'W') Then clr = white
            When (cl = 'G') Then clr = 'GREEN'
            When (cl = 'P') Then clr = 'PINK'
            When (cl = 'T') Then clr = 'TURQUOISE'
            When (cl = 'R') Then clr = 'RED'
            When (cl = 'B') Then clr = 'BLUE'
            Otherwise            clr = 'NEUTRAL'
        End
        Select
            When (hi = 'R') Then hil = 'REVERSE'
            When (hi = 'U') Then hil = 'UNDERLINE'
            When (hi = 'B') Then hil = 'BLINK'
            Otherwise            hil = 'OFF'
        End

        atb.i_s = atb
        clr.i_s = clr
        hil.i_s = hil
        If audit='Y' Then Do
            xx = Substr(atrs,(i_s-1)*al +1,1)
            line = i xx atb.i_s clr.i_s hil.i_s
            "LINE_AFTER .ZLAST=(line)"
        End

    End

/*--------------------------------------------------------------------*/
/* Get .ZVARS....                                                     */
/*--------------------------------------------------------------------*/
    zvars=
    If init# > 0 Then Do
        "CURSOR=1 0"
        Do Forever
            "FIND '.ZVARS'"
            If rc /= 0 Then Leave
            "(lin#)=LINENUM .ZCSR"
            If lin# > init# Then Leave
        End
        If rc = 0 Then Do
            "(line)=LINE .ZCSR"
            Do Forever
                zvars = zvars Strip(line)
                zl = Length(zvars)
                If Substr(zvars,zl,1) = "'" Then Leave
                If Substr(zvars,zl,1) = "+" Then zvars =,
                   Substr(zvars,1,zl-1)
                lin# = lin# +1
                "(line)=LINE" lin#
            End
            Parse VAR zvars '(' zvars ')'
            zvars = Translate(zvars,' ',',')
        End
    End

/*--------------------------------------------------------------------*/
/* Get &FSET.....                                                     */
/*--------------------------------------------------------------------*/
    "(scan#)=SCAN";"SCAN=OFF"
    #fset=
    If init# > 0 Then Do
        "CURSOR=1 0"
        Do Forever
            "FIND '&&FSET ' FIRST"
            If rc /= 0 Then Leave
            "(lin#)=LINENUM .ZCSR"
            If lin# > init# Then Leave
        End
        If rc = 0 Then Do
            "(line)=LINE .ZCSR"
            Do Forever
                #fset = #fset Strip(line)
                fl = Length(#fset)
                If Substr(#fset,fl,1) = "'" Then Leave
                If Substr(#fset,fl,1) = "+" Then #fset =,
                   Substr(#fset,1,fl-1)
                lin# = lin# +1
                "(line)=LINE" lin#
            End
            Parse VAR #fset '(' #fset ')'
            #fset = Translate(#fset,' ',',')
        End
    End

/*--------------------------------------------------------------------*/
/* Get &INITS (initialise I/O field to spaces)                        */
/*--------------------------------------------------------------------*/
    inits=
    If init# > 0 Then Do
        "CURSOR=1 0"
        Do Forever
            "FIND '&&INITS ' FIRST"
            If rc /= 0 Then Leave
            "(lin#)=LINENUM .ZCSR"
            If lin# > init# Then Leave
        End
        If rc = 0 Then Do
            "(line)=LINE .ZCSR"
            Do Forever
                inits = inits Strip(line)
                fl = Length(inits)
                If Substr(inits,fl,1) = "'" Then Leave
                If Substr(inits,fl,1) = "+" Then inits =,
                   Substr(inits,1,fl-1)
                lin# = lin# +1
                "(line)=LINE" lin#
            End
            Parse VAR inits '(' inits ')'
            inits = Translate(inits,' ',',')
        End
    End

/*--------------------------------------------------------------------*/
/* Get &INITU (initialise I/O field unconditionally to assignment     */
/* value in the )INIT section.                                        */
/*--------------------------------------------------------------------*/
    initu=
    If init# > 0 Then Do
        "CURSOR=1 0"
        Do Forever
            "FIND '&&INITU=' FIRST"
            If rc /= 0 Then "FIND '&&INITU ' FIRST"
            If rc /= 0 Then Leave
            "(lin#)=LINENUM .ZCSR"
            If lin# > init# Then Leave
        End
        If rc = 0 Then Do
            "(line)=LINE .ZCSR"
            Do Forever
                initu = initu Strip(line)
                fl = Length(initu)
                If Substr(initu,fl,1) = "'" Then Leave
                If Substr(initu,fl,1) = "+" Then initu =,
                   Substr(initu,1,fl-1)
                lin# = lin# +1
                "(line)=LINE" lin#
            End
            Parse VAR initu '(' initu ')'
            initu = Translate(Strip(initu),' ',',')
        End
    End

    If initu /= '' Then Do
        If init# > 0 Then Do
            "LABEL" init# "= .LINEI"
            xxx=initu
            Do While xxx/=''
                Parse VAR xxx var xxx
                "FIND '&&"var"=' FIRST .LINEI .ZLAST"
                If rc/=0 Then "FIND '&&"var" ' FIRST .LINEI .ZLAST"
                If rc/=0 Then Iterate
                "(line)=LINE .ZCSR"
                line=Strip(line)
                If Substr(line,Length(line),1)='+' Then Do
                    line=Substr(line,1,Length(line)-1)
                    "(xx)=LINENUM .ZCSR"
                    "(xx)=LINE" xx+1
                    line=line || Strip(xx)
                End
                Parse VAR line "'" lit "'".
                iniu.var=lit
            End
        End
    End
    "SCAN=(scan#)"
#tr=Trace('o')


/*--------------------------------------------------------------------*/
/* Get .CURSOR...                                                     */
/*--------------------------------------------------------------------*/
    #curs=
    If init# > 0 Then Do
        "CURSOR=1 0"
        Do Forever
            "FIND '.CURSOR '"
            If rc /= 0 Then Leave
            "(lin#)=LINENUM .ZCSR"
            If lin# < init# Then Iterate
            "(line)=LINE .ZCSR"
            Parse VAR line '.CURSOR' line
            Parse VAR line '=' #curs
            Parse VAR #curs "'" #curs "'"
            #curs = Strip(#curs)
            If #curs /= '' Then Leave
        End
    End

proc_body:
    If body# = 0 Then Do
        zedlmsg = "F*#! OFF. What's this NO ')BODY'....."
        Address ISPEXEC "SETMSG MSG(ISRZ001)"
        Signal us_exit
    End
    lim# = Length(atrs) % al
    "(last)=LINENUM .ZLAST"
    If end#  > 0 Then last = end#  -1
    If proc# > 0 Then last = proc# -1
    If rini# > 0 Then last = rini# -1
    If init# > 0 Then last = init# -1

    lin# = 0
    j_s  = 0
    Do k_s=body#+1 To last
        lin#  = lin# +1
        "(linex)=LINE" k_s
        If Index(ja,Substr(Strip(linex,'L'),1,1)) = 0 Then Do
            If Substr(linex,1,1) = ' ' Then
                 linex = Overlay(Substr(atrs,al+1,1),linex,1,1)
            Else
                 linex = Substr(atrs,al+1,1) || linex
        End
        linex = Substr(linex,1,80)
        pap   = 0
        pa#   = 0
        Do Forever
            ap = 9999
            a# = 0
            Do i_s=1 To lim#
                ab = Substr(atrs,(i_s-1)*al +1,1)
                x  = Index(linex,ab,pap+1)
                If x = 0 Then Iterate
                If x < ap Then Do
                    a# = i_S
                    ap = x
                End
            End
            If a# = 0 Then Do
                ap = Length(linex) +1
                Leave
            End
            If pap = 0 Then Do
                pap = ap
                pa# = a#
                Iterate
            End
            Else Do
                If pap > 80 Then Leave
                Call set_body_atrb
                pap = ap
                pa# = a#
                Iterate
            End
        End
        If pap > 80 Then Leave
/*      If pap = 0 Then Iterate                                       */
        Call set_body_atrb
    End
    val.0 = j_s

/*--------------------------------------------------------------------*/
/* Create the headline..                                              */
/*--------------------------------------------------------------------*/
    "(caps)=CAPS";"CAPS=OFF"
    line = Copies('*',71)
    "LINE_AFTER .ZLAST=(line)";"LINE_AFTER .ZLAST=(line)"
    line=Substr('*',1,70)'*';"LINE_AFTER .ZLAST=(line)"
    If identify = 'Y' Then Do
        line='* The L.B.D. U-BYUTE unpatented BMS from ISPF system.'
        line=Substr(line,1,70)'*';"LINE_AFTER .ZLAST=(line)"
    End
    Else Do
        line='* BMS map From ISPF panels.....'
        line=Substr(line,1,70)'*';"LINE_AFTER .ZLAST=(line)"
    End
    line='* Generated at' Time('C') 'on' Date('E')' from panel' member'.'
    line=Substr(line,1,70)'*';"LINE_AFTER .ZLAST=(line)"
    line=Substr('*',1,70)'*' ;"LINE_AFTER .ZLAST=(line)"
    line=Copies('*',71)      ;"LINE_AFTER .ZLAST=(line)"
    "CAPS=(caps)"
/*--------------------------------------------------------------------*/
/* Create the DFHMSD entry..                                          */
/*--------------------------------------------------------------------*/
    line=Substr(mapset,1,9) || 'DFHMSD TYPE=&SYSPARM,LANG='maplang','
    line=Substr(line,1,71)'X';"LINE_AFTER .ZLAST=(line)"
    If mapmode/='' Then Do
        line='               MODE='mapmode','
        line=Substr(line,1,71)'X';"LINE_AFTER .ZLAST=(line)"
    End
    If storage/='' Then Do
        line='               STORAGE='storage','
        line=Substr(line,1,71)'X';"LINE_AFTER .ZLAST=(line)"
    End
    If term/='' Then Do
        line='               TERM='term','
        line=Substr(line,1,71)'X';"LINE_AFTER .ZLAST=(line)"
    End
    If data/='' Then Do
        line='               DATA='data','
        line=Substr(line,1,71)'X';"LINE_AFTER .ZLAST=(line)"
    End
    If extatt/='' Then Do
        line='               EXTATT='extatt','
        line=Substr(line,1,71)'X';"LINE_AFTER .ZLAST=(line)"
    End
    If mapatts/='' Then Do
        If mapxatr='Y' Then Do
            line='               MAPATTS='mapatts','
            line=Substr(line,1,71)'X';"LINE_AFTER .ZLAST=(line)"
        End
    End
    If ctrl/='' Then Do
        line='               CTRL='ctrl','
        line=Substr(line,1,71)'X';"LINE_AFTER .ZLAST=(line)"
    End
    line='               TIOAPFX='tioapfx
    "LINE_AFTER .ZLAST=(line)";"LINE_AFTER .ZLAST='*'"

/*--------------------------------------------------------------------*/
/* Create the DFHMDI entry..                                          */
/*--------------------------------------------------------------------*/
    line=Substr(mapname,1,9) || 'DFHMDI SIZE=('nol','noc')' || ,
           ',CTRL='ctrli
    "LINE_AFTER .ZLAST=(line)";"LINE_AFTER .ZLAST='*'"
    line=Copies('*',71);"LINE_AFTER .ZLAST=(line)"

/*--------------------------------------------------------------------*/
/* Build DFHMDF entries for each attribute byte and associated data   */
/* detected.                                                          */
/*--------------------------------------------------------------------*/
    ioflds=
    Do i_s=1 to val.0
        If len.i_s = 0 Then Iterate
        If Index(' '#mapilns' ',' 'lin.i_s' ') > 0 Then Iterate
        If #mapplns/='*' &,
           Index(' '#mapplns' ',' 'lin.i_s' ') = 0 Then Iterate
        lin.i_s = Substr('000',1,2-Length(lin.i_s))lin.i_s
        col.i_s = Substr('000',1,2-Length(col.i_s))col.i_s
        orig_fld.i_s = fld.i_s
        If mapngen = 'Y' Then Do
            lin = lin.i_s +0
            Select
                When (Index(' '#maphlns' ',' 'lin' ') > 0) Then,
                    fld.i_s = maphpf || lin.i_s || col.i_s
                When (Index(' '#mapblns' ',' 'lin' ') > 0) |,
                     (#mapblns = '*') Then,
                    fld.i_s = mapbpf || lin.i_s || col.i_s
                Otherwise Nop
            End
            If orig_fld.i_s /= '' Then,
                Interpret 'o_1.'orig_fld.i_s' = fld.i_s'
        End
        ioflds  = ioflds  orig_fld.i_s'*'fld.i_s
        line=Left(fld.i_s,8) 'DFHMDF POS=('lin.i_s','col.i_s'),'
        line=Substr(line,1,71)'X';"LINE_AFTER .ZLAST=(line)"

        j_s=atr.i_s
        atb=Substr(atb.j_s,2)
        If fld.i_s /= '' Then Do
            x = Index(' '#fset' ',' 'fld.i_s' ')
            If x > 0 Then atb = atb || ',FSET'
            If fld.i_s = #curs Then atb = atb || ',IC'
        End
        line='               ATTRB=('atb'),'
        line=Substr(line,1,71)'X';"LINE_AFTER .ZLAST=(line)"

        If mapxatr = 'Y' Then Do
            line='               COLOR='clr.j_s',HILIGHT='hil.j_s','
            line=Substr(line,1,71)'X';"LINE_AFTER .ZLAST=(line)"
        End

/*--------------------------------------------------------------------*/
/* Setup PICIN/PICOUT for COBOL/PLI numeric fields                    */
/*--------------------------------------------------------------------*/
        If maplang = 'COBOL' | maplang = 'PLI' Then Do
          If mappicio = 'Y' Then Do
            If Index(atb,'NUM') > 1 Then Do
                pic = Copies('9',len.i_s)
                linex = Substr(Copies(' ',15)"PICIN='"pic"',",1,71)'X'
                "LINE_AFTER .ZLAST=(linex)"
                linex = Substr(Copies(' ',15)"PICOUT='"pic"',",1,71)'X'
                "LINE_AFTER .ZLAST=(linex)"
            End
          End
        End

        len.i_s=Right(len.i_s,3,'0')
        line='               LENGTH='len.i_s
/*--------------------------------------------------------------------*/
/* Do we have an initial value. I/O fields have to be defined in      */
/* the panel under variable &INITS or &INITU for assignment.          */
/*--------------------------------------------------------------------*/
        If inits/='' & orig_fld.i_s/='' Then Do
            If Index(' 'inits' ',' 'orig_fld.i_s)>0 Then,
                val.i_s=Substr(' ',1,len.i_s)
        End
        If Index(' 'initu' ',' 'orig_fld.i_s' ')>0 &,
            orig_fld.i_s/='' Then Do
                xxx=orig_fld.i_s;val.i_s=iniu.xxx
        End

        If Length(val.i_s)=0 Then "LINE_AFTER .ZLAST=(line)"
        Else Do
            If exp/='' Then,
                If Index(val.i_s,exp)>0 Then call expand_line
            line=Substr(line',',1,71)'X'
            "LINE_AFTER .ZLAST=(line)"
            line="INITIAL='"val.i_s"'"
            Do Forever
                Parse VAR line linex +56 line
                If line='' Then Do
                    linex=Copies(' ',15)linex
                    "LINE_AFTER .ZLAST=(linex)"
                    Leave
                End
                linex=Substr(Copies(' ',15)linex,1,71)'X'
                "LINE_AFTER .ZLAST=(linex)"
            End
        End

        If septor='Y' Then "LINE_AFTER .ZLAST='*'"
    End

/*--------------------------------------------------------------------*/
/* Reconcile ISPF variable names with COBOL/PL1 names:                */
/* Processing needs to proceed to this stage as we need all the       */
/* variable names to reconcile the &N_ equates.                       */
/* Logic:                                                             */
/* 1. Remove the stuff inserted in the BMS generation process.        */
/* 2. Find )END                                                       */
/* 3. Exclude all &N_ equates.                                        */
/* 4. Find all &N_ that have equivalent variable names and insert     */
/*    ones that haven't.                                              */
/* 5. Delete redundant ones (may have been deeleted/renamed).         */
/*    (At this stage the redundant lines are not deleted auto-        */
/*     matically as accidental change would remove original COBOL/PL1 */
/*     name reference. User advised to delete manually.               */
/*--------------------------------------------------------------------*/
    If maprecn = 'Y' Then Do
/*      "FIND '********' 1 FIRST"                                     */
        "CURSOR=" llast
        "DELETE ALL NX .ZCSR .ZLAST"

        "RESET"
        "F '"Substr(atrs,1,72)"' 1 FIRST"
        If rc=0 Then "DELETE ALL NX .ZCSR .ZLAST"
        "F ')END ' 1 LAST"
        If rc /= 0 Then Do
            "LINE_AFTER .ZLAST = ')END'"
            "(#end)=LINENUM .ZLAST"
        End
        Else "(#end)=LINENUM .ZCSR"
        "LABEL" #end " = .ENDLB"
        "(scan#)=SCAN";"SCAN=OFF"
        "X '&&N_' ALL .ENDLB .ZLAST"
        Do while ioflds /= ''
            Parse VAR ioflds var ioflds
            Parse VAR var oname '*' nname
            If oname = '' Then Iterate
            oname = Left("&N_"oname,11) "="
            "F '"oname"' FIRST .ENDLB .ZLAST"
            If rc /= 0 Then Do
                oname = oname "'"mapCprf"'"
                "LINE_AFTER .ZLAST=(oname)"
            End
        End
/*      "DELETE ALL X"                                                */
        zedlmsg = 'COBOL/PL1 name equates have been reconciled. Any',
                'discrepancies found have been eXcluded. Use the FLIP',
                'command and if you concur with their deletion,',
                'delete them manually.'
        Address ISPEXEC "SETMSG MSG(ISRZ001)"
        "F '&&N_' FIRST"
        "F ""'"mapCprf"'"" NEXT"
        "(lin#)=CURSOR";"CURSOR=" lin# 20;"DOWN CURSOR";"SCAN=(scan#)"
        Exit
    End

/*--------------------------------------------------------------------*/
/* Create the DFHMDI (final) entry....                                */
/*--------------------------------------------------------------------*/
    line = Substr('         DFHMDI TYPE=FINAL',1,39) || mapname
    "LINE_AFTER .ZLAST=(line)"
    line = Substr('         END    ,',1,39) || mapset
    "LINE_AFTER .ZLAST=(line)"

/*--------------------------------------------------------------------*/
/* Set Initial values for I/O fields....                              */
/*--------------------------------------------------------------------*/
    If mappicio = 'Y' Then Do
        find = 'O_'
        outp = 'PICOUT='
        Call set_values

        find = 'I_'
        outp = 'PICIN='
        Call set_values
    End

/*  find = 'N_'                                                       */
/*  outp = 'NAME='                                                    */
/*  Call set_values                                                   */

/*  Call io_fld_init                                                  */

    If mapcobn = 'Y' Then Call io_COBOL_names
    If mapcobn='Y' & PaySys='Y' Then "ISREDIT BFIPSYS"

/*  "FIND '********' 1 FIRST"                                         */
    "CURSOR=" llast
    "DELETE ALL NX .ZFIRST .ZCSR"

    If mapseqn  = 'Y' Then,
        "ISREDIT NO 73-80 100 100 AP ALL"

ext1:
    mappanl = member
    If vputit  /= 'N' Then Address ISPEXEC "VPUT ("profvar") PROFILE"
    Call build_noteline_1

us_exit:
    "USER_STATE=(status)"
    Exit

/*--------------------------------------------------------------------*/
/* Expand a literal using the EXPADND(..) feature to the actual       */
/* literal value. The length of the field is established from the     */
/* start of this attribute character to the next (now line wrap is    */
/* permitted so if next line, extend to column 80).                   */
/* If there is an uneven distribution, the last expansion will carry  */
/* the 'fillers'.                                                     */
/*--------------------------------------------------------------------*/
expand_line:
    j_s = i_S +1
    If col.j_s = 'COL.'j | col.j_s <= col.i_s Then prev_c=80
    ELse prev_c=col.j_s
    len=prev_c-col.i_s                      /* Length till next atrib */
    s_st=1                                  /* Index start point      */
    nxdat=                                  /* Non expandable data    */
    exp#=0                                  /* No. of expansions      */
    j_s=1
    Do Forever
        n_st=Index(val.i_s,exp,s_st);If n_st=0 Then Leave
        dat.j_s=Substr(val.i_s,s_st,(n_st-s_st))
        nxdat=nxdat || dat.j_s
        exp_i.j_s='N'                       /* Expansion indicator    */
        j_s=j_s+1
        dat.j_s=Substr(val.i_s,n_st+1,1)
        exp_i.j_s='Y'
        j_s=j_s+1
        exp#=exp#+1
        s_st=n_st+3
    End
    dat.j_s=Substr(val.i_s,s_st)
    nxdat=nxdat || dat.j_s
    exp_i.j_s='N'

    yy=len-Length(nxdat);expl=yy%exp#;reml=yy//exp#;val.i_s=
    Do k_s=j_s By -1 To 1                   /* Reverse order for REML */
        If exp_i.k_s='Y' Then Do
            dat.k_s=Copies(dat.k_s,expl+reml)
            reml=0
        End
        val.i_s=dat.k_s || val.i_s
    End
    line='               LENGTH='Right(len,3,'0')
    Return 0

/*--------------------------------------------------------------------*/
/* Set values for PICIN, PICOUT and NAME if present...                */
/* Overwrite any PICIN, PICOUT generated by NUMERIC(ON) attribute     */
/* value.                                                             */
/* NAME is commented out as it does not appear to be a vaild option   */
/* under CICS V4.1.                                                   */
/*--------------------------------------------------------------------*/
set_values:
    If maplang = 'COBOL' | maplang = 'PLI' Then Nop
    Else Return 0
    If end#  = 0 Then Return 0
    Else              lin#i = end#
    Do Forever
        "CURSOR=" lin#i 0
        "F '"find"'"
        If rc /= 0 Then Leave
        "(line)=LINE .ZCSR"
        "(lin#i)=LINENUM .ZCSR"
        zzz = "Parse VAR line '"find"' var '=' vi"
        Interpret zzz
        If mapngen = 'Y' Then Do
            Interpret 'var = o_1.'var
        End
        vi = Strip(vi)
        If qutd = 'N' Then,
            If Substr(vi,1,1) = "'" Then vi = Substr(vi,2,Length(vi)-2)
        "F '"Strip(var)" ' 1 FIRST"
        If rc = 0 Then Do
            "(lin#y)=LINENUM .ZCSR"
            "LABEL" lin#y "=.MACST"
            "F 'LENGTH=' 16 NEXT"
            "(lin#x)=LINENUM .ZCSR"
            "LABEL" lin#x "=.MACEN"
            line = outp ||vi','
            "FIND '"outp"' 16 FIRST .MACST .MACEN"
            If rc = 0 Then Do
                "(lin#x)=LINENUM .ZCSR"
                action = 'LINE'
            End
            Else action = 'LINE_BEFORE'
            Do Forever
                Parse VAR line linex +56 line
                linex = Substr(Copies(' ',15)linex,1,71)'X'
                "&ACTION" lin#x "=(linex)"
                If line = '' Then Leave
                lin#x = lin#x +1
            End
        End
        lin#i = lin#i +1
    End

    Return 0

/*--------------------------------------------------------------------*/
/* Set initial values for I/O fields from SET statements in the )INIT */
/* section.                                                           */
/*--------------------------------------------------------------------*/
io_fld_init:
    "LABEL" init# "=.INITS"
    Select
        When (rini# > 0) Then "LABEL" rini# "=.INITE"
        When (proc# > 0) Then "LABEL" proc# "=.INITE"
        Otherwise             "LABEL" end#  "=.INITE"
    End
    "SCAN=OFF"
    Do i_s=1 to val.0
        If orig_fld.i_s = '' Then Iterate
        find = "&&"Strip(orig_fld.i_s)" "
        "FIND '"find"' 2 .INITS .INITE LAST"
        If rc /= 0 Then Iterate
        "(line)=LINE .ZCSR"
        Parse VAR line . . val
        val = Strip(val)
        val = Substr(val,2,Length(val)-2)
        val = Substr(val,1,len.i_s)
        k_s = Index(val,"'")
        If k_s > 0 Then Do
            Do Forever
                val = Substr(val,1,k)"'"Substr(val,k+1)
                k_s = Index(val,"'",k_s+2)
                If k_s = 0 Then Leave

            End
        End
        "FIND '"fld.i_s" ' 1 LAST"
        If rc /= 0 Then Do
            Say "Error... '"fld.i_s"' not found column 1..."
            Say "Premature ejaculation..................."
            Signal us_exit
        End
        "FIND 'LENGTH=' 16"
        If rc /= 0 Then Do
            Say "Error... 'LENGTH=' not found column 16.."
            Say "Premature ejaculation..................."
            Signal us_exit
        End
        "(lin#)=LINENUM .ZCSR"
        If Length(val) > 0 Then Do
            line = "               INITIAL='"val"',"
            linx = Substr(line,72)
            line = Substr(line,1,71)'X'
            "LINE_BEFORE" lin# "=(line)"
            If linx /= '' Then Do
                line = Substr(Copies(' ',15)linx,1,71)'X'
                "LINE_AFTER" lin# "=(line)"
            End
        End
    End
    "SCAN=ON"

    Return 0

/*--------------------------------------------------------------------*/
/* This block of code looks for &N_ in the panel and inserts any      */
/* COBOL name equates as a 'coment' on the DFHMDF macro in columns 40 */
/* for a max of 32 bytes.                                             */
/*--------------------------------------------------------------------*/
io_COBOL_names:
    If maplang = 'COBOL' | maplang = 'PLI' Then Nop
    Else Return 0

    "SCAN=OFF"
    "F '&N_' FIRST";If rc/=0 Then Return 0

    "(caps)=CAPS";"CAPS=OFF"
    "(lin#)=LINENUM .ZCSR"
/*  l_t='NOTELINE'                                                    */
    l_t=

/*  "FIND '********' 1 FIRST"                                         */
/*  "(lin#i)=LINENUM .ZCSR"                                           */
    lin#i=llast

    lin#i=lin#i+5;line=Copies('*',71)
    "LINE_AFTER" lin#i"="l_t "(line)"
    line=Substr('*',1,70)'*';lin#i=lin#i+1
    "LINE_AFTER" lin#i"="l_t "(line)"
    line='* COBOL names have been inserted as comments on the DFHMDF'
    line=Substr(line,1,70)'*';lin#i=lin#i+1
    "LINE_AFTER" lin#i"="l_t "(line)"
    line='* macro. This will be used to process the COBOL source against'
    line=Substr(line,1,70)'*';lin#i=lin#i+1
    "LINE_AFTER" lin#i"="l_t "(line)"
    line='* this member to generate the map redefines copy book.'
    line=Substr(line,1,70)'*';lin#i=lin#i+1
    "LINE_AFTER" lin#i"="l_t "(line)"
    line=Substr('*',1,70)'*';lin#i=lin#i+1
    "LINE_AFTER" lin#i"="l_t "(line)"
    "CAPS=(caps)"
    ioflds=ioflds fld.i_s
    "F ' DFHMDF ' 10 FIRST";"LABEL .ZCSR=.FMARKER"
    "F '&&N_' FIRST"
    Do While rc=0
        "(line)=LINE .ZCSR";"(lin#)=LINENUM .ZCSR"
        Interpret "Parse VAR line '&N_' var '=' vi"
        If mapngen='Y' Then Interpret 'var = o_1.'var
        vi=Strip(vi)
        If Substr(vi,1,1)="'" Then vi=Substr(vi,2,Length(vi)-2)
        If vi/=mapCprf Then Do
            line=Substr('* 'Substr(var,1,10)vi,1,70)'*';lin#i=lin#i+1
            "F '"var" ' 1 FIRST .FMARKER .ZLAST"
            "(line)=LINE .ZCSR"
            line=Overlay(vi,line,40,Length(vi))
            "LINE .ZCSR=(line)"
        End
        "CURSOR=" lin#+1 0
        "F '&N_' NEXT"
    End

    "SCAN=ON"
    Return 0


/*--------------------------------------------------------------------*/
/* Set up details for each attribute found in the )BODY section.      */
/*--------------------------------------------------------------------*/
set_body_atrb:
    j_s = j_s +1
    lin.j_s = lin#
    If pap /= 0 Then atr.j_s = pa#
    Else Do
        pap   = 1
        atr.j_s = 2
    End
    col.j_s = pap
    len.j_s = (ap-pap)-1
    val.j_s = Substr(linex,pap+1,len.j_s)
    atr   = Substr(atrs,(atr.j_s-1)*al +1,al)
    If Substr(atr,2,1) = 'I' | ,
       Substr(atr,2,1) = 'O' Then Do
        fld.j_s = Strip(val.j_s,'t')
        val.j_s = ''
    End
    Else fld.j_s = ''
    If fld.j_s = 'Z' Then Parse VAR zvars fld.j_s zvars
    Call parse_4_quotes
    If maptran = 'TRNK' & fld.j_s = '' Then Do
/*                                                                    */
/* Need a terminator if previous field was input.                     */
/*                                                                    */
        If maptrnk = 'B' | maptrnk = 'L' Then Do
            l1 = Length(val.j_s)
            l2 = Length(Strip(val.j_s,'L'))
            If Substr(prevatr,2,1) /= 'I' Then col.j_s = col.j_s + (l1 - l2)
        End
        val.j_s = Strip(val.j_s,maptrnk)
        len.j_s = Length(val.j_s)
        If len.j_s = 0 Then Do
            If Substr(prevatr,2,1) = 'I' Then len.j_s = 1
            Else j_s = j_s -1
        End
    End
    prevatr = atr

    Return 0

/*--------------------------------------------------------------------*/
/* Set up details for each attribute found in the )BODY section.      */
/*--------------------------------------------------------------------*/
parse_4_quotes:
    If Index(val.j_s,"'") = 0 & Index(val.j_s,"&") = 0 Then Return 0
    d = Index(val.j_s,"'")
    If d > 0 Then Do
        Do Forever
            val.j_s = Substr(val.j_s,1,d)"'"Substr(val.j_s,d+1)
            d = Index(val.j_s,"'",d+2)
            If d = 0 Then Leave

        End
    End

    d = Index(val.j_s,"&")
    c = 0
    If d > 0 Then Do
        Do Forever
            If Substr(val.j_s,d+1,1) /= '&' Then Do
                Say "Error... '&&' not doubled up on line" k".",
                    "Premature ejaculation......"
                Signal us_exit
            End
            c = c +1
            d = Index(val.j_s,"&",d+2)
            If d = 0 Then Leave

        End
        len.j_s = len.j_s - c
    End

    Return 0

/*--------------------------------------------------------------------*/
/* Expand number range in field to individual numbers.                */
/*--------------------------------------------------------------------*/
Expand_Range:
    xxx=Arg(1)
    Do Forever
        d_p=Index(xxx,'-');If d_p=0 Then Leave
        w_w=$Wordat(xxx,d_p)
        w_#=$Wordat(xxx,d_p,'#');xxx=Delword(xxx,w_#,1)
        Parse Var w_w n_s '-' n_e
        If \Datatype(n_s,'w') | \Datatype(n_s,'w') | n_s>n_e Then Do
            zedlmsg='Invalid date range "'w_w'" entered. Please',
                    'correct and try again.'
            "ISPEXEC SETMSG MSG(ISRZ001)"
            csr=Arg(2)
            Return 'Error'
        End
        Do i=n_s To n_e
            If Wordpos(i,xxx)=0 Then xxx=xxx i
        End
    End
    Return xxx
/*--------------------------------------------------------------------*/
/* Verify datasets, create and submit JCL.                            */
/*--------------------------------------------------------------------*/
create_sub_jcl:
    Address ISPEXEC
    If Substr(bmsmlib,1,1) /= "'" Then bmsmlib = "'"sysuid"."bmsmlib"'"
    If Sysdsn(bmsmlib) /= 'OK'Then Do
        zedlmsg = Sysdsn(bmsmlib)
        csr = 'BMSMLIB'
        Signal create_sub_jcl_x
    End
    If bmsllib /= 'DUMMY' Then Do
        If Substr(bmsllib,1,1) /= "'" Then ,
            bmsllib = "'"sysuid"."bmsllib"'"
        If Sysdsn(bmsllib) /= 'OK' Then Do
            zedlmsg = Sysdsn(bmsllib)
            csr = 'BMSLLIB'
            Signal create_sub_jcl_x
        End
    End

    Parse VAR bmsmlib "'" bmsmlibo "'"
    Parse VAR bmsllib "'" bmsllibo "'"

    If amode=31 Then rmode='ANY';Else rmode=24

    If mapset='' |  mapname='' Then Call Get_mapset_mapname
    If mapdind='S' Then dsectnam=mapset;Else dsectnam=mapname

    "ISREDIT (membero)=MEMBER"
    "CONTROL ERRORS CANCEL"
    "FTOPEN TEMP"
    "FTINCL" skel
    "FTCLOSE"
    "VGET ZTEMPF"
    tempsub=ztempf
    If edjcl="Y" | cmd="EDIT" Then Do
        Address TSO "ALLOC DD(ZTEMPF) DS('"ztempf"') OLD REU"
        "LMINIT DATAID(DATAID) DDNAME(ZTEMPF)"
        umodel="NOTEZED";"VPUT UMODEL SHARED"
        "EDIT DATAID(&DATAID) MACRO(UMODEL)"
        "LMFREE DATAID(&DATAID)"
        Address TSO "FREE DD(ZTEMPF)"
    End

Subit:
    "VPUT (TEMPSUB) SHARED"
    x=Msg('On');Address TSO "%TEMPSUB";rc1 = rc;x=Msg('Off')
    "VGET (JOBNUMB JOBNAME MESSAGE) SHARED"
    zedlmsg=message

create_sub_jcl_x:
    "SETMSG MSG(ISRZ001)"
    Address
    Signal ext1

Get_mapset_mapname:
    If mapset='' Then Do
        "ISREDIT F '&&M_MAPSET' LAST"
        If rc=0 Then Do
            "ISREDIT (line)=LINE .ZCSR"
            Parse VAR line . . mapset .
            If Substr(mapset,1,1)="'" Then,
                Parse VAR mapset "'" mapset "'"
        End
        Else Do
            csr='MAPSET'
            zedsmsg=
            zedlmsg="Mapset name variable '&M_MAPSET' equate not found.",
                    "Suggest set up after the ')END' panel statement or",
                    "enter here manually."
            Address ISPEXEC "SETMSG MSG(ISRZ001)";Signal scr1
        End
    End
    If mapname='' Then Do
        "ISREDIT F '&&M_MAPNAME' LAST"
        If rc=0 Then Do
            "ISREDIT (line)=LINE .ZCSR"
            Parse VAR line . . mapname .
            If Substr(mapname,1,1) = "'" Then,
                Parse VAR mapname "'" mapname "'"
        End
        Else Do
            csr='MAPSET'
            zedsmsg=
            zedlmsg="Mapset name variable '&M_MAPSET' equate not found.",
                    "Suggest set up after the ')END' panel statement or",
                    "enter here manually."
            Address ISPEXEC "SETMSG MSG(ISRZ001)";Signal scr1
        End
    End
    Return 0

build_noteline_1:
    x_msg=Msg('Off')
    Trace o
    n_st=mark(2)
/*

    This BMS map macro has been generated from your model ISPF panel.
    Unless it is a very basic design, take a few moments to peruse it
    to ensure it at least appears OK.
    Note that this member has not been saved to permit rejection, by
    CANcellation, if so desired.
    Consequently, if you now wish to assemble it, explicitly save it
    by entering SAVE on the command line and hitting <ENTER>.

    To assemble, simply invoke the BFI edit macro over this BMS map
    macro and set field Assemble=Y.

    Install the mapset and either launch from the appropriate program
    or send under CECI.

*/
    n_en=mark(-2)
    Signal put_noteline

build_noteline_2:
    x_msg=Msg('Off')
    n_st=mark(2)
/*

    The generation of the BMS macro using BFI has been terminated.

    As it is a corruptible process, suggest "CANning" out of this
    session or correcting the cause and re-invoking it.

*/
    n_en=mark(-2)
    Signal put_noteline

put_noteline:
    Trace
    x=Msg(x_msg)
    "(caps)=CAPS";"CAPS=OFF"
    x=nl('*'Centre('ooo000OOOO000ooo',70,'-')'*')
    Do i_s=n_st To n_en
        x=nl('*'Substr(Sourceline(i_s),1,70)'*')
    End
    x=nl('*'Copies('-',70)'*')
    "CAPS=(caps)"
    Return 0

nl: Parse Arg #nl;"LINE_BEFORE .ZFIRST=NOTELINE (#nl)";Return 0
Mark:Arg diff;If Datatype(diff)/='NUM' Then diff=1;Return sigl+diff

TSO_Help:
    #msg=Msg('Off')
    Address TSO "ALLOC F(BFIDH) DA('"$alkhlq()"."$alkllqr()"') SHR REU"
    zcmd=;Address ISPEXEC "SELECT CMD(%HELPDRVR BFIDH=BFIDH I)"
    Address TSO "FREE F(BFIDH)"
    x=Msg(#msg)
    Return 0
