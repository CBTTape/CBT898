/******************************** REXX ********************************/
CSDA:csda_ver='2.07'                        /* CSDA version           */
    v1=            ,                        /* Set following in CSDA$ */
    readcsd        ,                        /* Read CSD if available  */
    listdesc       ,                        /* Site list Desc default */
    listdate       ,                        /* Site list changed date */
    datefmt        ,                        /* E(urop), U(SA) J(ulian)*/
    callign        ,                        /* Automatically allign   */
    nrcolor        ,                        /* CSD NoRead color       */
    isort_limit    ,                        /* "Internal"sort limit   */
    proc_lim       ,                        /* On-line proc limit     */
    pop_upf        ,                        /* Pop up progress freq   */

    Interpret "Parse Value Csda$(v1) With" v1
/*--------------------------ooo000OOOO000ooo--------------------------*/
/*  CSDA: CSD Analyser.                                               */
/*                                                                    */
/*  This macro is designed to analyse the contents of a viewed/edited */
/*  listing of a CSD (not OBJECT as it would be too large).           */
/*                                                                    */
/*  For further details browse the comments at the bottom of this     */
/*  member or invoke with a paremeter of "?".                         */
/*--------------------------------------------------------------------*/
    Parse SOURCE . xenv xcmd xdd xdsn .
    Arg parm#;Address ISPEXEC;"CONTROL ERRORS RETURN";ima_macro=0
    If parm#/='' Then Signal byp1
    "ISREDIT MACRO (parm#) NOPROCESS";If rc=0 Then ima_macro=1

byp1:
/*  "CONTROL ERRORS CANCEL"                                           */

ini1:
    u=Sysvar(Sysuid);p=Sysvar(Syspref);If u/=p&p/='' Then u=p'.'u
    Parse Value Date('e') with d1 '/' m1 '/' y1
    outdsn=u'.CSDALIST.D'||y1||m1||d1

    w1=Word(parm#,1);If Wordpos(w1,"? ??")>0 Then Signal help_#1

No_help_#1:
    If Wordpos('/LM',Translate(parm#))>0 Then Do
        "VGET (csdalmsg) PROFILE"
        zedsmsg=;zedlmsg=csdalmsg
        If zedlmsg='' Then zedlmsg="OOPS - Missing previous 'CSDA' message for",
                                   "redisplaying."
        "SETMSG MSG(ISRZ001)"
        Exit
    End
    If Wordpos('/T',Translate(parm#))>0 Then Do
        Trace r;parm#=Delword(parm#,Wordpos('/T',Translate(parm#)),1)
    End

    Signal on Syntax Name error_off_$ALKUVOL
    uvol_to="UNIT(SYSDA)";uvol_po="UNIT(SYSALLDA)"
    uvol_tb="UNIT=SYSDA";uvol_pb="UNIT=SYSALLDA"
    uvol_to=$ALKUVOL('$ZTEMPF');uvol_po=$ALKUVOL()
    uvol_tb=$ALKUVOL('$ZTEMPF',,'J');uvol_pb=$ALKUVOL('SMS',,'J')
error_off_$ALKUVOL:Signal off Syntax
    If uvol_tb/='' Then uvol_tb=uvol_tb','

    Address ISREDIT;"(status)=USER_STATE";"SCAN=OFF";"CAPS=OFF"
    "(dataset)=DATASET"
    key_w=;key_b=;pfield=0;append=0;f_oper.=;f_val.=;m_fields=;cicsv=
    qit=0;hot=0;h#=0;hardcopy=0
    If Wordpos('/HE',Translate(parm#))>0 Then Do
        If Sysdsn("'"outdsn"'")/='OK' Then Do
            zedlmsg="'"outdsn"'" Sysdsn("'"outdsn"'")
            Address ISPEXEC "SETMSG MSG(ISRZ001)"
        End
        Else Address ISPEXEC "EDIT DATASET('&OUTDSN')"
        Exit
    End
    If Wordpos('/#',Translate(parm#))>0 Then Do
        in_error=1;parm#=Delword(parm#,Wordpos('/#',Translate(parm#)),1)
        key_w=key_w '/#'
    End;Else  in_error=0
    If Wordpos('/1',Translate(parm#))>0 Then Do
        o_liner=1;parm#=Delword(parm#,Wordpos('/1',Translate(parm#)),1)
        key_w=key_w '/1';key_b=key_b '/1'
    End;Else o_liner=0
    If Wordpos('/13',Translate(parm#))>0 Then Do
        cicsv=13;parm#=Delword(parm#,Wordpos('/13',Translate(parm#)),1)
        key_w=key_w '/13';key_b=key_b '/13'
    End;Else cicsv=21
    If Wordpos('/21',Translate(parm#))>0 Then Do
        cicsv=21;parm#=Delword(parm#,Wordpos('/21',Translate(parm#)),1)
        key_w=key_w '/21';key_b=key_b '/21'
    End
    If Wordpos('/A',Translate(parm#))>0 Then Do
        append=1;parm#=Delword(parm#,Wordpos('/A',Translate(parm#)),1)
        key_w=key_w '/A'
    End
    If Wordpos('/B',Translate(parm#))>0 Then Do
        batch='Y';parm#=Delword(parm#,Wordpos('/B',Translate(parm#)),1)
        key_w=key_w '/B'
    End;Else batch='N'
    If Wordpos('/BE',Translate(parm#))>0 Then Do
        batch_emulate=1;parm#=Delword(parm#,Wordpos('/BE',Translate(parm#)),1)
        key_w=key_w '/BE'
    End;Else batch_emulate=0
    If Wordpos('/C',Translate(parm#))>0 Then Do
        listdate=1;parm#=Delword(parm#,Wordpos('/C',Translate(parm#)),1)
        key_w=key_w '/C';key_b=key_b '/C'
    End
    If Wordpos('/CA',Translate(parm#))>0 Then Do
        callign=1;parm#=Delword(parm#,Wordpos('/CA',Translate(parm#)),1)
        key_w=key_w '/CA';key_b=key_b '/CA'
    End
    If Wordpos('/CE',Translate(parm#))>0 Then Do
        listdate=1;parm#=Delword(parm#,Wordpos('/CE',Translate(parm#)),1)
        key_w=key_w '/CE';datefmt='E';key_b=key_b '/CE'
    End
    If Wordpos('/CJ',Translate(parm#))>0 Then Do
        listdate=1;parm#=Delword(parm#,Wordpos('/CJ',Translate(parm#)),1)
        key_w=key_w '/CJ';datefmt='J';key_b=key_b '/CJ'
    End
    If Wordpos('/CU',Translate(parm#))>0 Then Do
        listdate=1;parm#=Delword(parm#,Wordpos('/CU',Translate(parm#)),1)
        key_w=key_w '/CU';datefmt='U';key_b=key_b '/CU'
    End
    If Wordpos('/NCA',Translate(parm#))>0 Then Do
        callign=0;parm#=Delword(parm#,Wordpos('/NCA',Translate(parm#)),1)
        key_w=key_w '/NCA';key_b=key_b '/NCA'
    End
    If Wordpos('/D',Translate(parm#))>0 Then Do
        listdesc=1;parm#=Delword(parm#,Wordpos('/D',Translate(parm#)),1)
        key_w=key_w '/D';key_b=key_b '/D'
    End
    If Wordpos('/H',Translate(parm#))>0 Then Do
        hardcopy=1;parm#=Delword(parm#,Wordpos('/H',Translate(parm#)),1)
        key_w=key_w '/H';append=1
    End
    If Wordpos('/MG',Translate(parm#))>0 Then Do
        multigp=1;parm#=Delword(parm#,Wordpos('/MG',Translate(parm#)),1)
        key_w=key_w '/MG';key_b=key_b '/MG'
    End;Else multigp=0
    If Wordpos('/NC',Translate(parm#))>0 Then Do
        listdate=0;parm#=Delword(parm#,Wordpos('/NC',Translate(parm#)),1)
        key_w=key_w '/NC';key_b=key_b '/NC'
    End
    If Wordpos('/NM',Translate(parm#))>0 Then Do
        nm_supr=1;parm#=Delword(parm#,Wordpos('/NM',Translate(parm#)),1)
        key_w=key_w '/NM';key_b=key_b '/NM'
    End;Else nm_supr=0
    If Wordpos('/ND',Translate(parm#))>0 Then Do
        listdesc=0;parm#=Delword(parm#,Wordpos('/ND',Translate(parm#)),1)
        key_w=key_w '/ND';key_b=key_b '/ND'
    End
    If Wordpos('/NF',Translate(parm#))>0 Then Do
        no_flds=1;parm#=Delword(parm#,Wordpos('/NF',Translate(parm#)),1)
        key_w=key_w '/NF';key_b=key_b '/NF'
    End;Else no_flds=0
    If Wordpos('/NS',Translate(parm#))>0 Then Do
        sep_it=0;parm#=Delword(parm#,Wordpos('/NS',Translate(parm#)),1)
        key_w=key_w '/NS';key_b=key_b '/NS'
    End;Else sep_it=1
    If Wordpos('/O',Translate(parm#))>0 Then Do
        batch='O';parm#=Delword(parm#,Wordpos('/O',Translate(parm#)),1)
        key_w=key_w '/O'
    End
    If batch/='Y' Then Do
        If Wordpos('/HNE',Translate(parm#))>0 Then Do
            e_after=0;parm#=Delword(parm#,Wordpos('/HNE',Translate(parm#)),1)
            key_w=key_w '/HNE';hardcopy=1;append=1
        End;Else e_after=1
    End;Else e_after=1
    If hardcopy Then,                       /* After all the append=  */
        If Wordpos('/NA',Translate(parm#))>0 Then Do
            append=0;parm#=Delword(parm#,Wordpos('/NA',Translate(parm#)),1)
            key_w=key_w '/NA'
        End
    If Wordpos('/OG',Translate(parm#))>0 Then Do
        parm#=Delword(parm#,Wordpos('/OG',Translate(parm#)),1)
        key_w=key_w '/OG';key_b=key_b '/OG'
        orphan_groups=1
    End;Else orphan_groups=0
    If Wordpos('/OGI',Translate(parm#))>0 Then Do
        parm#=Delword(parm#,Wordpos('/OGI',Translate(parm#)),1)
        key_w=key_w '/OGI';key_b=key_b '/OGI'
        orphan_groups=1;orphan_IBM=1
    End;Else orphan_IBM=0
    If Wordpos('/OD',Translate(parm#))>0 Then Do
        parm#=Delword(parm#,Wordpos('/OD',Translate(parm#)),1)
        key_w=key_w '/OD';key_b=key_b '/OD'
        orphan_delete=1;orphan_groups=1
    End;Else orphan_delete=0
    If Wordpos('/TS',Translate(parm#))>0 Then Do
        time_s=1;parm#=Delword(parm#,Wordpos('/TS',Translate(parm#)),1)
        key_w=key_w '/TS';;key_b=key_b '/TS'
    End;Else time_s=0
    If Wordpos('/XT',Translate(parm#))>0 Then Do
        xontally=1;parm#=Delword(parm#,Wordpos('/XT',Translate(parm#)),1)
        key_w=key_w '/XT';key_b=key_b '/XT'
    End;Else xontally=0
    If Index(Translate(' 'parm#),' /CSD(')>0 Then Do
        Parse Value Translate(parm#) With p1 '/CSD(' dsnvsam ')' p2
        If dsnvsam/='' Then Do
            parm#=Space(p1 p2);key_w=key_w '/CSD('dsnvsam')'
        End
    End;Else dsnvsam=
    If Index(Translate(' 'parm#),' /PL(')>0 Then Do
        Parse Value Translate(parm#) With p1 '/PL(' xxx ')' p2
        If Datatype(xxx,'w') | xxx='*' Then Do
            parm#=Space(p1 p2);key_w=key_w '/PL('xxx')'
            proc_lim=xxx;n_prog=1
        End
    End;Else n_prog=0
    If Wordpos('/CSDC',Translate(parm#))>0 Then Do
        parm#=Delword(parm#,Wordpos('/CSDC',Translate(parm#)),1)
        If Wordpos('/M',Translate(parm#))>0 Then csdc_funct='/M'
        Else csdc_funct='/MA'
        If Wordpos('/NJ',Translate(parm#))>0 Then CSDC_jcl='/NJ'
        Else CSDC_jcl=
        x_CSDC=1
        Signal Extract_CSD
    End;Else x_CSDC=0
#tr=Trace('o')
/*--------------------------------------------------------------------*/
/* After 'no_flds' set as uses it.                                    */
/*--------------------------------------------------------------------*/
    If \no_flds & Index(Translate(' 'parm#),' /MF(')>0 Then Do
        Parse VAR parm# p1 '/MF(' m_fields ')' p2
        If m_fields='' Then Parse VAR parm# p1 '/Mf(' m_fields ')' p2
        If m_fields='' Then Parse VAR parm# p1 '/mF(' m_fields ')' p2
        If m_fields='' Then Parse VAR parm# p1 '/mf(' m_fields ')' p2
        If m_fields='' Then Parse VAR parm# p1 '/mf(' m_fields ')' p2
        If m_fields/='' Then Do
            m_fields=Translate(m_fields,' ',',')
            parm#=Space(p1 p2);key_w=key_w '/MF('Space(m_fields,,',')')'
            m_fields=Translate(m_fields);pfield=1
            Parse_m_fields()
        End
    End;Else m_fields=
    If \no_flds & Index(Translate(' 'parm#),' /OF(')>0 Then Do
        Parse VAR parm# p1 '/OF(' o_fields ')' p2
        If o_fields='' Then Parse VAR parm# p1 '/Of(' o_fields ')' p2
        If o_fields='' Then Parse VAR parm# p1 '/oF(' o_fields ')' p2
        If o_fields='' Then Parse VAR parm# p1 '/of(' o_fields ')' p2
        If o_fields='' Then Parse VAR parm# p1 '/of(' o_fields ')' p2
        If o_fields/='' Then Do
            o_fields=Translate(o_fields,' ',',')
            parm#=Space(p1 p2);key_w=key_w '/OF('Space(o_fields,,',')')'
            o_fields=Translate(o_fields);pfield=1
        End
    End;Else o_fields=
    If \no_flds & o_fields='' & Index(Translate(' 'parm#),' /SF(')>0 Then Do
        Parse VAR parm# p1 '/SF(' s_fields ')' p2
        If s_fields='' Then Parse VAR parm# p1 '/Sf(' s_fields ')' p2
        If s_fields='' Then Parse VAR parm# p1 '/sF(' s_fields ')' p2
        If s_fields='' Then Parse VAR parm# p1 '/sf(' s_fields ')' p2
        If s_fields='' Then Parse VAR parm# p1 '/sf(' s_fields ')' p2
        If s_fields/='' Then Do
            s_fields=Translate(s_fields,' ',',')
            parm#=Space(p1 p2);key_w=key_w '/SF('Space(s_fields,,',')')'
            s_fields=Translate(s_fields);pfield=1
        End
    End;Else s_fields=
    If Index(Translate(' 'parm#),' /UF(')>0 Then Do
        Parse VAR parm# p1 '/UF(' u_fields ')' p2
        If u_fields='' Then Parse VAR parm# p1 '/Uf(' u_fields ')' p2
        If u_fields='' Then Parse VAR parm# p1 '/uF(' u_fields ')' p2
        If u_fields='' Then Parse VAR parm# p1 '/uf(' u_fields ')' p2
        If u_fields='' Then Parse VAR parm# p1 '/uf(' u_fields ')' p2
        If u_fields/='' Then Do
            u_fields=Translate(u_fields,' ',',')
            parm#=Space(p1 p2);key_w=key_w '/UF('Space(u_fields,,',')')'
            u_fields=Translate(u_fields);pfield=1
        End
    End;Else u_fields=
/*--------------------------------------------------------------------*/
/* Leave these setting last.                                          */
/*--------------------------------------------------------------------*/
    If Wordpos('/R',Translate(parm#))>0 Then Do
        readCSD=1;parm#=Delword(parm#,Wordpos('/R',Translate(parm#)),1)
        key_w=key_w '/R';key_b=key_b '/R'
    End
    If Wordpos('/NR',Translate(parm#))>0 Then Do
        readCSD=0;parm#=Delword(parm#,Wordpos('/NR',Translate(parm#)),1)
        key_w=key_w '/NR';key_b=key_b '/NR'
    End
    If Index(Translate(' 'parm#),' G(')>0 Then Do
        Parse VAR parm# p1 'G(' i_groups ')' p2
        If i_groups='' Then Parse VAR parm# p1 ' g(' i_groups ')' p2
        If i_groups='' Then Parse VAR parm# p1 ' GR(' i_groups ')' p2
        If i_groups='' Then Parse VAR parm# p1 ' Gr(' i_groups ')' p2
        If i_groups='' Then Parse VAR parm# p1 ' gr(' i_groups ')' p2
        If i_groups='' Then Parse VAR parm# p1 ' gR(' i_groups ')' p2
        If i_groups/='' Then Do
            i_groups=Translate(i_groups,' ',',')
            parm#=Space(p1 p2);key_w=key_w ' G('Space(i_groups,,',')')'
            i_groups=Translate(i_groups)
        End
        If parm#='' Then Do;parm#='G('i_groups')';i_groups=;End
    End;Else i_groups=
/*--------------------------------------------------------------------*/
/* Parse remaining positional parameters for type and item (and any   */
/* global prefixes and suffixed, eg. *(....)*                         */
/*--------------------------------------------------------------------*/
    lsl=$Cstring(parm#,'(',,1,'*')
    If lsl=0 Then Do;findt=parm#;ifind=;End
    Else Do
        If lsl=1 Then Parse VAR parm# findt '(' ifind ')'
        Else Do
            Parse VAR parm# findt '(' p1 '(' ifind ')' p2 ')'
            ifind=p1'('ifind')'p2
        End
    End
/*--------------------------------------------------------------------*/
    If ifind='' Then Parse VAR findt findt ifind
    If ifind='' Then Do;ifind=findt;findt='TRANS';End
    Parse Upper VAR findt findt

    first_time=1;#popr=6;#popc=12;vsamopen=0;#ft=;findtype=
Extract_CSD:
    csdid='CSD file:';inval='????'

    If dsnvsam='' Then Do
        "F '"csdid"' FIRST"; If rc=0 Then Do
            "(line)=LINE .ZCSR";line=Translate(line);csdid=Translate(csdid)
            Interpret "Parse VAR line '"csdid"' dsnvsam ."
            dsnvsam=Strip(dsnvsam);dsnvsam=Strip(dsnvsam,,".")
            dsnvsam=Strip(dsnvsam,,"'")
        End;Else dsnvsam=
    End

    If x_CSDC Then Signal Call_CSDC

    msgtypes=
    validtypes=CSDA$('validtypes')
    desc_id="Desc"

    csr1=
    If findt/='' Then Do
        ch1=Substr(findt,1,1);ptr=1
        Do Forever
            ptr=Index(validtypes,' 'ch1,ptr);If ptr=0 Then Leave
            xx=$wordat(validtypes,ptr+1)
            yy=Verify(xx,'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789','N')
            pref=Substr(xx,1,yy-1)
            If Index(' 'findt,' 'pref)>0 Then Do;findtype=xx;Leave;End
            ptr=ptr+1
        End
    End
    msgx=
    If orphan_groups=1 Then Do;findtype='Groups';ifind='*';End
    If findtype='' Then Do
        If msgtypes='' Then Do
            xxx=validtypes
            Do While xxx/=''
                Parse VAR xxx . xx . xxx;msgtypes=msgtypes xx
            End
        End
        msgtypes=Space(msgtypes,,',')
        msgtypes=$Cstring(msgtypes,',',', ',,'*')
        msgx='Invalid ''itemtype'' "'findt'" entered. Format is',
             '"itemtype(item)" - Where itemtype must be in list:',
             msgtypes'.'
        in_error=1;csr1='CD'
    End;Else cd=Word(validtypes,Wordpos(findtype,validtypes)-1)

    descflds=Csda$('descflds')
    no_wild=Csda$('no_wild')
    csda$_ver=Csda$('csda$_ver')
get_itemflds:
    Address ISPEXEC "VPUT (cicsv) SHARED"
    itemflds=Csda$('itemflds')
/*--------------------------------------------------------------------*/
    ispf=Sysvar(Sysispf);If batch_emulate Then ispf='BATCH'
    If ispf/='ACTIVE' Then Do
        ft=findtype;findtype=Translate(findtype)
        If #ft/=ft Then Call eXpose_fields
        Signal Bypassed_for_batch
    End
/*--------------------------------------------------------------------*/
    zedsmsg=;zedlmsg=
scr1:screen=1
    Address ISPEXEC
/*--------------------------------------------------------------------*/
    If ispf/='ACTIVE' Then Do
        Say 'Error detected:';Say '  'zedlmsg
        Say ' ';Say 'Processing terminated.';Say ' '
        Exit
    End
/*--------------------------------------------------------------------*/
    If ifind='' | findtype='' | in_error Then Do
        If first_time Then Call x_first_time
        zcmd=
        If o_fields/='' Then,
            zedlmsg=zedlmsg 'Subset of fields selected for reporting is:',
                    '"'Space(o_fields,,',')'".'
        Else If s_fields/='' Then,
            zedlmsg=zedlmsg 'The following fields will be suppressed:',
                    '"'Space(s_fields,,',')'".'
        If m_fields/='' Then,
            zedlmsg=zedlmsg 'The following fields have conditions:',
                    '"'Space(m_fields,,',')'".'
        zedlmsg=Space(zedlmsg msgx);If zedlmsg/='' Then "SETMSG MSG(ISRZ001)"
        zwinttl='CSD Analyser';typ#='INPUT'
        "ADDPOP ROW(&#POPR) COLUMN(&#POPC)"
        csdalmsg=zedlmsg;"VPUT (csdalmsg) PROFILE"
        "DISPLAY PANEL("xcmd"P) CURSOR(&CSR1)";rc1=rc;"REMPOP";csr1=;zedlmsg=
        If rc1/=0 | Substr(zcmd,1,3)='CAN' Then Do
            zedlmsg='Parameter entry screen abandoned.'
            "SETMSG MSG(ISRZ001)"
            Signal exi2
        End
        If Wordpos('/LM',Translate(zcmd))>0 Then Do
            zedsmsg=;zedlmsg=csdalmsg
            If zedlmsg='' Then zedlmsg="OOPS - Missing previous 'CSDA'",
                                       "message for redisplaying."
                "SETMSG MSG(ISRZ001)"
            Signal scr1
        End
        msgx=
        If Word(zcmd,1)='TRACE' Then Do
            If Word(zcmd,1)='OFF' Then Trace o;Else Trace r
            Signal scr1
        End
        If zcmd='?' | ifind='?' Then Do
            Signal on Syntax Name error_on_01
            Interpret 'x=$BR('xcmd' "??")';Signal error_off_01
error_on_01: Address TSO xcmd "??"
error_off_01:Signal off Syntax
            If ifind='?' Then ifind=;Signal scr1
        End
        If zcmd='/HE' Then Do
            If Sysdsn("'"outdsn"'")/='OK' Then Do
                zedlmsg="'"outdsn"'" Sysdsn("'"outdsn"'")
                "SETMSG MSG(ISRZ001)"
            End
            Else "EDIT DATASET('&OUTDSN')"
            ifind=
            Signal scr1
        End
        If Index(zcmd,'/')>0 Then Do
            If Wordpos('/1',Translate(zcmd))>0 Then Do
                o_liner=1;If Wordpos('/1',key_w)=0 Then key_w=key_w '/1'
                If Wordpos('/1',key_b)=0 Then key_b=key_b '/1'
            End
            If Wordpos('/21',Translate(zcmd))>0 Then Do
                cicsv=21;If Wordpos('/21',key_w)=0 Then key_w=key_w '/21'
                If Wordpos('/21',key_b)=0 Then key_b=key_b '/21'
            End
            If Wordpos('/A',Translate(zcmd))>0 Then Do
                append=1;If Wordpos('/A',key_w)=0 Then key_w=key_w '/A'
                If Wordpos('/A',key_b)=0 Then key_b=key_b '/A'
            End
            If Wordpos('/B',Translate(zcmd))>0 Then Do
                batch='Y';If Wordpos('/B',key_w)=0 Then key_w=key_w '/B'
            End
            If Wordpos('/C',Translate(zcmd))>0 Then Do
                listdate=1;If Wordpos('/C',key_w)=0 Then key_w=key_w '/C'
                If Wordpos('/C',key_b)=0 Then key_b=key_b '/C'
            End
            If Wordpos('/CE',Translate(zcmd))>0 Then Do
                listdate=1;If Wordpos('/CE',key_w)=0 Then key_w=key_w '/CE'
                If Wordpos('/CE',key_b)=0 Then key_b=key_b '/CE'
                datefmt='E'
            End
            If Wordpos('/CJ',Translate(zcmd))>0 Then Do
                listdate=1;If Wordpos('/CJ',key_w)=0 Then key_w=key_w '/CJ'
                If Wordpos('/CJ',key_b)=0 Then key_b=key_b '/CJ'
                datefmt='J'
            End
            If Wordpos('/CU',Translate(zcmd))>0 Then Do
                listdate=1;If Wordpos('/CU',key_w)=0 Then key_w=key_w '/CU'
                If Wordpos('/CU',key_b)=0 Then key_b=key_b '/CU'
                datefmt='U'
            End
            If Wordpos('/O',Translate(zcmd))>0 Then Do
                batch='O';If Wordpos('/O',key_w)=0 Then key_w=key_w '/O'
            End
            If Wordpos('/H',Translate(zcmd))>0 Then Do
                hardcopy=1;If Wordpos('/H',key_w)=0 Then key_w=key_w '/H'
                append=1
            End
            If batch/='Y' Then Do
                If Wordpos('/HNE',Translate(zcmd))>0 Then Do
                   hardcopy=1;If Wordpos('/HNE',key_w)=0 Then key_w=key_w '/HNE'
                   e_after=0;hardcopy=1;append=1
                End
            End
            If \hardcopy Then,              /* After all the append=  */
                If Wordpos('/NA',Translate(zcmd))>0 Then Do
                    append=0;If Wordpos('/NA',key_w)=0 Then key_w=key_w '/NA'
                End
            If Wordpos('/OG',Translate(zcmd))>0 Then Do
                If Wordpos('/OG',key_w)=0 Then key_w=key_w '/OG'
                If Wordpos('/OG',key_b)=0 Then key_b=key_b '/OG'
                orphan_groups=1
            End
            If Wordpos('/OGI',Translate(zcmd))>0 Then Do
                If Wordpos('/OGI',key_w)=0 Then key_w=key_w '/OGI'
                If Wordpos('/OGI',key_b)=0 Then key_b=key_b '/OGI'
                orphan_groups=1;orphan_IBM=1
            End
            If Wordpos('/OD',Translate(zcmd))>0 Then Do
                If Wordpos('/OD',key_w)=0 Then key_w=key_w '/OD'
                If Wordpos('/OD',key_b)=0 Then key_b=key_b '/OD'
                orphan_groups=1;orphan_delete=1
            End
            If Wordpos('/NC',Translate(zcmd))>0 Then Do
                listdate=0;If Wordpos('/NC',key_w)=0 Then key_w=key_w '/NC'
                If Wordpos('/NC',key_b)=0 Then key_b=key_b '/NC'
            End
            If Wordpos('/NM',Translate(zcmd))>0 Then Do
                nm_supr=1;If Wordpos('/NM',key_w)=0 Then key_w=key_w '/NM'
                If Wordpos('/NM',key_b)=0 Then key_b=key_b '/NM'
            End
            If Wordpos('/NS',Translate(zcmd))>0 Then Do
                sep_it=0;If Wordpos('/NS',key_w)=0 Then key_w=key_w '/NS'
                If Wordpos('/NS',key_b)=0 Then key_b=key_b '/NS'
            End
            If Wordpos('/R',Translate(zcmd))>0 Then Do
                readCSD=1;If Wordpos('/R',key_w)=0 Then key_w=key_w '/R'
                If Wordpos('/R',key_b)=0 Then key_b=key_b '/R'
            End
            If Wordpos('/NR',Translate(zcmd))>0 Then Do
                readCSD=0;If Wordpos('/NR',key_w)=0 Then key_w=key_w '/NR'
                If Wordpos('/NR',key_b)=0 Then key_b=key_b '/NR'
            End
            If Wordpos('/TS',Translate(zcmd))>0 Then Do
                time_s=1;If Wordpos('/TS',key_w)=0 Then key_w=key_w '/TS'
                If Wordpos('/TS',key_b)=0 Then key_b=key_b '/TS'
                key_w=key_w '/TS'
            End
            If Wordpos('/XT',Translate(zcmd))>0 Then Do
                xontally=1;If Wordpos('/XT',key_w)=0 Then key_w=key_w '/XT'
                If Wordpos('/XT',key_b)=0 Then key_b=key_b '/XT'
            End
            If Index(Translate(' 'zcmd),' /PL(')>0 Then Do
                Parse Value Translate(zcmd) With p1 '/PL(' new_lim ')' p2
                If Datatype(new_lim,'w') Then Do
                    zcmd=Space(p1 p2);key_w=key_w '/PL('new_lim')'
                    n_prog=1
                End
            End
            zedlmsg='Switch change processed.'
            "SETMSG MSG(ISRZ001";in_error=1
            Signal scr1
        End
        If csr='DYNAV' Then ptr=csp;Else ptr=Index(dynav,' 'cd+0)
        ptr=ptr%(ent_len+1)+1;findtype=Word(dynav,ptr*2);cd=Word(dynav,ptr*2-1)
    End
    ft=findtype;findtype=Translate(findtype)
    If hardcopy & batch/='Y' Then hot=1;Else hot=0

    If #ft/=ft Then Call eXpose_fields

    If o_fields='?' Then Do
        x=nl('Valid field names for "'ft'" are:')
        x=Output(xf,'  Fields(','NoSort')
        Signal exi2
    End
    If o_fields='*' Then o_fields=@xf
    Else If o_fields/='' Then o_fields=ver_fields(o_fields)
    If s_fields='*' Then s_fields=@xf
    Else If s_fields/='' Then s_fields=ver_fields(s_fields)
    If m_fields='*' Then m_fields=@xf
    Else If m_fields/='' Then m_fields=ver_fields(m_fields)
/*--------------------------------------------------------------------*/
/* Field selection screen built from the fields per item.             */
/*--------------------------------------------------------------------*/
    If pfield Then Do
        If first_time Then Call x_first_time
        If  s_fields='' & o_fields='' & m_fields/='' Then o_fields=xf
        #dynav=dynav;#shadv=shadv;xf=@xf;#xf=xf
scr2:
        dynav='¬¬¬'Space(xf,3,'¬')
        If  s_fields/='' Then Do
            ofU=Translate(s_fields);ol1='Y';ol2=' '
        End
        Else Do
            ofU=Translate(o_fields);ol1=' ';ol2='Y'
        End
        dynav=$Cstring(dynav,'¬¬¬','¬'ol1'{',,'*');dynavU=Translate(dynav)
        Do While ofU/=''
            Parse VAR ofU xxx ofU
            xx=Index(dynavU,'{'xxx)
            If xx>0 Then dynav=Overlay(ol2,dynav,xx-1)
        End
        If m_fields/='' Then Do
            ofU=Translate(m_fields)
            Do While ofU/=''
                Parse VAR ofU xxx ofU;Parse Upper VAR xxx uxx
/*
                col#=Verify(xxx,'<>=/','M')
                If col#>0 Then Do
                    Interpret "Parse VAR xxx xxx +"col#-1 "oper +1 val"
                    If oper='/' Then Do;oper='/=';val=Substr(val,2);End
                    Parse Upper VAR xxx uxx
                    f_oper.uxx=oper;f_val.uxx=val
                End
*/
                If f_oper.uxx='' Then ol2='=';Else ol2=f_oper.uxx
                xx=Index(dynavU,'{'xxx)
                Parse VAR ol2 ol2 +1
                If xx>0 Then dynav=Overlay(ol2,dynav,xx-1)
            End
        End
        shadv=;pfield=0;in_error=1;zcmd=
        dynav=Substr(' ',1,57)dynav
        zedlmsg='Enter any non blank against the fields you want',
                'reported OR more specifically one of ">", "<", "=" or',
                '"/" to generate corresponding field selection',
                'criteria.  Enter "ALL" on the command line to select',
                'all or "NONE" to unselect all.  Enter "SORT" to sort',
                'field names alphabetically.'
        "SETMSG MSG(ISRZ001"
scr2a:screen=2
        zwinttl=ft'- Field selection'
        "ADDPOP ROW(&#POPR) COLUMN(&#POPC)";typ#='OUTPUT'
        csdalmsg=zedlmsg;"VPUT (csdalmsg) PROFILE"
        "DISPLAY PANEL("xcmd"P) CURSOR(DYNAV) CSRPOS(59)";rc1=rc;"REMPOP";csr1=
        If Wordpos('/LM',Translate(zcmd))>0 Then Do
            zedsmsg=;zedlmsg=csdalmsg
            If zedlmsg='' Then zedlmsg="OOPS - Missing previous 'CSDA'",
                                       "message for redisplaying."
                "SETMSG MSG(ISRZ001)"
            Signal scr2a
        End
        zedlmsg=
        If Word(zcmd,1)='TRACE' Then Do
            If Word(zcmd,1)='OFF' Then Trace o;Else Trace r
            Signal scr2a
        End
        If zcmd='?' | ifind='?' Then Do
            Signal on Syntax Name error_on_02
            Interpret 'x=$BR('xcmd' "??")';Signal error_02              off_00
error_on_02: Address TSO xcmd "??"
error_off_02:Signal off Syntax
            If ifind='?' Then ifind=;Signal scr2a
        End
        If rc1=0 Then Do
            If zcmd='ALL' Then Do
                m_fields=;o_fields=Translate(@xf);Signal scr2
            End
            If zcmd='NONE' Then Do
                o_fields=;Signal scr2
            End
            If zcmd='SORT' Then Do
                xf=$sort(xf);Signal scr2
            End
            o_fields=;dynav=Substr(strip(dynav),2)'¬'
            $dynav='¬'Substr(dynav,1,Length(dynav)-1)
            $dynav=Substr($dynav,1,((Length($dynav)%57)+1)*57)
            $dynav=Substr(' ',1,57)$dynav||Substr(' ',1,57);$dl=Length($dynav)
            bm_fields=
            Do While dynav/=''
                Parse VAR dynav sel '{' fname '¬' dynav
scr3:
                If sel/='' Then Do
/*--------------------------------------------------------------------*/
/* Evaluate what action to take if the selection is not space.        */
/*--------------------------------------------------------------------*/
                    If Wordpos(sel,'> < = /')>0 Then Do
                        @dynav=dynav;If sel='/' Then sel='/='
                        Parse Upper VAR fname uname
                        val=f_val.uname;f_oper.uname=sel
                        zedlmsg='Enter "'sel'" value to process against',
                                "'"fname"'."
                        dynav=$dynav'}'fname'¬'Substr(val,1,55)'{'
                        cp=Lastpos('¬',dynav)+1
                        "SETMSG MSG(ISRZ001"
scr3a:screen=3
                        zwinttl=ft'- Field match entry'
                        csdalmsg=zedlmsg;"VPUT (csdalmsg) PROFILE"
                        "ADDPOP ROW(&#POPR) COLUMN(&#POPC)";typ#='OUTPUT'
                        "DISPLAY PANEL("xcmd"P) CURSOR(DYNAV) CSRPOS(&CP)"
                        rc1=rc;"REMPOP"
                        If Wordpos('/LM',Translate(zcmd))>0 Then Do
                            zedsmsg=;zedlmsg=csdalmsg
                            If zedlmsg='' Then,
                                     zedlmsg="OOPS - Missing previous 'CSDA'",
                                             "message for redisplaying."
                                "SETMSG MSG(ISRZ001)"
                            Signal scr3a
                        End
                        zedlmsg=
                        If zcmd='?' | ifind='?' Then Do
                            Signal on Syntax Name error_on_02
                            Interpret 'x=$BR('xcmd' "??")';Signal error_off_02
error_on_02: Address TSO xcmd "??"
error_off_02:Signal off Syntax
                            If ifind='?' Then ifind=;Signal scr3a
                            If Word(zcmd,1)='TRACE' Then Do
                                If Word(zcmd,1)='OFF' Then Trace o;Else Trace r
                                Signal scr3a
                            End
                        End
                        If rc1/=0 Then Do
                            If Wordpos(fname,m_fields)>0 Then m_fields=,
                                delword(m_fields,Wordpos(fname,m_fields),1)
                            f_val.uname=;f_oper.uname=
                            dynav=@dynav;Iterate
                        End
                        Interpret "Parse VAR dynav" $dl "'¬' val '{'"
                        f_val.uname=Space(val)
                        If Index(m_fields,fname)=0 Then,
                            m_fields=m_fields fname
                        If Index(' 'bm_fields,' 'fname)=0 Then,
                            bm_fields=bm_fields fname||sel||Space(val,0)
                        dynav=@dynav;shadv=@shadv
                    End
                    Else If Wordpos(fname,m_fields)>0 Then m_fields=,
                            Delword(m_fields,Wordpos(fname,m_fields),1)
                    o_fields=o_fields fname
                End
/*--------------------------------------------------------------------*/
            End
            o_fields=Translate(Space(o_fields))
            If o_fields='' Then no_flds=1;Else no_flds=0
        End
        pfield=0;dynav=#dynav;shadv=#shadv;xf=#xf;in_error=1
        Signal scr1
    End
/*--------------------------------------------------------------------*/
    If batch='Y' Then Signal set_up_for_batch
/*--------------------------------------------------------------------*/
Bypassed_for_batch:
    in_error=0
    Signal on Syntax Name error_on_05
    If \readCSD Then no_flds=1
    If dsnvsam='' | no_flds Then Signal error_on_05
    dsnvsam=Strip(dsnvsam,,"'")
    xx=Listdsi("'"dsnvsam"'")
    If xx<5 | sysreason=9 | sysreason=25 Then Nop
    Else Signal error_on_05
    If sysdsorg/='VS' Then Do
        Signal off Syntax
        msgx="NOTE:- Dataset is not a VSAM dataset."
        in_error=1;Signal scr1
    End
    Address TSO "EXECIOVS * KSDSLL '"dsnvsam"' (LOG)"
    Parse Pull arecl mrecl
    If arecl/=200 & CICSV=21 Then Do
        Signal off Syntax
        msgx="NOTE:- CSD is pre TS2.1 and version has been set to 1.3."
        in_error=1;cicsv=13;#ft=;Signal get_itemflds
    End
    try2open=CSDR('T',dd,dsnvsam)
    Signal error_off_05
error_on_05: try2open=0;listdesc=0
error_off_05:Signal off Syntax
    Address ISREDIT
    #tr=Trace('o')
/*--------------------------------------------------------------------*/
/* Expand multi entities with global prefix suffix if present         */
/*--------------------------------------------------------------------*/
    Parse VAR ifind p1 '(' xxx ')' p2
    If xxx/='' Then Do
        ifind=;xxx=Translate(xxx,' ',',')
        Do While xxx/=''
            Parse VAR xxx xx xxx
            ifind=ifind p1||xx||p2
        End
        ifind=Space(ifind,,',')
    End
/*--------------------------------------------------------------------*/
    find=ifind;hit1=0;off=0
    If Wordpos('*',Translate(find,' ',','))>0 & batch/='O' &,
       Wordpos(findtype,no_wild)>0 Then Do
        zedlmsg='At least one componponent of "'ifind'" is ''*'' which',
                'may take an unsurmountable time to process and',
                'therefore not permitted for the following blacklisted',
                'items "'Space(no_wild,,',')'".',
                'Batch processing has been enforced.'
        Address ISPEXEC "SETMSG MSG(ISRZ001)";in_error=1;csr1='IFIND'
        batch='Y'
        Signal scr1
    End
    If Substr(find,1,1)='*' Then find=Substr(find,2)
    Else Do;find=' 'find;off=1;End
    ll=Length(find)
    If Strip(find)/='' Then Do
        If Substr(find,ll,1)='*' Then find=Substr(find,1,ll-1);Else find=find' '
    End
/*
    If Strip(find)='' Then Do
        zedlmsg='Invalid ''item'' "'ifind'" entered. Item translates',
                'to "'find'" which is not permitted.'
        Address ISPEXEC "SETMSG MSG(ISRZ001)";in_error=1;csr1='IFIND'
        Signal scr1
    End
*/

    Address ISREDIT
    If \append Then "RESET"
    xx=Date('e')
/*--------------------------------------------------------------------*/
/* If date changed is to be listed, determine if $DATEMAN is available*/
/* once.                                                              */
/*--------------------------------------------------------------------*/
    If listdate Then Do
        dm_avail=0
        Signal on Syntax Name error_on_$DATEMAN
        If datefmt='U' Then xx=$DATEMAN('VUR');Else xx=$DATEMAN('VER')
        dm_avail=1
        Select
            When datefmt='E' Then dm_opt='J2E'
            When datefmt='U' Then dm_opt='J2U'
            Otherwise dm_avail=0
        End
        If datefmt='J' Then xx=$DATEMAN('E2J',,2);Else xx=$DATEMAN(dm_opt)
    End
error_on_$DATEMAN:Signal off Syntax
/*--------------------------------------------------------------------*/
    x='Start..'Time() '('xx')  '
    y='[ Vers -' xcmd':'csda_ver',' xcmd'$:'csda$_ver '].'
    x=nl(x y);x=nl(' ');x=Time('r')
    "F 'GROUP NAME: ' FIRST"
    If rc/=0 Then Do
        zedlmsg='Cannot find "GROUP NAME:". Is this a valid CSD listing?'
        Address ISPEXEC "SETMSG MSG(ISRZ001)"
        Signal exi1
    End
    "(#lin#)=LINENUM .ZCSR";"(lrecl)=LRECL"
    "F '************************************************' LAST"
    "LABEL .ZCSR=.BLINE"
    findt=Substr($U2lower(findtype),1,Length(findtype))
    If findtype='GROUPS' Then Do
        "F 'GROUP NAMES:' FIRST";"(lin#)=LINENUM .ZCSR";lin#=lin#-1
        linex=
        Do Forever
            lin#=lin#+1;"(line)=LINE" lin#
            If Index(line,'***********')>1 Then Leave
            Parse Var line ch1 +1 line;If ch1=1 Then Iterate
            linex=linex Substr(line,2)
        End
        linex=' 'Space(Subword(linex,3))
        groups=;ptr=1;og_#=0;ogi_#=0
        Parse UPPER VAR find find .
        If find='' Then find=' '
        Else If Substr(ifind,1,1)/='*' Then find=' 'find
        Do Forever
            ptr=Index(linex,find,ptr);If ptr=0 Then Leave
            group=$Wordat(linex,ptr)
            If Wordpos(group,groups)=0 Then groups=groups group
            ptr=ptr+1
        End
        groups=Space(groups)
        hits=groups;X=output_stats#01()
        If groups='' Then Do
             x=nl('** None Found **')
             x=nl(' ')
/*           x=nl('**** Used in lists **')                            */
/*           groups=find                                              */
        End
        Else x=nl(' ')
        If groups/='' Then hit1=1
        If Words(groups)>1 Then groups=Output(groups,findt'(')
        x=nl(' ');og_i=0
        If orphan_groups Then Do
            If orphan_IBM Then xtra=;Else xtra=' (excluding IBM groups)'
            x=nl('Orphaned groups'xtra':')
        End
        g_#=Words(groups)
        Do While groups/=''
            Parse VAR groups group groups
            lists=find_list(group)
            If orphan_groups Then Do
                If lists/='' Then Iterate
                og_#=og_#+1
                If Substr(group,1,3)='DFH' Then Do
                    ogi_#=ogi_#+1;If \orphan_IBM Then Iterate
                End
                If orphan_delete Then Do
                    og_i=og_i+1;lineog.og_i='DEL GROUP('group')'
                End
            End
            xx=Substr('  Group('group')',1,18)'- Lists('
            x=Output(lists,xx)
        End
        x=nl(' ')
        x=nl('  Total groups:' Right(g_#,7))
        x=nl('  Orphans     :' Right(og_#,7) '('ogi_# 'IBM)')
        If orphan_delete Then Do
            Address TSO "NEWSTACK"
            Do i=1 To og_i
                Queue lineog.i
            End
            Address TSO "%CSDL '"dsnvsam"' /Q"
        End
        Signal Get_out
    End
    lin#=#lin#;col#=0;hits=
    afind=Translate(ifind,' ',',')
    Do While afind/=''
        Parse Var afind find afind;ofind=find
        If Index(find,'*')=0 Then find=' 'find' '
        Else Do
            off=0
            If Substr(find,1,1)='*' Then find=Substr(find,2)
            Else Do;find=' 'find;off=1;End
            ll=Length(find)
            If Strip(find)/='' Then Do
                If Substr(find,ll,1)='*' Then find=Substr(find,1,ll-1)
                Else find=find' '
            End
        End
        x=find_wild_item(find,findtype)
    End
    X=output_stats#01()
    x=nl(' ')
    If u_fields/='' Then Do
        x=nl('Unavailable_fields:')
        x=nl('  'Space(u_fields,,','))
        x=nl(' ')
    End
    If gs_fields/='' Then Do
        x=nl('Global_suppressed_fields:')
        x=nl('  'Space(gs_fields,,','))
        x=nl(' ')
    End
    If m_fields/='' Then Do
        x=nl('Match_fields_on:')
        xxx=m_fields
        Do While xxx/=''
            Parse VAR xxx xx xxx;Parse Upper VAR xx ux
            x=nl('  'Substr(xx,1,8) Substr(f_oper.ux,1,2) f_val.ux)
        End
        x=nl(' ')
    End
    If hits/='' Then hit1=1
    If Words(hits)>1 Then Do
          If time_s Then Do
              x_x=Time('s');x=nl('...... Sort start:' Time())
              x=nl(' ')
          End
      hits=Output(hits,findt'(')            /* Lists items found      */
          If time_s Then Do
              y_y=Time('s');x=nl('...... Sort End:  ' Time() '('y_y-x_x'secs)')
              x=nl(' ')
          End
    End
    If xontally Then Signal exi1
    If proc_lim='*' Then proc_lim=Words(hits)+1
    If batch='N' & Words(hits)>proc_lim Then Do
        zedsmsg=
        zedlmsg='Number of hits of "'Words(hits)'" exceed the limit of',
                '"'Proc_lim'". Either run in batch, force on-line or',
                "change the limit using the '/PL(nnnn)' parameter."
        Address ISPEXEC "SETMSG MSG(ISRZ001)"
        Signal exi1
    End
    findt=Substr(ft,1,Length(ft)-1)
    wx=Word(itemflds,Wordpos(findtype,itemflds)+1);wx=TRanslate(wx,' ','_')
    If listdesc Then Do
        wd=Word(descflds,Wordpos(findtype,descflds)+1);wd=TRanslate(wd,' ','_')
        wx=wx wd
    End
    If ispf/='ACTIVE' Then wx=Translate(wx)

    If o_fields/='' Then Do
        yyy=;Parse Upper VAR @xf u@xf;Parse Upper VAR o_fields o_fields
        Do While o_fields/=''
            Parse VAR o_fields xx o_fields
            yy=Wordpos(xx,u@xf);If yy>0 Then yyy=yyy Word(@xf,yy)
        End
        xf=Space(yyy)
    End;Else xf=@xf
    m_finds=
    x=nl(' ');If sep_it Then x=nl(Copies('_',72))
    If n_prog Then Do
        If first_time Then Call x_first_time
        rept=Words(hits);rep#=rept//pop_upf;shadv=
    End
    Do While hits/=''
        Parse var hits find hits
        If n_prog Then Do
            If Words(hits)//pop_upf=rep# Then Do
                dynav=Right('Processed 'rept-Words(hits)'/'rept 'hits.',200)
                shadv=Copies('y',Length(dynav))
                Address ISPEXEC
                "CONTROL DISPLAY LOCK";"ADDPOP ROW(&#POPR) COLUMN(&#POPC)"
                "DISPLAY PANEL("xcmd"P) CURSOR(&CSR1)";"REMPOP"
                Address
            End
        End
        lin#=#lin#;col#=0;groups=
        x=find_groups(find,findtype)
        If multigp Then,
            If Words(groups)=1 Then Iterate
        m_finds=m_finds find
        groups=Space(groups,1,',')
        If m_fields/='' Then Do;qit=1;q#=0;End
        x=Output(groups,findt'('find') > Groups(')
        If sep_it Then Do;x=nl(' ');s_sep='-';s_pad='  ';End
        Do While groups/=''
            Parse VAR groups group ',' groups
            If i_groups/='' & Wordpos(group,i_groups)=0 Then Iterate
            hd1=Substr('  Group('group')',1,18);hdx=hd1
            lists=find_list(group)
            If lists='' Then xx=hd1'- Lists (';Else xx=hd1'+ Lists ('
            x=Output(lists,xx);hd1=Substr(' ',1,18)
            If \no_flds Then,
                If Wordpos(findtype,itemflds)>0 Then xx=Get_CSD_Data()
            If sep_it Then Do
                If groups='' Then Do;s_sep='=';s_pad=;End
                x=nl(s_pad||Copies(s_sep,72))
            End
            If m_fields/='' Then Do;qit=1;q#=0;End
        End
    End
    If multigp Then Do
        x=nl(' ')
        x=nl('Multi_groups: The following' Words(m_finds) 'items found',
             'in >1 groups.')
        x=Output(m_finds,'  'findt'(')
    End

Get_out:
    If \hit1 Then x=nl('** None Found **')
    x=nl(' ');x=nl(Centre('- *** -',72));x=nl(' ')
exi1:
    x=nl('End...'Time() '('Time('r')' secs)');x=nl(' ')
exi2:
    If vsamopen Then vsamopen=CSDR('f',dd)
    If \first_time Then Do
        #msg=Msg('Off')
        Address ISPEXEC "LIBDEF ISPPLIB";Address TSO "DELETE '"csdadsn"'"
        x=Msg(#msg)
    End
    "ISREDIT USER_STATE=(status)"
    If ispf/='ACTIVE' Then "ISREDIT CANCEL"
    Else Do
        If hot Then Do
            dd='EI'Time('s')
            If append & Sysdsn("'"outdsn"'")='OK' Then Do
                Address TSO "ALLOC F("dd") DSN('"outdsn"') SHR REU"
                Address TSO "EXECIO * DISKR "dd" (STEM linei. FINIS)"
                Address TSO "FREE F("dd")"
                linei.0=linei.0+1
                Interpret 'linei.'linei.0'=" "'
                linei.0=linei.0+1
                Interpret 'linei.'linei.0'=Left("*- Appending ",71,"-")"*"'
                linei.0=linei.0+1
                Interpret 'linei.'linei.0'=" "'
            End;Else linei.0=0
            #m=Msg('Off');Address TSO "DELETE '"outdsn"'";x=Msg(#m)
            Address TSO "ALLOC F("dd") DSN('"outdsn"') NEW CATALOG",
                        "SPACE(100 30) TRACKS RECFM(F B) LRECL(80)",
                        "BLKSIZE(0) RELEASE" uvol_to
            Address TSO "EXECIO * DISKW "dd" (STEM linei.)"
            Address TSO "EXECIO * DISKW "dd" (STEM lineh. FINIS)"
            If e_after Then Do
                Address ISPEXEC "LMINIT DATAID(DATAID) DDNAME("dd")"
                Address ISPEXEC "EDIT DATAID(&DATAID)"
                Address ISPEXEC "LMFREE DATAID(&DATAID)"
            End
            Address TSO "FREE F("dd")"
        End
    End
    csdalmsg=zedlmsg;Address ISPEXEC "VPUT (csdalmsg) PROFILE"
    Exit

/*--------------------------------------------------------------------*/
/* Verify fields.                                                     */
/*--------------------------------------------------------------------*/
ver_fields: Arg ifld
    vfld=TRanslate(@xf);rfld=
    Do While ifld/=''
        Parse VAR ifld xx ifld
        If Wordpos(xx,vfld)>0 Then rfld=rfld Word(@xf,Wordpos(xx,vfld))
    End
    Return rfld

/*--------------------------------------------------------------------*/
/* Parse match fields parameter to it's seperate components           */
/*--------------------------------------------------------------------*/
Parse_m_fields:
    yyy=m_fields;m_fields=
    Do While yyy/=''
        Parse VAR yyy xxx yyy
        col#=Verify(xxx,'<>=/','M')
        Interpret "Parse VAR xxx xxx +"col#-1 "oper +1 val"
        If oper='/' Then Do;oper='/=';val=Substr(val,2);End
        Parse Upper VAR xxx uxx
        f_oper.uxx=oper;f_val.uxx=val;m_fields=m_fields xxx
    End
    Return 0

/*--------------------------------------------------------------------*/
/* Determine eXpose Fields (fields to be reported)                    */
/*--------------------------------------------------------------------*/
eXpose_fields:
    xxx=SubWord(itemflds,Wordpos(findtype,itemflds)+1,1);xf=;u_fields=
    gs_fields=
    Do While xxx/=''
        Parse VAR xxx fname '_' . '_' report '_' xxx
        Parse VAR report report1 '/' report2
        If report1='N' & report2/='' Then Do
            u_fields=u_fields fname
            Iterate
        End
        If report1='N' | report2='N' Then Do
            gs_fields=gs_fields fname
            Iterate
        End
        xf=xf fname
    End
    xf=Space(xf desc_id)
    If ispf/='ACTIVE' Then xf=Translate(xf)
    @xf=xf;#ft=ft
    Return 0

/*--------------------------------------------------------------------*/
/* If CSD available, get extra information for items as per contents  */
/* of variable "itemflds".                                            */
/*--------------------------------------------------------------------*/
Get_CSD_Data:
    If try2open Then Do
        try2open=0;dd='VS'Time('s')
        If \vsamopen Then vsamopen=CSDR('o',dd,dsnvsam);Address TSO "DELSTACK"
    End
    If vsamopen Then Do
        xx=Wordpos(findtype,Translate(validtypes))
        hexoff=Word(validtypes,xx+1)
        key=Substr(group,1,8)||x2c(right(hexoff,12,'0'))||Substr(find,1,8)
        vrc=CSDR('R',dd,key)
        If vrc=12 Then Do
            vsamopen=0;Parse PULL line
            x=nl(' ');x=nl('*'Copies('-',70)'*')
            p1=$wordat(line,69,'L');p2=$wordat(line,69,'T')
            x=nl(Substr('* CSD process error:',1,71)'*')
            x=nl('*'Copies(' ',70)'*')
            x=nl(Substr('* 'p1,1,71)'*')
            x=nl(Substr('*         'p2,1,71)'*')
            x=nl('*'Copies(' ',70)'*')
            x='* This may be due to environmental/site conflicts.'
            x=nl(Substr(x,1,71)'*')
            x=nl('*'Copies('-',70)'*');x=nl(' ')
        End
    End;Else vrc=12
    If vrc=0 Then Do
        Parse PULL line;ll=Length(line)
        i_tm=Strip(Substr(key,15,8));ps=Index(line,i_tm,Length(key)+1)-2
        Parse VAR line 25 cdate +8
    End;Else cdate=inval
    Address TSO "DELSTACK"

    oval=;odesc=;#wx=wx
/*--------------------------------------------------------------------*/
/* Parse the CSD record                                               */
/*--------------------------------------------------------------------*/
    If vrc=8 Then Do
        oval='** Not found in group (may be mistaken case?) **;'
        Signal End_field_process
    End
    Do While #wx/=''
        Parse VAR #wx w1 w2 '/' ml rit #wx
        If Wordpos(w1,xf)=0 Then Iterate
        Parse Var ml ml '(' d_val ')'
        Parse VAR ml ml 'X' xl;Parse VAR ml ml 'R' rl;Parse VAR ml ml 'D' dl
        Parse VAR ml ml 'N' nl;Parse VAR ml ml '*' al
        pp=ps;val=
        If vrc=0 & pp>0 Then Do
            If Index(w2,':')>0 Then Do
                Parse VAR w2 col ':' il '(' matrix ')'
                val=Substr(line,col,il)
                Interpret "Parse VAR matrix '"val"=' val ','"
            End
            Else Do
                Do Forever
                    id=Substr(line,pp,1);il=c2d(Substr(line,pp+1,1))
                    If id=x2c(w2) Then Do
                        val=Substr(line,pp+2,il)
                        Select
                            When nl/='' Then val=c2d(val)
                            When dl/='' Then val=Right(c2d(val),ml,'0')
                            When xl/='' Then val=c2x(val)
                            Otherwise Nop
                        End
                        Leave
                    End
                    pp=pp+2+il
                    If pp>ll Then Leave
                End
                If val='' & d_val/='' Then Do;val=d_val;ml=Length(d_val);End
            End
        End;Else val=inval
        If val='' & rit='I' Then Iterate
/*------------------------------------------------------------------- */
/* The next line MUST be before the following line as "val" may need  */
/* to be reprocessed by "CSDA$" befor it's value is changed.          */
/*------------------------------------------------------------------- */
        If rl/='' & val/=inval Then val=Csda$('/R',rl,val)
        If Length(val)>ml Then val='«'Substr(val,(Length(val)-ml)+2)
/*------------------------------------------------------------------- */
        If val='' & al/='' Then Do
            If Datatype(al,'w') Then val=Substr(find,1,al)
            Else val=find
        End
        If Wordpos(w1,m_fields)>0 Then Do
            Parse Upper VAR w1 uw1
            If f_oper.uw1/='' Then Do
                xxx=f_val.uw1
                If xxx/='' Then Do
                    If Substr(xxx,Length(xxx),1)='*' Then Do
                        Parse VAR xxx xxx '*'
                        vax=Translate(Substr(val,1,Length(xxx)))
                    End
                    Else vax=Translate(val)
                End
                Else vax=Translate(val)
                keep=1
                Interpret "If '"vax"'"f_oper.uw1"'"xxx"' Then Nop;Else keep=0"
                If \keep Then Do
                    If nm_supr Then Return 0
                    qit=0;q#=0
                    x=nl(lineq.1)
                    If Substr(lineq.1,1,2)/='  ' Then x=nl(lineq.3)
                    x=nl(Right('  *** No match for "Match_field_on" ***',57))
                    Return 0
                End
            End
        End
        If Length(val)>ml Then ml=Length(val)
        If callign & ml<8 Then ml=8
        pad=Substr(' ',1,ml-Length(val))
        If w1/=desc_id Then oval=oval||Substr(w1,1,6,'.')'('val'); 'pad
        Else odesc=val
    End
End_field_process:
    If qit Then Do
        qit=0
        Do ii=1 To q#
            x=nl(lineq.ii)
        End
        q#=0
    End
    If oval/='' Then Do
        oval=Substr(Strip(oval),1,Lastpos(';',oval)-1)
        x=Output_oval(oval,hd1'» ');hd1=Substr(' ',1,18)
    End
#tr=Trace('o')
    If odesc/='' & odesc/=inval Then x=nl(hd1'* "'odesc'"')
    If listdate Then Do
        If cdate/=inval Then Do
            cdate=c2x(cdate)
            Parse VAR cdate yy +2 ddd +3 hh +2 mm +2 ss +2
            If dm_avail Then Do
                cdate=$DATEMAN(dm_opt,yy||ddd)
                If Word(cdate,1)='Error' Then cdate=yy'.'ddd
            End;Else cdate=yy'.'ddd
            cdate=cdate 'at' hh':'mm':'ss'.'
        End
        If vrc/=8 Then x=nl(hd1'4A'x cdate)
    End
/*  If m_fields/='' Then Do;qit=1;q#=0;End                            */
    Return 0

/*--------------------------------------------------------------------*/
/* Find all entities for wilcarded entry(s).                          */
/*--------------------------------------------------------------------*/
find_wild_item:Arg findit,findtype
    If ofind='*' Then findit="p' ¬'";Else findit="'"findit"'"
    "LABEL" #lin#"=.TLINE";lint=#lin#
    If findtype='FILES' Then col_end=09;else col_end=20
    Do Forever
        "CURSOR="lint 0
        "F '"findtype":' 1 "col_end" .TLINE .BLINE";If rc/=0 Then Leave
        "(line)=LINE .ZCSR";Parse VAR line xx ':';xx=Strip(xx)
        "LABEL .ZCSR=.FLINE";"(linf)=CURSOR";"CURSOR="linf+1 0
        "F ':' 1 20 .ZCSR .BLINE"
        If rc=0 Then "(lint)=CURSOR";Else "(lint)=LINENUM .BLINE"
        "LABEL" lint-1"=.TLINE";"CURSOR="linf 0
        If linf+1=lint Then range=".TLINE .TLINE";Else range=".FLINE .TLINE"
        Do Forever
/*          "F '"findit"' 20" lrecl range;If rc/=0 Then Leave         */
            "F "findit" 20" lrecl range;If rc/=0 Then Leave
            "(line)=LINE .ZCSR";If Word(line,1)='1CICS' Then Iterate
            "(lin#,col#)=CURSOR"
            yy=col#+off;hit=$Wordat(line,yy)
            If Wordpos(hit,hits)=0 Then hits=hits hit
        End
    End
    Return 0
/*--------------------------------------------------------------------*/
/* Find all groups for appropriate entity.                            */
/*--------------------------------------------------------------------*/
find_groups:Arg findit,s_findtype
    If s_findtype='LIBRARYS' Then s_findtype='LIBRARYs'
    Do Forever
        "CURSOR="lin# col#+1
        "F ' "findit" ' ";If rc/=0 Then Leave;"(lin#,col#)=CURSOR"
        "(line)=LINE .ZCSR";yy=col#+off;hit=$Wordat(line,yy)
        "F ':' 1 20 PREV";If rc/=0 Then Iterate
        "(line)=LINE .ZCSR";Parse VAR line 2 id ':'
        id=Strip(id);If id='GROUP NAME' Then Iterate
        If id/=s_findtype Then Iterate
        "F 'GROUP NAME:' 1 20 PREV";If rc/=0 Then Leave
        "(line)=LINE .ZCSR";Parse VAR line ':' group .
        If Wordpos(group,groups)=0 Then groups=groups group
    End
    Return 0
/*--------------------------------------------------------------------*/
/* Find all lists for group.                                          */
/*--------------------------------------------------------------------*/
find_list:Arg findit
    lista=
    "F 'GROUP      ' LAST";"(xx)=CURSOR";"CURSOR="xx+1
    Do Forever
        "F 'GROUP      "group" ' PREV";If rc/=0 Then Leave
        "F 'LIST NAME:' PREV";If rc/=0 Then Leave
        "(line)=LINE .ZCSR";Parse VAR line ':' list .;lista=lista list
    End
    Return Space(lista)
/*--------------------------------------------------------------------*/
/* Output a line and if > 72 chars break up into appropriate lines.   */
/*--------------------------------------------------------------------*/
Output:Parse Arg xxx,pre,dont_sort
    If xxx='' Then Do;x=nl(pre')');Return xxx;End
    Signal on Syntax Name error_off_10
    xxx=Translate(xxx,' ',',')
/*  If dont_sort='' Then xxx=$sort(xxx)                               */
    If dont_sort='' Then Do
        If Words(xxx)>isort_limit Then xxx=sync_sort(xxx)
        Else xxx=$sort(xxx)
    End
error_off_10:Signal off Syntax
    xx=Space(xxx)')'
    Do While xx/=''
        x=$Wordat(xx,72-Length(pre),'l')
        If x='' Then Do;x=nl(xx);xx=;Leave;End
        xx=Strip($Wordat(xx,72-Length(pre),'t'));If xx='' Then y=;Else y=','
        x=nl(pre||Space(x,1,',')y);pre=Copies(' ',Length(pre))
    End
    Return xxx
Output_oval:Parse Arg xxx,pre
    xx=xxx
    Do While xx/=''
        If o_liner Then Do
            Parse Var xx x ';' xx;x=strip(x)
        End
        Else Do
            x=$Wordat(xx,72-Length(pre),'l')
            If x='' Then Do
                x=$Wordat(xx,72,'l')
                If x='' Then Do
                    x=Substr(xx,1,71)'+'
                    xx=Substr(xx,72)
                End
                Else xx=$Wordat(xx,72,'t')
                x=nl(x);Iterate
            End
            xx=Strip($Wordat(xx,72-Length(pre),'t'))
        End
        x=nl(pre||x);pre=Copies(' ',Length(pre))
    End
    Return xxx
output_stats#01:
    x=nl('Parameter:' findtype'('ifind') -' Words(hits) 'unique hits.')
    If key_w/='' Then x=nl('Key_words:' Space(key_w))
    If \try2open Then xtra=' (not processed)';Else xtra=
    If dsnvsam/='' Then x=nl("CSD:       '"dsnvsam"'"xtra)
    Else                x=nl("CSD:       Unavailable...")
    Return 0
nl:Parse Arg nl1
    If qit Then Do;q#=q#+1;lineq.q#=nl1;End
    Else Do
       If hot Then Do;h#=h#+1;lineh.h#=nl1;Return 0;End
       If ispf='ACTIVE' Then "LINE_BEFORE 2=NOTELINE (nl1)";ELse Say nl1
    End
    Return 0
/*nl:Parse Arg nl1;"LINE_BEFORE .ZFIRST=NOTELINE (nl1)";Return 0      */
/*--------------------------------------------------------------------*/
/* Sort using the IBM supplied SORT program                           */
/*--------------------------------------------------------------------*/
sync_sort: Arg yyyy
    i=0;Do While yyyy/='';Parse VAR yyyy xx yyyy;i=i+1;v.i=xx;End
    shlq=Sysvar(Syspref)'.'Userid()'.CSDASORT'
    sortin=shlq'.SORTIN';sortout=shlq'.SORTOU';sysin=shlq'.SYSIN'
    sysout=shlq'.SYSOUT'
    Address TSO;#m=Msg('Off')
    "FREE F(SORTIN,SORTOUT,SYSIN,SORTWK01)"
/*  "FREE F(SORTLIB)"                                                 */
    "DELETE '"sortin"'";"DELETE '"sortout"'";"DELETE '"sysin"'"
    "DELETE '"sysout"'"
    "ALLOC F(SORTIN) DA('"sortin"') CATALOG" uvol_po "NEW REU",
       "SPACE(10,10) CYLINDERS RECFM(F B) LRECL(8) BLKSIZE(0) DSORG(PS)"
    "ALLOC F(SORTMSG) DUMMY SHR REU"
    "ALLOC F(SORTOUT) DA('"sortout"') CATALOG NEW REU LIKE('"sortin"')"
    "ALLOC F(SYSIN) DA('"sysin"') CATALOG" uvol_po "DSORG(PS)",
       "SPACE(1) TRACKS RECFM(F) LRECL(80) NEW REU"
    "ALLOC F(SYSOUT) DA('"sysout"') CATALOG" uvol_po "DSORG(PS)",
       "SPACE(1,1) TRACKS RECFM(F) LRECL(80) NEW REU"
    "EXECIO * DISKW SORTIN (STEM v. FINIS)"
    "NEWSTACK";Queue ' SORT FIELDS=(1,8,CH,A)';Queue ''
    "EXECIO * DISKW SYSIN (FINIS"
    "ALLOC FILE(SORTWK01)" uvol_to "SPACE(5,5) CYLINDERS"
/*  "ALLOC FILE(SORTLIB)  DA('DFSORT.SORTLIB') SHR REU"               */
    Address ISPEXEC "SELECT PGM(SORT)"
    sort_rc=rc
    If time_s & sort_rc=0 Then Do
        Address ISREDIT
        z_z=Time('s');x=nl('...... SyncSorted:' Time() '('z_z-x_x'secs)')
        Address
    End
    "EXECIO * DISKR SORTOUT (STEM v. FINIS)"
    "FREE F(SORTIN,SORTOUT,SYSIN,SORTWK01)"
    "FREE F(SORMSG)"
/*  "FREE F(SORTLIB)"                                                 */
    "DELETE '"sortin"'";"DELETE '"sortout"'";"DELETE '"sysin"'"
    "DELETE '"sysout"'"
    If sort_rc/=0 Then Return $sort(xxx)
    yyyy=;Do i=1 To v.0;yyyy=yyyy v.i;End
    Return yyyy

/*--------------------------------------------------------------------*/
/* First time execution.                                              */
/*--------------------------------------------------------------------*/
x_first_time:
    #tr=Trace('o')
    first_time=0;dynav=validtypes;shadv=;Call build_panel
    noitems=Words(validtypes)%3
    dynav=;xxx=validtypes;ent_len=18
    Do while xxx/=''
        Parse VAR xxx w1 w2 w3 xxx
        yy=Verify(w2,'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789','N')
        w2=Substr(w2,1,ent_len-2)
        dynav=dynav||Right(w1,2) w2
        shadv=shadv||'yy 'Copies('w',yy-1)Copies('t',ent_len-(yy+1))
    End
    x=Trace(#tr)
    Return 0
/*--------------------------------------------------------------------*/
/* Allocate panel                                                     */
/*--------------------------------------------------------------------*/
build_panel:
    u=Sysvar(Sysuid);p=Sysvar(Syspref);If u/=p&p/='' Then u=p'.'u;hlq=u
    csdadsn=hlq'.$$$TEMP.CSDPANEL'
    Address TSO;#msg=Msg('Off');"DELETE '"csdadsn"'"
    "ALLOC DA('"csdadsn"') NEW CATALOG TRACK SPACE(1,1) DSORG(PO) LRECL(80)",
       "BLKSIZE(0)" uvol_po "DIR(1) RECFM(F B) REU"
    "FREE DA('"csdadsn"')";"NEWSTACK";Call make_mem_1;#tr=Trace('o')
    Do i=n_st To n_en;Queue Sourceline(i);End;Queue '';x=Trace(#tr)
    "ALLOC F("dd") DA('"csdadsn"("xcmd"P)') SHR REU"
    "EXECIO * DISKW "dd" (FINIS";"FREE  F("dd")"
    Address
    Address ISPEXEC "LIBDEF ISPPLIB DATASET ID('&CSDADSN') STACK"
    x=Msg(#msg)
    Return 0

/*--------------------------------------------------------------------*/
/* Set up atch jcl and present under viewer.                          */
/*--------------------------------------------------------------------*/
set_up_for_batch:
    parm1=' ISPSTART CMD(%CSDABTCH /BE /O'  ;If cicsv=13 Then parm1=parm1 '/13'
    If xontally Then parm1=parm1 '/XT'
    If time_s   Then parm1=parm1 '/TS'
    acct=$alkacct()
    prognm='CSDA-Batch'
    v1='def_ac def_bb def_ex def_hd def_id def_tp def_vm'
    Interpret "Parse Value '() X J H A 3480 J,H,X,Z' With" v1
    Signal on Syntax Name error_off_alkjcpg
    x=$Alkjcpg(prognm);If x/='' Then prognm=x
    Interpret "Parse Value $alkjc(v1) With" v1
error_off_alkjcpg:Signal off Syntax
    Address "NEWSTACK"
    Queue '//'Substr(Userid()'AB',1,8) 'JOB ('acct'),'
    Queue "//   '"prognm"',MSGCLASS="def_bb",REGION=0M,"
    Queue '//   CLASS='def_ex',MSGLEVEL=(1,1),NOTIFY=&SYSUID  ,TIME=1440'
    Queue '/*JOBPARM ROOM=ZTS,LINES=9999'
    Queue '//*MAIN     LINES=(999,W),CLASS=CICSUTIL'
    Queue '//*'
    Queue '//*----------------------------------------------------------------*'
    Queue '//* Modify as required and manually submit job.                    *'
    Queue '//*----------------------------------------------------------------*'
    If hardcopy & \append Then Do
        Queue '//*'
    Queue '//*----------------------------------------------------------------*'
    Queue '//* Comment or delete the following to "append".                   *'
    Queue '//*----------------------------------------------------------------*'
        Queue '//DONTAPND EXEC PGM=IEFBR14'
        Queue '//SYSTSPRT DD DSN='outdsn','
        Queue '//            SPACE=(TRK,(0,0)),'
        Queue '//            'uvol_pb','
        Queue '//            DISP=(MOD,DELETE,DELETE)'
    Queue '//*----------------------------------------------------------------*'
    End
    Queue '//*'
    Queue '//TSEP1 EXEC PGM=IEBUPDTE,PARM=NEW'
    Queue '//*'
    Queue '//SYSPRINT DD SYSOUT=*'
    Queue '//SYSUT2   DD DSN=&&CLISTS,'uvol_tb
    Queue '//       DISP=(NEW,PASS),SPACE=(TRK,(2,1,1)),'
    Queue '//       DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)'
    Queue '//SYSIN  DD DATA,DLM=$$'
    Queue './ ADD NAME=CSDABTCH'
    Queue '/* REXX */'
    Queue '   Arg parm#'
    Queue '   csd="''"'dataset'"''"'
    Queue '   Address ISPEXEC "VIEW DATASET(&CSD) MACRO(CSDA) PARM(parm#)"'
    Queue '   Exit'
    Queue './ ENDUP'
    Queue '$$'
    Queue '//*----------------------------------------------------------------*'
    Queue '//TSEP2    EXEC PGM=IKJEFT01,DYNAMNBR=65'
    Queue '//SYSPROC  DD DISP=(OLD,DELETE),DSN=&&CLISTS'
    Queue '//         DD DISP=SHR,DSN='$alkhlq()'.$$'
    Queue '//*----------------------------------------------------------------*'
    Queue '//* Batch ISPF environment.                                        *'
    Queue '//* (Hit me with command "BE" for site specifics. Use "BE *" to add*'
    Queue "//*  my datasets before system's.)                                 *"
    Queue '//* (Use "BE ALL" to add all then customise.)                      *'
    Queue '//*----------------------------------------------------------------*'
    Call batchisp 'NJ NS NU NI QUEUE CONC(SYSEXEC,SYSPROC)'
/*
    Let "BATCHISP" do all this for you......

    Queue '//ISPPLIB  DD  DISP=SHR,DSN=ISP.SISPPENU'
    Queue '//ISPSLIB  DD  DISP=SHR,DSN=ISP.SISPSENU'
    Queue '//ISPMLIB  DD  DISP=SHR,DSN=ISP.SISPMENU'
    Queue '//ISPTLIB  DD  DISP=SHR,DSN=ISP.SISPTENU'
    Queue '//ISPLLIB  DD  DISP=SHR,DSN='$alkhlq()'.$LOAD'
    Queue '//ISPPROF  DD  DSN=&ISPPROF,SPACE=(TRK,(10,,10)),'uvol_tb
    Queue '//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)'
    Queue '//ISPLOG   DD DUMMY'
*/
    Queue '//ISPLIST  DD DUMMY'
    If hardcopy Then Do
        Queue '//SYSTSPRT DD DSN='outdsn','
        Queue '//            SPACE=(TRK,(100,30),RLSE),'
        Queue '//            'uvol_pb','
        Queue '//            DISP=(MOD,DELETE,DELETE)'
    End
    Else Queue '//SYSTSPRT DD SYSOUT='def_hd
    Queue '//SYSTSIN  DD *'
    Queue parm1 key_b '+'
    Queue '  /CSD('dsnvsam') +'
    Queue '  'ft'('ifind') +'
    If o_fields/='' Then x=break_up(Strip(o_fields,,','),'/OF')
    If m_fields/='' Then x=break_up(Strip(bm_fields,,','),'/MF')
    If s_fields/='' Then x=break_up(Strip(s_fields,,','),'/SF')
    Queue '  )'
    Queue '/*'
    Queue '//'
    Queue ''
    Address ISPEXEC
    "VGET ZTEMPF"
    Address TSO "ALLOC DD(ZTEMPF) DS('"ztempf"') SHR REU"
    Address TSO "EXECIO * DISKW ZTEMPF (FINIS"
    "LMINIT DATAID(DATAID) DDNAME(ZTEMPF)"
    zedlmsg='JCL to run your report in batch. This JCL needs to be',
            'manually submitted.'
    "SETMSG MSG(ISRZ001)"
    "VIEW DATAID(&DATAID)"
    "LMFREE DATAID(&DATAID)"
    Address TSO "FREE DD(ZTEMPF)"
    Signal exi1

break_up:Parse Arg string,pref
    string='  'pref'('string')';pad='  '
    Do While Length(string)>70
        Queue pad||Space(Strip($Wordat(string,70,'l'),'t') '-',,',')
        pad=
        string=$Wordat(string,70,'t')
    End
    Queue pad||Space(Strip(string,'t'),,',') '+'
    Return 0

/*--------------------------------------------------------------------*/
/* Invoke CSDC /MA() function.                                        */
/*--------------------------------------------------------------------*/
Call_CSDC:
    Address ISPEXEC
/*  zscreeni=$Screenc()   /* Original screen        */                */
    "VGET (zscreeni)";"VGET (zscreenc)"
    Parse Value $Dat@CSR(zscreeni,'/L') with 9 line
    Parse Value Word(line,3) With '(' groups ')'
    w2=Word(line,1);groups=Translate(groups,' ',',')
    If groups='' Then Do
        zedlmsg=Substr("Data on line appears invalid.",
                "  Does not seem to contain:",1,70),
                "'resource(entry) > Groups(group1,..,groupN)' format data."
        "SETMSG MSG(ISRZ001)"
    End
    Else Do
        Do While groups/=''
            Parse VAR groups group groups
            If Words(groups)>0 Then jcl='/NJ';Else jcl=CSDC_jcl
            csdc_parm=csdc_funct'(GROUP('group'):'w2')'
            Address TSO "%CSDC '"dsnvsam"'" csdc_parm jcl
            csdc_funct='/MA'
        End
        If CSDC_jcl/='' Then Do
            zedlmsg='To generat your define/alter statements, you will',
                    'need to invoke "CSDC" with parameter of',
                    "'/MJ' agains CSD '"dsnvsam"' seperately."
            "SETMSG MSG(ISRZ001)"

        End
    End
    "ISREDIT USER_STATE=(status)"
    csdalmsg=zedlmsg;Address ISPEXEC "VPUT (csdalmsg) PROFILE"
    Exit

/*--------------------------------------------------------------------*/
/* Create help panel(s) from sourcelines between the '/* */'          */
/*--------------------------------------------------------------------*/
make_mem_1:
    n_st = mark(2)                          /* Mark start of data     */
/*
)ATTR DEFAULT(%?_)
 _ TYPE(INPUT)   INTENS(HIGH) COLOR(RED)    HILITE(USCORE)
 ` TYPE(&TYP#)   INTENS(HIGH) COLOR(RED)    HILITE(USCORE) CAPS(OFF)
 # TYPE(&TYP#)   INTENS(HIGH) COLOR(RED)    HILITE(USCORE)
 @ TYPE(TEXT)    INTENS(HIGH) COLOR(YELLOW)
 + TYPE(TEXT)    INTENS(LOW)  COLOR(GREEN)
 $ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)
 ! AREA(DYNAMIC)
 ¬ TYPE(DATAIN)  INTENS(HIGH) COLOR(RED) CAPS(ON) HILITE(USCORE)
 { TYPE(DATAOUT) INTENS(LOW)  COLOR(TURQ) CAPS(OFF) SKIP(ON)
 } TYPE(DATAOUT) INTENS(LOW)  COLOR(GREEN) CAPS(OFF) SKIP(ON)
 w TYPE(CHAR) COLOR(WHITE)
 W TYPE(CHAR) COLOR(WHITE) HILITE(USCORE)
 y TYPE(CHAR) COLOR(YELLOW)
 b TYPE(CHAR) COLOR(BLUE)
 B TYPE(CHAR) COLOR(BLUE) HILITE(USCORE)
 r TYPE(CHAR) COLOR(RED)
 t TYPE(CHAR) COLOR(TURQ)
 g TYPE(CHAR) COLOR(GREEN)
)BODY EXPAND(\\) WINDOW(60,23)
%&SID%=>_ZCMD
%
+Enter details below:                             ->@&WEXEC
+Item....`IFIND                    +Mask or comma seperated.
+TYpe....#CD+Enter code from list below (or place cursor):
   !DYNAV,SHADV                                            !
   !                                                       !
   !                                                       !
   !                                                       !
   !                                                       !
   !                                                       !
   !                                                       !
   !                                                       !
   !                                                       !
   !                                                       !
   !                                                       !
   !                                                       !
+DFHCSD..#DSNVSAM                                     +
+Fields..#Z+Field selection for reporting (Y/N).
+Muti.gp.#Z+Multi group, item in >1 groups (Y/N).
+Desc....#Z+Report description if available (Y/N).
+Allign..#Z+Column allign (where possible) (Y/N).
@ENTER+-process,@END/CANCEL+-abandon,@?+-tutorial.
)INIT
 IF (&READCSD=0)  .ATTR (DSNVSAM)='TYPE(OUTPUT) HILITE(REVERSE)'
 IF (&SCREEN=3)
    .ATTR (IFIND)='TYPE(OUTPUT)'
    .ATTR (CD)='TYPE(OUTPUT)'
 &SID=&ZSYSID
 .ZVARS='(PFIELD,MULTIGP,LISTDESC,CALLIGN)'
 &PFIELD=TRANS(&PFIELD 1,Y 0,N *,N)
 &MULTIGP=TRANS(&MULTIGP 1,Y 0,N *,N)
 &LISTDESC=TRANS(&LISTDESC 1,Y 0,N *,N)
 &CALLIGN=TRANS(&CALLIGN 1,Y 0,N *,N)
 IF (&BATCH='Y') &WEXEC='Batch'
 ELSE &WEXEC='On-line'
 IF (&PFIELD=&Z)
    &PFIELD='N'
 IF (&MULTIGP=&Z)
    &MULTIGP='N'
 IF (&LISTDESC=&Z)
    &LISTDESC='N'
 IF (&CALLIGN=&Z)
    &CALLIGN='N'
)PROC
 &CSR=.CURSOR
 &CSP=.CSRPOS
 &CHAR1=TRUNC(&ZCMD,1)
 IF (&CHAR1 ¬= '/')
    IF (&ZCMD ¬= '?','CANCEL','CAN')
       IF (&TYP# ¬= 'OUTPUT')
          IF (&CSR ¬= DYNAV)
             IF (&PFIELD ¬= 'Y')
                VER(&IFIND,NB)
          IF (&IFIND ¬= '?')
             IF (&CSR ¬= DYNAV)
                VER(&CD,NB,RANGE,1,&NOITEMS)
       VER(&PFIELD,NB,LIST,Y,N)
       VER(&MULTIGP,NB,LIST,Y,N)
       VER(&LISTDESC,NB,LIST,Y,N)
       VER(&CALLIGN,NB,LIST,Y,N)
 &PFIELD=TRANS(&PFIELD Y,1 N,0 *,0)
 &MULTIGP=TRANS(&MULTIGP Y,1 N,0 *,0)
 &LISTDESC=TRANS(&LISTDESC Y,1 N,0 *,0)
 &CALLIGN=TRANS(&CALLIGN Y,1 N,0 *,0)
)END
*/
    n_en = mark(-2)                         /* Mark end of data       */
    Return 0

help_#1:
    n_st=mark(2)    /* Mark Start (TF72 for line overflow) */
/*

&TOD. &CNAME. :)

  CSDA: CSD Analyser.

  This macro is designed to analyse the contents of a viewed/edited
  listing of a CSD (not OBJECT as it would be too large and CSDA only
  uses the standard LIST portion.)
  It's primary objective is to give a hierarchical presentation of
  selected entities, eg. what group(s) the entity(s) is defined in and
  which list(s) use those group(s).

  This routine will provide expansion of entity details by directly
  reading the CSD and supplying the appropriate details.  Refer below
  for further details on field formats for entity types.

  If you are analysing TRANsactions and have supplied the CSD name,
  the executing program is reported. This is handy when different
  groups contain the same transaction with a different executable
  program.

  If the CSD is available, you may fine tune your selections by
  setting field comparisons. (For further details, refer to the "/MF"
  parameter.)

  Output summary:
  ---------------
  The following are delimiters used to identify the type of data/fields
  being presented in the report:
    > List of groups the entity belongs to.
    + List of lists the group belongs to.
    - Group not used by any lists.
    » Fields extracted from the CSD (as set up in the field definition
      matrix).  Any field exceeding the maximum allowable length (should
      not be greater than 42 characters) will have the leading
      characters truncated and replaced by '«'.
    * Description (extracted from CSD if it is defined in matrix).
    ¢ Date/time last modified.

  The output is presented as NOTE lines and it is recommended that you
  view the CSD list so that the notelines can be converted to data
  using the 'md' line command to permit text/data manipulation without
  accidentally changing the list.
  This tutorial will be placed before line 1 and reports placed after
  line 1 thereby permitting display of the tutorial at the top of the
  file and always before the report.

  Items of note:
    1. You can get a list of all the groups not used in a list by
       specifying "GROUPS(*)" which will list all the LISTs the group
       is defined in. Any summary without lists, ie. "- Lists()", are
       orphaned groups. (Use parameter '/OGx' instead.)

                             ***********

  Parameters:
  -----------
  Summary Positional:
    1. itemtype(item) | itemtype item | item

  Summary Keyword:
    G(group1{,group2{,groupn}})
        - only hroups
    /#  - Data entry screen.
    /1  - One liner output.
    /13 - TS1.3 or earlier.
    /21 - CICS TS2.1 or later.
    /A  - Append report.
    /B  - Execute in batch.
    /CA - Column Align.
    /C  - Changed date/time stamp.
    /CE - Date in European format.
    /CJ - Date in Julian format.
    /CSD(csd_dataset)
        - CSD dataset to use.
    /CSDC
        - Invoke CSDC to generete define statements.
    /CU - Date in USA format.
    /D  - List description.
    /H  - Hardcopy for batch jobs (and on-line).
    /HE - Hardcopy Edit.
    /HNE- Hardcopy No Edit.
    /MF(match_field_list | *)
        - Match Fields.
    /MG - Multi Group.
    /NA - No Append.
    /NC - No Changed date/time stamp.
    /NCA- No Column Align.
    /ND - No description.
    /NF - No Fields.
    /NR - Do not attempt to read/process the CSD.
    /NS - No seperator lines.
    /O  - On-line execution.
    /OD - Orphaned Delete (excluding IBM DFH* groups).
    /OF(only_field_list | *)
        - Only Fields.
    /OG - Orphaned Groups (excluding IBM DFH* groups).
    /OGI- Orphaned Groups (including IBM DFH* groups).
    /PL(nnnnn | *)
        - Increase the processing limit.
    /R  - Attempt to read/process the CSD.
    /SF(suppress_field_list | *)
        - Suppress Fields.
    /T  - Turn REXX trace on. Used for debugging.
    /TS - Time Sort.
    /XT - eXit after Tally.
    ?   - This tutorial.

  Detailed:
  ---------
  Keyword parameters will be evaluated first and removed from the
  parameter list as they are encountered.  The remaining string(s)
  will be interpreted as positional parameters.

  Positional parameters:
  Note: While keyword paramaters may precede positional ones, any
        misspelt keyword paramaters will be treated as positional
        parameters.  Consequently get into the practice of using
        keyword as the trailing parameters.

   Positional:
    1. itemtype(item) | itemtype item | item
       Where:
          itemtype - selection of the type of item to report.  Execute
                     CSDA without parameters to display an input panel
                     that will list all the permissable item types and
                     acceptable abbreviations.
          item     - You may enter any combination of items (comma
                     seperated) or you may wildcard "item" by using an
                     optional leading and/or trailing '*'. It is
                     suggested that a more discreet than more generic
                     searches be used as too many hits may blow out
                     response.  (That is why '*' by itself is batch
                     forced as a TRANS(*) batch process for a medium
                     sized CSD took over 3 hours to execute. If fact
                     a "/XT" report on a 8000 transaction CSD to about
                     10 minutes in batch.)
                     Note: 'Item(s)' is not case sensitive and CSDA
                           will report on both upper and lower (and
                           mixed) case items. However, the input
                           screen is case sensitive so if you enter
                           in upper case, only the upper case hit will
                           be reported.
                         : Choosing '*' will force batch processing
                           unless it is overridden using the "/O"
                           parameter. The exception for this is
                           'GROUP(*)' which is permitted on-line.
                         : To extend your search use a combination
                           of wildcarded items (comma seperated).
                           For multi items you can 'globalise' the
                           wildcarding by including the items between
                           brackets with any potential prfix and/or
                           suffix outside the brackets, eg.
                              (d,h,yy)*    -> d*,h*,yy*
                              a(bb,ee,xy)* -> abb*,aee*,axy*.
                           Don't forget the itemtype, eg.
                              trans(*(bb,ee,xy)*)
                           (You may ask why?  Because I can and I
                            needed variety for testing!!!)
       If only one parameter is used, it will be assumed to be 'items'
       and the default is,
           'TRANSactions(items)'
       These positional parameters may be group restricted by using the
       "G()" keyword parameter.  (Note the deliberate absence of a
       leading "/".

  Keyword parameters:
    Many of the keyword parameters are purely provided to fine tune
    display options and speed up processing.  On slow systems or when
    large amounts or output is anticipated, consider the following and
    either adjust the default settings in the REXX program 'CSDA' or
    supply swithes from the list below.
    1. Disabling the facility to read the CSD will save significant
       the cycles. Either set the variable "readCSD" to 0 (zero) in
       'CSDA$' or use the "/NR" keyword. This is recommended if you
       only want a cross reference of items/groups/lists and DO NOT
       want available item details reported. If "readcsd" is set to 0,
       use the "/R" keyword to read the CSD.
    2. Description may provide unnecessary noise (display clutter).
    3. All defined field values, especially when most are not defined
       can clutter displays.
    4. The align feature eliminates/minimises clutter, however, adds
       cycles to processing required.
    5. Date changed report can significantly increase processing time
       espoecially for large outputs.  Consider suppressing it or
       set it to Julian (as either default or parameter) as this will
       bypass invoking '$DATEMAN' for conversion to other formats.

   Note: Sometimes certain combinations are redundant or duplicated as
         old features may not be disabled or re-documented as features
         of this routine are expanded.

   Keywords GOTCHAS:
   1. Keyword parameters may be entered/Changed in the primary input
      screen.  Only those marked with a 'o' are changeable.
   2. Watch stacked commands.  For example the following command will
      not give desired results.
           CSDA PI(ECT2IMS) /NA /H;CSDA TC(SOAPPORT) /H
      a) The first command will output data to hardcopy (with
         no-append).  However the hardcopy will be presented under
         editor and the second command will be executed against the
         hardcopy.  This is NOT what you want.  You want the second
         command to be executed against the CSD listing.
      b) To bypass the edit session you should replace the first '/H'
         parameter with a '/HNE' which will process with no edit and as
         we are not editing hardcopy infers a hardcopy is required and
         will turn it on.  So the command should be,
           CSDA PI(ECT2IMS) /NA /HNE;CSDA TC(SOAPPORT) /H

   Keywords:
    G(group1{,group2{,groupn}})
        - Only report item matches if they are in this comma seperated
          gloup list. Wildcarding is NOT permitted.
          This parameter by itself will be treated as a normal "group"
          interrogation.
    /#  - Explicitly force data entry screen regardless of parameters
          entered.
          Use this parameter to get into screen display if you wish to
          get into the 'field selection for reporting' display.
    /1  o One liner output. Output each field on a seperate line.
          Why?  Because I can and needed it (once).
    /13 o Indicate that the CSD is for CICS TS1.3 or earlier.  This
          parameter will flag positional parameters as unavailable
          thereby preventing erroneous reporting and speed up
          processing. (Unavailable fields will be summarised in the
          report.)
          Note: EXECIOVS is used to establish average record length for
                the CSDE file. If it is not 200, it will be interpreted
                as pre TS2.1 and this flag will automatically set and
                user notified prior to progressing.
    /21 o Explicitly set CICS version to TS2.1 or later. Use this to
          reverse TS1.3 detection (with reservation as may blow out
          response times).
    /A  o Append report (do not remove previous notelines).
    /B  o Execute in batch.  Use this flag for large CSDs and when you
          expect long execution.  This format will be enforced if '*'
          item is chosen for fields in the "no_wild" parameter list in
          'CSDA$'.  This can be overriden using the "/O" parameter.
          You have been warned, do it at your own peril.
          Note: The field names will be displayed in upper case.  This
                is not an error but limitations of executing in batch.
    /C  o Changed date/time stamp. Explicitly display changed date/time
          regardless of default setting.
          Note: Variable "listdate" can be set in routime CSDA$ to set
                default date changed display defaults.
              : Date will be displayed in the format dd/mm/yyyy if
                '$DATEMAN' is available otherwise yy.mmm will be used.
              : If '$DATEMAN' is available variable "datefmt" can be
                set in routine CSDA$ to set default format to
                E(uropean), J(lulian) or U(SA).
              : '$DATEMAN' is an external routine and is invoked for
                each hit and may take up larger than desired cycles
                in generating reports.
    /CA - Column Align.  To align columns based on a field length of 8
          if the lenght is <8.  Alternatively rearange the report
          field order in CSDA$ or change the report field length to 8
          (max size except for description and a few WEB related
          fields). Aligning columns will increase the physical size of
          the report.
          Note: Variable "autoalign" can be set in this routine to
                'auto align' without the "/CA" parameter.
    /CE o Changed Date stamp to European format dd/mm/yyyy regardless
          of variable "datefmt" setting.
    /CJ o Changed Date stamp to Julian format yy.ddd regardless of
          variable "datefmt" setting.  This is the default format
          and quickest in processing requirements which may be worth
          consideration on slow systems or high output volumes.
    /CSD(csd_dataset)
        - CSD dataset. This value is used to get additional entity
          details for detailed analysis.
          Without this parameter it will look for eyecatcher
             "  CSD file: 'CSD_dataset....' "
          which has to be manually entered or let "CSDL" do it for you.
    /CSDC
        - Invoke CSDC to generate define statements for the entry
          extracted from the line the cursor is on.  You use this
          function to generate a DEFINE statement for the resource in
          the group that can be canabilised to nake a customisable ALTER
          statement.  The cursor MUST be on the line that lists both the
          resource and it's appropriate group. (This can be a NOTELINE.)
          You can pass it a sub-parameter of '/M' to create a new entry
          dataset used by the CSDC function.  By default a parameter of
          /MA is passed to append to existing dataset.
          If you are building a list of define/alter statements, you can
          also use the '/NJ' ("CSDC" parameter) to prevent CSDC from
          presenting JCL for submission.  (By default, the '/NJ'
          parameter will be used for all bar the last group for a
          resource defined in a number of groups.)
          For futher details, refer to CSDC documentation.
    /CU o Changed Date stamp to USA format mm/dd/yyyy regardless of
          variable "datefmt" setting.
    /D  - List description if available from CSD dataset.
          Note:- You may get unexpected output if you mix "/D" and/or
                 "/ND" and the description field in field selection
                 options.
    /H  o Hardcopy for batch jobs (or on-line).  Output to dataset,
            '&OUTDSN.'.
          Notes:
            1. For batch jobs, '.Dyymmdd' will be used as a suffix.
               Output will be MODded to the dataset so the first run for
               the day will create the dataset.  If you don't want to
               append, delete the dataset prior to execution (commented
               JCL will be provided).
            2. For on-line jobs you must explicitly request appending
               using the '/A' parameter.
               You have been warned.  Without the '/A', existing data
               will be creamed and you will need to start again, which
               could be a painn if you're well advanced into building
               a large list.
    /HE - Hardcopy Edit.  Edit the dataset created using the '/H'
          parameter. Automatically evaluates the dataset and you don't
          have to run off and look for it.
    /HNE- Hardcopy No Edit.  When processing on-line with the '/H'
          option, the hardcopy will be editted after processing.  When
          nesting commands (or building a composite list) you can bypass
          the edit using this command.  You can later edit the hardcopy
          by using the '/HE' command.
          Note: This parameter automatically enables the '/H' option so
                you may leave it out.  No bad if you don't (short of a
                few extra cycles).
    /LM - Last Message.  Re-display the last message displayed when CSDA
          processing was terminated.  Use this when you accidentally hit
          a key that removes the message before you were smart enough to
          read it.
    /MF(match_field_list | *)
        - Match Fields. Provide a list of field (comma or space
          seperated) to perform a comparison with. This is additional
          to the "/OF" and "/SF" parameters if used.
          For all fields in the list an interim '=' is placed into the
          field selection field for the upcomming field selection
          screen. The remaining fields will be set in accordance with
          the "/OF" and "/SF" field list. (If neither is used, all
          fields will be set to 'Y'.
          You may overtype the system generated parameter by any of
          the following (these are also applicable for the field
          selection/suppression features):
              =  Field value equal to.
              >  Field value greater than.
              <  Field value less than.
              /  Field value not equal to (expanded to '/=').
              Y  Ignore field matching but report field
              b  Blank, Ignore field matching and do not report field.
              x  Any other character will be treated as 'Y'.
          If "=,>,<,/" is entered, a subsequent screen is presented for
          comparison value entry.
          You may enter any value. It will be used in a literal
          comparison.  You may wildcard values by using a trailing '*'
          in which case the '*' will be dropped off and the field
          value truncated to the same length befor the comparisson is
          made.
          Note: You still cannot do a global seach, however you can
                maximise your scope with a two pass of the following,
                   CSDA TRANS((A,B,C,D,E,F,G,H,I,J,K,L,M)*) /MF(X)
                         - followed by -
                   CSDA TRANS((N,O,P,Q,R,S,T,U,V,W,X,Y,Z)*) /MF(X) /A
                (This would cover all the alphabetic transaction,
                however, I'd hate to be the one waiting for completion
                especially on a large CSD.)
    /MG - Multi Group. Only report 'items' that belong to more than 1
          group.  This is to determine what combination of settings
          may be in play (accross systems).
          All items found will be listed, however, only items in more
          than one group will be detailed.
          All multi-group item hits will be summarised at the end of
          the report.
    /NA o No Append.  By default no-append is the default for NOTELINE
          output, however, append is the default for hardcopy.  Use this
          to either deliberatelly no append or to clear the file for
          the first run.
    /NC o No Changed date/time stamp.  Explicitly suppress changed
          date/time regardless of default setting.
    /NCA- No Column Align. (Only provided for completeness because of
          the "/CA" parameter and "autoalign" variable.)
    /ND - No description even if available from CSD dataset.  Use this
          parameter to reduce "noise" without resorting to field
          selection/suppression.
          Note:- You may get unexpected output if you mix "/D" and/or
                 "/ND" and the description field in field selection
                 options.
    /NF - No Fields. This is further to the "/D" option. Even if the
          CSD is accessible, do not get and display the 'field'
          details that would be available. (This value forces "/D" so
          it is not required and will negate any "/OF" or "/SF" lists.)
    /NM - No Match.  Normally if "/MF" parameters are entered and no
          match is found the following entry is diplayed:
             TRANSaction(tttt) > Groups(gggggggg)
                                 *** No match for "Match_field_on" ***
          This parameter will suppress the 'no match' message.
    /NR o Do not attempt to read/process the CSD, even if the required
          tools are available.  This will automatically activate the
          "/NF" switch.
          Note: Variable "readCSD" can be set in routine CSDA$ to
                either enable or disable the default CSD process.
              : If "/NR" is in effect, the "DFHCSD" field becomes
                protected and the color reversed.
              : If "/NR" is set you will need to exit process to
                reverse it as there is no converse of "/NR".
    /NS - No seperator lines. Removes/adds to the congestion (depending
          on your point of view).
    /O  o On-line execution.  In cases when the system enforces batch
          execution because of full wildcarding (*) on fields in the
          "no_wild" parameter list in 'CSDA$' you can force on-line
          execution.  (This is automatically set in batch format as you
          don't want a recursive batch execution.)
    /OD - Orphaned Delete. Generate JCL to delete all orphaned groups
          This flay will automatically set "/OG".  Needs access to
          "CSDL" to set up job to delete orphan groups.
          IBM goups (DFH*) are excluded.
    /OF(only_field_list | *)
        - Only Fields. Provide a list of field (comma or space
          seperated) to report.  This is an alternative to supressing
          all fields using the "/NF" parameter or playing with the
          "report" flags on the "itemflds" variable in 'CSDA$' member.
          The field list is not case sensitive but must match the full
          spelling of the field which may be obtained from a listing
          of the tutorial of by browsing member 'CSDA$'.
          Alternatively use field name of '?' to provide a list of
          valid fields for that item type.  These values will be used
          to populate the field selection screen if it is selected.
          If '*' is entered, you will either be directed to the field
          selection screen or the field selection screen flag will be
          set in the data entry screen without any fields selected.
          Note:- You may get unexpected output if you mix "/D" and/or
                 "/ND" and the description field in field selection
                 options.
    /OG - Orphaned Groups. Only lists groups that are not defined in
          a valid list. IBM goups (DFH*) are excluded.
    /OGI
        - Orphaned Groups (including IBM defined groups).  Same as "/OG"
          except that unused IBM goups (DFH*) are also listed.
    /PL(nnnnn | *)
        - Increase the processing limit.
          Variable "proc_lim" in 'CSDA$' is set to "&PROC_LIM." to control
          on-line processing.  If this value is exceeded by the number
          of entries, you can either force on-line processing using the
          "/O" parameter or use this to increase the threshold but still
          control the number processed without unnecessary hangs.
          Using a parameter of '*' will process all regardless of number
          and inefficiency in execution.  The difference is that when
          you use the "/PL()" parameter a progress meter is displayed
          to keep track of the progress level.
          Variable "pop_upf" (currently set to "&POP_UPF.") is set in 'CSDA$'
          and is used as the pop up display frequency processor.
          Alternatively change the variable's value in 'CSDA$'.
    /R  o Attempt to read/process the CSD.  If the tools are not
          available a read attempt will be performed and resultant
          action modified accordingly. (For further details, refer to
          the '/NR' parameter.)
          Note: Variable "readCSD" can be set in routine CSDA$ to
                either enable or disable the default CSD process.
                Use this parameter if it "readcsd" is set to 0 for
                default performance purposes.
          Note: Set variable "try2read" to 1 or 0 for default settings.
                (The dafeult is 1 (try to read) and depending on it's
                setting, use '/NR' or '/R' to toggle action to be
                performed. This setting should be governed by the
                availability of VSAM read facility and response time
                preferances.)
    /SF(suppress_field_list | *)
        - Suppress Fields.  Provide a list of field (comma or space
          seperated) to suppress from the report.  This is an
          alternative to supressing fields you don't think are
          meaningfull for your circumstance and you do not wish to use
          the field selection screen.  Alternatively you can either
          suppress the field by setting the "report" flag to 'N'
          against the field on variable "itemflds" in member 'CSDA$'
          if that is acceptable by all at your site or arange for a
          personalised copy of CSDA$.  (If the later option is
          selected, you may miss out on any important future updates
          or repeat the process when an upgrade is isntalled.)
          If '*' is entered, you will either be directed to the field
          selection screen or the field selection screen flag will be
          set in the data entry screen without all fields selected.
          Note:- This option actually sets the all fields report flag
                 to 'Y' and sets these fields to 'N'.  This will be
                 evident if you invoke the field selection panel.
               - You may get unexpected output if you mix "/D" and/or
                 "/ND" and the description field in field selection
                 options.
    /T  - Turn REXX trace on. Used for debugging.
    /TS o Time Sort.
          Used for debugging to fine tune the setting for variable
          "isort_limit" in 'CSDA'.  If response is bad, use the "/TS"
          parameter to time the sort reporting start, end and duration
          and "/XT" to exit befor reporting details.  If the sort
          takes > 30 seconds and "isort_limit" has not been exceeded,
          suggest reducing it till a happy comprimise is reached.
          By default the "isort_limit should be set at around 200
          to minimise file creation/deletion and I/O. The break-
          even value between $SORT and SORT is between 100-150 items,
          however, this may be influenced by site responses to
          file creation/deletion and I/O hence the 200 initial
          compromise.
          Note: This should only be an issue if SORT is not available
                at your site.
    /XT - eXit after Tally.  This parameter is designed for batch
          processing to list all the items for a particular item
          type sorted. Once reported processing terminates.
          This is useful to then run more discreet selections.
    ?   - This tutorial. But you already know that. Don't you?
    Parameters "/D" and "/ND" should be used depending on site
    defaults, (ie. if default is to display description then use "/ND"
    to suppress it). This default is set by variable "listdesc" at the
    top of the REXX program 'CSDA$'.
    Use parameters "/D", "/ND" and "/NF" to reduce the "noise" in
    larger analysis reports and/or speed up processing. (Processing
    may take twice as long with full field reporting.)

    The following keywords (at least mutually exclusive ones),
      /13, /21, /A, /B, /C, /CE, /CJ, /CU, /O, /OD, /OG, /NC, /NM, /NR,
      /NS, /R, /TS, /XT and ?,
    can be entered individualy or en-masse in the data entry screen to
    avoid exiting and re-invoking using the parameters. Other parameters
    can be changed using the input data fields.

  Screen entry fields:
  --------------------
  1. Enter "item" as per above details.
  2. "Itemtype" may be selected by code or place cursor on code or
     description.  The capital (white colored) part of "itemtype" can
     be used under parameter function entry, eg.
         CSDA TRANS(CED*,AA*)
  3. DFHCSD. If you used the "CSDL" routine to list the CSD, it would
     have stamped the list with the source CSD dataset name which
     would then be extracted and inserted here.  Alternatively you can
     manually enter the CSD (unquoted).
     Note: Blanking out the CSD name (if available) will speed up
           processing but not as significantly as the "/NF" or even
           more significantly the "/NR" switches.
  4. Description reporting. Set this to 'N' to suppress descriptions
     from being reported (if available).
  5. Fields to include in the reports. If 'Y' is entered (will be set
     to 'Y' of "/OF" parameters are passed and screen display is
     entered. (See below for field report screen.)
  6. Allign fields in the report. Used for presentation and where
     field sizes adversely affect the esthetics of the report lay-
     out.
  Field selection screen:
  -----------------------
  If option 5 above is set to 'Y' a screen will be displayed with the
  main body part listing all the available fields that may be included
  in the report. If "/OF" parameters are supplied, they will be used to
  set 'Y' values against their respective fields.  If "/SF" parameters
  are supplied, they will be used to set 'Y' values against all fields
  and ' ' (space) against their respective fields.

  On exit (either by using enter or END PF key) control will always be
  passed to the main parameter entry screen even if it was not
  initially displayed.

  Enter any non blank character in the input field before the field
  name to select for reporting.  Return will be passed to the previous
  screen with the fields reported defined as if the "/OF" parameter
  was used.  Once this screen is entered and no fields are selected
  then all fields will be excluded from the report (same as if "/NF"
  parameter used on entry).

  Field selection screen entry commands:
     ALL  - Selects all fields.  Use this command to reset all fields
            in case screen previously exited without a selection.
            (This will negate any "/MF" and "/NF" setting.)
     NONE - Unselect all fields.  Quicker than repetaed TAB overtype
            with space.
     SORT - Sort field name display alphabetically.
            NOTE:- This sort is for selection only and will not alter
                   the field sequences in the report.

  For explanation of the fields refer to the CICS manual. Field sequence
  and tend follow the CEDA display sequence. Field names are limited to
  6 characters so some of them may be somewhat cryptogramic.

  Packaging:
  ----------
  The following members are required to package this function.  Those
  marked with an 'o' seperator are optional and enhance the available
  features:
   REXX:
   -----
    $ALK*    o Generic routines customised for site.  This includes
               members $ALKHLQO, $ALKACCT, $ALKJC, $ALKJCPG, $ALKUVOL.
               Without these defaults are used that may not be
               applicable for site.
    $BR      o Required to display these instructions under browser
               when help (?) is invoked from panel.
               If unavailable, you will get a red screen.
    $CSTRING - Change string.  Used to build the field selection
               screen.
    $DATEMAN o Date converter required if the "/C" option is requested
               or defaulted.
    $DDALLOC o Required by BATCHISP (if used).
    $SORT    o Routine top sort a string of space seperated words.  If
               the routine is not found, the transaction item(s)
               report will not be sorted. (For large lists, IBM's sort
               is used.)
    $WORDAT  - Identify text according to column position. Required
               for parsing data to format output.
    BATCHISP o Required to get default ISPF datasets to execute in
               batch.
    CSDA     - This driver.
    CSDA$    - External variable setter. Externally designed to permit
               sites to customise field definitions external to the
               CSDA driver.
    CSDAxxxx - Reserved for dedicated post reporting processing (to be
               developed and may have not been included in this doco).
    CSDAFV   - Routine to list files and their associated volumes and
               a volume(s) used summary. Complements processing the
               output from command,
                   CSDA F(*) /NC /MF(DSNAME/=) /OF(DSNAME) /B
               when prompted, just hit enter on the "match operator" and
               the following "match equate" screen as the operator of
               "/" (not equal) will be inserted against the 'dsname'
               field and spaces on the "match equate" screen (which is
               what we want).
    CSDR     o CSD reader.  May be included instream in selective
               packaging of CSDA. Required to read the CSD for field
               values past the standard group/list details.
               (It requires access to EXECIOVS.  Unavailability will
               force the "/NF" option.)
    EXECIOVS o EXECIO format VSAM file reader required by CSDR.  Uses
               program RXVSAM (see below).
   Panels:
   -------
    CSDAP    - Self extracted out of this routine.
   Programs:
   ---------
    RXVSAM   o VSAM reader. (Off CBT tape.) Used by EXECIOVS.
    SORT     o IBM sort.  Called upon when number of items to report
               exceed variable "isort_limit" at start of 'CSDA$'.
               This sort is much quicker than the REXX bubble sort
               $SORT but it need to allocate I/O files hence do not set
               "isort_limit" too low unless sort times blow out. Use
               parameter "/TS" to report on sort times.

  Internal secrets:
  -----------------
  1. Variables used for field definitions:
    a) validtypes:-
         Format:- 'nn type hex', where,
           nn   - sequence number
           type - entity identifier
           hex  - hex entity record identifier (cols 13-14 in CSD VSAM
                  dataset).
         This variable is used to build the data entry screen and
         validate request type.
    b) itemflds:-
         Defines all the fields that may be reported against
         individual entity types.  Refer to member CSDA$ for further
         details as it sets the variable values and contains
         processing sub-routines for specialised parsing.
    c) descflds:-
         Can be considered a single field format of
         'itemflds'.  The descriptions have been removed to permit
         exclusion of descriptions as often they are too abstract and
         also using this format they can be forced to the end of the
         report to avoid clutter.
    d) exclflds:-
         Fields to exclude from the defined "itemflds"
         variable during reporting.  Refer to member CSDA$ for setting
         of exclusion list.

------------------------------------------------------------------------
*/
n_en=mark(-2)   /* Mark End   */
    If w1="??" Then Signal Help_me;"ISREDIT (m)=MEMBER";rcm=rc
    If rcm=0 Then Do
        Address ISREDIT
        "(caps)=CAPS";"CAPS=OFF"
        "(dl1,dl2)=DISPLAY_LINES";If rc/=0 Then dl1=0
        If \Datatype(dl1,'w') Then "(dl1)=LINE .ZFIRST"
        If dl1=0 Then Do;dl1='.ZFIRST';"LINE_AFTER" dl1"=' '";End
        Else If dl1>1 Then dl1=dl1+1
        Address
        Signal Help_me
    End;Signal On Syntax Name Help_me
    Parse Source . . xcmd .;x=$BR(xcmd "??");Return
Mark:If Datatype(Arg(1))/="NUM" Then Arg(1)=1;Return sigl+Arg(1)
Help_me:Signal Off Syntax;#tr=Trace("o")
    Do i=n_st To n_en;nl=Sourceline(i)
        Parse Value Time() With hh ':' 1 time +5
        Select
            When hh<6 Then tod='Hello night-owl'
            When hh<12 Then tod='Good morning'
            When hh<18 Then tod='Good afternoon'
            Otherwise tod='Good evening'
        End
        chgchar='&';cname='there';today=Date('e')
        Signal on Syntax Name error_off_$WHOAMI
        Parse Value $Whoami() With cname sname .
error_off_$WHOAMI: Signal Off Syntax
        Do While Index(nl,chgchar)>0
            Interpret "Parse VAR nl p1 '"chgchar"' var '.' p2"
            If Index(var,'(')>0 Then Do
                Parse VAR var var '(' vl ')'
                If \Datatype(vl,'W') Then vl=Length(var)
                Interpret 'nl=p1||Substr('var',1,vl)||p2'
            End
            Else Interpret 'nl=p1||'var'||p2'
        End
        If rcm=0 Then "ISREDIT LINE_BEFORE" dl1"=NOTELINE (nl)"
        Else Say Substr(nl,1,79);End
/*  x=Msg('On')                                                       */
    If rcm=0 Then Do
        "ISREDIT CSDA$ ?";"ISREDIT CAPS=(caps)"
    End;Else Address TSO "%CSDA$ ??"
    Return 0
