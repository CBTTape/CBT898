/*--------------------------ooo00 REXX 00ooo--------------------------*/
/*                                                                    */
/*  Macro to determine if all the datasets in JCL have been defined.  */
/*  For further details either browse the bottom or invoke with '?'   */
/*  parameter.                                                        */
/*                                                                    */
/*  Packaging. (Optional members are marked with a 'o' seperator.     */
/*                                                                    */
/*  REXX:                                                             */
/*    $ALKACCT o Set default account.                                 */
/*    $DDALLOC o Dataset allocated to a particular DD. Used to find   */
/*               location of REXX DSNE fo batch processing and other  */
/*               DD allocated datasets.                               */
/*    $EVALAMP - Evaluate any ampersands(&) and perform variable      */
/*               substitution. (Embeded into this program to eliminate*/
/*               external dependancy).                                */
/*    $WHOAMI  o Message to identify user.                            */
/*    BATCHISP o Set IBM "default" ISPF dataset.                      */
/*    BR | $BR o Output message browser.                              */
/*    DSNE     - This driver                                          */
/*    VV       o Macro to Verify Volser.                              */
/*  Panels:                                                           */
/*    POPMSG   o Pop up progress display panel.                       */
/*                                                                    */
/*--------------------------------------------------------------------*/
DSNE:dsne_ver='1.11'
    Address ISPEXEC;"CONTROL ERRORS RETURN";ima_macro=0
    ARG parm#;If parm#/='' Then Signal byp1
    "ISREDIT MACRO (parm#) NOPROCESS";If rc=0 Then ima_macro=1

byp1:
/*  "CONTROL ERRORS CANCEL"                                           */

ini1:
    zedsmsg=;chgchar='`'

    PARSE Upper VAR parm# parm#;Parse VAR parm# parm1 .
    Parse SOURCE . . xcmd .
    #parm=parm#

    cname='there';Signal On Syntax Name ret_syntax_0
    cname=$Whoami('C')
ret_syntax_0:
    acct='(MISSING)';Signal On Syntax Name ret_syntax_1
    userid=Userid();acct=$alkacct()
ret_syntax_1:
    Signal Off Syntax

    "VGET (dsnebtch,dsneparm,dsnebtrc) SHARED"
    If dsnebtrc='TRACE' Then Trace r
    If dsnebtch='Y' Then Do
        If Wordpos(dsneparm,'HELP ?? ?')>0 Then Signal TSO_help
        parm#=dsneparm;Signal nohelp
    End
    "VGET (dsnemac) SHARED"
    If dsnemac/='' Then Interpret "Signal macro_"dsnemac

    panel='POPMSG'
    If Wordpos(parm1,'HELP ? ??')>0 Then Signal TSO_help

    If Wordpos('/B',parm#)>0 Then Do
        Call set_4_batch
        Exit
    End

nohelp:
    Signal On Syntax Name errproc_1
    "ISREDIT (STATUS)=USER_STATE"
    "ISREDIT (cpstate)=CAPS";"ISREDIT CAPS=OFF"

    npr=0                                   /* No datasets processed  */
    nfd=0                                   /* Not found              */
    arc=0                                   /* Archived               */
    unm=0                                   /* Un-mounted             */
    vsm=0                                   /* VSAM                   */
    nvs=0                                   /* Non-VSAM               */
    nac=0                                   /* Not in Alt Cat         */
    hsm=0                                   /* Migrated               */
    vbl=0                                   /* Temporary              */
    jlb=0                                   /* JCLLIB                 */
    jln=0                                   /* JCLLIB not found       */
    nal=0                                   /* New/Mod allocation     */
    inc=0                                   /* Include statements     */
    vin=0                                   /* Misspalced variable    */
    pre=0                                   /* Parsing error          */
    mnf=0                                   /* Member not found       */
    #dz=0                                   /* Total size             */

    "ISREDIT PROCESS RANGE C M";"ISREDIT (cmd) = RANGE_CMD"
    If cmd='C' Then Do
        "ISREDIT (zfrange)=LINENUM .ZFRANGE"
        "ISREDIT (zlrange)=LINENUM .ZLRANGE"
    End
    Else Do
        "ISREDIT (zfrange)=LINENUM .ZFIRST"
        "ISREDIT (zlrange)=LINENUM .ZLAST"
    End
    zfrange=zfrange+0;zlrange=zlrange+0

    #tr=Trace('o')
    Call parse_parms
    x=Trace(#tr)

    If t_scan='Y' Then Signal Do_a_scan

    If i_xst = '' Then "ISREDIT RESET"
    Else "ISREDIT (lin#) = LINENUM .ZCSR"

    If conv4v='Y' Then Call conv_for_verify
    If p4dsne='Y' Then Call Prepare_4_dsne

    Call Any_Inbuilt_Procs

    range = (zlrange - zfrange) +1
    If range > 20 & pop_it = 'Y' Then Do
        "ISREDIT (lastp)=LINENUM .ZLAST"
        zwinttl = 'Catalog Check Progress Meter'
        "VPUT (ZWINTTL)"
        "ADDPOP ROW(5) COLUMN(6)"
        addpop  = 'Y'
        reverse = X2C('10')                 /* Reverse mask           */
        uscore  = X2C('20')                 /* Underscore mask        */
        blink   = X2C('30')                 /* Blink Mask. Note - this*/
        ored    = X2C('08')                 /* Input  RED etc...      */
        oblue   = X2C('09')
        oyellow = X2C('0A')
        ogreen  = X2C('0B')
        oturq   = X2C('0C')
        opink   = X2C('0D')
        owhite  = X2C('0E')
        c_n     = oyellow                   /* Color numbers          */
        c_p     = ored                      /* Color progress arrow   */
        c_p     = Bitor(ored,reverse)       /* Color progress arrow   */
        c_l1    = owhite                    /* Color JCL line 1       */
        c_l2    = ogreen                    /* Color JcL line rest    */
        jcl_f   = 7                         /* JCL fill lines         */
        marker  = '0---1----2----3----4----5----6----7----8----9----%'
        markit  = '>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'
    End
    Else pop_it='N'
    x=Msg('Off')
    "ISREDIT SEEK ' SET ' FIRST";If rc=0 Then Do
        lin#s=0
        Do Forever
            "ISREDIT CURSOR="lin#s+1 0
            "ISREDIT SEEK ' SET '";If rc/=0 Then Leave
            "ISREDIT (lin#s)=LINENUM .ZCSR";"ISREDIT (line)=LINE .ZCSR"
            If Index(line,'&')=0 Then Iterate
            Parse VAR line . w2 . 1 c12 +2 c3 +1
            If w2/='SET' Then Iterate
            If c12/='//' Then Iterate
            If c3='*' Then Iterate
            Parse Value Translate(line,' ',',')With . 'SET ' linei
            Do While linei/=''
                Parse VAR linei x_x linei
                If Index(x_x,'&')=0 Then Iterate
                y_y=$evalamp(x_x)
                Parse VAR y_y var '=' val
                Interpret 'vas_'var'=val'
            End
        End
    End
    Do i=zfrange To zlrange
        i_o = (i - zfrange) +1
        If i_o // 10 = 0 Then Call pop_message
        If i_xst /= '' Then Do
            "ISREDIT (XST) =  XSTATUS" i
            If i_xst = xst Then Iterate
        End

        "ISREDIT (line) = LINE" i
        If word_o>0 Then Do
            line=Strip(Word(line,word_o),,"'");If line='' Then Iterate
            line='// DSN='line
        End
        If Substr(line,1,2) /= '//' Then Iterate
        If Substr(line,3,1) =  '*' Then Do
           If Word(line,2) = 'SET' & com_set = 'Y' Then NOP
           Else Iterate
        End
        If Word(line,2) = 'SET' Then Do
            Call eval_setcmd
            Iterate
        End
        If Word(line,2) = 'INCLUDE' Then Do
            inc=inc +1
            Iterate
        End
        If Word(line,2)='JCLLIB' Then Do
            #nfd=nfd
            Parse VAR line 'ORDER=(' all_dsname ')'
            all_dsname=Translate(all_dsname,' ',',')
            Do While all_dsname/=''
                jlb=jlb+1
                Parse VAR all_dsname dsname all_dsname
                yy=Index(line,dsname)
                If Index(dsname,'&')>0 Then dsname=eval_amper(dsname)
                If a_mcat/='?' Then Do
                    xx=Dsneacat(dsname,a_mcat)
                    Address ISPEXEC "VGET (sysreason) SHARED"
                End
                Else xx=Listdsi("'"dsname"' NORECALL")
                If xx<5 | sysreason=9 | sysreason=25 Then Iterate
                If #nfd=nfd Then Do;l.i='N';cp.i=yy;n_l.i=dsname 0;End
                nfd=nfd+1;jln=jln+1
            End
            Iterate
        End
        finds='DSN='
        line_s=line
        Parse VAR line 'DSN=' dsname .
        If dsname='' Then Do
            finds='DSNAME='
            Parse VAR line 'DSNAME=' dsname .
        End
        If dsname = '' Then Iterate
        If Substr(dsname,1,1) = '*' Then Iterate
        Parse Upper VAR dsname dsname "," .

        If Index(dsname,'&&') > 0 Then,
            vbl = vbl +1
        Else Do
            npr = npr +1
            If Index(dsname,'&') > 0 Then,
                dsname=eval_amper(dsname)
            If Index(dsname,'&') > 0 Then Do
                vin = vin + 1
                l.i = 'V'
                cp.i = Index(line_s,finds)
                n_l.i = dsname Length(finds)
                Iterate
            End
            If Index(dsname,'+') > 0 Then Iterate     /* GDG          */
            If Index(dsname,'-') > 0 Then Iterate     /* GDG          */
            If Index(dsname,'(0') > 0 Then Iterate    /* GDG          */
            If dsname = '' Then Do          /* Missing dsname DSN=,   */
                mnf = mnf +1
                l.i = 'N'
                cp.i = Index(line_s,finds)
                n_l.i = 'Not_assigned' Length(finds)
                Iterate
            End
            If xtraex /= '' & Index(dsname,xtraex) > 0 Then Iterate
            Parse Value Strip(dsname,,"'") With xx '(' .
            If a_mcat/='?' Then Do
                sysreason=Dsneacat(dsname,a_mcat)
            End
            Else x=listdsi("'"xx"' DIR NORECALL")
            Select
                When (sysreason = 1) Then Do
                    hsm = hsm + 1
                    l.i = 'P'
                    cp.i = Index(line_s,finds)
                    n_l.i = dsname Length(finds)
                    pre = pre + 1
                End
                When (sysreason = 5 | sysreason = 24) Then Do
                    If c_new.dsname = 'Y' Then Iterate
                    Call eval_disp
                    If disp = 'NEW' Then Do
                        c_new.dsname = 'Y'
                        nal = nal +1
                        Iterate
                    End
                    nfd = nfd + 1
                    l.i = 'N'
                    cp.i = Index(line_s,finds)
                    n_l.i = dsname Length(finds)
                End
                When (sysreason = 9) Then Do
                    hsm = hsm + 1
                    If arcrep = 'Y' Then Do
                        l.i = 'A'
                        cp.i = Index(line_s,finds)
                        n_l.i = dsname Length(finds)
                    End
                End
                When (sysreason = 8)  Then unm = unm +1
                When (sysreason = 19) Then unm = unm +1
                When (sysreason = 12) Then vsm = vsm +1
                When (sysreason = MA) Then Do
                    nac = nac +1
                    l.i = 'AC'
                    cp.i = Index(line_s,finds)
                    n_l.i = dsname Length(finds)
                End
                Otherwise Do
                    nvs = nvs +1
                    If mis_m = 'Y' & Index(dsname,'(') > 0 &,
                       Sysdsn("'"dsname"'") /= 'OK' Then Do
                        mnf = mnf +1
                        l.i = 'M'
                        cp.i = Index(line_s,finds)
                        n_l.i = dsname Length(finds)
                    End
                End
            End
            If lv = 'Y' & l.i = 'L.'i Then Do
                l.i = 'D'
                cp.i = Index(line_s,finds)
                If Datatype(sysalloc) = 'NUM' Then Do
                    If Substr(sysunits,1,1) = 'C' Then trksize = sysalloc * 15
                    Else                               trksize = sysalloc
                End
                Else trksize = ''
                n_l.i = dsname Length(finds) sysvolume sysreason trksize
            End
        End
    End

ext1:
#tr=Trace('o')
/*  If zlrange > 20 Then "REMPOP"                                     */
    owe1n=                                  /* Owe 1st. line NOTELINE */

    If pre > 0  Then Signal tagg_em
    If nfd > 0  Then Signal tagg_em
    If nac > 0  Then Signal tagg_em
    If vin > 0  Then Signal tagg_em
    If mnf > 0  Then Signal tagg_em
    If lv = 'Y' Then Signal tagg_em
    If hsm > 0 & arcrep = 'Y' Then Signal tagg_em
    Else Signal tagged_all

tagg_em:

    "ISREDIT X ALL"
    i_o   = 0
    If range > 20 & pop_it = 'Y' Then Do
        zwinttl = 'VOLSER Check Progress Meter'
        "VPUT (ZWINTTL)"
        "ADDPOP ROW(5) COLUMN(6)"
        addpop='Y'
    End
    Do i=zfrange To zlrange
       If batch = 'Y' | lv = 'Y' Then Do
           "ISREDIT (line) = LINE &I"
           If batch = 'Y' Then Say Right(i,6,'0') Substr(line,1,72)
       End
       If l.i = 'L.'i Then Iterate
       "ISREDIT XSTATUS &I = NX"
       Parse VAR n_l.i n_ld n_ll volser sysr trksize
       Select
           When (l.i = 'D') Then Do
               xx = ' 'volser'  '
               mt = 'NOTELINE'
           End
           When (l.i = 'V') Then Do
               xx = 'Var N/F ?'
               mt = 'MSGLINE'
           End
           When (l.i = 'A') Then Do
               xx = 'Archived '
               mt = 'NOTELINE'
           End
           When (l.i = 'P') Then Do
               xx = 'Parse Err'
               mt = 'NOTELINE'
           End
           When (l.i = 'M') Then Do
               xx = 'M-Member '
               mt = 'NOTELINE'
           End
           When (l.i = 'AC') Then Do
               xx = 'Miss AC '
               mt = 'NOTELINE'
           End
           Otherwise Do
               xx = 'Not found'
               mt = 'MSGLINE'
           End
       End
       n_l = Substr('//* - 'xx' ===>',1,cp.i+n_ll-1) ||,
             Substr(n_ld,1,44)
       If word_o>0 Then n_l=xx '===>' n_ld
       Else n_l=Substr('//* - 'xx' ===>',1,cp.i+n_ll-1) ||,
                Substr(n_ld,1,44)
       If batch /= 'Y' Then Do
          If i > 1 Then,
              "ISREDIT LINE_BEFORE &I = &MT '"n_l"'"
          Else owe1n = mt "'"Strip(n_l,'t')"'"
       End
       Else
          Say '----->' n_l
       If lv = 'Y' Then Call get_all_vols
    End

tagged_all:
    If addpop='Y' Then "REMPOP"

    x=note_line(Copies('*',65))
    x=note_line('')

    x=note_line(' Hello' cname'.')
    x=note_line('')
    x=note_line(' DSNE (V'dsnev') summary at' Time() 'on' Date('E')'.')
    x=note_line('')
    x=note_line('   Processed :'Right(npr,6))
    x='   Not found :'Right(nfd,6);If nfd>0 Then x=x '*****'
    x=note_line(x)
    x='   Var N/F   :'Right(vin,6);If vin>0 Then x=x '*****'
    x=note_line(x)
    x='   Parse Err :'Right(pre,6);If pre>0 Then x=x '*****'
    x=note_line(x)
    x=note_line('   M-Member  :'Right(mnf,6))
    x=note_line('   VSAM      :'Right(vsm,6))
    If dsize='Y' Then Do
        If length(#dz)<5 Then #dz=Right(#dz,5)
        x=note_line('   VSAM DASD :' #dz '(Tracks)')
    End
    x=note_line('   NONVSAM   :'Right(nvs,6))
    x=note_line('   New/Mod   :'Right(nal,6)' ( NonVSAM )')
    If a_mcat/='?' Then,
        x=note_line('   Miss AC   :'Right(nac,6)' MCAT('a_mcat')')
    x=note_line('   Unmounted :'Right(unm,6))
    x=note_line('   Migrated  :'Right(hsm,6))
    x='   Includes  :'Right(inc,6)
    If inc>0 Then Do
        x=note_line(x '** Included members have NOT been checked')
        x=Substr(' ',1,23) ||,
          'and may contain uncatalogued datasets'
    End
    x=note_line(x)
    If jln=0 Then x=note_line('   JCLLIBs   :'Right(jlb,6))
    Else x=note_line('   JCLLIBs   :'Right(jlb,6)' (' jln 'not found )')
    x=note_line('   Temporary :'Right(vbl,6))
    If ver_vol Then Do
        zedlmsg='Verifying volsers using external routine "VV".',
                'This may take some time if there are many "DD" statements.'
        "SETMSG MSG(ISRZ001)"
        Call pop_message
        If batch='Y' Then vv_p vv_P '/B'
        "ISREDIT VV /L("zfrange","zlrange")" vv_p
        x=note_line('   Bad VolSer:'Right(rc,6)' ( Can run "VV"',
                    'stand-alone when fixed. )')
    End
    x=note_line(' ')
    x=note_line(Copies('*',65))
    If owe1n/='' Then "ISREDIT LINE_BEFORE 1=&owe1n"

    zedlmsg=

ext2:
    "ISREDIT CAPS=(cpstate)";"ISREDIT USER_STATE=(status)"
    If batch='Y' Then "ISREDIT CANCEL";Else "SETMSG MSG(ISRZ001)"
    Exit

note_line: Parse Arg n_l
    n_l='//*'Substr(n_l,1,65)'*//'
    If batch/='Y' Then "ISREDIT LINE_BEFORE &ZFRANGE=NOTELINE '"n_l"'"
    Else Say '----->' n_l

    Return 0

/*--------------------------------------------------------------------*/
/* Convert for verification                                           */
/*--------------------------------------------------------------------*/
conv_for_verify:
    "ISREDIT (lastl)=LINENUM .ZLAST"
    Address TSO "NEWSTACK"
    Do i=1 To lastl
        "ISREDIT (line)=LINE" i
        Parse VAR line . 'DSN=' dsn .
        If dsn='' Then Parse VAR line . 'DSNAME=' dsn .
        If dsn='' Then Iterate
        Parse VAR dsn dsn ',' .
        llq=Substr(dsn,Lastpos('.',dsn)+1)
        Parse VAR llq llq '('
        llq=Substr(llq,Verify(llq,'&','N'))
        line='//'Substr(llq,1,8)' DD DISP=SHR,DSN='dsn
        Queue line
    End
    Queue ''
    dd='DX'Time('s')
    "VGET ZTEMPF"
    Address TSO "ALLOC F("dd") DSN('"ztempf"') SHR REU"
    Address TSO "EXECIO * DISKW "dd" (FINIS"
    parm@=Delword(#parm,Wordpos('/CV',#parm),1)
    "LMINIT DATAID(DATAID) DDNAME("dd")"
    "EDIT DATAID(&DATAID) MACRO("xcmd") PARM(parm@)"
    "LMFREE DATAID(&DATAID)"
    Address TSO "FREE F("dd")"

    Exit 0

/*--------------------------------------------------------------------*/
/* Prepare for DSNE processing.                                       */
/*--------------------------------------------------------------------*/
Prepare_4_dsne:
    j=0
    Do i=zlrange By -1 To zfrange
        "ISREDIT (line)=LINE" i
        line=Translate(line,' ',',')
        Do while line/=''
            dsn=Word(line,Words(line))
            line=subWord(line,1,Words(line)-1)
            llq=Substr(dsn,Lastpos('.',dsn)+1)
            linex='//'Left(llq,8)' DD  DISP=SHR,DSN='Strip(dsn)
            "ISREDIT LINE_AFTER" zlrange"=(linex)";j=j+1
        End
    End
    "ISREDIT LABEL" zfrange"=.MARKF";"ISREDIT LABEL" zlrange"=.MARKT"
    "ISREDIT DEL ALL .MARKF .MARKT"
    zlrange=zfrange+j-1

    Return 0

/*--------------------------------------------------------------------*/
/* Build pop up message screen and display it.                        */
/*--------------------------------------------------------------------*/
pop_message:
    If pop_it /= 'Y' Then Return
    da1 = oturq'Processed'c_n || i_o ||,
          oturq'of'c_n || range ||,
          oturq'lines of data.'
    da1 = Substr(da1,1,52) ||  Substr(' ',1,52) || owhite ||,
          Substr(marker,1,51)
    l = Format((( (i_o/range) *100 ) /2),5,0) +0
    da1 = da1 || c_p ||,
          Substr(Substr(markit,1,l) || oblue,1,51) Substr(' ',1,51)
    j = jcl_f % 2
    j = i-j
    If j < 1 Then j=1
    pop_lim=j+jcl_f;If pop_lim>lastp Then pop_lim=lastp
    Do j=j To pop_lim
        "ISREDIT (linx) = LINE" j
        If rc /= 0 Then Leave
        linx = Right(j,6,'0') linx
        If j = i Then c_x = c_l1
        Else          c_x = c_l2
        da1 = da1 || c_x || Substr(linx,1,51)
    End
    "CONTROL DISPLAY LOCK"
    "DISPLAY PANEL(&PANEL)"
    If rc /= 0 Then pop_it = 'N'
    Return 0

/*--------------------------------------------------------------------*/
/* Parse the JCL looking for instream procedures and if one is found, */
/* parse and pre-set variables until all continauation lines are      */
/* exhausted.                                                         */
/* For each instream procedure the JCL will be scanned for execution  */
/* of that procedure for overrifdes which will replace the variable.  */
/* Mltiple procedure invocations with different overides has not been */
/* coded for and unpredictable results may be encountered.            */
/*--------------------------------------------------------------------*/
Any_Inbuilt_Procs:
    "ISREDIT CURSOR=1 0"
    Do Forever
        "ISREDIT F ' PROC '";If rc/=0 Then Leave
        "ISREDIT (line) = LINE .ZCSR"
        If Substr(line,1,2) /= '//' Then Iterate
        If Substr(line,3,1) =  '*'  Then Iterate
        If Word(line,2) /= 'PROC'   Then Iterate
        Parse VAR line proc . vars
        If Index(vars,'=') = 0 Then Iterate
        proc = Substr(proc,3)
        "ISREDIT (lin#) = CURSOR"
        Do Forever
           line = '// SET' Strip(vars)      /* Fudge SET command      */
           Call eval_setcmd
           lin# = lin# +1
           If l_cont /= 'Y' Then Leave
           "ISREDIT (line) = LINE" lin#
           Do Forever
               If Substr(line,3,1) /= '*' Then Leave
               If lin# = zlrange Then Leave
               lin# = lin# +1
               "ISREDIT (line) = LINE" lin#
           End
           Parse VAR line . vars
        End
        Call Find_proc_overrides
        "ISREDIT CURSOR =" lin# 0
    End

    Return

/*--------------------------------------------------------------------*/
/* Parse the instream procedure overrides.                            */
/* This will not be automatically pre-processed if there is no        */
/* instream procedure. The variables will be scanned for once a non-  */
/* predefined variable is encountered.                                */
/*--------------------------------------------------------------------*/
Find_proc_overrides:
    "ISREDIT CURSOR =" zlrange 0
    find = ' PROC='proc
    Do Forever
        "ISREDIT F '"find"' PREV"
        If rc /= 0 Then Leave
        "ISREDIT (line) = LINE .ZCSR"
        If Substr(line,1,2) /= '//' Then Iterate
        If Substr(line,3,1) =  '*'  Then Iterate
        If Word(line,2) /= 'EXEC'   Then Iterate
        "ISREDIT (lin@,col@) = CURSOR"
        vars = Substr(line,col@+Length(find))
        If Index(vars,'=') = 0 Then Iterate
        Do Forever
           line = '// SET' Strip(vars)      /* Fudge SET command      */
           Call eval_setcmd
           If l_cont /= 'Y' Then Leave
           lin@ = lin@ +1
           "ISREDIT (line) = LINE" lin@
           Do Forever
               If Substr(line,3,1) /= '*' Then Leave
               If lin# = zlrange Then Leave
               lin# = lin# +1
               "ISREDIT (line) = LINE" lin#
           End
           Parse VAR line . vars
        End
        Leave
    End

    Return dsn

$EVALAMP:$evalamp_ver='2.09'
/*--------------------------------------------------------------------*/
/* Parse the line looking for variables startingt with an '&'.        */
/* If found, extract the variable name and than calls anouther sub-   */
/* routine to see if the variable has been set.                       */
/* If the variable name is returned it is not a system symbol and no  */
/* substitution is made.                                              */
/* Parameters:                                                        */
/*  1. Text to parse.                                                 */
/*  2. Column to parse from.                                          */
/*  3. Literal 'LAST' to start from last line rather than current     */
/*     position. Designed when parm is passed to instream proc.       */
/*--------------------------------------------------------------------*/
eval_amper: Parse Arg text,v_p,s_order
    loop_lim=50                             /* Arbitary loop limit    */
    If debug/=1 Then debug=0
    "ISREDIT (xx)=DATASET"
    If rc/=0 Then Do
        If Verify(text,nat,'N')=0 & Length(text)<=8 Then val=Mvsvar(Symdef,text)
        Else val=
        If val/='' Then Return val;Else Return text
    End
    #tr=Trace()
    expand=1
    nat='ABCDEFGHIJKLMNOPQRSTUVWXYZ' ||,
        'abcdefghijklmnopqrstuvwxyz' ||,
        '0123456789@#$'
    If lin#='LIN#' Then "ISREDIT (lin#)=LINENUM .ZCSR"
    If s_order='LAST' Then "ISREDIT (lin#)=LINENUM .ZLAST"
    If \Datatype(v_p,'W') Then v_p=1
    Do Forever
        v_p=Index(text,'&',v_p)
        If v_p=0 Then Return text
        next_char=Substr(text,v_p+1,1)
        If next_char='&' | next_char=' ' Then Do;v_p=v_p+2;Iterate;End
        If v_p=1 Then p1=;Else p1=Substr(text,1,v_p-1)
        p2=Substr(text,v_p)
        lc=Verify(p2' ',nat,'N',2)
        var=Substr(p2,1,lc-1)
        If Substr(p2,lc,1)='.' Then Do
            lc=lc+1
            var=var'.'
        End
        p2=Substr(p2,lc)
        If debug Then Say Space(var Substr(text,1,72))
        var_v=Get_equate(var)
        If var_v/=var Then Do
            If var_v/='' Then Do
                If Index(var_v,"''")>0 Then var_v=$cstring(var_v,"''","'",,'*')
                text=$cstring(text,var,var_v,v_p,'*')
            End
            Else Do
                x=Index(text,var)
                If x>0 Then text=Delstr(text,x,Length(var))
            End
        End
        If var_v/='' Then v_p=v_p+1
    End
    Return text

/*--------------------------------------------------------------------*/
/* Receive a variable name as the argument and seacrh the JCL for any */
/* variable equate statements, eg. "varname=". If such an equate is   */
/* found it is assumed it is a user variable. If no equate is found   */
/* a MVS symbolic evaluation is undertaken.  If successfull, the      */
/* new value is returned else the original variable name is returned. */
/* Variable "findtry" is used in case we are not in JCL and get into  */
/* an indefinite loop.                                                */
/*--------------------------------------------------------------------*/
Get_equate: Parse Arg var_v
    Parse VAR var_v '&' xxx '.' var_suf
    sysvar=0
    If xxx='SYSUID' Then Return var_v
    Interpret "If vas_"xxx"/='VAS_"xxx"' Then Return vas_"xxx
    lin@=lin#;col@=0;find=xxx'='
    findtry=0                               /* Stop indefinite loop   */
    Do Forever
        findtry=findtry+1;If findtry>loop_lim Then Do
            Say 'Recursive loop limit "'loop_lim'" reached processing:'
            Say '  'Space(var_v Substr(text,1,72))
            Say 'Check your source and try again.'
            Leave
        End
        "ISREDIT CURSOR=" lin@ col@
        "ISREDIT SEEK '"find"' PREV"
        If rc/=0 Then "ISREDIT SEEK '"find"'"
        If rc=0 Then Do
            "ISREDIT (liney)=LINE .ZCSR"
            "ISREDIT (lin@,col@)=CURSOR"
            If Verify(#tr,'NO')>0 Then Say lin@+1 Col@+0 Substr(liney,1,70)
            If Substr(liney,1,3)='//*' | Substr(liney,1,2)/='//' Then,
                Do;col@=col@-1;Iterate;End
            If Verify(liney,nat,'M',col@-1)=col@ & expand Then Do
                If \expand Then Return var_v
                Interpret "Parse VAR liney '"find"' liney"
                If Substr(liney,1,1)/="'" Then Do
                    If Substr(liney,1,1)=' ' Then liney=
                    Parse VAR liney val .
                    Parse VAR val val ',' .
                End
                Else val=get_quote_delim(liney)
                If Substr(val,1,1)='&' Then Do
                    Parse VAR val '&' xxx '.' zzz;xxx=Strip(xxx,,"'")
                    var_suf=var_suf||zzz;find=xxx'='
/*                  findtry=0                                         */
                    col@=col@-1;Iterate
                End
                Select
                    When val='DATE()' Then Return $DATEMAN('REV',,2,'D')
                    When val='TIME()' Then Do
                        Parse Value Time() with hh ':' mm ':' ss
                        Return hh||mm||ss
                    End
                    When Substr(val,1,8)='$DATEMAN(' Then Do
                        Parse VAR liney '$DATEMAN(' dmv ')' .
                        Interpret "xx=$DATEMAN("dmv")"
                        If Word(xx,1)/='Error' Then Return xx
                        Else Return val
                    End
                    Otherwise Return val||var_suf
                End
            End
            Else Do;col@=col@-1;Iterate;End
        End
        Leave
    End
Return_Var_val:
    If Verify(xxx,nat,'N')=0 & Length(xxx)<=8 Then val=Mvsvar(Symdef,xxx)
    Else val=
    If val='' Then Return var_v||var_suf
    Else Do;sysvar=1;Return val||var_suf;End

/*--------------------------------------------------------------------*/
/* It has been established that the first character of a value is a   */
/* quote and the value is parsed for a valid SINGLE quote terminator. */
/*--------------------------------------------------------------------*/
get_quote_delim:
    yyy=Substr(Arg(1),2);nq=1
    Do Forever
        nq=Index(yyy,"'",nq)
        If nq=0 Then nq=Length(Strip(yyy))+1
        Else If Substr(yyy,nq+1,1)="'" Then Do
                 nq=nq+2;Iterate
             End
        val=Substr(yyy,1,nq-1)
        yyy=Substr(yyy,nq+1);If yyy='' Then Leave
        Parse VAR yyy . ',' yyy
        Leave
    End
    Return val
$EVALAMP_end:

/*--------------------------------------------------------------------*/
/* Genereic routine to pare a line until all equates on that line are */
/* resolved. The procedure expects data in the format of:             */
/*     '//xx SET var1=val1,var2,val2,..varn=valn'                     */
/* This format is fudged for PROC/PROC_override statements.           */
/*--------------------------------------------------------------------*/
eval_setcmd:
    Parse VAR line . . line
    If Strip(line) = ',' Then Do
        l_cont = 'Y'
        Return 0
    End
    l_cont = 'N'
    Do Forever
        cn = 1
        Call extract_val
        v.var = val
        If line = '' Then Leave
        If Index(line,'=') = 0 Then Leave
    End

    Return 0

/*--------------------------------------------------------------------*/
/* Extracts the variable name and it's value and leaeve the remaining */
/* line data for subsequent var/value processing.                     */
/* A record is kept if the line has a continuation character.         */
/*--------------------------------------------------------------------*/
extract_val:
    line = Substr(line,cn)
    Parse VAR line var '=' line
    If Substr(line,1,1)=' ' Then line=
    Select
        When (Substr(line,1,1) = "'") Then val = get_quote_delim(line)
        When (Substr(line,1,1) = "(") Then val = get_bracket_delim(line)
        When (Substr(line,1,1) = "" ) Then val =
        Otherwise Do
            Parse VAR line line .
            If Substr(line,length(line),1) = ',' Then l_cont = 'Y'
            Parse VAR line val ',' line
        End
    End

    Return

/*--------------------------------------------------------------------*/
/* It has been established that the first character of a value is a   */
/* quote and the value is parsed for a valid SINGLE quote terminator. */
/*--------------------------------------------------------------------*/
get_quote_delim:
    l_cont='N';line=Substr(line,2);nq=1
    Do Forever
        nq=Index(line,"'",nq)
        If nq=0 Then nq=Length(Strip(line))+1
        Else,
            If Substr(line,nq+1,1)="'" Then Do
                nq=nq+2;Iterate
            End
        val=Substr(line,1,nq-1)
        line=Substr(line,nq+1)
        If line='' Then Leave
        If Substr(line,length(line),1)=', ' Then l_cont='Y'
        Parse VAR line . ',' line
        Leave
    End

    Return val

/*--------------------------------------------------------------------*/
/* It has been established that the first character of a value is a   */
/* left bracket '(' which at the end of it all requires a matching    */
/* right bracket.  This routine evaluates the data until the logical  */
/* terminating rght bracket is reached.  Note is taken if the line is */
/* continued.                                                         */
/*--------------------------------------------------------------------*/
get_bracket_delim:
    l_cont='N';rb=
    Do j=1 To Length(line)
        ch=Substr(line,j,1)
        If ch='(' Then Do
            rb=rb||')';Iterate
        End
        If ch=')' Then Do
            If Length(rb)=1 Then Leave
            rb=Substr(rb,2);Iterate
        End
    End
    val=Substr(line,1,j)
    line=Substr(line,j+1)
    If line='' Then Leave
    If Substr(line,length(line),1)=', ' Then l_cont='Y'
    Parse VAR line . ',' line

    Return val

/*--------------------------------------------------------------------*/
/* Evaluate disposition of not found dataset.                         */
/*--------------------------------------------------------------------*/
eval_disp:
    disp='OLD'
    "ISREDIT (lastl)=LINENUM .ZLAST"
    lin#=i
    Do Forever
        If Word(line,2)='DD' & Substr(line,3,1)/='*' Then Leave
        If lin#=1 Then Return 4
        lin#=lin#-1;"ISREDIT (line)=LINE" lin#
    End
    Do Forever
        If Index(line,'DISP=')>0 & Substr(line,3,1)/='*' Then Leave
        If lin#=lastl Then Return 4
        lin#=lin#+1;"ISREDIT (line)=LINE" lin#
    End

    Parse VAR line 'DISP=' dsp .
    Parse VAR dsp dsp ','
    If substr(dsp,1,1)='(' Then Parse VAR dsp '(' dsp ')'
    If Wordpos(dsp,'MOD NEW')>0 Then disp='NEW'
    Return 0

/*--------------------------------------------------------------------*/
/* Get multi volumes for VSAM datasets                                */
/*--------------------------------------------------------------------*/
get_all_vols:
    i_o=i_o+1
    If i_o//10=0 Then Call pop_message
    If sysr/=12 Then Do
        If trksize/='' Then Do
            If batch/='Y' Then
               "ISREDIT LINE_BEFORE &I = &MT '//*    "trksize" Tracks'"
            Else Say '             ' trksize 'Tracks'
        End
        Return
    End
    volume=volser
    m=Msg('On');x=Outtrap('out.',5000,'NOCONCAT')
    Address TSO "LISTCAT ENT('"n_ld"') ALL"
    tsize=0
    Do js=1 To out.0
        If Index(out.js,' TRACKS-')>0 Then Do
            Parse VAR out.js . . v1
            v1=Translate(v1,' ','-')
            Parse VAR v1 . size
            tsize=tsize+size
            Iterate
        End
        If Index(out.js,' VOLSER-')=0 Then Iterate
        Parse VAR out.js v1 .;v1=Translate(v1,' ','-');Parse VAR v1 . vol
        vol=Strip(vol)
        If Index(volser,vol)>0 Then Iterate
        volser=volser vol
        If batch/='Y' Then "ISREDIT LINE_BEFORE &I=&MT '//*    "vol"'"
        Else Say '             ' vol
    End
    If dsize='Y' Then Do
        aix=
        If tsize=0 & Substr(out.1,1,5)='PATH ' Then Do js=1 To out.0
            If Index(out.js,' AIX-')=0 Then Iterate
            Parse VAR out.js v1 .;v1=Translate(v1,' ','-');Parse VAR v1 . aix .
            xx=(cp.i+n_ll-1)-22             /* Line up with gen'd DSN */
            aix=Substr(' ',1,xx)'AIX -' aix
            Leave
        End
        If batch/='Y' Then
           "ISREDIT LINE_BEFORE &I=&MT '//*    "tsize" Tracks" aix"'"
        Else Say '             ' tsize 'Tracks' aix
        #dz=#dz+tsize
    End
    x=Msg(m)
    Return 0

/*--------------------------------------------------------------------*/
/* Go determine where this REXX routine resides and use in batch JCL. */
/*--------------------------------------------------------------------*/
Get_dataset: Arg a_dsn,a_memb
    xxx=$ddalloc(a_dsn,U)
    Do While xxx/=''
        Parse Var xxx xx xxx
        If Sysdsn("'"xx"("a_memb")'")='OK' Then Return xx
    End
    Return 'Missing.dataset'

/*--------------------------------------------------------------------*/
/* Parse the JCL to identify whether it's a JOB/PROC.                 */
/* If job, insert a 'TYPRUN=SCAN' card in JOB card else wrap a jobcard*/
/* with TYPRUN=SCAN around the procedure.                             */
/*--------------------------------------------------------------------*/
Do_a_scan:
    Address TSO "NEWSTACK"

    "ISREDIT (last) = LINENUM .ZLAST"
    p_name = ''
    Do i=1 To last
        "ISREDIT (line) = LINE" i
        If Substr(line,1,2) /= '//' Then Iterate
        If Substr(line,1,3) = '//*' Then Iterate
        If Word(line,2) = 'JOB' Then Leave
        If Word(line,2) = 'PROC' Then Do
            p_name = Strip(Substr(Word(line,1),3))
            Leave
        End
    End
    i = 1
    If p_name /= '' Then Do
        Queue "//"Substr(userid"SC",1,8)" JOB "acct",'SCAN JCL',"
        Queue '//             CLASS=A,COND=(4,LT),'
        Queue '//             MSGCLASS=X,'
        Queue '//             TYPRUN=SCAN,'
        Queue '//             NOTIFY=&SYSUID'
    End
    Else Do i=1 To last
        "ISREDIT (line) = LINE" i
        If Substr(line,1,3) = '//*' Then Iterate
        If Substr(line,1,2) = '/*' Then Iterate
        line = Strip(Substr(line,1,72))
        ll = Length(line)
        If Substr(line,ll,1) = ',' Then Do
            Queue line
            Queue '//  TYPRUN=SCAN,'
        End
        Else Do
            Queue line','
            Queue '//  TYPRUN=SCAN'
        End
        Leave
    End
    Do i=i+1 To last
        "ISREDIT (line) = LINE" i
        Queue line
    End
    If p_name /= '' Then Do
        Queue '// PEND'
        Queue '//*'
        Queue '//SCAN1 EXEC' p_name
        Queue '//*'
    End
    Queue ''

    "VGET ZTEMPF"
    Address TSO
    dd = 'DD'Time('s')
    "ALLOC DD("dd") DS('"ztempf"') OLD REU"
    "EXECIO * DISKW "dd" (FINIS"
    "DELSTACK"
    Address ISPEXEC
    "LMINIT DATAID(DATAID) DDNAME("dd")"
    dsnemac = '2' ; "VPUT (dsnemac) SHARED"
    "VIEW DATAID(&DATAID) MACRO(&XCMD)"
    "LMFREE DATAID(&DATAID)"
    Address TSO "FREE DD("dd")"

    Exit

/*--------------------------------------------------------------------*/
/* Parse parameters                                                   */
/*--------------------------------------------------------------------*/
parse_parms:

    trace = parse_cons('TRACE')

    i_xst = parse_cons('/X','NX','NULL')    /* Ignore X status        */
    If i_xst = '' Then i_xst = parse_cons('/NX','X','NULL')

    lv = parse_cons('/LV')

    dsize  = parse_cons('/DS')
    If dsize = 'Y' Then lv = 'Y'

    conv4v = parse_cons('/CV')              /* Convert for verific    */

    p4dsne = parse_cons('/PD')              /* Prepare for DSNE       */

    arcrep = parse_cons('/LA')              /* Highligh archived      */

    pop_it = parse_cons('/NP','N','Y')      /* Progress message       */

    mis_m  = parse_cons('/MM','Y','N')      /* Report missing members */

    t_scan = parse_cons('/SCAN')            /* Build JCL to test proc */

    vv_p=
    ver_vol= parse_cons('/VV',1,0)          /* Verify Volser          */
    vv_p=parse_cons('/IU','/IU','NULL')     /* Ignore uncataloged     */
    xx=parse_cons('/VT','/VT','NULL')       /* Volume toggle          */
    If xx/='' Then Do;vv_p=vv_p xx;ver_vol=1;End
    word_o=parse_varb('/W',0)               /* Word only (not JCL)    */
    If word_o='' Then word_o=1;If \Datatype(word_o,'W') Then word_o=0

    a_mcat=parse_varb('/MCAT(','?')         /* Alternate catalog      */
    If a_mcat/='?' Then Do
        Parse VAR a_mcat a_mcat ')';a_mcat="'"Strip(a_mcat,,"'")"'"
        If SYSdsn(a_mcat)/='OK' Then Do
            zedlmsg='Invalid "/MCAT()" parameter 'a_mcat' passed ->',
                    SYSdsn(a_mcat)'. Please correct and try again.'
            Address ISPEXEC "SETMSG MSG(ISRZ001)"
            Exit
        End
        Else If Sysdsn(a_mcat)/='OK' Then a_mcat='?'
    End

    xtraex = parse_varb('I=','NULL')

    com_set = parse_varb('/U','MISSING')
    If com_set /= 'MISSING' Then com_set = 'Y'

    Parse VAR parm# parm# parm#_rest

    batch = parse_cons('/B')
    If batch = 'Y' Then Do
        pop_it = 'N'
        i_xst  = ''
        Return 0
    End

    If Datatype(parm#) = "NUM" Then Do
        zfrange = parm#
        zlrange = parm#
    End
    Else Do
        If parm# /= '' Then Do
            zedlmsg = "Unknown parameter '"Strip(parm#)"' supplied.",
                    "Correct and re-invoke."
            Signal ext2
        End
    End

    Return 0

/*--------------------------------------------------------------------*/
/* Parse string 'parm#' with 'mask'. Result set to 'N' if mask not    */
/* found or set to 'Y' if found. Can pass positive/negative result    */
/* substitution as the 2 and 3 parameter. Defaults are Y and N.       */
/* Can set null return value for either by passing 'NULL'. Can set    */
/* either to the original mask by entering '*' (suggest 'NULL' for the*/
/* other value).                                                      */
/* Can pass a mask length as fourth parameter. Comma delimit to pad   */
/* out if prior parameters are not supplied.                          */
/* Can pass 'WORD' as fourth parameter to return the word that        */
/* contain that mask (word does not need to start with mask).         */
/*--------------------------------------------------------------------*/
parse_cons: Procedure Expose parm#;Arg mask,posr,negr,maskl
    If posr=''     Then posr='Y' ;If negr=''     Then negr='N'
    If posr='NULL' Then posr=''  ;If negr='NULL' Then negr=''
    If posr='*'    Then posr=mask;If negr='*'    Then negr=mask
    Select
        When (maskl='WORD') Then Do
            y#=0;xxx=parm#
            Do i=1 To Words(xxx)
                Parse VAR xxx x_x xxx
                If Index(x_x,mask)>0 Then Do;y#=i;posr=x_x;Leave;End
            End
        End
        When (Datatype(maskl,'W')) Then Do
            y#=0;xxx=parm#
            Do i=1 To Words(xxx)
                Parse VAR xxx x_x xxx
                If Substr(x_x,1,maskl)=Substr(mask,1,maskl) Then Do
                    y#=i;Leave
                End
            End
        End
        Otherwise y#=Wordpos(mask,parm#)
    End
    If y#>0 Then Do;parm#=Delword(parm#,y#,1);Return posr;End
    Return negr

/*--------------------------------------------------------------------*/
/* Parse string 'parm#' with 'mask'. Result set to 'N' if mask not    */
/* found or set to next space delimeted value immediately following   */
/* the mask (NULLs is a valid value).                                 */
/* Can pass positive/negative result substitution as the 2 parameter. */
/* Can pass 'NUM' as third parameter to check for numerics and return */
/* negative result if not numeric.                                    */
/*--------------------------------------------------------------------*/
parse_varb: Procedure Expose parm#;Arg mask,negr,dt
    If negr='' Then negr='N'
    parm##=' 'parm#;m#=' 'mask;y#=Index(parm##,m#)
    If y# > 0 Then Do
        If Substr(parm##,y#+Length(m#),1)='' Then Do
            px='';data="Parse VAR parm## p1 '"m#"' p2"
        End
        Else data="Parse VAR parm## p1 '"m#"' px p2"
        Interpret data
        parm#=Strip(p1) Strip(p2)
        If dt='NUM' & Datatype(px)/='NUM' Then Return negr
        Else                                   Return px
    End
    Return negr

/*--------------------------------------------------------------------*/
/* Traps syntax errors                                                */
/* Cancel error traps, then deal with the error                       */
/*--------------------------------------------------------------------*/
errproc_1:
    If Condition('C')='ERROR' Then Return
    Signal Off Syntax
    error_type = Condition('C')
    Parse Value Condition('D') With Func Secprof .
    Say error_type" at line "sigl
    Say Condition('D')" RC="rc" "
    Exit 12

/*--------------------------------------------------------------------*/
/* Set Batch JCL                                                      */
/*--------------------------------------------------------------------*/
set_4_batch:
    "ISREDIT (dsn) = DATASET"
    "ISREDIT (mem) = MEMBER"
    dsnmemb = "'"dsn"("mem")'"

    Address TSO "NEWSTACK"

    Queue "//"Substr(userid"DB",1,8) "JOB "acct",'DSNE-BATCH',"
    Queue '//         CLASS=A,COND=(4,LT),'
    Queue '//         MSGCLASS=X,'
    Queue '//         NOTIFY=&SYSUID'
    Queue '//*-------------------------------------------------------------*//'
    Queue '//* Batch processing JCL. Either save into permanent member or  *//'
    Queue '//* submit from the command kine...                             *//'
    Queue '//*-------------------------------------------------------------*//'
    Queue '//STEP1 EXEC PGM=IEBUPDTE,PARM=NEW'
    Queue '//SYSPRINT DD SYSOUT=*'
    Queue '//SYSUT2   DD DSN=&&REXX,'
    Queue '//       DISP=(NEW,PASS),UNIT=SYSDA,SPACE=(TRK,(2,1,1)),'
    Queue '//       DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)'
    Queue '//SYSIN  DD DATA,DLM=$$'
    Queue './ ADD NAME=DSNEBTCH'
    Queue '/*  REXX  */'
    Queue '    Arg dsnmemb'
    Queue '    Address ISPEXEC'
    Queue "    dsnebtch='Y'"
    Queue "    dsneparm='"parm#"'"
    Queue "    dsnebtrc='NTRACE'             /* Delete 'N' to trace */"
    Queue '    "VPUT (dsnebtch,dsneparm,dsnebtrc) SHARED"'
    Queue '    "VIEW DATASET("dsnmemb") MACRO(DSNE)"'
    Queue '    Exit'
    Queue './ ENDUP'
    Queue '$$'
    Queue '//STEP2    EXEC PGM=IKJEFT01,DYNAMNBR=65,REGION=4096K'
    Queue '//SYSEXEC  DD DISP=(OLD,DELETE),DSN=&&REXX'
    Signal On Syntax Name ret_syntax_2
    Queue '//         DD DISP=SHR,DSN='Get_dataset('SYSEXEC SYSPROC',xcmd)
ret_syntax_2:
    Signal On Syntax Name ret_syntax_3
    yy='ISPPLIB=???:ISPMLIB=???:ISPSLIB=???:ISPTLIB=???:'
    xx='ISPPLIB ISPMLIB ISPSLIB ISPTLIB';yy=Batchisp('RETURN')
ret_syntax_3:
    Do While xx/=''
        Parse VAR xx dd xx
        Interpret "Parse VAR yy '"dd"=' "dd" ':'"
        Interpret 'zz='dd
        Do While zz/=''
            Parse VAR zz dsn zz
            Queue Substr('//'dd,1,10) 'DD DISP=SHR,DSN='dsn
            dd=
        End
    End
    Queue '//ISPPROF  DD DSN=&&ISPPROF,SPACE=(TRK,(10,,10)),UNIT=SYSDA,'
    Queue '//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)'
    Queue '//ISPLOG   DD DUMMY'
    Queue '//ISPLIST  DD DUMMY'
    Queue '//SYSTSPRT DD SYSOUT=X'
    Queue '//SYSTSIN  DD *'
    Queue 'PROFILE PREFIX(&USERID.)'
    Queue 'ISPSTART CMD(%DSNEBTCH 'dsnmemb')'
    Queue '/*'
    Queue ''

    "VGET ZTEMPF"
    Address TSO
    dd='DD'Time('s')
    "ALLOC DD("dd") DS('"ztempf"') OLD REU"
    "EXECIO * DISKW "dd" (FINIS"
    "DELSTACK"
    Address ISPEXEC
    "LMINIT DATAID(DATAID) DDNAME("dd")"
    dsnemac='1';"VPUT (dsnemac) SHARED"
    "VIEW DATAID(&DATAID) MACRO(&XCMD)"
    "LMFREE DATAID(&DATAID)"
    Address TSO "FREE DD("dd")"

    Return 0

macro_1:
    dsnemac = '' ; "VPUT (dsnemac) SHARED"
    n_st = mark(2)                          /* Mark next line         */
/*

  This is the JCL to process the DSNE routine in batch against your
  selected member. Either submit by entering SUB on the command line
  or save into a permanent dataset and tailor/process at your own
  convenience...

*/
    n_en = mark(-2)                         /* Mark prev 2 line       */
    Call output_notelines

    Exit

macro_2:
    dsnemac=;"VPUT (dsnemac) SHARED"
    n_st = mark(2)                          /* Mark next line         */
/*

  This is the JCL generated to submit the JCL with TYPRUN=SCAN.

  Notes:
    1. TYPRUN=SCAN checks for syntax and not for valid datasets.
    2. If it's a JOB then a TYPRUN=SCAN has been inserted. Watch for
       continuation syntax if last character of a continued job card
       is not a comma (ie. has comments on line) as this may cause
       JCL errors.
    3. If it's a PROC, then a job with the instream proc has been set
       up.

*/
    n_en = mark(-2)                         /* Mark prev 2 line       */
    Call output_notelines

    Exit

macro_P:
    dsnemac=;"VPUT (dsnemac) SHARED"

    Exit

output_notelines:
    "ISREDIT (caps)=CAPS";"ISREDIT CAPS=OFF";"ISREDIT RESET"
    x=pit('*'Centre('ooo000OOOO000ooo',70,'-')'*')
    Do i=n_st To n_en
        x=pit('*'Substr(Sourceline(i),1,70)'*')
    End
    x=pit('*'Copies('-',70)'*')
    "ISREDIT CAPS=(caps)"
    Return 0

TSO_help:
    dsneparm=;"VPUT (dsneparm) SHARED"
    n_st = mark(2)                          /* Mark next line         */
/*

    Hello `CNAME..

    DSNE is an ISPF edit macro to determine if all the datasets in JCL
    have been defined.
    (Dare I say??? For sites without CA's JCLCHECK!!!!!)

    All defined datasets will be excluded with the uncataloged
    datasets only being displayed unless they all exist whereby all will
    be displayed with the stats.

    Notes:
      1. Will only report on what it can see.  If there are any external
         PROCs or INCLUDEs, tough titties, use JCLCHECK or shut your
         mouth.  (Next release...)  It will, however, take note of any
         NEW/MOD datasets predefined and will pass any subsequent
         OLD/SHR references to them. No check is made for intermediate
         deletions.
      2. Does NOT perform syntax checking. Only reports on datasets
         (hence DSN Exists). For syntax checks use parameter of "/SCAN".
         This will wrap a job card with TYPRUN=SCAN around the procedure
         and an EXEC statement to exeute it in batch. If it's a job, it
         will insert a TYPRUN=SCAN card as the second line in the
         jobcard.
         Note: Watch for potential syntax errors if the first line of
               the job card has trailing comments.

    Summary explained:
       Processed : Number of datasets (DSN=) processed.
       Not found : Number of datasets not found (uncataloged).
       Var N/F   : Number of variables in the JCL (&varname) not
                   referebced by a PROC or SET command.
       Parse Err : Number of parsing errors.
       M-Member  : Number of missing members. Only tallied if the
                   appropriate parameter "/MM" is used. Otherwise
                   missing members are ignored and only highlighted
                   if the dataset doe not exist.
       Includes  : Number of "INCLUDE" commands used. DSNE cannot
                   validate datasets in "INCLUDE" members.
       VSAM      : Number of VSAM datasets in the total processed.
       NONVSAM   : Number of Non-VSAM datasets in the total processed.
       New/Mod   : Number of Non-VSAM datasets with a disp of MOD/NEW
                   to "justify" their non existance.
       Unmounted : Number of datasets unmounted.
       Migrated  : Number of datasets migrated.  This can give an
                   indication of potential delays in executing job.
       Temporary : Number of temporary dataset (&&tempname).
       Bad VolSer: Number of datasets on volumes other than that
                   explicitly stated in JCL.  Note, depending on logic
                   these may not be errors.


    Scanning is delimted by either a line Cnnn, block CC or default
    'ALL' command.

    Valid parameters:
      /B      - Batch process. The batch JCL will be presented for
                submission.
      /CV     - Convert for Verification. Will extract the 'DSN=..'
                from the member and generate JCL of the format
                '//llq DD DISP=SHR,DSN=' where 'llq' is low level qual.
                This is designed to remove all the noise and make it
                easier to see. This is made to a copy of curent edit
                member.
      /DS     - Display size of datasets. For this feature /LV is
                required. Will turn on /LV if not requested.
                Both the data and index (if applicable) will be summed.
      /IU     - Ignore Uncataloged datasets. Used in conjunction with
                the /VV parameter and will not flag any datasets whose
                actual volume is different to that in the JCL.
      /LA     - List archived datasets.  This is usefull when you might
                want to create a list of datasets for batch recall.
                (You may want to wrap an IEFBR14 job around it.)
      /LV     - List all the volumes the dataset that exist are
                catalogued on. It will give a list of all volumes for
                VSAM datasets but only the first one for NON-VSAM.  A
                popup screen will be used to display the progress of
                processing unless the /NP option was used.
      /MCAT(alt.mcat)
              - Alternate catalog to use to establish "existance" of
                datasets. Uncataloged datasets will be tagged as
                'Miss AC' (MISSing from Alternate Catalog).
                Note: If this feature is used all datasets cataloged
                      in user catalogs (under their respective alias)
                      will be tagged 'Miss AC'.
      /MM     - Report Missing members.
      /NP     o Do not display the progress panel.
      /NX     o Report on non-excluded members only.
      /PD     - Prepare a list of Dataset names only (preferably one per
                line, however, may have multiple datasets comma or space
                seperated) for DSNE processing. Note, this is a
                destructive process and should only be executed on a
                copy or in view mode. (You have been warned.)
      /SCAN   o Modify the JCL to permit submission with TYPRUN=SCAN
                option. Will wrap JOB/EXEC cards around procedures.
                This is not destructive as a processing will be
                performed on a copy of the JCL.
      /Ucs    - Use Comented (out) SET line commands for variable
                substitution.  (Used in special test occassions.)
      /VT     - Volser Toggle. Only valid with the /VV parameter and
                will cause the noteline to be toggled with the original
                line if the cataloged volume is different from the JCL
                VOL=SER= value.  If the dataset is "Uncatl" then it will
                NOT be toggled.
                This parameter will automatically enable the /VV
                parameter.
      /VV     - Verify Volser. Use this parameter to verify volser for
                cataloged datasets where VOL=SER= is used on the DD
                statement.  Uncataloged (non-defined datasets will be
                ignored unless the /IU parameter is used.  If the
                dataset is cataloged to another volume to that defined
                in the JCL a NOTELINE will be placed above it with the
                correct volume. (Requires access to nacro "VV".)
                Warning:
                - This option is processed last and will not be part of
                  the progress meter. For a large number of DD's this
                  may cause significant delays near the tail end of
                  processing.
                - This option will automatically be executed if the /VT
                  parameter is used.
      /Wn     - Word 'n'. Data presented is not JCL but dataset is  the
                'n' th. word on line.  Default is word 1. The 3rd. byte
                (past the "/W") must be numeric.
      /X      o Report on excluded members only.
      ?       o Display help details as notelines in the edit/view
                session.
      HELP    o Same as ?.
      nnnn    o Process that line number only.


    Results will be presented in MSGline or NOTEline format at the
    top of the JCL depending on the type of message or presented after
    the line in batch processin.

    Notes and GOTCHAs:
      1. Parameters marked with an 'o' above (instead of '-' sperator)
         are invalid in batch and will be ignored.
      2. The /X or /NX options operate against original display. The
         nature of this routines processing will change the exclusion
         status for display purposes. (If available, use the "SNAP Tn"
         command to take a snap of the exclude status and reset it after
         DSNE had weaved it's magic.
      3. For VSAM datasets the /LV options issues and parses the output
         from a LISTCAT command. This can be quite timely for large JCL
         hence the /B option. Use of the /DS feature will automatically
         turn on the /LV option.
      4. The /DS feature will generate a VSAM stats and parses the
         output from a LISTCAT command. This can be quite timely for
         large JCL hence the /B option. Use of the /DS feature will
         automatically turn on the /LV option.
      5. With the /DS feature a summary of VSAM DASD (size) will be
         displayed immediately after the VSAM entry. This is only a
         rough estimate as it does not take into consideration
         duplicate dataset name entries in the processed JCL.
      6. In batch processing all lines will be processed and JCL can be
         generated by using the /B switch
                         - or -
         can be launched by one of the following set of REXX commands in
         a batch TSO session:

             dsnebtch = 'Y'
             dsneparm = '/B other_dsne_parms'
             dsnebtrc = 'TRACE' er_dsne_parms'
             "VPUT (dsnebtch,dsneparm,dsnebtrc)"

         then one of the following:

             "ISPEXEC VIEW DATASET('dsn/dsn(member)' MACRO(DSNE)"

         or from within an existing batch edit of the required JCL:

             "ISREDIT DSNE /B other_dsne_parms"

         Note - Batch processing requires a batch ISPF environment.

      7. Any migrated dataset will be tagged. This is usefull for
         jobs that cannot afford to wait for recalls or would bypass
         recall and cause grief later on. These datasets could be
         recalled by some other external intervention.

      8. Comments on line 1 of job cards may cause syntax errors
         if the "/SCAN" option is used.

      9. "&&" will be treated as a variable JES2 name. & by itself
         will try to substitute any variables. Not found variables
         will be signalled as an error.  If the name is a valid
         variable name, please ignore message.

     10. If multiple datasets are used on the same JCLLIB statement
         only the first not found will be highlighted. However, the
         stats will include all JCLLIB datasets not found. Correct
         the first in error and the next invalid one will be high-
         lighted.


    Packaging. (Optional members are marked with a 'o' seperator.

    REXX:
      $ALKACCT o Set default account.
      $DDALLOC o Dataset allocated to a particular DD. Used to find
                 location of REXX DSNE fo batch processing and other
                 DD allocated datasets.
      $WHOAMI  o Message to identify user.
      BATCHISP o Set IBM "default" ISPF dataset.
      BR       o Output message browser.
      DSNE     - This driver
      VV       o Macro to Verify Volser.

    Panels:
      POPMSG   o Pop up progress display panel. If this panel is not
                 available, always use the /NP parameter.

                                     *****

*/
    n_en = mark(-2)                         /* Mark prev 2 line       */

    If ima_macro Then Do;"ISREDIT (caps)=CAPS";"ISREDIT CAPS =OFF";End
/*  Else Address TSO "CLEAR"                                          */
    x=pit(Centre(' ooo000OOOO000ooo ',79,'*'))
    Do i=n_st To n_en
        line = Sourceline(i)
        Do While Index(line,chgchar)>0
            Interpret "Parse VAR line p1 '"chgchar"' var '.' p2"
            Interpret 'line=p1||'var'||p2'
        End
        x=pit(line)
    End
    x=pit(Centre(' End ',79,'*'))
    x=pit(' ')
    If dsnebtch='Y' Then "ISREDIT CANCEL"
    If ima_macro Then "ISREDIT CAPS=(caps)"
    Exit


pit:If ima_macro Then x=nl(Arg(1));Else Say Arg(1);Return 0
nl: Parse Arg nl1;"ISREDIT LINE_BEFORE .ZFIRST = NOTELINE (nl1)";Return 0
Mark: Arg diff;If Datatype(diff)/='NUM' Then diff=1;Return sigl+diff
/*--------------------------ooo00 REXX 00ooo--------------------------*/
/*  DSNEACAT:                                                         */
/*  Issues a LISTCAT against a dataset using a passed catalog to      */
/*  determine "existance" of dataset.                                 */
/*                                                                    */
/*  Parameters:                                                       */
/*    1. dataset name.                                                */
/*    2. Catalog.                                                     */
/*  Returns:                                                          */
/*    8 if dataset not cataloged in alternate catalog.                */
/*--------------------------------------------------------------------*/
DSNEACAT:dsneacat_ver='1.01'
Arg dsname,catalog
    Parse Value Strip(dsname,,"'") With dsname '(' .
    #m1=Msg('On');x=Outtrap('line.',10,'NOCONCAT')
    Address TSO "LISTCAT ENT('"dsname"') CAT("catalog")"
    x=Outtrap('Off');x=Msg(#m1)
    If rc/=0 Then rc='MA'
    Return rc
