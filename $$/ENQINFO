/*--------------------------ooo00 REXX 00ooo--------------------------*/
/*                                                                    */
/* Macro/EXEC to drive ENQINFOL, the ENQ inquirer.                    */
/*                                                                    */
/* For more details invoke it with either one of the following help   */
/* parameters: ?, /?, HELP or /H.                                     */
/*                                                                    */
/* Members required to package this product. Optional members are     */
/* marked with a 'o':                                                 */
/*   REXX:                                                            */
/*     ENQINFO  - This driver                                         */
/*     ENQINFDH - Dynamic tutorial (requires access to HELPDRVR suite */
/*                packaging).                                         */
/*     ENQINFX  o Exit to execute your own commands against line      */
/*                commands not covered by the driver                  */
/*     U2LOWER  o Convert user name to lower case                     */
/*     BR       o Help browser                                        */
/*                                                                    */
/*   Panels:                                                          */
/*     ENQINFPY - Dynamic display panel (optional if the '/TSO'       */
/*                feature is to be used).                             */
/*     ENQINFP2 - Dynamic display panel (LEFT scroll).                */
/*     ENQINFPQ o Qname selection panel                               */
/*     ENQINFPn o Tutorial panels where 'n' is a digit                */
/*     EXTBPANL o VSAM browse panel (required to browse VSAM datasets)*/
/*                                                                    */
/*   LoadMOD"                                                         */
/*     ENQINFOL - Assembler source                                    */
/*     EXTBVSAM o VSAM browser                                        */
/*                                                                    */
/*--------------------------------------------------------------------*/
enqinfo_ver='2.15'
    ARG parm#;Address ISPEXEC;"CONTROL ERRORS RETURN";ima_macro=0
    Parse Upper VAR parm# parm1 parm2 parm3 parm4 parm5 parm6
    Parse Source opsys . xcmd . dsn_name .
    uid=Userid()
    If Wordpos(parm1,'? /? HELP ??')>0 |,
       Substr(parm1,1,2)='/H' Then Signal help
    If Sysvar(SYSISPF)/='ACTIVE' Then Do
        Address TSO "ISPSTART CMD(%"xcmd parm#" /TSO)"
        Return 0
    End

/*  "CONTROL ERRORS CANCEL"                                           */
    zerrhm='*';zerralrm='NO';zedsmsg=

    xracf=                                  /* Set to XRACF at Telstra*/
    screen2=0
    pgm      = 'ENQINFOL'
    bvsampgm =                              /* VSAM browse disabled   */
    bvsampgm = 'EXTBVSAM'                   /* VSAM browse program    */
    dispnl   = 'ENQINFPY'
    qnmpnl   = 'ENQINFPQ'                   /* Qname panel            */
    helpanel = 'ENQINFP1'
    enqexit  = 'ENQINFX'
    enqtype1 = 'INPUT'
/*  enqcol1  = 'WHITE'                                                */
    enqcol1  = 'YELLOW'
    enq_#=
    ohex='000102030405060708090A0B0C0D0E1112131415161718191A'x  ||,
         '1B1C1D1E2122232425262728292A2B2C2D2E31323334353637'x  ||,
         '38393A3B3C3D3E'x
    chex=Copies('.',Length(ohex))

    c_sys=Strip(storage(d2x(x2d(c2x(storage(10,4)))+x2d(154)),8))
    If parse_cons('/TSO')='Y' Then Do
        keep='Y'                            /* Return to this routine */
        tsocall=4
    End
    Else Do
        keep='R'                            /* Re-invoke this routine */
        tsocall=0
    End

    If parm1='GRSC' | Substr(parm1,1,8)='CONFLICT' Then Do
        x=S1_Grsc()
        Exit
    End
    If Wordpos(Substr(parm1,1,1),'. ?')>0 Then Call test_alias

    If parm1='2ND' Then Signal ini2
    isn='*';isc='*';is1='*';is2='*';iqn='*';ijn='*';irn='*';irt='*'
    jnl=Length(uid)
    tablenm='$W'Time('s');tablemq=;sortf='RNAME'

    If parm#/='' Then Do
        #tr=Trace('o');Call parse_parms;x=Trace(#tr)
        If Substr(resource,1,7)/='RESERVE' Then Do
            If Substr(resource,Length(resource),1)/='*' Then Do
                resource=Strip(resource,,"'")
                If asis Then Nop;Else resource=resource'*'
            End
        End
    End
    Else Do
        resource=uid'*';rid='J'
    End
    If trace='Y' Then Trace r

    If rid='R' Then irn=resource;Else ijn=Strip(Substr(resource,1,8))
    If Verify(ijn,'%*','M')<Length(irn) Then Do
        enqmaskj=ijn;ijn=Translate(ijn,'*','%')
    End;Else enqmaskj=
    If Verify(irn,'%*','M')<Length(irn) Then Do
        enqmaskr=irn;irn=Translate(irn,'*','%')
    End;Else enqmaskr=
    "VPUT (TABLENM TABLEMQ DISPNL ISN IJN ISC IS1 IS2 IQN IRN IRT KEEP",
        "SORTF XCMD ENQTYPE1 TSOCALL RESRV ENQMASKR ENQMASKJ) SHARED"
    "SELECT PGM(&PGM)"

    If tsocall/=0 Then Do
        x=output_details(tablenm,'SAY')
        "TBEND &TABLENM"
    End
    Return tsocall

/*--------------------------------------------------------------------*/
/* Processing for 2nd. invocation.                                    */
/*--------------------------------------------------------------------*/
ini2:
    "VGET (TABLENM DISPNL ISN IJN ISC IS1 IS2 IQN IRN IRT",
        "SORTF XCMD TSOCALL ENQMASKR ENQMASKJ) SHARED"
    sit='Y'
    tablegm=tablenm

    If enqmaskj/='' Then Do
        "ISPEXEC TBTOP &TABLEGM"
        maskj=De_Mask(enqmaskj)
        Do Forever
            "TBSKIP &TABLENM";If rc/=0 Then Leave
            If $wild_match(jobname,maskj)/='OK' Then "TBDELETE &TABLENM"
        End
        ijn=enqmaskj
    End
    If enqmaskr/='' Then Do
        "ISPEXEC TBTOP &TABLEGM"
        maskr=De_Mask(enqmaskr)
        Do Forever
            "TBSKIP &TABLENM";If rc/=0 Then Leave
            If $wild_match(rname,maskr)/='OK' Then "TBDELETE &TABLENM"
        End
        irn=enqmaskr
    End

    "ISPEXEC TBTOP &TABLEGM"
    "ISPEXEC TBQUERY &TABLEGM ROWNUM(rownum) POSITION(tabptr)"
    rownum=rownum+0

sort_b4_scr2:
    If sit='Y' Then Do
        "TBSORT &TABLEGM FIELDS("sortf",C,A)"
        "ISPEXEC TBTOP &TABLEGM"
        sit='N';tabptr=0;scrolln=0
    End

    If first_time/='N' Then Call init_vars_etc
    Call build_field

scr2:
    dispstat=owhite'Row' tabptr+1 'of' rownum
    Parse Value Time() With xx +5 .
    headline=Substr(oyellow|| xx '-'mainhead,1,79-Length(dispstat))||dispstat

    zcmd=;If enqmaskj/='' Then ijn=enqmaskj
    If enqmaskr/='' Then irn=enqmaskr
    "DISPLAY PANEL(&DISPNL)"
    If rc>4 Then Do;"TBEND &TABLEGM";Return 8;End
If zcmd='?D' Then Do
    mmv=mm_ver
    helpvars='mmv,xcmd';"VPUT (helpvars,"helpvars") SHARED"
    x=helpdrvr('HELPDRVR=ENQINFDH');Signal scr2
End
    If csr1='VARX1' Then Do
        Call disp_qname;Signal exi2
    End
    csr1='ZCMD'

    Parse VAR zcmd cmd parm1 parm2 parm3
    Parse VAR parm1 p11 +1 .
    If Substr(irn,Length(irn))/='*' Then irn=irn'*'
    If Verify(ijn,'%*','M')<Length(ijn) Then Do
        enqmaskj=ijn;ijn=Translate(ijn,'*','%')
    End;Else enqmaskj=
    If Verify(irn,'%*','M')<Length(irn) Then Do
        enqmaskr=irn;irn=Translate(irn,'*','%')
    End;Else enqmaskr=

/*--------------------------------------------------------------------*/
/* Test for scrolling                                                 */
/*--------------------------------------------------------------------*/
    "ISPEXEC VGET (zscrolla zscrolln zverb)"
    If Wordpos(zverb,'UP DOWN')>0 Then Do
        Call scroll_data_ud;Call bld2
        Signal scr2
    End
    If Wordpos(zverb,'LEFT RIGHT')>0 Then Do
        If scroll_data_lr()=0 Then Call bld2
        Signal scr2
    End

/*--------------------------------------------------------------------*/
/* Test for commands/selections                                       */
/*--------------------------------------------------------------------*/
    If Wordpos(cmd,'TRACE DEBUG')>0 Then Do
        If parm1='OFF' Then trace='N'
        Else Do;If trace='Y' Then trace='N';Else trace='Y';End
        If trace='Y' Then Trace r;Else Trace Off
        Signal scr2
    End
    If Substr(cmd,1,7)='RESERVE' Then Do
        irn=cmd;Signal exi2
    End
    If cmd='?' Then Do
        Address TSO "%BR" xcmd "'?'";Signal exi2
    End
    If cmd='SORT' | Substr(cmd,1,2)='/S' Then Do
        Select
            When (p11='O') Then sortf='STAT2'
            When (p11='W') Then sortf='STAT2,C,D'
            When (p11='R') Then sortf='RNAME'
            When (p11='Q') Then sortf='QNAME'
            When (p11='J') Then sortf='JOBNAME'
            When (p11='S') Then sortf='SYSNAME'
            Otherwise NOP
        End
        sit='Y'
        Signal sort_b4_scr2
    End

    If cmd='PRINT' | cmd='PRNT' | Substr(cmd,1,2)='/P' Then Do
        "TBTOP &TABLENM"
        Address TSO "NEWSTACK"
        x=output_details(tablenm,'QUE')
        "TBTOP &TABLENM"
        ztempf=$ztempf();dd='ZT'Time('s')
        Address TSO "ALLOC F("dd") DA('"ztempf"') SHR REU"
        Address TSO "EXECIO * DISKW "dd" (FINIS"
        Address TSO "DELSTACK"
        "ISPEXEC LMINIT DATAID(DATAID) DDNAME("dd")"
        "ISPEXEC VIEW DATAID(&DATAID)"
        "ISPEXEC LMFREE DATAID(&DATAID)"
        Address TSO "FREE F("dd")";ztempf=$ztempf(ztempf,'/D')
        Signal scr2
    End

    If cmd='/ALIAS' Then Do
        Call test_alias
        Parse VAR zcmd '?' a_i ':' a_v
        If a_i/='' & a_v/='' Then Do
            ins='?'Strip(a_i)':'Strip(a_v)
            i_l=Length(ins)
            i_p=Index(enqinfoa,'?ZZ:')
            If i_p=0 Then i_p=Length(enqinfoa)+1
            enqinfoa=Insert(ins,enqinfoa,i_p-1)
            "VPUT (enqinfoa) PROFILE"
            enq_#=enqinfoa
        End
        zedlmsg=enqinfoa
        "SETMSG MSG(ISRZ001)"
        Signal scr2
    End

    If Substr(zcmd,1,1)='?' Then Do
        Parse VAR zcmd parm1 .
        Call test_alias
        If result=0 Then irn=parm1'*'
        Signal exi2
    End

    If cmd='GRSC' | Substr(cmd,1,8)='CONFLICT' |,
       irn='GRSC' | Substr(irn,1,8)='CONFLICT' Then Do
        #keep=keep;#tablenm=tablenm;#tabptr=tabptr;#rownum=rownum
        x=S1_Grsc()
        keep=#keep;tablenn=#tablenm;tablegm=tablenm;tabptr=#tabptr;
        rownum=#rownum
        "VPUT keep SHARED"
        Signal scr2
    End

    If  Test_selection()<8 Then Signal scr2

exi2:
    If Substr(irn,1,7)='RESERVE' Then,
        Parse Value '* * * * * *' With isn isc is1 is2 iqn ijn
    "VPUT (SORTF ISN IJN ISC IS1 IS2 IQN IRN IRT ENQMASKR ENQMASKJ) SHARED"
    "TBEND &TABLENM"
    Exit

/*--------------------------------------------------------------------*/
/* Parse parameters                                                   */
/*--------------------------------------------------------------------*/
parse_parms:
    trace=parse_cons('TRACE')
    asis=Parse_cons('/ASIS',1,0,2)
    rid=Parse_cons('/J','J','R')
    If Parse_cons('/E')='Y' Then is1='EXCL'
    If Parse_cons('/S')='Y' Then is1='SHR'
    If Parse_cons('/O')='Y' Then is2='OWN'
    If Parse_cons('/W')='Y' Then is2='WAIT'
    xx=Parse_varb('/Q(','?');If xx/='?' Then Parse VAR xx iqn ')'
    xx=Parse_varb('/J(','?');If xx/='?' Then Parse VAR xx ijn ')'
    xx=Parse_varb('/S(','?');If xx/='?' Then Parse VAR xx isn ')'
    xx=Parse_varb('/R(','?')
    If xx/='?' Then Do
        Parse VAR xx irn ')';rid='R'
    End

    Parse VAR parm# parm# parm#_rest
    resource=Strip(parm#)

    Return 0

/*--------------------------------------------------------------------*/
/* Parse string 'parm#' with 'mask'. Result set to 'N' if mask not    */
/* found or set to 'Y' if found. Can pass positive/negative result    */
/* substitution as the 2 and 3 parameter. Defaults are Y and N.       */
/* Can set null return value for either by passing 'NULL'. Can set    */
/* either to the original mask by entering '*' (suggest 'NULL' for the*/
/* other value).                                                      */
/* Can pass a mask length as fourth parameter. Comma delimit to pad   */
/* out if prior parameters are not supplied.                          */
/* Can pass 'WORD' as fourth parameter to return the word that        */
/* contain that mask (word does not need to start with mask).         */
/*--------------------------------------------------------------------*/
parse_cons: Procedure Expose parm#;Arg mask,posr,negr,maskl
    If posr=''     Then posr='Y' ;If negr=''     Then negr='N'
    If posr='NULL' Then posr=''  ;If negr='NULL' Then negr=''
    If posr='*'    Then posr=mask;If negr='*'    Then negr=mask
    Select
        When (maskl='WORD') Then Do
            y#=0;xxx=parm#
            Do i=1 To Words(xxx)
                Parse VAR xxx x_x xxx
                If Index(x_x,mask)>0 Then Do;y#=i;posr=x_x;Leave;End
            End
        End
        When (Datatype(maskl,'W')) Then Do
            y#=0;xxx=parm#
            Do i=1 To Words(xxx)
                Parse VAR xxx x_x xxx
                If Substr(x_x,1,maskl)=Substr(mask,1,maskl) Then Do
                    y#=i;Leave
                End
            End
        End
        Otherwise y#=Wordpos(mask,parm#)
    End
    If y#>0 Then Do;parm#=Delword(parm#,y#,1);Return posr;End
    Return negr

/*--------------------------------------------------------------------*/
/* Parse string 'parm#' with 'mask'. Result set to 'N' if mask not    */
/* found or set to next space delimeted value immediately following   */
/* the mask (NULLs is a valid value).                                 */
/* Can pass positive/negative result substitution as the 2 parameter. */
/* Can pass 'NUM' as third parameter to check for numerics and return */
/* negative result if not numeric.                                    */
/*--------------------------------------------------------------------*/
parse_varb: Procedure Expose parm#;Arg mask,negr,dt
    If negr='' Then negr='N'
    parm##=' 'parm#;m#=' 'mask;y#=Index(parm##,m#)
    If y# > 0 Then Do
        If Substr(parm##,y#+Length(m#),1)='' Then Do
            px='';data="Parse VAR parm## p1 '"m#"' p2"
        End
        Else data="Parse VAR parm## p1 '"m#"' px p2"
        Interpret data
        parm#=Strip(p1) Strip(p2)
        If dt='NUM' & Datatype(px)/='NUM' Then Return negr
        Else                                   Return px
    End
    Return negr

/*--------------------------------------------------------------------*/
/* Test Aliases                                                       */
/*--------------------------------------------------------------------*/
test_alias:
    "VGET (enqinfoa) PROFILE"
    enqinfoa=enq_#
    If enqinfoa='' Then enqinfoa=,
        '?SMPE:SMPE.MVS.GLOBAL.CSI'         ||,
        '?TEDS:SYS2.TEDS.$$'                ||,
        '?TEDST:TPTEDS.TEDS.TABLES'         ||,
        '?PTS:SMPE.MVS.GLOBAL.SMPPTS'       ||,
        '?ME:'uid                           ||,
        '?ZZ:DUMMY_LAST'
    alias=Strip(parm1)':'
    hit=Index(enqinfoa,alias)
    If hit>0 Then Do
        string=Substr(enqinfoa,hit)
        Parse VAR string . ':' parm1 '?' .
        parm1=Strip(parm1)
        parm#=parm1
        Return 0
    End
    Else Return 4

/*--------------------------------------------------------------------*/
/*Activate CONSOLE facility                                           */
/*--------------------------------------------------------------------*/
cancel_job:
    If Substr(rname,1,8)='/CANCELU' Then jobname='U='jobname
    Else If Substr(rname,1,8)='/CANCELJ' Then NOP
         Else Do
             zedlmsg='Invalid cancel command used'
             Return 1
         End
    actn='C'
    If c_sys/=sysname Then actn='RO 'sysname','actn

    iodfvo='??????'
    sol=sysvar('SOLDISP');unsol=sysvar('UNSDISP')
    Address TSO
    "CONSPROF SOLDISP(NO) UNSOLDISP(NO)" /* SET PROFILE TO NO DISPLAYS*/
    alfabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    Do i=1 To 26
        cn=uid || Substr(alfabet,i,1)
        x=Outtrap('line.',1,'NOCONCAT')
        "CONSOLE ACTIVATE NAME("cn")"   /* ACTIVATE CONSOLE           */
        rc1=rc
        If rc1=0 Then Leave
    End
    If rc1/=0 Then Do
        iodf='Could not establist CONSOLE'
Signal deact_con
        Return 1
    End
/*--------------------------------------------------------------------*/
/* Issue command to cancel job                                        */
/*--------------------------------------------------------------------*/
    "CONSOLE SYSCMD("actn jobname") CART('CJN')"
    msg=getmsg('consmsg.',,'CJN',,5)    /* wait 5 seconds for results */
    If msg/=0 Then Do
      zedlmsg='No output from console command to process'
      Signal deact_con
    End
    zedlmsg='Cancel command issued.'
/*--------------------------------------------------------------------*/
/* Deactivate console facility                                        */
/*--------------------------------------------------------------------*/
deact_con:
    'CONSPROF SOLDISP('sol') UNSOLDISP('unsol')' /* restore profile   */
    'CONSOLE DEACTIVATE'                /* then deactivate it         */
    Return 0

/*--------------------------------------------------------------------*/
/* Display QNAME selection screen                                     */
/*--------------------------------------------------------------------*/
disp_qname:
    zwinttl='Qname';"VPUT (ZWINTTL)"

    tablemq='$V'Time('s');Call get_qnames

ini_Q:
    Call Setup_da1
    Parse VAR iqn iqn '*' .
    If iqn='' Then iqn='* (All)'
    sp=Index(da1,iqn)
    If sp>0 Then Do
        sp=sp-1
        ch1=Substr(da1,sp,1)
        ch1=Bitor(o2,ch1)
        da1=Overlay(ch1,da1,sp,1)
        ch1=Substr(da1,sp-3,1)
        ch1=Bitor(o1,ch1)
        da1=Overlay(ch1,da1,sp-3,1)
    End
    zedlmsg="Please select 'Qname' from the above list either by",
            "number or cursor placement."
    zcmd=
    "SETMSG MSG(ISRZ001)";"ADDPOP ROW(1) COLUMN(6)"
    "DISPLAY PANEL(ENQINFPQ)"
    rc1=rc
    "REMPOP"
    If rc1/=0 Then Do
        Parse VAR iqn iqn .
        If iqn='' Then iqn='*'
        "TBEND &TABLEMQ"
        Return 0
    End
    If Index(da1,altered)>0 Then Do
        Call Rname_Color;Signal ini_Q_ret
    End
    If zcmd/='' Then Do
        If Datatype(zcmd)='NUM' Then sp=(zcmd-1)*da1_el+5
        Else sp=Index(da1,Strip(zcmd))
        iqn=Strip(Substr(da1,sp,8))
    End
    Else Do
        If csr2/='DA1' Then iqn='*'
        Else iqn=Strip(Substr(da1,csp2-((csp2 // da1_el)-5),8))
    End
ini_Q_ret:
    Parse VAR iqn iqn .;If iqn='' Then iqn='*';Signal ini_Q

/*--------------------------------------------------------------------*/
/* Get all major Q names and pass them back in a table.               */
/* The same program is used to build the ISPF table. Variable         */
/* 'TABLEMQ' must not be NULLS.                                       */
/*--------------------------------------------------------------------*/
get_qnames: Procedure Expose pgm tablemq
    If rid='R' Then irn=resource
    @keep=keep
    Parse Value '* * * * * * * * Y' With isn isc is1 is2 iqn ijn irn irt keep
    "VPUT (TABLEMQ ISN IJN ISC IS1 IS2 IQN IRN IRT KEEP) SHARED"
    "SELECT PGM(&PGM)"
    keep=@keep
    "TBSORT &TABLEMQ FIELDS(QNAME,C,A)"
    Return 0

/*--------------------------ooo000OOOO000ooo--------------------------*/
/*                                                                    */
/* Contention reporting part of ENQINFO routine.                      */
/*                                                                    */
/*--------------------------------------------------------------------*/
S1_Grsc: Procedure Expose pgm dispnl enqtype1 helpanel tsocall enqcol1
    zerrhm='*';zerralrm='NO';zedsmsg=;screen2=0

    If tsocall=0 Then Do
        zedlmsg='The following contentions were found.'
        "SETMSG MSG(ISRZ001)"
    End

s1_redo:
    Parse Value '* * * WAIT * * * * Y' With isn isc is1 is2 iqn ijn irn irt keep
    tablenm='$W'Time('s');tablenm#='#W'Time('s');tablenm2='@W'Time('s')
    "VPUT (TABLENM TABLEMQ DISPNL ISN IJN ISC IS1 IS2 IQN IRN IRT KEEP",
        "SORTF XCMD ENQTYPE1 TSOCALL) SHARED"
    "SELECT PGM(&PGM)"
    "TBCREATE &TABLENM# KEYS(SYSNAME JOBNAME SCOPE STAT1",
           "STAT2 QNAME RNAMEX) NAMES(RNAME) NOWRITE"
    Do Forever
        "TBSKIP &TABLENM";If rc/=0 Then Leave
        If Index(rname,'(')>0 Then Iterate
        rnamex=rname
        "TBMOD &TABLENM#"
        irn=Strip(Word(rname,1))'*'
        iqn=Substr(Strip(Word(qname,1))'*',1,8)
        Call s1_sub_table

    End

    "ISPEXEC TBTOP &TABLENM#"
    "ISPEXEC TBQUERY &TABLENM# ROWNUM(rownum) POSITION(tabptr)"
    rownum=rownum+0
    sortf='RNAME,C,A,STAT2,C,A'
    csr1='ZCMD'

s1_sort_tab#:
    "TBSORT  &TABLENM# FIELDS(&SORTF)"

    If tsocall/=0 Then Do
        x=output_details(tablenm#,'SAY')
        Return tsocall
    End

    tablegm=tablenm#
    grsc='ON'
    If first_time/='N' Then Call init_vars_etc
    Call build_field
    csr2='ZCMD'

s1_scr2:
    dispstat=owhite'Row' tabptr+1 'of' rownum
    mainhead=oyellow || 'CONFLICT Information',
             Copies('-',70)
    headline=Substr(mainhead,1,79-Length(dispstat)) || dispstat

    Parse Value '* * * *  ' With is2 iqn irn irt zcmd
    "DISPLAY PANEL(&DISPNL) CURSOR(&CSR2)"
    If rc>4 Then Do
        "TBEND &TABLENM#";"TBEND &TABLENM";Drop grsc
        Return 8
    End

    Parse VAR zcmd cmd parm1 parm2 parm3
    Parse VAR parm1 p11 +1 .
    If Wordpos(cmd,'TRACE DEBUG')>0 Then Do
        If parm1='OFF' Then trace='N'
        Else Do;If trace='Y' Then trace='N';Else trace='Y';End
        If trace='Y' Then Trace r;Else Trace Off
        Signal s1_scr2
    End

/*--------------------------------------------------------------------*/
/* Test for scrolling                                                 */
/*--------------------------------------------------------------------*/
    "ISPEXEC VGET (zscrolla zscrolln zverb)"
    If Wordpos(zverb,'UP DOWN')>0 Then Do
        Call scroll_data_ud;Call bld2
        Signal scr2
    End
    If Wordpos(zverb,'LEFT RIGHT')>0 Then Do
        If scroll_data_lr()=0 Then Call bld2
        Signal scr2
    End

/*--------------------------------------------------------------------*/
/* Test for sorting                                                   */
/*--------------------------------------------------------------------*/
    If cmd='SORT' | Substr(cmd,1,2)='/S' Then Do
        Select
            When (p11='O') Then sortf='STAT2'
            When (p11='W') Then sortf='STAT2,C,D'
            When (p11='R') Then sortf='RNAME'
            When (p11='Q') Then sortf='QNAME'
            When (p11='J') Then sortf='JOBNAME'
            When (p11='S') Then sortf='SYSNAME'
            Otherwise NOP
        End
        Signal s1_sort_tab#
    End
    If Substr(zcmd,1,1)='/' Then Do
        Parse VAR zcmd parm1 .
        Call test_alias
        If result=0 Then irn=parm1'*'
        Signal exi2
    End

    x_c = Test_selection()
    Signal s1_redo

/*--------------------------------------------------------------------*/
/* Create a new table in the sub-routine                              */
/*--------------------------------------------------------------------*/
s1_sub_table:
    Parse Value '* * * OWN *' With isn isc is1 is2 ijn

    tablenm1=tablenm;tablenm=tablenm2
    "VPUT (TABLENM ISN IJN ISC IS1 IS2 IQN IRN IRT KEEP) SHARED"
    "SELECT PGM(&PGM)"
    "TBTOP &TABLENM"
    Do Forever
        "TBSKIP &TABLENM";If rc/=0 Then Leave
        If rname'*'/=irn Then Iterate
        "TBMOD &TABLENM#"
    End
    "TBEND &TABLENM"
    tablenm=tablenm1
    Return 0

/*--------------------------------------------------------------------*/
/* 'SAY' details to permit entrapment using the "outtrap" command.    */
/* or 'QUE' details for output to a dataset.                          */
/*--------------------------------------------------------------------*/
output_details:
    ARG #tabl,#type
    ln1=Substr('Sys',1,4)       ,
        Substr('Jobname',1,8)   ,
        Substr('Scope',1,6)     ,
        Substr('Status',1,9)    ,
        Substr('Qname',1,8)     ,
        Substr('Rname',1,37) 'R'
    ls1=Copies('-',4) ,
        Copies('-',8) ,
        Copies('-',6) ,
        Copies('-',9) ,
        Copies('-',8) ,
        Copies('-',37) '-'
    If enqmaskj='' Then xxx=ijn;Else xxx=enqmaskr
    If enqmaskr='' Then yyy=irn;Else yyy=enqmaskr
    ln2=Substr(isn,1,4)         ,
        Substr(xxx,1,8)         ,
        Substr(isc,1,6)         ,
        Substr(is1,1,4)         ,
        Substr(is2,1,4)         ,
        Substr(iqn,1,8)         ,
        Substr(yyy,1,37)        ,
               irt

    If #type='SAY' Then Do
/*      Address TSO "CLEAR"                                           */
        Say Substr(ln1,1,79)
        Say ls1
        Say Substr(ln2,1,79)
        Say ls1
    End
    Else Do
        Queue Substr(ln1,1,79)
        Queue ls1
        Queue Substr(ln2,1,79)
        Queue ls1
    End
    "TBTOP &#TABL"
    If enqmaskj/='' Then maskj=De_Mask(enqmaskj)
    If enqmaskr/='' Then maskr=De_Mask(enqmaskr)
    Do Forever
        "TBSKIP &#TABL";If rc/=0 Then Leave
        If enqmaskj/='' Then,
            If $wild_match(jobname,maskj)/='OK' Then Iterate
        If enqmaskr/='' Then,
            If $wild_match(rname,maskr)/='OK' Then Iterate
        lnx=Substr(sysname,1,4),
            Substr(jobname ,1,8),
            Substr(scope ,1,6),
            Substr(stat1 ,1,4),
            Substr(stat2 ,1,4),
            Substr(qname ,1,8),
            Substr(rname ,1,37),
                   qtype
        If #type='SAY' Then Say Substr(lnx,1,79)
        Else Queue Substr(lnx,1,79)
    End
    If #type='SAY' Then Say Centre(' End of Data ',79,'*')
    Else Do
        Queue Centre(' End of Data ',79,'*');Queue ''
    End

    Return 0

/*--------------------------------------------------------------------*/
/* Initialise variables                                               */
/*--------------------------------------------------------------------*/
init_vars_etc:
    first_time='N'
    Numeric digits(15)
    Call constant_vars;Call variable_vars
    Return 0

/*--------------------------------------------------------------------*/
/* To following are constant variables and should not change.         */
/*--------------------------------------------------------------------*/
constant_vars:
    ztdmark = Centre(' Rsend ',80,'*')
    #colors = 7                             /* Number of colors       */

    reverse = X2C('10')                     /* Reverse mask           */
    uscore  = X2C('20')                     /* Underscore mask        */
    blink   = X2C('30')                     /* Blink Mask. Note - this*/
                                            /* may not work on some   */
                                            /* terminals...           */

    ired    = X2C('01')                     /* Input RED etc...       */
    iblue   = X2C('02')
    iyellow = X2C('03')
    igreen  = X2C('04')
    iturq   = X2C('05')
    ipink   = X2C('06')
    iwhite  = X2C('07')

    ored    = D2C(#colors+C2D(ired))        /* Output RED etc...      */
    oblue   = D2C(#colors+C2D(iblue))
    oyellow = D2C(#colors+C2D(iyellow))
    ogreen  = D2C(#colors+C2D(igreen))
    oturq   = D2C(#colors+C2D(iturq))
    opink   = D2C(#colors+C2D(ipink))
    owhite  = D2C(#colors+C2D(iwhite))
    oyellow = D2C(#colors+C2D(iyellow))

    oyellowu= Bitor(oyellow,uscore)

    altered = x2c('AA')                     /* Altered field indicator*/

    sortc   = '/SORT'                       /* Sort command           */
    csr     = ''                            /* Cursor field           */
    csrp    = ''                            /* Cursor position        */
    ll      = 79                            /* Line length (ex attrib)*/
    qual    = 1
    scrolln = 0

    "VGET (zscrmaxd)"                       /* Max screen size        */

    Return 0

/*--------------------------------------------------------------------*/
/* To following are variables dependant on the application.           */
/*--------------------------------------------------------------------*/
variable_vars:
    mainhead = oyellow ||,
               "ENQ Information",
               Copies('-',70)

    a1='07'x                                /* Number color (in)   -W */
    q1='01'x                                /* Qname color  (out)  -R */
    q2='02'x                                /* Qname color  (out)  -B */
    q3='03'x                                /* Qname color  (out)  -Y */
    q4='04'x                                /* Qname color  (out)  -G */
    q5='05'x                                /* Qname color  (out)  -T */
    q6='06'x                                /* Qname color  (out)  -P */
    q7='07'x                                /* Qname color  (out)  -W */
    o1='10'x                                /* Active Qname color  -Y */
    o2='10'x                                /* Active Number color -Y */

    qname='SPFEDIT'
    c.qname=q1                              /* Preset colors -R       */
    qname='SYSDSN'
    c.qname=q4                              /* Preset colors -R       */
    qname='SYSVSAM'
    c.qname=q7                              /* Preset colors -R       */

    Return 0

/*--------------------------------------------------------------------*/
/* Display QNAME selection screen                                     */
/*--------------------------------------------------------------------*/
Setup_da1:
    da1=a1 || ' 1' || q6 || Substr('* (All)',1,9)
    da1_el=Length(da1)
    Do i=2 To 99999
        "TBSKIP &TABLEMQ";If rc/=0 Then Leave
        If 'C.'qname=c.qname Then x=Color_me(qname)
        da1=da1 || a1 || Right(i,2) || c.qname || Substr(qname,1,9)
    End
    Return 0

/*--------------------------------------------------------------------*/
/* Color major q name                                                 */
/*--------------------------------------------------------------------*/
color_me:
    Arg qname
    Select
        When (Substr(qname,1,4)='SYSZ') Then c.qname=q5
        When (Substr(qname,1,3)='SYS')  Then c.qname=q3
        Otherwise c.qname = q6
    End
    Return 0

/*--------------------------------------------------------------------*/
/* Rebuild screen                                                     */
/*--------------------------------------------------------------------*/
bld2:
    Call build_field
    Return 0

/*--------------------------------------------------------------------*/
/* This section builds the display field 'DA1' from the table from    */
/* the NEXT row to that poinetd to by variable TABPTR. This allows    */
/* for TBTOP (which is row 0).                                        */
/*--------------------------------------------------------------------*/
build_field:
    Call scroll_table
    Trace Off

    da2=
    Do zscrmaxd
        "ISPEXEC TBSKIP &TABLEGM"
        If rc/=0 Then Do
            da2=da2 || Substr(oyellowu||ztdmark,1,80)||oturq
            Leave
        End

        If stat1='Excl' Then hl1=ored;Else hl1=owhite
        If stat2='Own'  Then hl2=owhite;Else hl2=ored

        If qtype='R'    Then hl5=ored
        Else If qtype='C' Then hl5=oyellow;Else hl5=owhite

        If 'C.'qname=c.qname Then x=Color_me(qname)
        hl4=c.qname;hl3=d2c(c2d(hl4)+7)

        rname=translate(rname,chex,ohex)
        If screen2 Then,
            dax=oturq   || Substr(sysname,1,4) Substr(jobname,1,8),
                hl3     || Substr(qname,1,8)  ||,
                hl4     || rname
/*              hl4     || Substr(rname,1,37)                         */
        Else,
            dax=oturq   || Substr(sysname,1,4) Substr(jobname,1,8),
                           Substr(scope,1,6)  ||,
                hl1     || Substr(stat1,1,4)  ||,
                hl2     || Substr(stat2,1,4)  ||,
                hl3     || Substr(qname,1,8)  ||,
                hl4     || Substr(rname,1,37) ||,
                hl5     || qtype

        da2=da2 || Substr(dax,1,ll+1)
    End

    If trace='Y' Then Trace r
    Return 0

/*--------------------------------------------------------------------*/
/* This section re-positions the table to the appropriate row         */
/* according to the scroll parameters returned from ISPF.             */
/*--------------------------------------------------------------------*/
scroll_table:
    If tabptr+(qual*scrolln)>rownum Then tabptr=rownum
    Else tabptr=tabptr+(qual*scrolln)
    If tabptr<0 Then tabptr=0
    "ISPEXEC TBTOP &TABLEGM"
    "ISPEXEC TBSKIP &TABLEGM NUMBER(&TABPTR) POSITION(TABPTR)"
    Return 0

/*--------------------------------------------------------------------*/
/* Scroll the screen to selected line after an UP/DOWN command.       */
/*--------------------------------------------------------------------*/
scroll_data_ud:
    If zscrolla='MAX' Then Do
        If zverb='UP' Then tabptr=0;Else tabptr=rownum-(zscrolln-1)
        scrolln=0
    End;Else scrolln=zscrolln
    If zverb='UP' Then qual=-1;Else qual=+1
    Return 0

scroll_data_lr:
    scrolln=0
    If zverb='RIGHT' Then Do;dispnl='ENQINFP2';screen2=1;End
    Else Do;dispnl='ENQINFPY';screen2=0;End
    "ISPEXEC TBTOP &TABLEGM"
    "ISPEXEC TBSKIP &TABLEGM NUMBER(&TABPTR) POSITION(TABPTR)"
    Return 0

/*--------------------------------------------------------------------*/
/* This is the logic for processing selections. It also caters for    */
/* eXclusion of lines from the table.                                 */
/*--------------------------------------------------------------------*/
Test_selection:
    changed = Index(da2,altered)
    If changed = 0 Then Return 8
    Do While changed > 0
        scrolln  = 0
       lin# = ((changed % 80) +1) +tabptr
        "ISPEXEC TBTOP &TABLEGM"
        "ISPEXEC TBSKIP &TABLEGM NUMBER("lin#")"
/*      rname = Substr(da2,changed+1,2)                               */
        Parse Value Substr(da2,changed+1,5) With,
              rname +2 1 cmd1 +1 1 cmd3 +3
        If rname='/EX' Then Do
            da2 = Substr(da2,1,changed-1) ||,
                  Substr(da2,changed+(ll+1))
            "ISPEXEC TBDELETE &TABLEGM"
            "ISPEXEC TBSKIP &TABLEGM NUMBER(-1) POSITION(TABPTR)"
            rownum = rownum - 1
        End
        Else Do
            x=Process_selection()
            If x/=0 Then Do;changed=x;Leave;End
            changed=changed+1
        End
        changed=Index(da2,altered,changed)
    End
    Call bld2

    Return changed

/*--------------------------------------------------------------------*/
/* See if there is a selection and then process it                    */
/*--------------------------------------------------------------------*/
Process_selection:
    rname=Translate(rname);cmd=rname
    If cmd1='=' Then Do
        If p_cmd='P_CMD' Then Do
            zedlmsg='You must issue a command first to use the "=" command.'
            "ISPEXEC SETMSG MSG(ISRZ001)"
            Return 4
        End
        cmd=p_cmd
    End
    Else p_cmd=cmd
/*  cmd3=Translate(Substr(da2,changed+1,3))                           */
    action=
    Select
        When (cmd = '/V') Then action='VIEW'
        When (cmd = '/E') Then action='EDIT'
        When (cmd = '/B') Then action='BROWSE'
        When (Wordpos(Translate(cmd3),'/DL /DS /34')>0) Then Do
            "TBGET &TABLEGM"
            alk32enq='Y';alk32dsn=Strip(rname,,"'");alk32vol=
            "ISPEXEC VPUT (ALK32DSN ALK32ENQ ALK32VOL) SHARED"
            "ISPEXEC SELECT PGM(ISRUDL) PARM(ISRUDLP)"
            alk32dsn=;alk32enq=;alk32vol=
            "ISPEXEC VPUT (ALK32DSN ALK32ENQ ALK32VOL) SHARED"
            Signal exi2
        End
        When (cmd = '/S') Then Do
            isn = sysname
            sortf  = 'SYSNAME,C,A,JOBNAME,C,A,RNAME'
            Signal exi2
        End
        When (Substr(cmd,1,2) = '/W') Then Do
            name  = ''
            "CONTROL ERRORS RETURN"
            Signal On Syntax Name errsyntax
            retsyn = 'ret_syntax_1'

            jnl = Length(jobname)
            len = Substr(rname,3,1)
            If Datatype(len) = 'NUM' & len > 0 & len < 9 Then jnl = len
            uid = Substr(jobname,1,jnl)
            xx = Whois(uid,'/R')
            If Word(xx,1) = 4 Then Parse VAR xx . zedlmsg
            Else zedlmsg = 'You have just identified ->' xx

ret_syntax_1:
            "ISPEXEC SETMSG MSG(ISRZ001)"
            Return 4
        End
        When (cmd = '/J') Then Do
            ijn = Substr(jobname'*',1,8)
            irn = '*'
            sortf  = 'RNAME'
            Signal exi2
        End
        When (cmd = '/R') Then Do
            ijn = '*'
            "TBGET &TABLEGM"
            irn = rname'*'
            sortf  = 'JOBNAME'
            Signal exi2
        End
        When (cmd = '/X') Then Do
            "TBGET &TABLEGM"
            zedlmsg = '"'rname'"',
                     "translates to X'"c2x(rname)"'"
            "SETMSG MSG(ISRZ001)"
            Return 4
        End
        When (Substr(rname,1,7) = '/CANCEL') Then Do
            Call cancel_job
            "SETMSG MSG(ISRZ001)"
            Return 4
        End
        Otherwise Do
            Signal On Syntax Name syntax_handle
            y = enqexit
            x = Enqinfx(tablegm,Substr(da2,changed+1,37))
            Signal Off Syntax
            Return x
        End
    End

    If action /= '' Then Do
        "TBGET &TABLEGM"
        x = Msg('Off')
        y = Sysdsn("'"rname"'")
        x = Msg('On')
        If y /= 'OK' Then sysdsorg = 'ER'
        Else y = Listdsi("'"rname"'")
        Select
            When (sysdsorg = 'VS') Then Do
                If action = 'VIEW' | action = 'EDIT' Then Do
                    zedlmsg = 'Browse subtituted for VSAM dataset.'
                    "SETMSG MSG(ISRZ001)"
                End
                If bvsampgm = '' Then Do
                    zedlmsg = 'VSAM Browse is not enabled.'
                    "SETMSG MSG(ISRZ001)"
                    Return 0
                End
                ddvsam   = 'DD'time
                dsvsam   = rname
                Address TSO "ALLOC DD("ddvsam") DA('"rname"') SHR REU"
                "VPUT (DSVSAM DDVSAM) SHARED"
/*              "SELECT PGM(EXTBVSAM)"                                */
                "SELECT PGM(&BVSAMPGM)"
                rc1 = rc
                Address TSO "FREE DD("ddvsam")"
                If rc1 = 20 Then Do
                    zedlmsg = "Sorry, VSAM browsing facility is not",
                             "available to you."
                    "SETMSG MSG(ISRZ001)"
                End
            End
            When (sysdsorg = 'ER') Then Do
                zedlmsg = y
                "SETMSG MSG(ISRZ001)"
            End
            Otherwise Do
                "CONTROL ERRORS RETURN"
                Call ON ERROR NAME errbr1
                "&ACTION DATASET('&RNAME')"
                Call OFF ERROR
                "CONTROL ERRORS" cactn
                If rc1 > 4 Then Do
                    If is1 = 'Excl' Then Do
                        zedlmsg = "Cannot '"action"' Exclusively",
                                 "allocated dataset."
                        "SETMSG MSG(ISRZ001)"
                    End
                    Else "SETMSG MSG(&ZERRMSG)"
                End
            End
        End
    End
    Return 0

/*--------------------------------------------------------------------*/
/* Error detection handler                                            */
/*--------------------------------------------------------------------*/
syntax_handle:Signal Off syntax
    y='ENQINFX'
    zedlmsg="Routine '"y"' is not available to you. Please contact",
            "your dialogue administrator."
    "SETMSG MSG(ISRZ001)"
    Return 4

errsyntax:Signal Off Syntax;Interpret Signal retsyn

/*--------------------------------------------------------------------*/
/* Browse error capture                                               */
/*--------------------------------------------------------------------*/
errbr1:
    rc1=rc
    Return

    Call ON ERROR NAME errbr1
    Call OFF ERROR
/*--------------------------------------------------------------------*/
/* Change colour.                                                     */
/*--------------------------------------------------------------------*/
Rname_Color:
    changed=1
    changed=Index(da1,altered,changed) +1
    Do While changed>1
       xx=Strip(Substr(da1,changed+3,8))
       co=Substr(da1,changed,1)
       Select
           When (co = 'R') Then cc = q1
           When (co = 'B') Then cc = q2
           When (co = 'Y') Then cc = q3
           When (co = 'G') Then cc = q4
           When (co = 'T') Then cc = q5
           When (co = 'P') Then cc = q6
           Otherwise            cc = q7
       End
       c.xx = cc
       changed = Index(da1,altered,changed) +1
    End
    Call bld2

    Return changed

/*--------------------------------------------------------------------*/
/* Help instructions.                                                 */
/*--------------------------------------------------------------------*/
help:
    If parm1 = '??' | Sysvar(SYSISPF) /= 'ACTIVE' Then,
        Signal help_process

    Address TSO "%BR" xcmd "??"
    Return 0

help_process:
    n_st=mark(2)                            /* Mark Start             */
/*
  Good &TOD. &CNAME..

  &XCMD. [V&ENQINFO_VER.].

  This driver will invoke program ENQINFOL that will build an ISPF table
  or display using PUTLINE statements, from the parameter(s) passed.

  Parameters (positional):
    1. The requested ENQ resource parameter.
       If it is not wildcarded (trailing *), one will be inserted for
       you free of charge, unless a /ASIS keyword parameter is used.  By
       default, your userid followed by an '*' will be inserted in the
       event you transgress and omit a parameter (a /J will also be
       appended whether you like it or not).

       This parameter may have one of the following keywords:

         CONFLICT- which will display all the contentions on the system
                   if they exist.
         GRSC    - same as CONFLICT.
         RESERVE - which will naturaly display all the reserves.  During
                   normal use of this facility, overtype the Resource
                   name with RESERVE (no trailing *) to display
                   reserves.

  The following keyword parameters are permitted:
    /ASIS    - take the resource ASIS and do NOT append an '*' if
               missing.
    /J       - resource is a jobname or started task.
    /J(jname)- combine "jname" with the resource (if supplied)
    /Q(qname)- combine the a jobname or started task.
    /R       - resource is a Resource (default).
    /R(rname)- combine "rname" with the resource (if supplied)
    /S       - resource is a SYSID.
    /S(sysid)- combine "sysid" with the resource (if supplied)
    /TSO     - used to bypass ISPF table processing and display data
               through 'PUTLINE' statements permitting capture using the
               OUTTRAP command. This is the default in a Non-ISPF
               environment.  Note the actual data is after the headings
               and start on line 5.

  Once the screen is displayed, you may change any of the masks to hone
  into your favourite ENQ combination.

  If there are long resource names enqueued, you can get a full display
  of the resource by using your RIGHT scroll PF key. The extra display
  will be at the expense of the "Scope  Status" columns. You can restore
  the original diplay layout by using your LEFT scroll PF key.  If the
  resource is stiil too large to fit onto the screen, use the '/X'
  (display resource in HEX) overlay to get a full expansion of that
  resource in a message.

  Commands:
    CONFLICT  - List all the contentions on the system.
    DEBUG     - Turn trace on for debugging.
                blank - Toggle trace.
                OFF   - Turn trace off.
                ON    - Turn trace on.
    GRSC      - Same as "CONFLICT".
    PRNT      - Prints the table into an exportable edit session.
    RESERVE   - Display all the reserves.
    SORT      - Sort table. Sort parameters are:
                S - SYSNAME
                J - JOBNAME
                O - STATUS/2 (Owner)
                W - STSUSS/2 (Waiting)
                Q - QNAME
                R - RNAME
    TRACE     - Same as "DEBUG".
    ?x /ALIAS - ?x is an alias that has been setup in the program.
                Eg. ?ME /ALIAS would return your userid.
    /P        - Alias to "PRNT".
    /S        - Alias to "SORT".
    ?         - Help tutorial.

  The main program can be invoked directly. On entry, the parameter will
  default to your 'userid*' &UID.* and control stays within the program.
  Alternatively it may be invoked by a dialog passing it additional
  parameters using ISPF VPUTs.

  This routine invokes the program passing it certain parameters and is
  re-entered by the program to perform the routine's own processing.
  Control is directed by this EXEC.
  This routine will permit you to enter the following overtypes in the
  resource display field to generate the indicated action:
     /B  - Browse dataset (minor, if valid dataset name).
     /DL | /DS | /34
         - DataSet List (ISPF option 3.4)
     /E  - Edit dataset (converted to browse for valid VSAM datasets).
     /V  - View dataset (converted to browse for valid VSAM datasets).
     /W  - Who is user. Issues 'BR XRACF LU jobname' with jobname
           truncated to default jobname length.
     /J  - Display all resources for the Jobname.
     /X  - Display resource in HEX.
     /R  - Display all using this resource.
     /S  - Display all Systems using this resource.
     =   - Repeat last "action" against this resource.  (Must have
           issued a command previously.)
  You may sort the display by entering 'SORT' or '/S' on the command
  line followed by one of the following sub-parameters:
     J   - Jobname.
     R   - Resource.
     S   - Systemid.

  You may invoke the program and get it to pass the table back to your
  dialog. However, you must control table disposition thereafter not
  forgeting to CLOSE the table.

  The following are the parameters that may be set and VPUT to program
  ENQINFOL:
    KEEP    - Whether to return table to dialog.
              'Y' indicates return table and exit program.
              'R' indicates to invoke routine 'XCMD' from within the
                  program and keep control in the program. (This option
                  is more efficient as program initialisation is only
                  done once.)
    XCMD    - Name of the routine to execute if KEEP=R. Default is
              'ENQINFO'.
    TABLEMQ - Table name for Major Resource name build to display Qname
              selection screen.
    TABLENM - Table name. Default is JJ$TXXXX which will not be unique
              if commands are stacked. Default is '' (not used).
    DISPNL  - Display panel name. You may tailor your own display
              screen. Default is 'ENQINFP'.
    ISN     o System wildcard parameter
    IJN     o Jobname wildcard parameter (can use both % and * wildcard
              characters in 'any' combination)
    ISC     o Scope wildcard parameter
    IS1     o Status #1 wildcard parameter (disposition)
    IS2     o Status #2 wildcard parameter
    IQN     o Queue wildcard parameter - major
    IRN     o Resource wildcard parameter - minor (can use both % and *
              wildcard characters in 'any' combination)
    IRT     o Reserve type
  Unless defaulting, all parameters marked with 'o' should be
  initialised to '*' or 'value*'.

  The following are the variables contained in the table:
    SYSNAME - System id
    JOBNAME - Jobname
    SCOPE   - Scope (GLOBAL or LOCAL)
    STAT1   - Disposition (Shr or Excl)
    STAT2   - Status (OWNer or WAITing)
    QNAME   - Queue name (Major resource)
    RNAME   - Resouce name (Minor resource)
    QTYPE   - Reserve type:
              C - RESERVE converted to ENQ
              N - Normal ENQ
              R - RESERVE (not converted)

  Commands:
    SORT | /S
       Parameters:
         R - Resource name
         J - Job name
         S - System name
    ?alias
       Shows ENQs against preset aliases:
         ?ME    - TPSCP.&ZUSER
         ?PTS   - SMPE.MVS.GLOBAL.SMPPTS
         ?SMPE  - SMPE.MVS.GLOBAL.CSI
         ?TEDS  - SYS2.TEDS.ISPTLIB
    PRNT - Print to a temporary dataset and present under VIEW.
  Resource overtype:
    /B  - Browse dataset
    /CANCELJ
        - Cancel job (need appropriate authority).
    /CANCELU
        - Cancel user (need appropriate authority).
    /E  - Edit dataset
    /J  - Show all ENQs for jobname holding this resource enq.
    /R  - Show all ENQs for resource holding this resource enq.
    /S  - Show all ENQs for system holding this resource enq.
    /V  - View dataset
    /W  - Who is holding this enq. Issues and traps LU command.
    xd  - Exit data. Covered later on under user exit.

 Additional features:
  GRSC
     Enter GRSC on the command line or overtype the Rname field to
     display all the GRS contentions (if any). End PF key will return
     you to the previous display.
  RESERVE
     Enter RESERVE on the command line or overtypr the Rname field to
     display all the reserves.

 The values under column R are as follows:
     C - Converted Reserve. RESERVE converted to an ENQ.
     N - Resource is an ENQ (ie. Not a Reserve)
     R - RESERVE request.

 If you place the cursor on the Qname literal on the sub-headline you
 will be presented with a list of all the Major Queue names on the
 system.
 These major names are colour co-ordinated to differentiate in large
 displays.  The current setting is in reverse video. To select a new
 major resource, either enter it's associated number on the command line
 or place the cursor on the name and hit [ENTER]. The new resource will
 be highlighted and placed in the wildcard line upon ending of the
 display.

 User exits can be coded in a member called ENQINFX . A sample exit
 should be included in this routine's package which will invoke
 Multi-Procs by default (if available).
 Any overtype in the Rname field, that is not covered in this tutorial,
 will be passed to the user exit as the second parameter to the table
 name.

 The sample exit first issues a TBGET to get the appropriate original
 values. It then parses the overtype substituting the quoted original
 value for each / encountered.
 It then passes the function onto multi-procs (which may not be
 available to you).

*/
    n_en=mark(-2)                           /* Mark End               */

    Parse Value Time() With hh ':' 1 time +5
    Select
        When hh<12 Then tod='morning'
        When hh<18 Then tod='afternoon'
        Otherwise tod='evening'
    End
    chgchar='&';cname='there'
    Signal on Syntax Name error_off_1
    Parse Value $Whoami() With cname sname  /* Toggle as per format   */
error_off_1: Signal Off Syntax
    x=nl_h('*'Centre('ooo000OOOO000ooo',77,'-')'*')
    Do i=n_st To n_en
        line=Sourceline(i)
        Do While Index(line,chgchar)>0
            Interpret "Parse VAR line p1 '"chgchar"' var '.' p2"
            If Index(var,'(')>0 Then Do
                Parse VAR var var '(' vl ')'
                If ¬Datatype(vl,'W') Then vl=Length(var)
                Interpret 'line=p1||Substr('var',1,vl)||p2'
            End
            Else Interpret 'line=p1||'var'||p2'
        End
        x=nl_h('*'Substr(line,1,77)'*')
    End
    x=nl_h('*'Copies('-',77)'*')
    Exit

nl_h:Parse Arg n#
    If ima_macro Then "LINE_BEFORE .ZFIRST=NOTELINE (n#)";Else Say n#
    Return 0
Mark:Arg diff;If \Datatype(diff,'W') Then diff=1;Return sigl+diff
Dont_help_me:    /* Move this to the appropriate place */

/*--------------------------ooo00 REXX 00ooo--------------------------*/
/*  $WILD:                                                            */
/*                                                                    */
/*  Function to check each word in a list against a mask. The list    */
/*  can be:                                                           */
/*    - List of datasets                                              */
/*    - List of mebers                                                */
/*    - String of text/code etc.                                      */
/*                                                                    */
/*  Parameters:                                                       */
/*  1. mask   - Dataset mask wildcarded by interspacings of '*' for   */
/*              any string mask or '%' for any single character mask. */
/*              Note: Mask is not validated but parsed into matching  */
/*                    components based on the locations of '%' and    */
/*                    '*'.                                            */
/*  2. list   - List of dataset names. Should be unquoted and space   */
/*              seperated, however, any quotes (no                    */
/*              prefix added) and comma seperators will be removed.   */
/*              If no list is provided 'NO-DATA' is returned.         */
/*              The returnde data will be en entry for each dataset   */
/*              with one of the following values:                     */
/*                NO-MATCH                                            */
/*                OK                                                  */
/*  3. 1 | ASIS                                                       */
/*            - Numeric "1" to indicate that the list is 1 record     */
/*              containing embeded blanks (eg. text or code) rather   */
/*              than space seperated entities.                        */
/*              If using this feature you must perform upper case     */
/*              translation if required before invoking the function. */
/*                          - or -                                    */
/*            - Any (other than 1) non blank character to prevent     */
/*              upper case translation to both the mask and list.     */
/*                                                                    */
/*  Examples:                                                         */
/*                                                                    */
/*  1.Check a list of datasets against a mask:-                       */
/*      list='dataset1 dataset 2 .... datasetn'                       */
/*      mask='hlq%.ISP%LIST.*.TEMP*'                                  */
/*      match=$wild(mask,list)                                        */
/*      Do WHile match/=''                                            */
/*          Parse VAR list dsn list;Parse VAR match rcm match         */
/*          Say Left(dsn,44) rcm                                      */
/*      End                                                           */
/*                                                                    */
/*  2.Check line(s) against a tring mask:-                            */
/*      mask='*STR%NG% #%%% *'                                        */
/*      Do i=first to last                                            */
/*          "(line)=LINE" i;lineu=Tranlate(line)                      */
/*          If $wild(mask,lineu,1)='OK' Then Say 'line' i 'matched'   */
/*      End                                                           */
/*                                                                    */
/*  Gotcha(s):                                                        */
/*  1. Each time the function is called, the mask is parsed. If you   */
/*     are execution cycle constrained and your need is to check for  */
/*     many single 'texts' at a time using complex masks, copy        */
/*     "$WILD" into your routine and invoke the 'De_Mask' option once */
/*     and then the '$Wild_Match' for each dataset, eg. (assuming     */
/*     this resides snugly at to end of your REXX),                   */
/*        x=De_Mask(mask)                                             */
/*        Do While dsn_list/=''                                       */
/*            ....                                                    */
/*            rcm=$wild_match(dsn)                                    */
/*            ....                                                    */
/*        End                                                         */
/*  2. Needs acces to routine '$CSTRING'.                             */
/*  3. '*' and '**' are treated the same. A single '*' will cross     */
/*     qualifier boundaries (dots) like '**'.                         */
/*                                                                    */
/*--------------------------------------------------------------------*/
$Wild:$wild_ver='1.01'
     Parse Arg mask,dsn_list,asis
     If asis='' Then Do;mask=Translate(mask);dsn_list=Translate(dsn_list);End
     If dsn_list='' Then Do
         Parse VAR mask mask ',' dsn_list
         If dsn_list='' Then Parse VAR mask mask dsn_list
         dsn_list=Translate(dsn_list,' ',',')
     End
     x=De_Mask(mask);If dsn_list='' Then Return 'NO-DATA'
     If asis=1 Then Return $wild_match(dsn_list)
     hit_list=
     Do While dsn_list/=''
         Parse VAR dsn_list dsn dsn_list;dsn=Strip(dsn,,"'")
         hit_list=hit_list $wild_match(dsn)
     End
     Return Space(hit_list)

/*--------------------------------------------------------------------*/
/* Break the mask up into each of its 'components' for later use.     */
/*--------------------------------------------------------------------*/
De_Mask: Parse Arg mask
    pmask=$cstring(mask,'.*','*',1,'*');optr=1;j=0
    Do Forever
        nptr=Verify(pmask,'*%','M',optr);If nptr=0 Then Leave
        j=j+1
        If optr/=nptr Then,
            Interpret "Parse VAR pmask" optr "mv.j +"nptr-optr" mc.j +1 rest"
        Else Do
            Interpret "Parse VAR pmask" optr ". +"nptr-optr" mc.j +1 rest"
            mv.j=
        End
        optr=nptr+1
        If mv.j||mc.j='.*' Then j=j-1
    End
    mv.0=j
    Return pmask

$wild_match: Parse Arg line
        optr=1;match=1;prevc='%'
        If mv.0=0 Then Do
            Interpret "Parse VAR line p1 +"Length(pmask)
            If pmask/=p1 Then Return 'NO-MATCH'
            Else Return 'OK'
            Iterate
        End
        Do j=1 To mv.0
            If mv.j/='' Then Do
                ll=Length(mv.j)
                If prevc='%' Then Do
                    Interpret "Parse VAR line" optr "p1 +"ll
                    If mv.j/=p1 Then Do;match=0;Leave;End
                    optr=optr+ll
                End
                Else Do
                    nptr=Index(line,mv.j,optr)
                    If nptr=0 Then Do;match=0;Leave;End
                    optr=nptr+ll
                End
            End
            prevc=mc.j;If prevc='%' Then optr=optr+1
        End
        If \match Then Return 'NO-MATCH'
        If rest/='' Then Do
            If prevc='%' Then Do
                Interpret "Parse VAR line" optr "p1 +"ll
                If rest/=p1 Then Return 'NO-MATCH'
            End
            Else Do
                nptr=Index(line,rest,optr)
                If nptr=0 Then Return 'NO-MATCH'
            End
        End
        Return 'OK'

