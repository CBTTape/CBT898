/******************************** REXX ********************************/
/**********************************************************************/
/* TRACE r                                                            */
/*--------------------------ooo000OOOO000ooo--------------------------*/
/*                                                                    */
/*   Program Name   : SYS                                             */
/*   Language       : REXX                                            */
/*   Assoc Panels   : GETSINFP, GETSINF1, GETSINF2, GETSINF3          */
/*   Assoc EXECs    : TDGETSIN, TDGETINF, $DATEMAN, BR, DS            */
/*   Objective      : Collect information about the system from       */
/*                    various MVS Control blocks...                   */
/*                                                                    */
/*                    For further details, invoke with a parameter of */
/*                    '?' for help details (or refer to bottom of     */
/*                    routine).                                       */
/*                                                                    */
/*--------------------------------------------------------------------*/
    ARG parm1,parm2,parm3,parm4

ini1:
    cactn = "RETURN"
/*  cactn = "CANCEL"                                                  */
    "ISPEXEC CONTROL ERRORS" cactn

    site     = 'ASYSTS'                     /* Change for site        */
    zwinttl  = site 'System Info'

    tedsexec = "SYS2.TEDS.EXEC"
    loadparm = "SYS1.PARMLIB"
    loadalt  = "SYS2.PARMLIB"
    telstra  = 'N'
    can_console = 'Y'

    If parm1 = 'DATA'  Then Do
        dataonly = 'Y'
        Signal data_only
    End
    If parm1 = '?' | parm1 = '/?' | parm1 = '??' Then Signal help

    zerrhm   = '*'
    zerralrm = 'NO'
    zerrsm   = ''

    panel    = "GETSINFP"
    cvt      = c2x(storage(10,4))
    smca     = c2x(storage(d2x(x2d(cvt) + x2d(c5) ),3))
    @sysid   = Strip(storage(d2x(x2d(c2x(storage(10,4))) + x2d(154)),8))
    env      = Sysvar(Sysenv)

    zresvol  = 'N/A'
/*  zresvol  = ''                                                     */
    zmntlvl  = 'Unavail.'
    zsiteid  = 'Unavail.'

scr1:
/*--------------------------------------------------------------------*/
/* Test if invoked to get parameters. If 'Y' then exit with parms in  */
/* ISPF shared pool.                                                  */
/*--------------------------------------------------------------------*/

    If poped ¬= "Y" Then Do
        Address ISPEXEC
        "ISPEXEC VGET ZSCREEND"
        If zscreend = 24 Then Do
            usepop   = 'N'
            row = 1
        End
        Else Do
            usepop   = 'Y'
            row = 5
        End
        If usepop = 'Y' Then,
            "ISPEXEC ADDPOP ROW(&ROW) COLUMN(5)"
        "ISPEXEC VPUT (ZWINTTL)"
        poped = "Y"
    End

scr2:

    If parm1 = '' Then getsinfox = getsinfo_data()
    Else Do
        sysid  = Strip(parm1)
        parm1  = ''
        #sysid = sysid
        getsinfox = get_remote_data()
    End
    Call parse_buffer

scr3:
    zcmd   = ""
    #sysid = sysid

    ddf = ''
    Signal On Syntax Name syntax_bp            /* Trap Syntax errors */
    y = $Dateman('E-E',ipldte,Date('e'))
    ddf = '('y * -1')'
    ddf = Right(ddf,5)
syntax_bp:
    Signal Off Syntax

    Address ISPEXEC "CONTROL ERRORS CANCEL"
    Address ISPEXEC "DISPLAY PANEL(&PANEL) CURSOR(&CSR1)"
    If rc ¬= 0 Then Signal ext1

    Parse VAR zcmd cmd parma parmb
    If cmd = 'TRACE' Then Do
        If parma = 'OFF' Then Do
            trace = 'N'
            Trace 'Off'
        End
        Else Do
            trace = 'Y'
            Trace r
        End
        Signal scr3
    End

    If csrr = 'MCAT' Then Do
        If @sysid /= sysid Then Do
            zerrlm = "Can only interrogate current system for catalog",
                     "information."
            "ISPEXEC SETMSG MSG(ISRZ002)"
            Signal syntax_bp
        End
        Address TSO '%CATTLE'
        Signal scr3
    End

    If csrr = 'ZRESVOL' & can_console = 'Y' Then Do
        Address TSO '%PLEXI ?'
        Signal scr3
    End

    If sysid = ""     Then Signal ext1
    #zmachine = zmachine
    If sysid /= #sysid Then Drop zmachine
    If sysid = @sysid Then Signal scr2
    Else Call remote_sys
    Signal scr3

ext1:
    If poped = "Y" & usepop = 'Y' Then,
        Address ISPEXEC "REMPOP"
    Return 0


/*--------------------------------------------------------------------*/
/* Use APPC to get details for a remote system. Uses EXEC TDGETSIN.   */
/*--------------------------------------------------------------------*/
remote_sys:
    getsinfox = get_remote_data()
    If getsinfox = 8 Then Return 8
    Call parse_buffer
    Return 0

/*--------------------------------------------------------------------*/
/* Use APPC to get details for a remote system. Uses EXEC TDGETSIN.   */
/*--------------------------------------------------------------------*/
get_remote_data:
    Address TSO "ALTLIB ACTIVATE APPLICATION(EXEC) DA('"tedsexec"')"

    sys = sysid
    status = 'GetDat'

    rl  = 'rl=4000'
    rl  = ''
    debug = 'DB=0'
    cmd = "Getsinfo('DATA')"
    getsinfox = Appcstrt('TEDS'sys debug rl cmd)

    Address TSO "ALTLIB DEACTIVATE APPLICATION(EXEC)"

    If buf = 'ERROR' Then Do
        zerrlm = "Getdata '"sys"' failed."
        "ISPEXEC SETMSG MSG(ISRZ002)"
        sysid = #sysid
        Return 8
    End

    Return getsinfox

/*--------------------------------------------------------------------*/
/* Set up individual fields from the one buffer data. A valid buffer  */
/* is delimited by $$$$$$$$ at start and ¢¢¢¢¢¢¢¢ at end with fields  */
/* seperated by '~'.                                                  */
/*--------------------------------------------------------------------*/
parse_buffer:
    Parse VAR getsinfox '$$$$$$$$' getsinfox '¢¢¢¢¢¢¢¢' .

    If getsinfox = '' Then Do
        zerrlm = "No data returned."
        "ISPEXEC SETMSG MSG(ISRZ002)"
        sysid = #sysid
        zmachine = #zmachine
        Return 4
    End
    Trace Off
    syspvars = ,
           'SMPID     '||,
           'SPREL     '||,
           'MVSREL    '||,
           'PUTLVL    '||,
           'SSCTNAM   '||,
           'DFPFMID   '||,
           'DFPREL    '||,
           'CPUAL     '||,
           'CPUOL     '||,
           'ICPID     '||,
           'IPLOPT    '||,
           'IPLDTE    '||,
           'IPLTME    '||,
           'RESVOL    '||,
           'RESADDR   '||,
           'ZRESVOL   '||,
           'NUCID     '||,
           'LOAD      '||,
           'SYSP      '||,
           'SYMP      '||,
           'SYSID     '||,
           'ZMACHINE  '||,
           'ZSITEID   '||,
           'ASCBMAX   '||,
           'ASCBACT   '||,
           'NRA       '||,
           'LOGCLS    '||,
           'LOGSTAT   '||,
           'GTFSTAT   '||,
           'SIPS      '||,
           'SICS      '||,
           'SOPT      '||,
           'REALM     '||,
           'XPAND     '||,
           'CSASZ     '||,
           'ECSAS     '||,
           'SQASZ     '||,
           'ESQAS     '||,
           'PVTSZ     '||,
           'EPVTS     '||,
           'MCAT      '||,
           'IOCID     '||,
           'IODF      '||,
           'IODFVO    '||,
           'IODD      '||,
           'CPUID     '
    Do Forever
        Parse VAR syspvars v_name syspvars
        Parse VAR getsinfox v_data '~' getsinfox
        data = v_name '= Strip(v_data,'t')'
        Interpret data
        If trace = 'Y' Then Say Substr(v_name,1,8) '=' v_data
        If syspvars = '' Then Leave
    End
    If trace = 'Y' Then Trace r
    If iodfvo = 'IODFVO' Then iodfdtls =,
             "}IODF    :{Not af iodfvole......."
    Else,
        If iodfvo /= '??????' Then iodfdtls = ,
             Substr("}IODF    :{"iocid"}DSN :¢'"iodf"'}Vol :{" ||,
                    iodfvo"}Dev :{"iodd,1,60)
        Else iodfdtls = "}IODF :{'"iodf"'"
    Call cpual_msgl
    Call csasz_msgl

    Return

/*--------------------------------------------------------------------*/
/* Get sysinfo and pass it back to the caller in one buffer.          */
/*--------------------------------------------------------------------*/
data_only:
    If parm2 = '' | Strip(parm2) =,
      Strip(storage(d2x(x2d(c2x(storage(10,4)))+x2d(154)),8)) Then
        getsinfox = Getsinfo_data()
    Else Do
        sysid = parm2
        Call get_remote_data
    End

    If Index(parm3,'(') = 0 Then Return getsinfox

    Parse VAR parm3 '(' parm3 ')' .
    Call parse_buffer
    buffer = ''
    sep = parm4
    If sep = 'B' Then sep = ' '
    Else If sep = '' Then sep = '~'
    #parm3 = parm3
    Do Forever
        Parse VAR parm3 v_name ',' parm3
        data = 'buffer = buffer || sep ||' v_name
        Interpret data
        If parm3 = '' Then Leave
    End
    If Substr(buffer,1,1) = sep Then buffer = Substr(buffer,2)
    "ISPEXEC VPUT ("#parm3") SHARED"
    Return Strip(buffer)

/*--------------------------------------------------------------------*/
/* Call info gathering routine then set up and return the data in one */
/* buffer for subsequent parsing.                                     */
/*--------------------------------------------------------------------*/
getsinfo_data:
    Call info
    buffer =,
            '$$$$$$$$'     || ,
            smpid      '~' ||,
            sprel      '~' ||,
            mvsrel     '~' ||,
            putlvl     '~' ||,
            ssctnam    '~' ||,
            dfpfmid    '~' ||,
            dfprel     '~' ||,
            cpual      '~' ||,
            cpuol      '~' ||,
            icpid      '~' ||,
            iplopt     '~' ||,
            ipldte     '~' ||,
            ipltme     '~' ||,
            resvol     '~' ||,
            resaddr    '~' ||,
            zresvol    '~' ||,
            nucid      '~' ||,
            load       '~' ||,
            sysp       '~' ||,
            symp       '~' ||,
            sysid      '~' ||,
            zmachine   '~' ||,
            zsiteid    '~' ||,
            ascbmax    '~' ||,
            ascbact    '~' ||,
            nra        '~' ||,
            logcls     '~' ||,
            logstat    '~' ||,
            gtfstat    '~' ||,
            sips       '~' ||,
            sics       '~' ||,
            sopt       '~' ||,
            realm      '~' ||,
            xpand      '~' ||,
            csasz      '~' ||,
            ecsas      '~' ||,
            sqasz      '~' ||,
            esqas      '~' ||,
            pvtsz      '~' ||,
            epvts      '~' ||,
            mcat       '~' ||,
            iocid      '~' ||,
            iodf       '~' ||,
            iodfvo     '~' ||,
            iodd       '~' ||,
            cpuid      '~' ||,
            '¢¢¢¢¢¢¢¢'
    Return buffer

/*--------------------------------------------------------------------*/
/* Extract info from control blocks...                                */
/*--------------------------------------------------------------------*/
info:
    Trace Off
    numeric digits 12
    cvt        =  c2x(storage(10,4))
    pcca       =  c2x(storage(208,4))
    cvtpfx     =  x2d(cvt) - x2d(100)
    cpudata    =  c2x(storage(d2x(x2d(pcca) + x2d(04)),12))
    cpuver     =  substr(cpudata,1,2)
    cpuser     =  0 || substr(cpudata,4,5)
    cputype    =  substr(cpudata,9,4)
    sysad      =  c2x(storage(d2x(x2d(cvt)     + x2d(30) ),4))
    icpid      =     (storage(d2x(x2d(cvt)     + x2d(5e) ),2))
    cvtoptb    =  c2x(storage(d2x(x2d(cvt)     + x2d(7b) ),1))
    smca       =  c2x(storage(d2x(x2d(cvt)     + x2d(c5) ),3))
    gtfst      =  c2x(storage(d2x(x2d(cvt)     + x2d(ec) ),1))
    jesct      =  c2x(storage(d2x(x2d(cvt)     + x2d(128)),4))
    xtnt2      =  c2x(storage(d2x(x2d(cvt)     + x2d(148)),4))
    asvt       =  c2x(storage(d2x(x2d(cvt)     + x2d(22c)),4))
    gda        =  c2x(storage(d2x(x2d(cvt)     + x2d(230)),4))
    csd        =  c2x(storage(d2x(x2d(cvt)     + x2d(294)),4))
    asmvt      =  c2x(storage(d2x(x2d(cvt)     + x2d(2c0)),4))
    mserv      =  c2x(storage(d2x(x2d(cvt)     + x2d(3c) ),4))
    real       =  c2x(storage(d2x(x2d(cvt)     + x2d(358)),4))
    rcep       =  c2x(storage(d2x(x2d(cvt)     + x2d(490)),4))
    dfaid      =  c2x(storage(d2x(x2d(cvt)     + x2d(4c0)),4))
/*  cpual      =     (storage(d2x(x2d(csd)     + x2d(08) ),2))        */
    cpuol      =  c2x(storage(d2x(x2d(csd)     + x2d(0a) ),2))
    cpuol      =  Strip(x2d(cpuol))
    ssct       =  c2x(storage(d2x(x2d(jesct)   + x2d(18) ),4))
    ssctnam    =     (storage(d2x(x2d(ssct)    + x2d(08) ),4))
    ssctsue    =  c2x(storage(d2x(x2d(ssct)    + x2d(14) ),4))
/*  jesfmid    =     (storage(d2x(x2d(ssctsue) + x2d(1c) ),8))        */
/*  putlvl     =      storage(d2x(x2d(ssctsue) + x2d(2a) ),4)         */
    iocid      =      storage(d2x(x2d(xtnt2)   + x2d(06) ),2)
    nucid      =      storage(d2x(x2d(xtnt2)   + x2d(04) ),1)
    nucid      = 'IEANUC0' || nucid
    iplopt     =  c2x(storage(d2x(x2d(asmvt)   + x2d(01) ),1))
    sprel      =      storage(c2x(d2c(cvtpfx   + x2d(d8))),8)
    mvsrel     =      storage(c2x(d2c(cvtpfx   + x2d(fc))),4)
    smpid      =      storage(c2x(d2c(cvtpfx   + x2d(e0))),8)
    dfprel     =  c2x(storage(d2x(x2d(dfaid)   + x2d(02) ),2))
    dfvt       =  c2x(storage(d2x(x2d(dfaid)   + x2d(2c) ),4))
    dfpfid     =  c2x(storage(d2x(x2d(dfvt)    + x2d(14) ),4))
    dfpfmid    =     (storage(d2x(x2d(dfpfid)  + x2d(27) ),8))
    dfprel     =  substr(dfprel,1,3)
    dfprel     =  insert('.',dfprel,1)
    dfprel     =  insert('.',dfprel,3)
    sysid      =     (storage(d2x(x2d(cvt)     + x2d(154)),4))
    smfid      =     (storage(d2x(x2d(smca)    + x2d(10) ),4))
    rmct       =  c2x(storage(d2x(x2d(cvt)     + x2d(25c)),4))
    sopt       =  c2x(storage(d2x(x2d(rmct)    + x2d(010)),4))
    sopt       =     (storage(d2x(x2d(sopt)    + x2d(053)),2))
    realm      =  right(format((x2d(real)/1024)),6) || 'MB'
    xpand      =  c2x(storage(d2x(x2d(rcep)    + x2d(a0) ),4))
    xpand      =  right(format((x2d(xpand)*4/1024)),6) || 'MB'
    csasz      =  c2x(storage(d2x(x2d(gda)     + x2d(70) ),4))
    ecsas      =  c2x(storage(d2x(x2d(gda)     + x2d(80) ),4))
    csasz      =  right(format((x2d(csasz)/1024)),6) || 'KB'
    ecsas      =  right(format((x2d(ecsas)/1024)),6) || 'KB'
    sqasz      =  c2x(storage(d2x(x2d(gda)     + x2d(94) ),4))
    esqas      =  c2x(storage(d2x(x2d(gda)     + x2d(9c) ),4))
    sqasz      =  right(format((x2d(sqasz)/1024)),6) || 'KB'
    esqas      =  right(format((x2d(esqas)/1024)),6) || 'KB'
    pvtsz      =  c2x(storage(d2x(x2d(gda)     + x2d(a4) ),4))
    pvtsz      =  right(format((x2d(pvtsz)/1024/1024)),6) || 'MB'
    epvts      =  c2x(storage(d2x(x2d(gda)     + x2d(ac) ),4))
    epvts      =  right(format((x2d(epvts)/1024/1024)),6) || 'MB'
    ascbmax    =  c2x(storage(d2x(x2d(asvt)    +    (516)),4))
    ascbmax    =  x2d(ascbmax)
    ascbact    =  0
    ascb@      =  "80"d2x(x2d(asvt)+ x2d(210))
    nra        =  0
    Do i = 1 to ascbmax
       ascb  = c2x(storage(d2x(x2d(asvt)+524+i*4),4))
       if  ascb = ascb@ Then nra = nra + 1
       If  abbrev((ascb),'80')   = 1
            Then iterate
       ascbact = ascbact + 1
    end
    ascbavl = (ascbmax-(ascbact+nra))
    ascbact = ascbact'/'ascbavl

    If  bitand(iplopt,'04'x) = '04'x Then
         iplopt = 'WARM '
    Else Do
            iplopt = 'CVIO '
            If  bitand(iplopt,'08'x) = '08'x Then
                 iplopt = 'QUICK'
            Else iplopt = 'CLPA '
         end

    If  bitand(gtfst,'80'x) = '80'x   Then gtfstat= 'ACTIVE   '
     Else gtfstat= 'INACTIVE'
    If  cvtoptb \= '10'x Then logstat= 'ACTIVE'
     Else logstat= 'INACTIVE'
    icpid= substr(c2x(icpid),3,2)
    logcls =    (storage(d2x(x2d(mserv)  + x2d(68) ),1))

    cvt   =  c2x(storage(10,4))
    gda   =  c2x(storage(d2x(x2d(cvt) + x2d(230)),4))
    csazz =  c2x(storage(d2x(x2d(gda) + x2d(70)),4))
/*
    fbqe1 =  c2x(storage(d2x(x2d(gda) + x2d(64)),4))
    fbqel =  c2x(storage(d2x(x2d(gda) + x2d(68)),4))
    If fbqel /=  fbqe1 Then Do
        tsize = 0
        fbqen = fbqe1
        Do While fbqen /= fbqel
            fsize = c2x(storage(d2x(x2d(fbqen) + x2d(8)),4))
            tsize = tsize + x2d(fsize)
            fbqen = c2x(storage(d2x(x2d(fbqen)),4))
        End
        fsize = c2x(storage(d2x(x2d(fbqen) + x2d(8)),4))
        tsize = tsize + x2d(fsize)
        csasz = csasz'/'Format(100-(tsize / x2d(csazz)*100),,0)
    End
    Else csasz = csasz'/100'
*/
    alloc  =  c2d(storage(d2x(x2d(gda) + x2d(1B0)),4))
    csasz = csasz'/'Format(100-(alloc / x2d(csazz)*100),,0)

    ecsazz =  c2x(storage(d2x(x2d(gda) + x2d(80)),4))
/*
    fbqe1 =  c2x(storage(d2x(x2d(gda) + x2d(74)),4))
    fbqel =  c2x(storage(d2x(x2d(gda) + x2d(78)),4))
    If fbqel /=  fbqe1 Then Do
        tsize = 0
        fbqen = fbqe1
        Do While fbqen /= fbqel
            fsize = c2x(storage(d2x(x2d(fbqen) + x2d(8)),4))
            tsize = tsize + x2d(fsize)
            fbqen = c2x(storage(d2x(x2d(fbqen)),4))
        End
        fsize = c2x(storage(d2x(x2d(fbqen) + x2d(8)),4))
        tsize = tsize + x2d(fsize)
        ecsas = ecsas'/'Format(100-(tsize / x2d(ecsazz)*100),,0)
    End
    Else ecsas = ecsas'/100'
*/
    alloc  =  c2d(storage(d2x(x2d(gda) + x2d(1B4)),4))
    ecsas = ecsas'/'Format(100-(alloc / x2d(ecsazz)*100),,0)

/*--------------------------------------------------------------------*/
/* The following values are static. If already set bypass subsequent  */
/* processing.                                                        */
/*--------------------------------------------------------------------*/
    If zmachine /= 'ZMACHINE' Then Return 0

/*--------------------------------------------------------------------*/
    sips       =  c2x(storage(d2x(x2d(rmct)    + x2d(018)),4))
    sips       =     (storage(d2x(x2d(sips)    + x2d(004)),2))
    sics       =  c2x(storage(d2x(x2d(rmct)    + x2d(0dc)),4))
    sics       =     (storage(d2x(x2d(sics)    + x2d(000)),2))

    cpual = (storage(d2x(x2d(csd) + x2d(08) ),2))
    x_1 = Substr(cpual,1,1)
    x_2 = Substr(cpual,2,1)
    cpual = ''
    If  bitand(x_1,'80'x) = '80'x Then cpual = cpual || ',0'
    If  bitand(x_1,'40'x) = '40'x Then cpual = cpual || ',1'
    If  bitand(x_1,'20'x) = '20'x Then cpual = cpual || ',2'
    If  bitand(x_1,'10'x) = '10'x Then cpual = cpual || ',3'
    If  bitand(x_1,'08'x) = '08'x Then cpual = cpual || ',4'
    If  bitand(x_1,'04'x) = '04'x Then cpual = cpual || ',5'
    If  bitand(x_1,'02'x) = '02'x Then cpual = cpual || ',6'
    If  bitand(x_1,'01'x) = '01'x Then cpual = cpual || ',7'
    If  bitand(x_2,'80'x) = '80'x Then cpual = cpual || ',8'
    If  bitand(x_2,'40'x) = '40'x Then cpual = cpual || ',9'
    If  bitand(x_2,'20'x) = '20'x Then cpual = cpual || ',A'
    If  bitand(x_2,'10'x) = '10'x Then cpual = cpual || ',B'
/*  If  bitand(x_2,'08'x) = '08'x Then cpual = cpual || ',C'          */
/*  If  bitand(x_2,'04'x) = '04'x Then cpual = cpual || ',D'          */
/*  If  bitand(x_2,'02'x) = '02'x Then cpual = cpual || ',E'          */
/*  If  bitand(x_2,'01'x) = '01'x Then cpual = cpual || ',F'          */

    Parse Var cpual ',' snumb ',' x_x
    cpual = ''
    pnumb = snumb
    Do Forever
        Parse Var x_x cnumb ',' x_x
        If X2D(pnumb) /= X2D(cnumb) -1 Then Do
            If pnumb = snumb Then cpual = cpual','snumb
            Else                  cpual = cpual','snumb'-'pnumb
            snumb = cnumb
        End
        pnumb = cnumb
        If x_x = '' Then Leave
    End
    If pnumb = snumb Then cpual = cpual','snumb
    Else                  cpual = cpual','snumb'-'pnumb
    cpual = Substr(cpual,2)
    If Substr(cpual,Length(cpual),1) = ',' Then,
        cpual = Substr(cpual,1,Length(cpual)-1)
    Call cpual_msgl

    cvt   = c2x(storage(10,4))
    amcbs = c2x(storage(d2x(x2d(cvt)   + x2d(100)),4))
    caxwa = c2x(storage(d2x(x2d(amcbs) + x2d(14)),4))

    Do while caxwa ¬= "0"
        caxcnam   = storage(d2x(x2d(caxwa) + x2d(34)),44)
        caxcnam   = strip(caxcnam)
        caxmct    = c2x(storage(d2x(x2d(caxwa) + x2d(8)),1))
        caxmct    = substr(x2b(caxmct),6,1)

        If caxmct = '1' Then
          Do
          mcat = "'"caxcnam"'"
          Leave
        End

        caxwa     = c2x(storage(d2x(x2d(caxwa) + x2d(4)),4))
    End

    ipldte  = c2x(storage(d2x(x2d(smca)    + x2d(154)),4))
    ipldte  = insert('.',substr(ipldte,3,5),2)
    ipltme  = (storage(d2x(x2d(smca)    + x2d(150)),4))
    iplhh   = Right(c2d(ipltme) % 100  % 3600      ,2,'0')
    iplmm   = Right(c2d(ipltme) % 100 // 3600 % 60 ,2,'0')
    iplss   = Right(c2d(ipltme) % 100 // 60        ,2,'0')
    ipltme  = iplhh || ':' || iplmm || ':' || iplss
    resaddr = (storage(d2x(x2d(sysad)   + x2d(0d) ),3))
    resaddr = c2x(storage(d2x(x2d(sysad)   + x2d(04) ),2))
    resvol  = (storage(d2x(x2d(sysad)   + x2d(1c) ),6))

    ecvt    = c2x(storage(d2x(x2d(cvt)     + x2d(8C) ),4))
    machine = Strip(storage(d2x(x2d(ecvt)    + x2d(150)),8))
    lpar    = Strip(storage(d2x(x2d(ecvt)    + x2d(158)),8))
    If zresvol /= 'N/A' Then Do
        Address TSO "TSOSYM  ZMACHINE,ZRESVOL,ZSITEID,ZMNTLVL,SYSPLEX"
        zresvol = zresvol '/' sysplex
    End
    putlvl = zmntlvl
    If machine /= '' Then zmachine = machine'/'lpar
    Else                  zmachine = 'Una./'lpar

    Call get_cpuid
    Call alt_addr
    If resaddr /= '' Then resaddr = resaddr'/'altaddr
    Call ddd_ddmmyy
    Call getsysp

    If parm1 /= 'DATA' Then Do
        call get_iodf_and_cpu;      /* get iodf file and WLM info    */
        If goal > 0 Then Do
/*          sips = 'WLM('sips')';  sics = 'WLM('sics')'               */
            sips = 'WLM'        ;  sics = 'WLM'
        End
    End

    Address ISPEXEC
    If trace = 'Y' Then Trace r

    Return 0


/*--------------------------------------------------------------------*/
/* X2B routine inserted in here to speed up execution of navigating   */
/* the CATSWA chain...                                                */
/*--------------------------------------------------------------------*/
x2b:
    Parse source . end
    If cmd="Command" Then Arg hexstring","hexlen","binlen
                     Else Arg hexstring,hexlen,binlen

    hexstring = space(hexstring,0)

    If ¬Datatype(hexstring,"X") Then
        If cmd="Command" Then Exit 44
                         Else exit
    bin = ""

    push "0000 0001 0010 0011 0100 0101 0110 0111",
         "1000 1001 1010 1011 1100 1101 1110 1111"

    pull b.0 b.1 b.2 b.3 b.4 b.5 b.6 b.7 b.8 b.9 b.a b.b b.c b.d b.e b.f

    If hexlen = ""  Then hexlen = length(hexstring)+1
    If hexlen = "S" Then hexlen = length(hexstring)
    If binlen = ""  Then binlen = length(hexstring)*4

    Hexstring = right(hexstring,hexlen,0)
    sgn = left(hexstring,1)
    sgn = left(b.sgn,1)

    Do x=1 to length(hexstring)
       hexchar = substr(hexstring,x,1)
       bin = bin || b.hexchar
    End

    bin = right(bin,binlen,sgn)

    If cmd="Command" Then Say bin
    Else Return bin

/*--------------------------------------------------------------------*/
/* The following routine gets the load parameter from the SCCB and    */
/* using it, extracts the SYSP value from:                            */
/*   - At Telstra sites:                                              */
/*     IEASYM01 member looking for SYSNAME/LRANAME(sysid) followed by */
/*     SYSPARM().                                                     */
/*--------------------------------------------------------------------*/
getsysp:
    cvtscpin =  c2x(storage(d2x(x2d(cvt)       + x2d(340)),4))
    sccb     =  c2x(storage(d2x(x2d(cvtscpin)  + x2d(18)),8))

    Loadp   = Strip(x2c(sccb))
    load    = Substr(loadp,5,2)
    sysp    = '??'
    symp    = '??'
    ecvt    =  c2x(storage(d2x(x2d(cvt)     + x2d(8C) ),4))
    ipa     =  c2x(storage(d2x(x2d(ecvt)    + x2d(188) ),4))
    iplparm =  Strip(storage(d2x(x2d(ipa)     + x2d(30) ),44))

/*  Signal not_at_site                                                */

    If zresvol > 09 | zresvol = 'N/A' Then Do
/*      zresvol = 'N/A'                                               */
        sym@ =  c2x(storage(d2x(x2d(ipa)     + x2d(120) ),4))
        sym# =  storage(d2x(x2d(ipa)     + x2d(120) ),16)
        If Substr(sym#,1,1) = '(' Then Parse VAR sym# '(' symp ')' .
        Else symp = Substr(sym#,1,2)
        sys@ =  c2x(storage(d2x(x2d(ipa)     + x2d(A80) ),4))
        sys# =  storage(sys@,8)
        If Substr(sys#,1,1) = '(' Then Parse VAR sys# '(' sysp ')' .
        Else sysp = Substr(sys#,1,2)
        ips@ =  c2x(storage(d2x(x2d(ipa)     + x2d(940) ),4))
        ips# =  storage(ips@,8)
        If Substr(ips#,1,1) = '(' Then Parse VAR ips# '(' sips ')' .
        Else sips = Substr(ips#,1,2)
        If sips = '' Then sips = Substr(ips#,1,2)
        ics@ =  c2x(storage(d2x(x2d(ipa)     + x2d(930) ),4))
        ics# =  storage(ics@,8)
        If Substr(ics#,1,1) = '(' Then Parse VAR ics# '(' sics ')' .
        Else sics = Substr(ics#,1,2)
        opt@ =  c2x(storage(d2x(x2d(ipa)     + x2d(9C0) ),4))
        opt# =  storage(opt@,8)
        If Substr(opt#,1,1) = '(' Then Parse VAR opt# '(' sopt ')' .
        Else sopt = Substr(opt#,1,2)
        Return 0
    End

If Strip(loadp) = '' Then Return
    dd = 'SP'Time('s')
    loadmem = "'"iplparm"(LOAD"load")'"
    If Sysdsn(loadmem) /= 'OK' Then Do
        errc = 'E01'
        Signal sysp_fail
    End
    Address TSO "ALLOC F("dd") DA("loadmem") SHR REU"
    If rc ¬= 0 Then Do
        errc = 'E02'
        Signal sysp_fail
    End

    Address TSO "EXECIO * DISKR "dd" (STEM line. FINIS)"

    Do i=1 To line.0
        If Index(line.i,'IEASYM') /= 1 Then Iterate
        Parse VAR line.i '(' symp ')'
        If symp = '' Then Parse VAR line.i . symp .
        Leave
    End
    Address TSO "FREE F("dd")"
    If symp = '??' Then Do
        errc = 'E03'
        Signal sysp_fail
    End

    dd   = 'SP'Time('s')
    sym# = symp
    sym# = Strip(symp)
    Do Forever
        Parse VAR sym# sym ',' sym#
        symmem   = "'"loadparm"(IEASYM"sym")'"
        If Sysdsn(symmem) /= 'OK' Then Do
            symmem   = "'"loadalt"(IEASYM"sym")'"
            If Sysdsn(symmem) /= 'OK' Then Do
                errc = 'E04'
                Signal sysp_fail
            End
        End
        Address TSO "ALLOC F("dd") DA("symmem") SHR REU"
        If rc ¬= 0 Then Do
            errc = 'E05'
            Signal sysp_fail
        End

        Address TSO "EXECIO * DISKR "dd" (STEM line. FINIS)"
        ec# = 'NAME('Strip(sysid)')'
        sp# = 'SYSPARM('
        Do i=1 To line.0
            If Index(line.i,ec#) > 0 & ec# /= sp# Then Do
                ec# = sp#
                Iterate
            End
            If Index(line.i,ec#) = 0 Then Iterate
            Parse VAR line.i '(' sysp ')' .
            i = line.0
        End
        Address TSO "FREE F("dd")"
        If sym# = '' | sysp /= '??' Then Leave
    End
not_at_site:
    Return

sysp_fail:
    zerrlm = errc 'Failed to establish SYSP member.'
    Address ISPEXEC "SETMSG MSG(ISRZ002)"
    Return 4


ddd_ddmmyy:
    Parse VAR ipldte yy '.' ddd
    Select
        When (yy // 1000 = 0) Then feb = 29
        When (yy // 400  = 0) Then feb = 28
        When (yy // 4    = 0) Then feb = 29
        Otherwise                  feb = 28
    End
    string = ,
             '31' ||,
             feb  ||,
             '31' ||,
             '30' ||,
             '31' ||,
             '30' ||,
             '31' ||,
             '31' ||,
             '30' ||,
             '31' ||,
             '30' ||,
             '31'
    Do i=1 To 12
        y = Substr(string,(i-1)*2 +1,2)
        If y >= ddd Then Do
            mm = Right(i,2,'0')
            dd = Right(ddd,2,'0')
            Leave
        End
        ddd = ddd - y
    End
    ipldte = dd'/'mm'/'yy

    Return 0

/*--------------------------------------------------------------------*/
/* Expand CPUs allocated and build message line based on expanded     */
/* CPUs.                                                              */
/*--------------------------------------------------------------------*/
cpual_msgl:
    xxx = '{('cpuol')}:{'cpual
    x_x = Length(xxx)
    If x_x < 17 Then x_x = 16
    cpuald = Substr('}CPU Avail',1,29-x_x) || xxx

    Return 0

/*--------------------------------------------------------------------*/
/* Break down CSA data into size and % used and set display line.     */
/*--------------------------------------------------------------------*/
csasz_msgl:
    Parse VAR csasz csasz '/' csapu
    If csapu /= '' Then csapu = '{('csapu'%)'
    x_x = 7 - Length(csapu)
    If x_x > 0 Then csadtl = Substr(' ',1,x_x)csapu'}:{'csasz
    Else            csadtl = csapu'}:{'csasz

    Parse VAR ecsas ecsas '/' ecsapu
    If ecsapu /= '' Then ecsapu = '{('ecsapu'%)'
    x_x = 7 - Length(ecsapu)
    If x_x > 0 Then ecsadtl = Substr(' ',1,x_x)ecsapu'}:{'ecsas
    Else            ecsadtl = ecsapu'}:{'ecsas

    Return 0

/*--------------------------------------------------------------------*/
/* Get alternative address                                            */
/*--------------------------------------------------------------------*/
alt_addr:
    altaddr = '????'
    If telstra /= 'Y' Then Return 0
    Parse VAR resvol 1 vol1 +5 volsuf
    volsuf = Translate(volsuf,'12','21')
    keeptb  = "Y"
    dstable = 'DSPACE'
    dasdspcw = "N"
    "ISPEXEC VPUT (KEEPTB dasdspcw DSTABLE) SHARED"
    "ISPEXEC SELECT PGM(DASDSPCE) PARM("vol1 || volsuf")"
    "ISPEXEC TBTOP DSPACE"
    "ISPEXEC TBSKIP DSPACE"
    "ISPEXEC TBEND DSPACE"
    zerrsm = ''
    If ucb /= 'UCB' Then altaddr = ucb
    x = Outtrap('line.',1,'NOCONCAT')
    Address TSO "DUDASD" voli
    If line.1 /= 'LINE.1' Then Parse VAR line.1 altaddr .

    Return 0

/*--------------------------------------------------------------------*/
/* Issue console command to get iodf file and find its volser and adr */
/*--------------------------------------------------------------------*/
get_iodf_and_cpu:
/*--------------------------------------------------------------------*/
/*Activate CONSOLE facility                                           */
/*--------------------------------------------------------------------*/
    iodfvo = '??????'
    iodf = 'CONSOLE command unavailable'
    If can_console /= 'Y' Then return 1
    sol   = sysvar('SOLDISP')       /* get current profile            */
    unsol = sysvar('UNSDISP')       /* get current profile            */
    Address TSO
    "CONSPROF SOLDISP(NO) UNSOLDISP(NO)" /* SET PROFILE TO NO DISPLAYS*/
    alfabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    Do i=1 To 26
        cn = Userid() || Substr(alfabet,i,1)
        x = Outtrap('line.',1,'NOCONCAT')
        "CONSOLE ACTIVATE NAME("cn")"   /* ACTIVATE CONSOLE           */
        rc1 = rc
        If rc1 = 0 Then Leave
    End
    If rc1 /= 0 Then Do
        iodf = 'Could not establist CONSOLE'
        Return 1
    End
/*--------------------------------------------------------------------*/
/* Issue command to see if WLM active or not                          */
/*--------------------------------------------------------------------*/
    "CONSOLE SYSCMD(D DMN) CART('IOS')"
    msg = getmsg('consmsg.',,'IOS',,5)  /* wait 5 seconds for results */
    If msg /= 0 Then,
        Say 'No output from console command to process'
    Else,
        goal = Index(consmsg.1,'NOT VALID IN GOAL MODE')
/*--------------------------------------------------------------------*/
/* Issue command to find IODF                                         */
/*--------------------------------------------------------------------*/
find_iodf:
    "CONSOLE SYSCMD(D IOS,CONFIG) CART('IOS')"
    msg = getmsg('consmsg.',,'IOS',,5)  /* wait 5 seconds for results */
    If msg ¬= 0 Then Do
      Say 'No output from console command to process'
      Return 1
    End
    If word(consmsg.2,1) = 'MVSCP' Then Do
      iodf = 'No IODF for this system'
      Return 2
    end
    parse var consmsg.2 . '=' iodf        /* get name of iodf file */
    iodf = Strip(iodf)
    If iodf = '' Then iodf = '?????'
    Else Do
        x = Listdsi("'"iodf"'")
        iodfvo = sysvolume
    End
/*  x = Outtrap('line.',1,'NOCONCAT')                                 */
/*  "DUDASD" iodfvo                                                   */
/*  line.1 = ????                                                     */
/*  Parse VAR line.1 iodd .                                           */
    Address ISPEXEC
    table = DS(iodfvo" RETURNIT")
    "TBTOP &TABLE"
    rc1 = rc
    Do While rc1 = 0
        "TBSKIP &TABLE"
        rc1 = rc
        If rc1 = 0 Then iodd = ucb
    End
    "TBEND &TABLE"
    Address TSO
/*--------------------------------------------------------------------*/
/* Deactivate console facility                                        */
/*--------------------------------------------------------------------*/
    'CONSPROF SOLDISP('sol') UNSOLDISP('unsol')' /* restore profile   */
    'CONSOLE DEACTIVATE'                /* then deactivate it         */
    Return 0

/*--------------------------------------------------------------------*/
/* Get CPU id                                                         */
/*--------------------------------------------------------------------*/
get_cpuid:
    cpuid = Storage(c2x(storage(208,4)),16)

    xx =  'CPU  MC MODEL'
    mx =  '0500 13 535  '    ||,   /*          0500/535    MIL        */
          '3090 22 3090 '    ||,   /*          3090/200S              */
          '5990 80 1400 '    ||,   /*          5990/1400              */
          '5995 80 1400A'    ||,   /*          5995/A                 */
          '5995 09 4550 '    ||,   /*          5995/M 4550            */
          '5995 C9 4570 '    ||,   /*          5995/M 4570            */
          '5995 C1 3570 '    ||,   /*          5995/M 3570            */
          '5995 D1 6670 '    ||,   /*          5995/M 6670            */
          '5995 F1 7670 '    ||,   /*          5995/M 7670            */
          '5995 D9 8670 '    ||,   /*          5995/M 8670            */
          '5995 BB 12670'    ||,   /*          5995/M 12670           */
          '9021 A6 900  '    ||,   /*          9021/900               */
          '9021 C3 831  '    ||,   /*          9021/831               */
          '9021 D5 SK52 '    ||,   /*          9021/952               */
          '9021 D6 962  '    ||,   /*          9021/962               */
          '9021 D4 SK427'    ||,   /*          HDS SKYLINE SK427      */
          '9021 D7 972  '    ||,   /*          9021/972               */
          '9021 D8 982  '    ||,   /*          9021/982               */
          '9021 DA 9X2  '    ||,   /*          9021/9X2               */
          '9672 74 R45  '    ||,   /*          9672/R45               */
          '9672 54 R44  '    ||,   /*          9672/R44               */
          '9672 55 R54  '    ||,   /*          9672/R54               */
          '9672 5D RC4  '    ||,   /*          9672/RC4               */
          '9672 56 R64  '    ||,   /*          9672/R64               */
          '9672 5A RX4  '          /*          9672/RX4               */
    el = Length(xx)
    ll = Length(mx) % el
    Parse VAR cpuid 1 li +4 5 mco +2 13 cpuo +4

    cpuid = 'CPUid not defined.'
    Do i=1 To ll
        xx = Substr(mx,(i-1)*el+1,el)
        Parse VAR xx cpu mc model .
        If mco = mc & cpuo = cpu Then Do
            cpuid = cpu'-'model
            Leave
        End
    End

    Return 0

/*--------------------------------------------------------------------*/
/* Help instructions.                                                 */
/*--------------------------------------------------------------------*/
help:
    If parm1 = '??' Then Signal help_actual
    Address TSO "%BR GETSINFO ??"
    Return 0

help_actual:
    last = Sourceline() -1
    Do i=last By -1
        line = Sourceline(i)
        If i = 1 Then Exit
        If Substr(line,1,2) /= '/*' Then Iterate
        first = i +1
        Leave
    End
    Address TSO "CLEAR"
    Do i=first To last
        If i=first Then Say Centre(' ooo000OOOO000ooo ',79,'*')
        Say '*'Substr(Sourceline(i),1,77)'*'
        If i=last  Then Say Centre(' End ',79,'*')
    End
    Exit

/*
    This routine display specific systems info in a formatted pop up
    window. You can either pass a parameter of 'sysid' for a remote
    system or change the sysid field in the panel once the details for
    the current system are displayed.
    For remote systems, APPC routine TDGETSIN is used to invoke this
    routine to extract and return the data by using the 'DATA' feature
    of this routine.

    To use the 'DATA' feature, invoke this routine as a function with
    'DATA' as the first parameter and it will return the following
    string of data.  The data will start with '$$$$$$$$' and terminated
    by '¢¢¢¢¢¢¢¢' with the actual data fields '~' delimited.
    If the first parameter is not the literal 'DATA', it will be
    interpreted as a system-id.

    Format of the 'DATA' facility function:
       x = Getsysinfo('DATA'{,systemid{,(field-list){,seperator}}})

       Where: (all parameters are positional)

         'DATA'       - Function identifier.
         systemid     - Remote systeid. The default is the current
         (field-list) - List of field variables to return (in
                        parentheses).  By default all data with above
                        mentioned delimiters will be returned. For the
                        field names and order of fields for a full list,
                        refer below to field variables.  Any invalid
                        variable_name passed in the list will be
                        returned unchanged.  Alternatively you may set
                        up the field-list as a parameter (including the
                        parentheses) and on return issue a '"VGET"
                        fldlst "SHARED"' to bypass the need to parse the
                        return data.

         seperator    - By default fields will be delimited by '~'. You
                        may set your own delimiter by passing it as the
                        fourth parameter. A 'B' will default to a single
                        space.

        Eg.

         x = Getsinfo('DATA',sysid,'(RESVOL,RESADDR,IPLDTE,FRED)','B')

             will return (for A01)

         "PIA101 1418(099E) 19/11/97 FRED"


    Variables list:

        MVS FMID         --> SMPID
        MVS SP Release   --> SPREL
        MVS SP Base      --> MVSREL
        PUT Level        --> PUTLVL
        JES Name         --> SSCTNAM
        DFP FMID         --> DFPFMID
        DFP Release      --> DFPREL
        CPU Available    --> CPUAL
        # CPU available  --> CPUOL
        IPL Processor    --> ICPID
        IPL Options      --> IPLOPT
        IPL Date         --> IPLDTE
        IPL Time         --> IPLTME
        Sysres Volume    --> RESVOL
        Sysres Addr/Alt  --> RESADDR
        Resvol           --> ZRESVOL
        Nucleus Member   --> NUCID
        Load Member      --> LOAD
        IEASYS Member    --> SYSP
        IEASYM Member    --> SYMP
        System name      --> SYSID
        Machine          --> ZMACHINE
        Site-id          --> ZSITEID
        ASCB Defined     --> ASCBMAX
        ASCB Active      --> ASCBACT
        ASCB (Non-Reuse) --> NRA
        SYSLOG Class     --> LOGCLS
        SYSLOG Status    --> LOGSTAT
        GTF Status       --> GTFSTAT
        SRM IPS Options  --> SIPS
        SRM ICS Options  --> SICS
        SRM OPT Options  --> SOPT
        Central  Storage --> REALM
        Expanded Storage --> XPAND
        CSA  Size        --> CSASZ
        ECSA Size        --> ECSAS
        SQA  Size        --> SQASZ
        ESQA Size        --> ESQAS
        Private  Size    --> PVTSZ
        EPrivate Size    --> EPVTS
        Catalog          --> MCAT
        I/O Config ID    --> IOCID
        IODF             --> IODF
        IODF Volume      --> IODFVO
        IODF Device      --> IODD
        CPU id           --> CPUID
*/
