%headline=' Assembler Commands '
)INI

  MISCELLANEOUS.
! 2             b

    RS  =  B2 + D2

    RX  =  B2 + X2 + D2

  EQUATE.
! 2      b

  * Equate label with current instruction.

    Use "*" with brances so that labels can be moved without changing
    instructions.

    eg.  LOOP   EQU  *

  FIXED POINT BINARY (FPB).
! 2                        b

                                   - - - - - - - - - - - - - - - -
  External decimal   ===>         ¦ D ¦ D ¦ D ¦ D ¦ D ¦ D ¦ D ¦ D ¦
                                   - - - - - - - - - - - - - - - -
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ¦ F   0 ¦ F   0 ¦ F   0 ¦ F   0 ¦ F   1 ¦ F   5 ¦ F   9 ¦ F   6 ¦
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  PACK:
                  ||
                  \/
                                   - - - - - - - - - - - - - - - -
  Packed decimal     ===>         ¦D D¦D D¦D D¦D D¦D D¦D D¦D D¦D D¦
                                   - - - - - - - - - - - - - - - -
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ¦ 0   0 ¦ 0   0 ¦ 0   0 ¦ 0   0 ¦ 0   0 ¦ 0   1 ¦ 5   9 ¦ 6   F ¦
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  CVB:
                  ||
                  \/
                                   - - - - - - - - - - - - - - - -
  Fixed Point Binary ===>         ¦s¦  63/31/15 bit binary value  ¦
                                   - - - - - - - - - - - - - - - -
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ¦ 0   0 ¦ 0   0 ¦ 0   0 ¦ 0   0 ¦ 0   0 ¦ 0   0 ¦ 0   6 ¦ 3   C ¦
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  Always use this format in FPB. RESULT is ALWAYS placed in a REGISTER.

          BCTR R5,R0   <=== quick way of decrementing a register by 1
                            without branching.

  To test return codes from MVS.

           LTR   R15,R15
           BNZ   ERROR

  LOGICAL OPERATIONS.
! 2                  b

  "A"    "B"       AND     OR    XOR
  ---    ---       ---     ---   ---
   0      0  ===>   0       0     0
   0      1  ===>   0       1     1
   1      0  ===>   0       1     1
   1      1  ===>   1       1     0

   AND   if both bits 1   ===> 1
   OR    if either bits 1 ===> 1
   XOR   if both differnt ===> 1

   AND  is used to turn bits OFF.
   OR   is used to turn bits ON.

   Eg.
      $WAIT    EQU  X'01'
      $SEND    EQU  X'02'
      $ACTIVE  EQU  X'04'
      $RECV    EQU  X'08'
      $CANCEL  EQU  X'10'
      $PARENT  EQU  X'20'
      $NOT     EQU  X'FF'

      Turning bit flags on:
         OI   FLAG,$ACTIVE
         OI   FLAG,$ACTIVE+$RECV

      Turning bit flags off:
         NI   FLAG,255-$RECV
         NI   FLAG,$NOT-$RECV

   SHIFTS.
! 2       b

                            LEFT
                    SINGLE /
           LOGICAL /       \RIGHT
   SHIFTS /        \DOUBLE
          \ARITHMETIC


   RIPPLE MOVE.
!  2           b

            MVI   PRLINE,C' '
            MVC   PRLINE+1(132),PRLINE
   PRLINE   DS    CL133

    --> --> --> --> --> -->
      - - - - - - - - - - - - - - - -
     ¦sp ¦sp ¦sp ¦sp ¦sp ¦sp ¦   ¦   ¦
      - - - - - - - - - - - - - - - -

  LABELS.
! 2      b
    - Used to identify the destination of GOTO instruction
    - Identify storage areas for data

  Assigns a character string to an address. Labels only exist at Object
  level. At assembly only it's effects remain.
  R15 is the initial base register

  CSECT Control Section.
! 2                     b

  TEST   CSECT
         LR     R3,R15
         USING  TEST,R3
         L      R4,DATA
         CVD    R4,DWORK
         LTORG
  DATA   DC     F'2'
  DWORK  DS     D
         END

  DEFINING STORAGE AREA.
! 2                     b
      Type   Description         Length Format   Padding
      ----   -------------       ------ ------   ---------------------
  DS }
  DC }  C  - character             ?    char     right (spaces)
        X  - hexadecimal           ?    A-f,0-9  left  (zeros)
        B  - binary                ?    0,1      left  (zeros)
        F  - fixed point           4    0-9      left  (zeros)
        H  - fixed point           2    0-9      left  (zeros)
        D  - long floating point   8    __       left  (zeros)
        P  - packed decimal        ?    0-9      _____
        A  - address               4    symbol   left  (zeros)
        v  - external address      4    symbol   left  (zeros)

  "A"  type storage are relocated during load.
  "V"  type storage are resolved by the linkage-editor.

  DATA1  DC   rTl'     '(      )
             / | \     \       \
           /   |   \     \       \ used for type = A or V
         /     |     \     \
   repetition  type  length for define constant(DC) init value

         DC  F'0003'  - specifies decimal value.

  Address calculation in registers use the low order 24 bits. The rest
  are ignored.

  2 BASE REGISTERS - BIG PROGRAMS.
! 2                               b

  ===================================
  ¦          EQUATES                ¦  No base - only definitions.
  ¦=================================¦
  ¦L1        MAIN ROUTINES          ¦
  ¦---------------------------------¦  R3 = Base
  ¦          MAIN DATA (global)     ¦
  ¦=================================¦
  ¦L2        SUB PROC 1             ¦
  ¦---------------------------------¦  R11 = Base  (sub pgms should
  ¦          DATA (local)           ¦ never call subs)
  ¦=================================¦
  ¦L3        SUB PROC 2             ¦
  ¦---------------------------------¦  R11 = Base
  ¦          DATA (local)           ¦
  ¦=================================¦
  ¦L4        SUB PROC 3             ¦
  ¦---------------------------------¦  R11 = Base
  ¦          DATA (local)           ¦
  ¦=================================¦
  ¦                                 ¦

  The last statement in each proc =>   DROP register.

  Eg.
      MAIN       CSECT
      SUBENT1    DC     A(SUB1)
      SUBENT2    DC     A(SUB2)
      SUBENT3    DC     A(SUB3)
                 ....
                 ....
      TASKACT    EQU    *
                 LA    R4,SUBENT2
                 L     R11,0(R4)
                 BALR  R14,R11
                 ....
      SUB2       CSECT
                 USING SUB2,R11
                 ....
                 ....
                 DROP  R11      Drop is the oposite of USING. Causes
                                the register to be removed from the
                                base table.

?MC
?MACRO
?MACROS
   MACROS.
!  2      b
   Macros take up no space in the object code

   col 1          col 10     col 16
   ¦              ¦         ¦
                  macro header
   prototype      name      parameters

   Eg.
                  MACRO
     &LABEL       MYMAC     &A,&B,&C=NO

   Work variables must be declared after prototype.

   Work variables :
                  LCLx      name

             whre x =>  A : arithmetic (32 bit signed integer init 0)
                        B : boolean (initialised to false "0")
                        C : character (up to 255 chars "nulls")

   All variables musr start with "&" => &Axxx, &Bbbb, &Cnnn

   Example :
                 MACRO
      &LABEL     MYMAC     &LIMIT
                 LCLA      &A1,&A2,&A3
      &A1        SETA      &LIMIT
      &A2        SETA      2
      &A3        SETA      1
      .LOOP      ANOP                  labels must begin with "."
      *                                ANOP = no operation
                 DC        PL16'&A2'
      &A2        SETA      &A2*2
      &A3        SETA      &A3+1
                 AIF       (&A3 LT &LIMIT).LOOP if (..) true goto else
                                               fall thru
                 MEND

      &C1        SETC      'DOG'
      &C2        SETC      '&C1&C2'
      &C3        SETC      'THIS IS A &C1'
      &C4        SETC      '&C1.CAT'        this is a no-no.

      LCLx       ===> Local macro variable
      GBLx       ===> Global macro variable and can be used by other
                      macros. Initialised when first hit, then stays
                      the same for the rest of the assembly or next hit.

      LCLA      &ACNT1(100) ==> Array of 100 elements (first element is
                                1).

      &C1       SETC   'ASSEMBLER IS FROG-SHIT'
      &C2       SETC   &C1(14,10)   <--- can use variables
                                    The first field in brackets is the
                                    starting position (> or = 1) the
                                    second is the number of chars to
                                    extract (extracts up to the limit
                                    and stops when the limit is reached)

     ===> &C2 = "FROG-SHIT"

 Another example:

           MACRO
           MYMAC  &R1,&DATA
           LCLA   &A1,&A2
           AIF    ('&R1' EQU '').NOREG
           AIF    ('&DATA' EQU '').NODATA
  &A1      SETA   &R1
  &A2      SETA   &A1+1
           AL     &A2,&DATA+4
           ST     &A2,&DATA+4
           BC     12,J&SYSNDX        Standard variable starts at 1 and
 *                                     increased by 1.
  J&SYSNDX EQU    *
           A      &A1,&DATA
           ST     &A1,&DATA
           AGO    .EXIT
  .NOREG   MNOTE  8,'HOW CAN I DO IT WITH NO REG?' the * is the minimum
 *                                   condition code for link-edit
           AGO    .EXIT
  .NODATA  MNOTE  8,'I NEED THE DATA TOO'
           AGO    .EXIT
  .EXIT    MEND


 Another one:

           MACRO
           REGEQU &A1=0
           CLCA   &A1
  .LOOP    ANOP
  R&A1     EQU    &A1
  &A1      SETA   &A1+1
           AIF    (&A1 LT 16).LOOP
           MEND


  Instream macros:

           MACRO
           .....
           .....
           MEND
           MACRO
           .....
           .....
           MEND
  MYPROG   CSECT
           .....
           Call to macros


?A
  A     :(RS) - ADD.
! 2                 b
  1)   A       R1,D2(X2,D2)            - explicit

  2)   A       R1,FDATA                - implicit

  ===> B + A => A.

  NOTE - Same as AR except "B" operand is a full word memory location.

?AH
  AH    :(RX) - ADD HALFWORD.
! 2                          b
  1)   AH      R1,D2(X2,D2)            - explicit

  2)   AH      R1,FDATA                - implicit

  ===> B + A => A.

  NOTE - Only 16 bits are used.

?AL
  AL    :(RX) - ADD LOGICAL.
! 2                         b
  1)   AL    R1,D2(X2,B2)              - explicit

  2)   AL    R1,FWORD                  - implicit

    Result stored in operand "A". Used to perform multi precision
    arithmetic.

    Condition codes set:    0 - Sum is 0 with NO carry.
                            1 - Sum is not 0 with NO carry.
                            2 - Sum is 0 with carry.
                            3 - Sum is not 0 with carry.

?ALR
  ALR   :(RR) - ADD LOGICAL REGISTER.
! 2                                  b
  1)   ALR   R1,r2                     - explicit

    Result stored in operand "A". Used to perform multi precision
    arithmetic.

    Condition codes set: (Refer to AL.)

?AP
  AP    :(SS) - ADD PACKED/DECIMAL.
! 2                                b
  1)   AP    D1(L1,B1),D2(L2,B2)       - explicit

  2)   AP    LAB1(L1),LAB2(L2)         - implicit

    Result stored in operand "A".

?AR
  AR    :(RR) - ADD REGISTER.
! 2                          b
  1)   AR      R1,R2                   - explicit

  ===> B + A => A.

?B
  BAL   :(RX) - BRANCH AND LINK. (Unconditional branch)
! 2                             b
  1)   BAL     R1,D2(X2,B2)            - explicit

  2)   BAL     R1,LABEL                - implicit

  Takes the effective address and puts it into the PSW and takes the
  effective address of the next instruction and places it into operand
  "A".

  PSW       |--------------------------------| ===> 1) R1
            |                       | NSIA   |      2) EA = X2 + B2 + D2
            |-----------------------'--------| <=== 3) EA
            |                                |
            |--------------------------------|

  Where : EA = Effective Address.

?BALR
  BALR  :(RR) - BRANCH AND LINK REGISTER.
! 2                                      b
  1)   BALR    R1,R2                   - explicit

  Branch to address in R2. Usually used for external calls where R2 is
  loaded from ===>  DC    v(xxxxxxxx).
  "A".

  PSW       |--------------------------------| ===> 1) R1
            |                       | NSIA   |      2) EA = X2 + B2 + D2
            |-----------------------'--------| <=== 3) EA
            |                                |
            |--------------------------------|

  Where : EA = Effective Address.

?BC
  BC    :(RX) - BRANCH ON CONDITION.
! 2                                 b
  1)   BC      mask,LABEL

       CC   ¦  0   ¦   1   ¦    2   ¦   3 (bits)
       -----¦----- ¦-------¦--------¦-----------
       mask ¦  8   ¦   4   ¦    2   ¦   1
       -----¦----- ¦-------¦--------¦-----------
       cond ¦  EQ  ¦ A low ¦ A high ¦ -

       A : B
       B   - unconditional branch.
       BH  -
       BL  -
       BE  -
       BZ  - branch zero.
       BNH -
       BNL -
       BNE -
       BNZ -

?BCR
  BCR   :(RR) - BRANCH ON CONDITION REGISTER.
! 2                                          b
  1)   BCR     M1,R2                   - explicit

  After test, branch instructions:
      BER   - branch if register = mask.
      BNER  -
      BHR   -
      BNHR  -

?BCT
  BCT   :(RS) - BRANCH ON COUNT.
! 2                             b
  1)   BCT     R1,D2(X2,B2)            - explicit

  2)   BCT     R1,DATA                 - implicit

  Decrements operand "A" by 1 and tests result for 0. If not 0 then
  branches to label. If 0 then it falls thru.

  NOTE - Decrements first and then tests.

  eg.
          LA    R6,1000
          LA    R5,EMPTABLE
  LOOP    CLC   ARG(6),0(R5)
          BE    KEYFND
          LA    R5,22(R5)       increment R5 by 22 (length of tbl ent.)
          BCT   R6,LOOP
  KEYFND  EQU   *

?C
  C     :(RX) - COMPARE.
! 2                     b
  1)   C       R1,D2(B2)

  2)   C       R1,LAB2

  3)   C       R1,=CL4'string'

       where - LAB2 is compared against register.
             - Rx is "A" operand.
             - LAB2 is "B" operand.

             A < B : BL (branch low)     { Ascertained by the 2 "CC"
             A > B : BH (branch high)     {bits in the PSW. Has 4
             A = B : Be (branch equal)    {states 00,01,10/11.

?CH
  CH    :(RX) - COMPARE HALFWORD.
! 2                              b
  1)   CH      R1,D2(B2)

  2)   CH      R1,LAB2

  3)   CH      R1,=CL2'string'

       where - LAB2 is compared against register.
             - Rx is "A" operand.
             - LAB2 is "B" operand.

             A < B : BL (branch low)     { Ascertained by the 2 "CC"
             A > B : BH (branch high)     {bits in the PSW. Has 4
             A = B : Be (branch equal)    {states 00,01,10/11.

?CL
  CL    :(RX) - COMPARE LOGICAL.
! 2                             b
  1)   CL      R1,D2(B2)

  2)   CL      R1,LAB2

  3)   CL      R1,=CL4'string'

       where - LAB2 is compared against register.
             - Rx is "A" operand.
             - LAB2 is "B" operand.

             A < B : BL (branch low)     { Ascertained by the 2 "CC"
             A > B : BH (branch high)     {bits in the PSW. Has 4
             A = B : Be (branch equal)    {states 00,01,10/11.

?CLC
  CLC   :(SS) - COMPARE LOGICAL CHARACTER.
! 2                                       b
  1)   CLC     D1(L1,B1),D2(B2)

  2)   CLC     LAB1(length),LAB2

  3)   CLC     LAB1(length),=Cl'string'

       where - LAB2 is compared against LAB1.
             - LAB1 is "A" operand.
             - LAB2 is "B" operand.

             A < B : BL (branch low)     { Ascertained by the 2 "CC"
             A > B : BH (branch high)     {bits in the PSW. Has 4
             A = B : Be (branch equal)    {states 00,01,10/11.

  NOTE - CLC   A(0),B   ===>  compares 256 bytes.

  CLI   :(SI) - COMPARE LOGICAL IMMEDIATE.
! 2                                       b
  1)   CLI     D2(B2),I1               - explicit

  2)   CLI     LABEL,C'A'              - implicit

  By definition, the source field is 1 byte long.

  CP    :(SS) - COMPARE PACKED/DECIMAL.
! 2                                    b
  1)   CP      D1(L1,B1),D2(L2,B2)

  2)   CP      LAB1(L1),LAB2{(L2)}

  The result is the setting of condition codes.

  CR    :(RR) - COMPARE REGISTER.
! 2                              b
  1)   CR      R1,R2                   - explicit

  ===> A - B => throws the result away but sets condition codes.

  CVB   :(RX) - CONVERT TO BINARY.
! 2                               b
  1)   CVB     R1,D2(X2,B2)            - explicit

  2)   CVB     R1,DWORD                - implicit

  Result in "A" operand.

  NOTE - R0 can be used for arithmetic; eg.     CVB   R0,DWORD.
       - Converts a DOUBLE WORD into a full word binary integer.

  CVD   :(RX) - CONVERT TO DECIMAL.
! 2                                b
  1)   CVD     R1,D2(X2,B2)            - explicit

  2)   CVD     R1,DWORD                - implicit

  Result in double word "B" operand.

  NOTE - Converts a full word binary integer into a double word.

?d
  D     :(RS) - DIVIDE.
! 2                    b
  1)   D       R1,D2(X2,D2)            - explicit

  2)   D       R1,FDATA                - implicit

  ===> B + A => A.

  NOTE - Same as DR except "B" operand is a full word memory location.

  DP    :(SS) - DIVIDE PACKED/DECIMAL.
! 2                                   b
  1)   DP    D1(L1,B1),D2(L2,B2)       - explicit

  2)   DP    LAB1(L1),LAB2(L2)         - implicit

    RULES - "B" operand length less than/equal to 8.
          - "A" operand length greater than "B".
          - The Quotient and Remainder goes into "A".
          - Lq = La - Lb
          - Lr = Lb

    ie.   DP  A(4),B(3)  ===>  A =  Q R R R

  DR    :(RR) - DIVIDE REGISTER.
! 2                             b
  1)   DR      R1,R2                   - explicit

  Uses EVEN/ODD pair. Register "A" MUST be even, the odd is assumed.

  Eg.  DR      R4,R1
                                  R1
                                   - - - - - - - - - - - - - - - -
                                  ¦        Divisor                ¦
                                   - - - - - - - - - - - - - - - -
   R4                             R5
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ¦          Remainder            ¦        Quotient               ¦
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   <---------------------- Dividend ------------------------------>

  NOTE - Cannot have a divisor of 0. Have to watch magnitude as if the
         remainder or quotient will not fit into a register it will
         blow up.

  REQO - Remainder even Quotient odd.

  DSECT
! 2    b
  DSECTS map a chunk of memory "using" a defined base register.
  Used to assign displacements. When DSECT is encountered, location is
  reset to 0.

  Addr
         TABLENT DSECT
  0000           DS      CL1
  0001   NAME    DS      CL20
  0021           DS      CL2
  0023   CODE    DS      CL20
  0043   LINK    DS      A
                 END
                 ....
                 LA      R4,TABLE
                 USING   TABLENT,R4
         LOOP    EQU     *
                 CLI     FLAG,TABLEEND
                 BE      TBFULL
                 CLI     FLAG,ENTUSD
                 BE      NEXT
                 MVC     NAME(20),NEWNAME
                 B       INSERTED
         NEXT    EQU     *
                 L       R4,LINK
                 B       LOOP
         ENDIT   DROP    R4      when finished with DSECT drop reg

?E
  ED  :(SS1) - EDIT.
! 2                 b
  1)   ED    D1(L1,B1),D2(B2)          - explicit

  2)   ED    LAB1(L1),LAB2             - implicit

       Operand "B" is 'mapped' into "A" ==> result in "A".

    RULES - X'21' = Significant start (Turned on AFTER operation).
          - X'20' = Digit select.

   PATTERN : First byte = fill character.
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ¦4 0¦2 0¦2 0¦6 B¦2 0¦2 1¦2 0¦4 B¦2 0¦2 0¦4 0¦C 3¦D 9¦
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        d   d   ,   d   s   d   .   d   d       C   R

   Result :
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ¦sp ¦sp ¦ 2 ¦ , ¦ 5 ¦ 7 ¦ 4 ¦ . ¦ 2 ¦ 6 ¦sp ¦sp ¦sp ¦
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

   VALUE :
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ¦0 2¦5 7¦4 2¦6 C¦
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

   Leading zeros are suppressed and filled with fill character. Signi-
   ficance is automatically turned on by a non zero digit. If signifi-
   cant start is encountered, and is already on, it is treated as a
   digit select.

   If last char of "VALUE" is +ve => Significance off.
   If last char of "VALUE" is -ve => Significance on.

   NOTE - Action of ED destroys the pattern. Therefore must be copied.

   Eg.    MVC   DEST(8),PATTEN
          ED    DEST(8),SOURCE
          ....
          ....
   DEST   DS    CL8
   PATTEN DC    XL8'40...etc'

  EX    :(RX) - EXECUTE.
! 2                     b
  1)   EX    R1,D2(X2,B2)              - explicit

  2)   EX    R1,LABEL                  - implicit

  Temporarily executes one instruction out of sequence. Eg. branch and
  link for 1 instruction to that at address of LABEL.

  Takes the low order byte of "A" operand and "OR"s it against the
  length field of SS1 instruction => variable length. Therefore length
  should be 0 or 1.

  Eg.
             EX    R2,MOVEXX
             ....
             ....
             B     BYPASS                  do not pass through the code
    MOVEXX   MVC   3(0,R2),0(R5)
    BYPASS   DS    0H

       ===>  OP ¦ L1 ¦ B1 ¦ D1 ¦ B2 ¦ D2
             ---¦----¦----¦----¦----¦----
             D2 ¦ 0  ¦ 2  ¦003 ¦ 5  ¦000 ---¦
                                            ¦
      ( R2 = xx xx xx 22 ) <-- OR ----------'

       ===>  D2 ¦ 22 ¦ 2  ¦003 ¦ 5  ¦000

   Modifies the second byte of all instructions by the last byte of
   specified register.


   NOTE - The length field in a MVC instruction is always 1 less than
          coded as it is relative to 0.

?I
  IC    : (RX) - INSERT CHARACTER.
! 2                               b
  1)   IC     R1,D2(X2,B2)              - explicit

  2)   IC     R1,DATA                   - implicit

  Takes the "A" operand and the first byte of data specified by the "B"
  operand and inserts it in the right most caharacter.

   R1                                DATA
   - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - -
  ¦       ¦       ¦       ¦       ¦ ¦       ¦       ¦       ¦       ¦
   - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - -
                              /¦\       ¦
                               '--------'

  ICM   : (RS) - INSERT CHARACTER UNDER MASK.
! 2                                          b
  1)   ICM    R1,M1,D2,(B2)             - explicit

  2)   ICM    R1,mask,DATA              - implicit

  Operand "A" is the destination. The mask is the map of the bytes in
  the register(A) that is to receive the bytes from operand "B".

  Eg.    ICM   R4,B'0101',DATA
   R4 0       1       2       3
   - - - - - - - - - - - - - - - -
  ¦       ¦       ¦       ¦       ¦
   - - - - - - - - - - - - - - - -
           /                /
         /         /------/
   DATA/         /
   - - - - - - - - - - - - - - - -
  ¦  3 C  ¦  A F  ¦  7 D  ¦  3 E  ¦
   - - - - - - - - - - - - - - - -

  NOTE - The mask patern only applies to registers and not to the memory
         location.

?L
  L     :(RS/RX) - LOAD.
! 2                     b
  1)   L       R1,D2(B2)               - explicit
       L       R1,D2(X2,B2)

  2)   L       R1,FWORD                - implicit

  Loads fullword "B" into "A", totally replacing "A" witb "B".

  LA    :(RX) - LOAD ADDRESS.
! 2                          b
  1)   LA      R1,D2(B2)               - explicit

  2)   LA      R1,DATA                 - implicit

  Takes the effective address of "B" operand and loads it into "A".
  Effective address is at execution time.

  eg.  LA   R5,6(R5)  ===> increment R5 by 6.
       LA   R5,6      ===> implied R0 as "B" operand which is as a base
                           register = 0. Therefore add 6 to 0 ===> set
                           constant 6 in R5.

  AS address is 24 bits, the high order 8 bits are cleared. It is
  treated as a number and is used as an address when we tell to go and
  get it.

  NOTE - Register 0 can never be used in a base displacement calcn.
         Irrespective of value, R0 will always yield 0.

  LH    :(RS/RX) - LOAD HALFWORD.
! 2                              b
  1)   LH      R1,D2(B2)               - explicit
       LH      R1,D2(X2,B2)

  2)   LH      R1,HWORD                - implicit

  Loads halfword "B" into "A", totally replacing "A" witb "B".
  Stores 16 bits into 32 bits and propogates the sign thru 16 to upper
  16 bits.

                                   - - - - - - - - - - - - - - - -
                                  ¦s¦          15 bits            ¦
                                   - - - - - - - - - - - - - - - -
                                                ||
                                                \/
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ¦ ¦   sign propogated             ¦                             ¦
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  LM    :(RS) - LOAD MULTIPLE.
! 2                           b
  1)   LM      R1,R2,D3(B3)            - explicit

  2)   LM      R1,R2,LABEL             - implicit

  R1 and R2 represent the start and end registers respectively. If R1
  is greater than r2, then wraparoung occurs after R15.

  eg.  LM   R14,R12,SAVEAREA+12

      R14     R15     R0      R1
      - - - - - - - - - - - - - - - -
     ¦       ¦       ¦       ¦       ¦
      - - - - - - - - - - - - - - - -
      /¦\      /¦\     /¦\     /¦\
   SAVEAREA+12  ¦       ¦       ¦
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ¦       ¦       ¦       ¦       ¦
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  LNR   :(RR) - LOAD NEGATIVE REGISTER.
! 2                                    b
  1)   LPR     R1,R1                   - explicit

  LPR   :(RR) - LOAD POSITIVE REGISTER.
1 2                                    b
  1)   LPR     R1,R1                   - explicit

  LTORG
! 2    b
  Controls where the current literal pool gets dumped.

     If:           ONE  DC 'F1'
                   ....
                        L  R5,ONE    same as L  R5,=F'1'

  The default literal pool is before the END statement.
  Suggest:
     < last instruction>
     LTORG
     < first DC/DS     >

  LTR   :(RR) - LOAD AND TEST REGISTER.
! 2                                    b
  1)   LTR     R1,R2                   - explicit

  Copies the "B" operand to "A" and sets condition code. Usually used
  to test return codes from MVS.

?M
  M     :(RS) - MULTIPLY.
! 2                      b
  1)   M       R1,D2(X2,D2)            - explicit

  2)   M       R1,FDATA                - implicit

  ===> B + A => A.

  NOTE - Same ar MR except "B" operand is a full word memory location.

  MH    :(RX) - MULTIPLY HALFWORD.
! 2                               b
  1)   MH      R1,D2(X2,D2)            - explicit

  2)   MH      R1,HDATA                - implicit

                                  HDATA
                                   - - - - - - - - - - - - - - - -
                                  ¦        Multiplier             ¦
                                   - - - - - - - - - - - - - - - -
                                  R6
                                   - - - - - - - - - - - - - - - -
                                  ¦        Multiplicant           ¦
                                   - - - - - - - - - - - - - - - -
                                  <----------- Product ----------->

  NOTE - Product stored as 1 word and will not give an indication of
         overflow.

  MP    :(SS) - MULTIPLY PACKED/DECIMAL.
! 2                                     b
  1)   MP    D1(L1,B1),D2(L2,B2)       - explicit

  2)   MP    LAB1(L1),LAB2(L2)         - implicit

    RULES - "B" operand length less than/equal to 8.
          - "B" operand length less than "A".
          - Must have as many bytes of leading zeros in "A" as length of
            "B".

    ie.   00 00 11 1C      00 00 1C
          <=2=>     not =  <== 3 =>   Therefore will not work.

  MR    :(RR) - MULTIPLY REGISTER.
! 2                               b
  1)   MR      R1,R2                   - explicit

  Uses EVEN/ODD pair. Register "A" MUST be even, the odd is assumed.

  Eg.  MR      R4,R1
                                  R1
                                   - - - - - - - - - - - - - - - -
                                  ¦        Multiplier             ¦
                                   - - - - - - - - - - - - - - - -
   R4                             R5
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ¦                               ¦        Multiplicant           ¦
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   <---------------------- Product ------------------------------->

  NOTE - Overflow cannot occur.

  MVC   :(SS) - MOVE CHARACTER.
! 2                            b
  1)   MVC     D1(l,B1),D2(B2)             - explicit }  Can mix the two

  2)   MVC     LAB1(length),LAB2           - implicit }  formats.

  3)   MVC     LAB1(length),=Cl'string'    - implicit

       where - LAB1 = begining of destination address
               LAB2 = start of source location

  NOTE - Avoid using implicit length. Specify length to move.

  MVI   :(SI) - MOVE IMMEDIATE.
! 2                            b
  1)   MVI     D2(B2),I1               - explicit

  2)   MVI     LABEL,C'A'              - implicit

  By definition, the source field is 1 byte long.

  MVCL  :(RR) - MOVE CHARACTER LONG.
! 2                                 b
  1)   MVC     R1,R2                       - explicit

  Both "A" and "B" operands represent an EVEN/ODD register pair each.

   Ra                                  Rb
   - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - -
  ¦///////¦  destination address    ¦ ¦///////¦  source address     ¦
   - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - -
   Ra + 1                              Rb + 1
   - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - -
  ¦///////¦  destination length     ¦ ¦  pad  ¦  source lenght      ¦
   - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - -

  NOTE - If operands overlap, it won't work.

?N
  N     :(RX) - AND.
! 2                 b
  1)   N      R1,D2(X2,B2)            - explicit

  2)   N      R1,FDATE                - implicit

  Operates on "A" and "B" and stores result in "A".

  NC    :(SS) - AND CHARACTER.
! 2                           b
  1)   NC     D1(L1,B1),D2(B2)        - explicit

  2)   NC     LAB1(L1),mask           - implicit

  Operates on "A" and "B" and stores result in "A".

  NI    :(SI) - AND IMMEDIATE.
! 2                           b
  1)   NI      D2(B2),I2               - explicit

  2)   NI      LABEL,X'FE'             - implicit

  NR    :(RR) - AND REGISTER.
! 2                          b
  1)   NR     R1,R2                   - explicit

  Operates on "A" and "B" and stores result in "A".

?O
  O     :(RX) - OR.
! 2                b
  1)   O      R1,D2(X2,B2)            - explicit

  2)   O      R1,FDATE                - implicit

  Operates on "A" and "B" and stores result in "A".

  OC    :(SS) - OR CHARACTER.
! 2                          b
  1)   OC     D1(L1,B1),D2(B2)        - explicit

  2)   OC     LAB1(L1),mask           - implicit

  Operates on "A" and "B" and stores result in "A".

  OI    :(SI) - OR IMMEDIATE.
! 2                          b
  1)   OI      D2(B2),I2               - explicit

  2)   OI      LABEL,X'FE'             - implicit

  OR    :(RR) - OR REGISTER.
! 2                         b
  1)   OR     R1,R2                   - explicit

  Operates on "A" and "B" and stores result in "A".

  ORG
! 2  b
  Eg.
     Addr
     1000  PRLINE    DC    CL133' '
     1133            ORG   PRLINE resets loc to addr PRLINE (redefines)
     1000            DS    CL1
     1001  PRNUMB    DS    CL10
     1011            DS    CL1
     1012            DS    CL10
     1022            ORG          resets to ORG TARGET (ie. 1133)
     1133

?P
  PACK  :(SS) - PACK.
! 2                  b
  1)   PACK    D1(L1,B1),D2(L2,B2)     - explicit

  2)   PACK    DATA1(L1),DATA2(L2)     - implicit

  Result in "A" operand. PACK is performed into a double word.

  Eg.  PACK    DWORD(8),VALUE(5)

   DWORD                              VALUE
   - - - - - - - - - - - - - - - -     - - - - - - - - - -
  ¦0 0¦0 0¦0 0¦0 0¦0 0¦0 9¦6 5¦2 F¦   ¦F 0¦F 9¦F 6¦F 5¦F 2¦
   - - - - - - - - - - - - - - - -     - - - - - - - - - -
   +0  +1  +2  +3  +4  +5  +6  +7

?S
  S     :(RS) - SUBTRACT.
! 2                      b
  1)   S       R1,D2(X2,D2)            - explicit

  2)   S       R1,FDATA                - implicit

  ===> B - A => A.

  NOTE - Same as SR except "B" operand is a full word memory location.

  SH    :(RX) - SUBTRACT HALFWORD.
! 2                               b
  1)   SH      R1,D2(X2,D2)            - explicit

  2)   SH      R1,FDATA                - implicit

  ===> B - A => A.

  NOTE - Only 16 bits are used.

  SL    :(RX) - SUBTRACT LOGICAL.
! 2                              b
  1)   SL    R1,D2(X2,B2)              - explicit

  2)   SL    R1,FWORD                  - implicit

    Result stored in operand "A". Used to clear registers. Faster than
    SR as it doesn't have to worry about signs.

    Condition codes set:    0 - Sum is 0 with NO borrow.
                            1 - Sum is not 0 with NO borrow
                            2 - Sum is 0 with borrow.
                            3 - Sum is not 0 with borrow.

  SLA/SRA : (RS) - SHIFT LEFT/RIGHT SINGLE ARITHMETIC.
! 2                                                   b
  1)   SLA    R1,D2(B2)                 - explicit

  2)   SRA    R1,number                 - implicit

  Looks at register as a signed binary number. The sign does not
  participate in the shift and stays put. However, overflow occurs
  if bit shifted out is not equal to the sign bit. With SRA, the sign
  bit is propogated in the shift.

  SLDL/SRDL : (RS) - SHIFT LEFT/RIGHT DOUBLE LOGICAL.
! 2                                                  b
  1)   SLDL   R1,D2(B2)                 - explicit

  2)   SRDL   R1,number                 - implicit

  Uses EVEN/ODD pair of registers, with the even specified as "A".

   Eg.
                             R6 R7
            0 ------>  - - - - - - - - - - - - - - - -   -----> bb
                      ¦0 0¦0 0¦0 0¦0 8¦0 0¦0 0¦0 0¦0 0¦
  bit bucket <------   - - - - - - - - - - - - - - - -  <----- 0
                                     <->

  SLL/SRL : (RS) - SHIFT LEFT/RIGHT SINGLE LOGICAL.
! 2                                                b
  1)   SLL   R1,D2(B2)                 - explicit

  2)   SRL   R1,number                 - implicit

  "B" operand signifies the number of bits to shift. In format "2", the
  low order 6 bits of the "B" operand are used.

   Eg.
                             R6
                  0 ------>  - - - - - - - -  -----> bit bucket
                            ¦0 0¦0 0¦0 0¦0 8¦
        bit bucket <------   - - - - - - - - <----- 0

       SLL   R6,1     ,  0000 1000 ====> 0001 0000

   NOTE - Much faster than divide.

  SLR   :(RR) - SUBTRACT LOGICAL REGISTER.
! 2                                       b
  1)   SLR   R1,R2                     - explicit

    Result stored in operand "A". Used to clear registers. Faster than
    SR as it doesn't have to worry about signs.

    Condition codes set:  (Refer to SL.)

  SP    :(SS) - SUBTRACT PACKED/DECIMAL.
! 2                                     b
  1)   SP    D1(L1,B1),D2(L2,B2)       - explicit

  2)   SP    LAB1(L1),LAB2(L2)         - implicit

    Result stored in operand "A".

    NOTE - Overflow will cause program inrerrupt.

  SR    :(RR) - SUBTRACT REGISTER.
! 2                               b
  1)   SR      R1,R2                   - explicit

  ===> A - B => A.

  ST    :(RS/RX) - STORE.
! 2                      b
  1)   ST      R1,D2(B2)               - explicit
       ST      R1,D2(X2,B2)

  2)   ST      R1,FWORD                - implicit

  Stores fullword "A" into "B", totally replacing "B" witb "A".

  STC   : (RX) - STORE CHARACTER.
! 2                              b
  1)   STC    R1,D2(X2,B2)              - explicit

  2)   STC    R1,DATA                   - implicit

  Takes the "B" operand and the last byte of data specified by the "A"
  operand and inserts it in the left most caharacter.

   R1                                DATA
   - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - -
  ¦       ¦       ¦       ¦       ¦ ¦       ¦       ¦       ¦       ¦
   - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - -
                               ¦       /¦\
                               '--------'

  STCM  : (RS) - STORE CHARACTER UNDER MASK.
! 2                                         b
  1)   STCM   R1,M1,D2,(B2)             - explicit

  2)   STCM   R1,mask,DATA              - implicit

  Operand "B" is the destination. The mask is the map of the bytes in
  the register(A) that is to pass the bytes to operand "B".

  Eg.    ICM   R4,B'0101',DATA

   R4 0       1       2       3
   - - - - - - - - - - - - - - - -
  ¦  7 6  ¦  A A  ¦  F 3  ¦  6 c  ¦
   - - - - - - - - - - - - - - - -
           /                /
         /         /------/
   DATA/         /
   - - - - - - - - - - - - - - - -
  ¦  A A  ¦  6 C  ¦       ¦       ¦
   - - - - - - - - - - - - - - - -

  NOTE - The mask patern only applies to registers and not to the memory
         location.

  STH    :(RS/RX) - STORE HALFWORD.
! 2                                b
  1)   STH     R1,D2(B2)               - explicit
       STH     R1,D2(X2,B2)

  2)   STH     R1,HWORD                - implicit

  Stores halfword "A" into "B", totally replacing "B" witb "A".

  STM   :(RS) - STORE MULTIPLE.
! 2                            b
  1)   STM     R1,R2,D3(B3)            - explicit

  2)   STM     R1,R2,LABEL             - implicit

  R1 and R2 represent the start and end registers respectively. If R1
  is greater than r2, then wraparoung occurs after R15. Arse about of
  LM.

  eg.  STM  R14,R12,12(R13)            - save callers registers

      SAVEAREA (18 x 4 byte area)
      - - - - - - - -
   0 ¦  PL1 VECTOR   ¦
      - - - - - - - -
  +4 ¦  BWD LINK     ¦
      - - - - - - - -
  +8 ¦  FWD LINK     ¦ <==== Store R13
      - - - - - - - -
  +12¦     R14       ¦
      - - - - - - - -       NOTE - R13 is assumed by MVS to point to a
     ¦     ...       ¦             register save area.
      - - - - - - - -            - R15 is the default entry point.
     ¦     ...       ¦
      - - - - - - - -
  +64¦     R12       ¦
      - - - - - - - -

  On entry to a program:

  MYPROG1 CSECT
          STM    R14,R12,12(R13)        Store callers regs
          USING  MYPROG1,R15            Use R15 as temporary base
          ST     R13,MYSAVE+4           Store callers R13 in my savearea
          LA     R12,MYSAVE             Load address of my savearea
          ST     R12,8(R13)             Store address of my save in
 *                                        callers save area
          LR     R13,R12                Point R13 to my savearea
          LR     R12,R15                Load R12 with default entry
          DROP   R15                    Drop R15 as base
          USING  MYPROG1,R12            Use R12 as permanent base

  Two base regs:

  MYPROG1 CSECT
          .....                         Save callers etc...
          .....
          LR     R11,R15                Load R12 with default entry
          LA     R12,4095(R11)          Point 2nd. base at +4096
          LA     R12,1(R11)                from first base
          DROP   R15                    Drop R15 as base
          USING  MYPROG1,R11,R12        Use R11 & R12 as permanent base


?T
  TM    :(SI) - TEST UNDER MASK.
! 2                             b
  1)   TM      D1(B1),I1               - explicit

  2)   TM      FLAG,$SEND              - implicit

    Eg.   F3     1111 0011
          mask   0000 0010

    CC returned: all 0       Branch cond ==>     BZ BNZ
                                                   X
                 all 1                           BO BNO
                 mixed                           BM BNM

    Example:
              TM   0(R4),ENTRYUSED
              BZ   INSERT
              BO   NEXT
              BM   TABLFUL
       all 1 etc... are bits in R4.

  TR    : (SS1) - TRANSLATE.
1 2                         b
  1)   TR     D1(L1,B1),D2(B2)          - explicit

  2)   TR     TARGET(L1),SOURCE         - implicit

  Eg:
       TR   TARGET(6),TABLE

       TARGET = 0E 12 15
          ==> Effective Address (of table) + 0E = Target Address (of
                                                  is to be moved).

  Field (target) contains effective address of source byte to be moved
  (one at a time).

     eg. If target has value X'0E'

         equivalent to ===>     MVI   TARGET,SOURCE+'0E'

  Useful routine for printing out packed format in character format:
  Example:

        WORK    DS    CL5
        WORK2   DS    CL9
        NCFIELD DC    X'0F0F0F0F0F0F0F0F'
        TRTABLE DC    C'0123456789ABCDEF'
        MEMORYL DC    A(= to 1000)
        at 1000       12 37 4C FA 6D 78
        ...
                L     R4,MEMORYL
                MVC   WORK(4),0(R4)     ===> 12 37 4C FA
                UNPK  WORK2(9),WORK(5)  ===> F1 F2 F3 F7 F4 FC FF FA
                NC    WORK2(8),NCFIELD  ===> 01 02 03 07 04 0C 0F 0A
                TR    WORK2(8),TRTABLE  ===> F1 F2 F3 F7 F4 C3 C6 C1

  TRT   : (SS1) - TRANSLATE AND TEST.
! 2                                  b
  1)   TRT    D1(L1,B1),D2(B2)          - explicit

  2)   TRT    TARGET(L1),SOURCE         - implicit

  Eg:
       TRT  SOURCE(6),TABLE

  TABLE contains a set of function bytes. Invalid bytes are set
  to X'00' while valid bytes are non zero.

  Processing logic is the same as for TR (translate) except :
     - no substitution is made (only testing)
     - when the first non-zero function byte is encountered, the TRT
       command is terminated
     - the function byte is inserted in R2 (via IC command so the
       leftmost 3 bytes remain unchanged)
     - the source byte's address in R1
     - condition code 1 is set.

  If no match is found, condition code of 0 is set and R1 and R2 remain
  unchanged.


?U
  UNPK  :(SS) - UNPACK.
! 2                    b
  1)   UNPK    D1(L1,B1),D2(L2,B2)     - explicit

  2)   UNPK    DATA1(L1),DATA2(L2)     - implicit

  Result in "A" operand. Swaps the last two nibbles and puts an "F" in
  front of the rest.

  Eg.  UNPK    VALUE(5),DWORD+5(3)

       NOTE - When originally packed, packed into double word (8 bytes)
              however when unpacking into 5 bytes, L5 packs into 3,
              therefore take the last 3 of the double word.

  Example:
      NUMBER   DS     D
      CUBE     DS     D
      SQUARE   DS     D
               LA     R9,1               set up star value
               LA     R10,50             set up loop counter (50)
      LOOP     EQU    *
               LR     R5,R9              load # to be calculated
               MR     R4,R9              square #
               CVD    R5,SQUARE          convert square to decimal
               UNPK   PRSQUARE(8),SQUARE+5(3)  unpack square to print
               CVD    R9,NUMBER          convert number to decimal
               UNPK   PRNUMBER(8),NUMBER+6(2)  unpack decim to print
               MR     R4,R9              cube #
               CVD    R5,CUBE
               UNPK   PRCUBE(8),CUBE+4(4)
               BAL    R14,PRINTIT
               LA     R9,1(R9)
               BCT    R10,LOOP
      FINISHED EQU    *
               ....
               ....
      PRINTIT  EQU    *
               ....
               ....
               BR     R14

?X
  X     :(RX) - XOR.
! 2                 b
  1)   X      R1,D2(X2,B2)            - explicit

  2)   X      R1,FDATE                - implicit

  Operates on "A" and "B" and stores result in "A".

  XC    :(SS) - XOR CHARACTER.
! 2                           b
  1)   XC     D1(L1,B1),D2(B2)        - explicit

  2)   XC     LAB1(L1),mask           - implicit

  Operates on "A" and "B" and stores result in "A".

  XI    :(SI) - XOR IMMEDIATE.
! 2                           b
  1)   XI      D2(B2),I2               - explicit

  2)   XI      LABEL,X'FE'             - implicit

  XR    :(RR) - XOR REGISTER.
! 2                          b
  1)   XR     R1,R2                   - explicit

  Operates on "A" and "B" and stores result in "A".


?Z
  ZAP   :(SS) - ZERO ADD PACKED.
! 2                             b
  1)   ZAP     D1(L1,B1),D2(L2,B2)     - explicit

  2)   ZAP     DATA1(L1),DATA2(L2)     - implicit

  Operand "A" is initialised to zero and then operand "B" is moved
  into operand "A". As a common practice, this instruction is often used
  to establish a longer field to avoid overflows. Often apply the ZAP
  instruction jointly with Multiply Packed(MP).

  Eg.  ZAP     DWORD(8),VALUE(4)

