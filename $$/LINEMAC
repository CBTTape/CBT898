/******************************** REXX ********************************/
/* )X  LINEMAC.COMMANDS(LINEMAC) <- Output (created if NF)            */
/* )I  $$              <- Infrastructure                              */
/*--------------------------------------------------------------------*/
lmac_R:lm1_ver='V3.05'                      /* LM1 copybook version   */
    Parse SOURCE . xenv xcmd# xdd xdsn .
    def_exit_rc=0                           /* Default exit return RC */
    next_exit='LMEXITAK'                    /* Next exit in chain     */
    help_expd='LMHELP00'                    /* Expanded HELP driver   */
                                            /* Leave blank if none.   */
    Signal Process

l_3:ms=mark(1) /* Super Search launcher
)M LMQS
)RC 4
*/; End_3:me=mark(-1);Return put_lines()

l_4:ms=mark(1) /* Repeat last LINEMAC command
)RC 4
*/; End_4:me=mark(-1);Return put_lines()

Start_User_Code:
/*--------------------------------------------------------------------*/
/* Place code between labels "Start_User_Code:" and "End_User_Code:". */
/* For valid Control Characters (CC) and syntax enter "HELP+" as a    */
/* line command.                                                      */
/*--------------------------------------------------------------------*/
User_Code_ver='2.02'
l_AL: /* All those alpha, national combinations you always wanted */
    uc='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    lc='abcdefghijklmnopqrstuvwxyz'
    nu='0123456789'
    na='@#$'
    x=n_b("uc='"uc"'")
    x=n_b("lc='"lc"'")
    x=n_b("mc='"uc||lc"'")
    x=n_b("an='"uc||nu"'")
    x=n_b("nc='"uc||nu||na"'")
    x=n_b("ac='"uc||lc||nu||na"'")
    "CURSOR =" line# 0
    zedlmsg='Use "MD" line command to convert noteline to data.'
    Address ISPEXEC "SETMSG MSG(ISRZ001)"
    Return 0
End_AL:

l_PZCMD:ms=mark(1) /* Parse ZCMD
)A 4
)NB Parse VAR zcmd cmd parm1 parm2 parm3 parm4 parm5 .,
)NB           1 cmd11 +1 1 cmd12 +2 1 cmd13 +3 1 cmd14 +4 1 cmd15 +5 .
)RC 4
*/; End_BER:me=mark(-1);Return put_lines()

l_BD:           /* Browse/View/Edit DSN from line using CMD(%XB) */
l_ED:           /* Browse/View/Edit DSN from line using CMD(%XB) */
l_VD:ms=mark(1) /* Browse/View/Edit DSN from line using CMD(%XB)
)R x=XB("/"Substr(lcmd,1,1))
)C 0,0
)RC 0
*/; End_BD:me=mark(-1);Return put_lines()

l_BER:ms=mark(1) /* Genarate NOTELINES for REXX Browse ERror
)A 1
)NB    Call ON Error Name br_err1
)NB    "ISPEXEC BROWSE DATAID(&DATAID1) MEMBER(&PARM1)"
)NB    "ISPEXEC BROWSE DATASET('&DSN(&MEMBER)')"
)NB    Call Off Error
)NB    ......
)NB
)NBbr_err1: If rc>4 Then "ISPEXEC SETMSG MSG(&ZERRMSG)";Return 4
)RC 4
*/; End_BER:me=mark(-1);Return put_lines()

l_BM:          /* Browse/Edit/View memb from line using MAC(LMPRMEMB) */
l_EM:          /* Browse/Edit/View memb from line using MAC(LMPRMEMB) */
l_VM:          /* Browse/Edit/View memb from line using MAC(LMPRMEMB) */
l_BMC:         /* Browse/Edit/View memb at cursor using MAC(LMPRMEMB) */
l_EMC:         /* Browse/Edit/View memb at cursor using MAC(LMPRMEMB) */
l_VMC:ms=mark(1) /* Browse/Edit/View memb at cursor using MAC(LMPRMEMB)
)M LMPRMEMB LOOK
)C -1
)C 0,0
)RC 4
*/; End_BM:me=mark(-1);Return put_lines()

l_EMP:         /* Edit memb from line using MAC(LMPRMEMB) and PI it   */
l_EMPS:        /* Edit memb from line using MAC(LMPRMEMB) and PIS it  */
    "LMPRMEMB" line#s","line#e","lcmd "LOOK"
    "(caps)=CAPS";"CAPS=OFF";"(statu)=USER_STATE";"(lin#)=LINENUM .ZCSR"
    If #lcmd='EMPS' Then pi=Substr('*-- Progress indicator #2',1,71,'-')'*'
    Else pi=Substr('*-- Progress indicator',1,71,'-')'*'
    "LINE_BEFORE" lin#-1"=(pi)";"LABEL" lin#-2"=.FMARK"
    Do Forever
        "SEEK '"pi"' PREV .ZFIRST .FMARK";If rc/=0 Then Leave
        "DEL .ZCSR .ZCSR"
        lin#=lin#-1
    End
    "USER_STATE=(statu)";"CAPS=(caps)";"CURSOR="lin# 0
    Return 4
End_EMP:

l_MS:           /* Stats memb from line using MAC(LMPRMEMB)           */
l_ST:ms=mark(1) /* Stats memb from "Index" line using MAC(LMPRMEMB)
)M LMPRMEMB STAT
)C -1
)C 0,0
)RC 4
*/; End_MS:me=mark(-1);Return put_lines()

l_SM:           /* Select member with default "sel" uses MAC(LMPRMEMB)*/
l_SMB:          /* Set default "SM" to browse                         */
l_SME:          /* Set default "SM" to edit                           */
l_SMV:          /* Set default "SM" to view                           */
    lmacdsmo=Substr(lcmd,3,1)
    If lmacdsmo='' Then Do
        Address ISPEXEC "VGET (lmacdsmo) PROFILE"
        If lmacdsmo='' Then lmacdsmo='VM'
    End;Else lmacdsmo=lmacdsmo'M'
    Address ISPEXEC "VPUT (lmacdsmo) PROFILE"
    '%LMPRMEMB' line#','line#e','lmacdsmo 'LOOK'
    Return rc
End_MS:

l_DM:            /* Delete memb from line using MAC(LMPRMEMB)         */
l_DMU:ms=mark(1) /* Delete memb from line using MAC(LMPRMEMB) + Update
)M LMPRMEMB DEL
)C -1
)C 0,0
)RC 4
*/; End_DM:me=mark(-1);Return put_lines()

l_RM:            /* Rename memb from line using MAC(LMPRMEMB)         */
l_RMU:ms=mark(1) /* Rename memb from line using MAC(LMPRMEMB) + Update
)M LMPRMEMB REN
)C -1
)C 0,0
)RC 4
*/; End_RM:me=mark(-1);Return put_lines()

l_XM:ms=mark(1)  /* Execute memb from line using MAC(LMPRMEMB)
)M LMPRMEMB EXEC
)C -1
)C 0,0
)RC 4
*/; End_XM:me=mark(-1);Return put_lines()

l_CM:            /* Copy member 'a' to 'b' using MAC(LMPRMEMB)        */
l_CMU:ms=mark(1) /* Copy member 'a' to 'b' using MAC(LMPRMEMB) + Update
)M LMPRMEMB COPYTO
)C -1
)C 0,0
)RC 4
*/; End_CM:me=mark(-1);Return put_lines()

l_KM:            /* superc (Kompare) Memb from line using MAC(LMPRMEMB)  */
l_SCM:ms=mark(1) /* SuperC Memb from line using MAC(LMPRMEMB)
)M LMPRMEMB SUPERC
)C -1
)C 0,0
)RC 4
*/; End_KM:me=mark(-1);Return put_lines()

l_CP:ms=mark(1) /* Copy member (1st. word) from same PDS after cursor (LMPRMEMB)
)M LMPRMEMB COPY
)C -1
)C 0,0
)RC 4
*/; End_CP:me=mark(-1);Return put_lines()

l_SUBM:ms=mark(1) /* Submit member - Macro(LMPRMEMB)
)M LMPRMEMB SUBM
)C -1
)C 0,0
)RC 4
*/; End_SUBM:me=mark(-1);Return put_lines()

l_BOX:ms=mark(1) /* Create a 'BOX' block
)E /*--------------------------------------------------------------------*/
)E /* Change this text to valid comments...                              */
)E#/*                                                                    */
)E /*--------------------------------------------------------------------*/
)C +1
)A 5
)N Insert code to be "boxed" and make next line data with "MD".
)A 1
)N /*--------------------------------------------------------------------*/
)C 2,5
)RC 4
*/; End_BOX:me=mark(-1);Return put_lines()

l_CL:  /* Comment line with '/*...*/' cols 1&71 (toggle, shift NB) */
l_CLC: /* Comment line with '/*...*/,' cols 1&70 (toggle, shift NB) */
l_CLN: /* As for "CL" but only non-excluded lines                   */
l_CLX: /* As for "CL" but only excluded lines                       */
    If Wordpos(lcmd,'CLN CLX')>0 Then Do
        Parse VAR lcmd 3 clxs;If clxs='N' Then clxs='NX'
    End;Else clxs=
    Do i=line#s To line#e
        If clxs/='' Then Do
            "(xs)=XSTATUS" i;If xs/=clxs Then Iterate
        End
        "(line) = LINE" i
        If lcmd='CL' Then Do;trm='*/';ecol=70;End;Else Do;trm='*/,';ecol=69;End
        If Substr(line,1,2)='/*' Then Do
            c1='  ';c2='  '
            If Subword(line,Words(line),1)/=trm Then,
                Interpret "Parse VAR line line '"trm"'"
            Else If Lastpos(trm,line)>0 Then,
                     line=Substr(line,1,Lastpos(trm,line)-1)
        End
        Else Do;If Substr(line,1,2)/='' Then line='  'line;c1='/*';c2=trm;End
        line=Strip(line,'t')
        If Length(line)<ecol Then line=Substr(line,1,ecol);ll=Length(line)
        line=Overlay(c1,line);line=Overlay(c2,line,ll+1)
        "LINE" i "= (line)"
    End
    "CURSOR ="line#s 0
#tr=Trace('o')
    Return 4
End_CL:

l_CLD:ms=mark(1) /* Comment line with doco in 45&71 and cursor placement (No tog
)C 0,49
)O +<45 '/*' 71 '*/'>
)H Insert your own meaningful documentation at the cursor.
*/; End_CLD:me=mark(-1);Return put_lines()

l_DLAST:ms=mark(1) /* Delete last (ex. only, only Terry Pollard would want this
)C L
)D
*/; End_DLAST:me=mark(-1);Return put_lines()

l_EIO:ms=mark(1) /* EXECIO Notelines (quick dirty)
)A 5
)C +1
)N dd='EI'Time('s');ztempf=$ztempf()
)N Address TSO "ALLOC F("dd") DSN('"ztempf"') SHR REU"
)N Address TSO "EXECIO * DISKW "dd" (FINIS"
)N Address TSO "EXECIO * DISKR "dd" (STEM linei. FINIS)"
)N Address TSO "EXECIO * DISKW "dd" (STEM lineo. FINIS)"
)N Address ISPEXEC "CONTROL ERRORS CANCEL"
)N If Index(dsn,'(')>0 Then Do
)N     Address TSO "FREE F("dd")"
)N     Parse VAR dsn dsn '('
)N     If Substr(dsn,1,1)="'" Then dsn=Strip(dsn,,"'")
)N     Else                        dsn=Sysvar(syspref)'.'dsn
)N     Address TSO "ALLOC F("dd") DSN('"dsn"') SHR REU"
)N End
)N Address ISPEXEC "LMINIT DATAID(DATAID) DDNAME("dd")"
)N Address ISPEXEC "EDIT DATAID(&DATAID)"
)N Address ISPEXEC "VIEW DATAID(&DATAID)"
)N Address ISPEXEC "BROWSE DATAID(&DATAID)"
)N Address ISPEXEC "LMFREE DATAID(&DATAID)"
)N Address TSO "FREE F("dd")";xx=$ztempf(ztempf,'D')
)C 1,0
)H Use "MD" line commands to convert Notelines into
)H valid data lines.
)A 1
)C 0,0
)RC 4
*/; End_EIO:me=mark(-1);Return put_lines()

l_EIOL:ms=mark(1) /* EXECIO in loop Notelines using source skip-blocks (memb req
)I(N) $$($EXECIOL) 37-82
)H Use "MD" line commands to convert Notelines into valid data lines.
)C 0,0
)RC 4                    /* Redundant, ")I" by default are once only  */
*/; End_EIOL:me=mark(-1);Return put_lines()

l_FT:ms=mark(1) /* Add File Tailoring dialog (sample, must be customised)
)A 1
    @adr=Address()
)N /*--------------------------------------------------------------------*/
    Address ISPEXEC
    "FTOPEN TEMP"
    "FTINCL &SKELETON"
    "FTCLOSE"
    "VGET ZTEMPF"
    tempsub=ztempf
zcmd='/EDIT'
    If Substr(zcmd,1,2)="/E" Then Do
       Address TSO "ALLOC DD(ZTEMPF) DS('"ztempf"') OLD REU"
       "LMINIT DATAID(DATAID) DDNAME(ZTEMPF)"
       "EDIT DATAID(&DATAID)"
)N     umodelds="'"$alkhlq".REXX(NOTEZED)'"
)N     "VPUT UMODELDS SHARED"
)N     "EDIT DATAID(&DATAID) MACRO(UMODEL)"
       "LMFREE DATAID(&DATAID)"
       Address TSO "FREE DD(ZTEMPF)"
       Address ISPEXEC
    End

    "VPUT (TEMPSUB) SHARED"
    x = MSG(On)
    Address TSO "%TEMPSUB"
    "ISPEXEC VGET (JOBNUMB JOBNAME MESSAGE) SHARED"
    zedlmsg=message
    "SETMSG MSG(ISRZ001)"
    Address(@adr)
)NA/*--------------------------------------------------------------------*/
)H Change data as require, starting at skeleton's name.
)C 4,15
)RC 4
*/; End_FT:me=mark(-1);Return put_lines()

l_GC:ms=mark(1) /* Create a 'General comment' block
)A * +4
)N zedsmsg=
)N zedlmsg='GC009 can be updated with macro "$ISRZ001".'
)N "SETMSG MSG(ISRZ001) MSGLOC(.)"
)N If rc1>4 Then "ISPEXEC SETMSG MSG(&ZERRMSG) MSGLOC(.)"
)N Else rc1=0
)C 1,9
)RC 4
*/; End_GC:me=mark(-1);Return put_lines()

l_ICL:ms=mark(1) /* Insert comment after last (example only 2 demo ")D" function
)C L
)D
)N First note line.
)N Sample Notelines at the end of the text placed in order.
)N Last note line.
)C L
)D *
*/; End_ICL:me=mark(-1);Return put_lines()

l_IF:ms=mark(1) /* Create an 'If,Else' block and a Noteline for the power hungry
)A *
)E If x=y Then Do
)E     aaaa=bbbb
)E End
)E Else Do
)E     aaaa=cccc
)E End
)N If x=y Then Do;a=b;c=d;End;Else Do;b=a;c=d;End /* Faster Exec */
)C 1,8
)RC 4
*/; End_IF:me=mark(-1);Return put_lines()

l_ITS: /* Convert a series of IFs to Select Block */
    "(line) = LINE" line#
    pad=Substr(' ',1,Verify(linec,' ')-1)
    l1=line#
    line=
    linex=pad || 'Select'
    If Substr(line,1,2)='/*' Then Do
        c1='  ';c2='  ';Parse VAr line line '*/'
    End
    Else Do;If Substr(line,1,2)/='' Then line='  'line;c1='/*';c2='*/';End
    line=Strip(line,'t')
    If Length(line)<70 Then line=Substr(line,1,70);ll=Length(line)
    line=Overlay(c1,line);line=Overlay(c2,line,ll+1)
    "LINE" line# "= (line)";"CURSOR ="line# 0
    Return 0
End_ITS:

l_ITW: /* Convert an If to a When */
    Do ii=line#s To line#e
        "CURSOR =" ii 1
        "C 'IF' 'When' .ZCSR .ZCSR"
        "C 'If' 'When' .ZCSR .ZCSR"
        "C 'if' 'When' .ZCSR .ZCSR"
    End
    Return 0
End_ITW:

l_LEV:ms=mark(1) /* Generate macro Level checking code. Use in ")M" destined mac
)A 5
)E "ISREDIT (lev) = MACRO_LEVEL"
)E If lev>1 Then Do
)E     Parse VAR parm# labf ',' labt ',' lcmd parm#
)E End
)N     If labf=labt Then "ISREDIT (labt)=LINENUM .ZLAST"
)C +1
)N Else Do
)A 7
)N (---------------------------------------------------------------)
)N (Change the "parm" value at the cursor to your variable name.   )
)N (Wrap a Do/End block around your original edit macro line range )
)N (detection code.                                                )
)N (You may need to move the "Parse" line to parameter processing  )
)N (and replace the above if with "If lev>1 Then Nop"....          )
)N (---------------------------------------------------------------)
)A 5
)N End
)C 3,19
)RC 4
*/; End_LEV:me=mark(-1);Return put_lines()

l_MK: /* Mark a block for instream NOTELINE Help processing */
 "(##caps##)=CAPS";"CAPS=OFF"
 x=n_b(' ')
 x=n_b("    If parm1='?' Then Signal Help_me;Else Signal Dont_help_me")
 x=n_b(' ')
 x=n_b('Help_me:')
 x=n_b('    "ISREDIT (#member#)=MEMBER"')
 x=n_b('    If rc=0 Then Do;Address ISREDIT;ima_macro=1;End;Else ima_macro=0')
 x='    n_st=mark(2)                            /* Mark Start             */'
 x=n_b(x)
 x=n_b('/*')
 x=n_b(' ')
 x=n_b('  Hello &CNAME..')
 x=n_b(' ')
 #_ls=ls;ls=line#e
 x=n_A("Dont_help_me:    /* Move this to the appropriate place */")
 x="Mark:Arg diff;If \Datatype(diff,'W') Then diff=1;Return sigl+diff"
 x=n_a(x)
 x=n_a('    Return 0')
 x=n_a('    If ima_macro Then "LINE_BEFORE .ZFIRST=NOTELINE (n#)";Else Say n#')
 x=n_a('nl_h:Parse Arg n#')
 x=n_a(' ')
 x=n_a('    Exit')
 x=n_a('    If ima_macro Then Do;"CAPS=(caps)";Address;End')
 x=n_a("    x=nl_h('*'Copies('-',70)'*')")
 x=n_a('    End')
 x=n_a("        x=nl_h('*'Substr(line,1,70)'*')")
 x=n_a('        End')
 x=n_a("            Else Interpret 'line=p1||'var'||p2'")
 x=n_a('            End')
 x=n_a("                Interpret 'line=p1||Substr('var',1,vl)||p2'")
 x=n_a("                If ¬Datatype(vl,'W') Then vl=Length(var)")
 x=n_a("                Parse VAR var var '(' vl ')'")
 x=n_a("            If Index(var,'(')>0 Then Do")
 x=n_a('            Interpret "Parse VAR line p1 ''"chgchar"'' var ''.'' p2"')
 x=n_a('        Do While Index(line,chgchar)>0')
 x=n_a('        line=Sourceline(i)')
 x=n_a('    Do i=n_st To n_en')
 x=n_a("    x=nl_h('*'Centre('ooo000OOOO000ooo',70,'-')'*')")
 x=n_a('    If ima_macro Then Do;Address ISREDIT;"(caps)=CAPS";"CAPS=OFF";End')
 x=n_a("    today=Date('e')")
 x=n_a(' ')
 x=n_a('error_off_1: Signal Off Syntax')
 x='Parse Value $Whoami() With cname sname  /* Toggle as per format   */'
 x=n_a('   ' x)
 x=n_a('    Signal on Syntax Name error_off_1')
 x=n_a("    chgchar='&';cname='there'")
 x=n_a(' ')
 x='    n_en=mark(-2)                           /* Mark End               */'
 x=n_a(x)
 x=n_a('*/')
 x=n_a(' ')
 ls=#_ls
 "CAPS="##caps##
 "CURSOR="line#s 0
 Return 4

End_MK:

l_NAT:ms=mark(1) /* Insert NATional characters as NOTELINES
)T
)A 5
)N nat='ABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890@#$'
)C 0,0
*/; End_NAT:me=mark(-1);Return put_lines()

l_OT:ms=mark(1) /* Insert OutTrap block code - Requires member REXX($OUTT)
)*I(E) $$($OUTT) 1-1
)I $$($OUTT) 1-1
)C 3,19
)RC 4
*/; End_OT:me=mark(-1);Return put_lines()

l_SEL:ms=mark(1) /* Create a 'SELECT' block
)A *
Select
)A 1
)N /*--------------------------------------------------------------------*/
)A *
   When (xxxx=yyyy) Then aaaa=bbbb
   When (xxxx=yyyy) Then Do
       aaaa=bbbb
   End
   Otherwise Do
       cccc=dddd
   End
End
)C +1
)A 1
)N /*--------------------------------------------------------------------*/
)C 2,14
)RC 4
*/; End_SEL:me=mark(-1);Return put_lines()

l_SL:ms=mark(1) /* Seperator line before cursor  "/*------.....------*/"
)C -1
)E /*--------------------------------------------------------------------*/
)C 1,0
*/; End_SL:me=mark(-1);Return put_lines()

l_SLA:ms=mark(1) /* Seperator line After cursor  "/*------.....------*/"
)E /*--------------------------------------------------------------------*/
)C 0,0
*/; End_SLA:me=mark(-1);Return put_lines()

l_SU:ms=mark(1) /* Set (status)=USER_STATE before line
)A 5
)EB"ISREDIT (status)=USER_STATE"
)C 0,7
)RC 4
*/; End_SU:me=mark(-1);Return put_lines()

l_TR:ms=mark(1) /* Turn TRace on, with complementary alternatine NOTE lines
)E Trace r
)C +1
)N x=Trace(#tr)                                /* Restore trace setting  */
)N #tr=Trace('o')                              /* Turn off               */
)N If Verify(#tr,'NO')>0 Then x=Trace('r')     /* Restore trace setting  */
)H Insert your own meaningful documentation at the cursor.
)C 1,0
)RC 4
*/; End_TR:me=mark(-1);Return put_lines()

l_TRC:ms=mark(1) /* Copy a test for "Toggle TRACE" block after a screen display
)A *
If cmd='TRACE' Then Do
)A 1
)N /*--------------------------------------------------------------------*/
)A *
    #tr=Trace()
    If Index('NO',#tr)>0 Then #tr=Trace('R')
    Else                      #tr=Trace('O')
    zedlmsg='Trace toggled...'
    Signal scr1m
End
)A 1
)NA/*--------------------------------------------------------------------*/
)H Change the screen display return to label (at cursor position).
)A *
)C 6,13
)RC 4
*/; End_TRC:me=mark(-1);Return put_lines()

l_TRF:ms=mark(1) /* Find all the traces generated by TR, TRO and TRT line cmds
)R "ISREDIT X ALL"
)R "ISREDIT F ""Trace"" 1 ALL"
)R "ISREDIT F ""#tr=Trace('o')"" 1 ALL"
)R "ISREDIT F ""If Verify(#tr,'NO')>0 "" 1 ALL"
)C 1,0
)RC 4
*/; End_TRF:me=mark(-1);Return put_lines()

l_TRO:ms=mark(1) /* Turn Trace off and prepare for reactvation with comp NOTES
)E #tr=Trace('o')
)N Trace r
)C +1
)N If Verify(#tr,'NO')>0 Then x=Trace('r')
)C 1,0
)RC 4
*/; End_TRO:me=mark(-1);Return put_lines()

l_TRT:ms=mark(1) /* Trace toggle code (Reactivate of "TRO"d) with comp NOTES
)E If Verify(Trace(),'NO')>0 Then #tr=Trace('R');Else #tr=Trace('o')
)N Trace r
)N #tr=Trace('o')
)C 1,0
)RC 4
*/; End_TRT:me=mark(-1);Return put_lines()

l_US:ms=mark(1) /* Set USER_STATE=(ststus) aftr line
)A 5
)E "ISREDIT USER_STATE=(status)"
)C 1,21
)RC 4
*/; End_US:me=mark(-1);Return put_lines()

l_$S:ms=mark(1) /* Generate Parse SOURCE command
)NA    Parse SOURCE op_sys op_mode xcmd_name dd_name dsn_name . . env .
)NA    xx=Sysvar(Sysenv)                        /* Returns FORE/BACK */
)EA    Parse SOURCE . . xcmd .
)RC 4
)C 1,23
*/; End_$S:me=mark(-1);Return put_lines()

l_DL:ms=mark(1) /* DSLIST (ISPF opt 3.4 for dataset)
)R dsn=XB('/R')
)R Address ISPEXEC "SELECT PGM(ISRDSLST) PARM(DSL '&DSN')"
)RC 4
*/; End_DL:me=mark(-1);Return put_lines()

l_SYN:ms=mark(1) /* Genarate Syntax error processing code
)NA
)NAerror_off_$ALKUVOL:Signal off Syntax
)NA    uvol_tb=$ALKUVOL('$ZTEMPF',,'J');uvol_pb=$ALKUVOL('SMS',,'J')
)NA    uvol_to=$ALKUVOL('$ZTEMPF');uvol_po=$ALKUVOL()
)NA    uvol_tb="UNIT=SYSDA";uvol_pb="UNIT=SYSALLDA"
)NA    uvol_to="UNIT(SYSDA)";uvol_po="UNIT(SYSALLDA)"
)NA    Signal on Syntax Name error_off_$ALKUVOL
)RC 4
)C 0,0
*/; End_SYN:me=mark(-1);Return put_lines()

l_VB:ms=mark(1) /* VSAM Browse - using CMD(%VB)
)R dsn=XB('/R')
)R xx=VB("'"dsn"'")
)RC 4
)C 0,0
*/; End_VB:me=mark(-1);Return put_lines()

l_WA:ms=mark(1) /* Demonstrate the use of the 'WA' command
)WA dsn
)RL
)R Say dsn
)RC 4
)C 0,0
*/; End_WA:me=mark(-1);Return put_lines()

l_CE: /* Center line */
"(dw)  = Data_Width"         /* get the width of the editable data  */
If dw > 72 Then
  dw = 72
"(line) = LINE" line#
line=center(strip(line),dw)
"LINE" line# "= (line)";
Return 0
End_CE:

l_CURSO:ms=mark(1) /* ISREDIT Get/Place Cursor position
)A *
"ISREDIT (ROW COL) = CURSOR"       /* Get cursor */
)N "ISREDIT (, COL) = CURSOR"
)N "Isredit cursor = &row 1"
)N "ISREDIT CURSOR = (ROW,COL)"
)N 'ISREDIT CURSOR = .ZFRANGE 1'
)C 1,12
)RC 4
*/; End_CURSO:me=mark(-1);Return put_lines()

l_DATAN:ms=mark(1) /* Check if data is numeric using datatype builtin fn
)A *
if datatype(arg2,'N') | arg2 = '*'  then
    nop

)RC 4
*/; End_DATAN:me=mark(-1);Return put_lines()

l_DATAW:ms=mark(1) /* Get maximum data width of screen being edited
)A *
"Isredit (dw) = Data_Width"  /* Get maximum data width         */

)RC 4
*/; End_DATAW:me=mark(-1);Return put_lines()

l_DOL:ms=mark(1) /* Do Loop sample codes
)A *
Do i = 1 to ctr
   ctr = ctr + 1
End
)N Do While (Disp_rc ¬= 8) & (Disp_Rc ¬= 4)
)N End
)N Do j = 1 to words(rec.i)
)N End
)N Do i = 1 to queued()
)N   parse pull member
)N End
)RC 4
*/; End_DOL:me=mark(-1);Return put_lines()

l_DT: /* Delete all from current line to the top line */
"Isredit Label 1 = .FROM"
"Isredit LABEL " line# "= .TO"
"Delete All .FROM .TO"  /* delete labeled lines */
count = line#+ 0 /* remove leading zeros */
zedsmsg = count 'Lines Deleted'
zedlmsg = count 'Lines were deleted from the cursor line' ,
                'to the top line.'
Address Ispexec "Setmsg Msg(Isrz000)"  /* msg - no alarm */
Return 0
End_DT:

l_IEBCO:ms=mark(1) /* Sample IEBCOPY JCL
)A 1
//       EXEC PGM=IEBCOPY
//SYSPRINT DD SYSOUT=A
)N //I%%      DD DSN=##,DISP=SHR
//INDD       DD DISP=SHR,DSN=##
//O**      DD DSN=@@,DISP=(,CATLG,DELETE),
)N //O**      DD DSN=@@,DISP=(,KEEP),
)N //            UNIT=CART,VOL=SER=SGTAP1,LABEL=($$,BLP,EXPDT=98000),
)N //            UNIT=SYSALLDA,VOL=SER=XXXXX,SPACE=(CYL,(1,1)),
)N //            UNIT=SYSALLDA,SPACE=(CYL,(1,1)),
//            UNIT=SYSALLDA,SPACE=(CYL,(1,1)),
//            RECFM=VB,LRECL=27936,BLKSIZE=27940
)N // DSNTYPE=LIBRARY,AVGREC=K       <---- PDSE
//SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(5,2))
//SYSIN    DD *
   COPY INDD=INDD,OUTDD=OUTDD
)N    COPY INDD=I++,OUTDD=--
)N    S M=(aaaa,bbbb)
)RC 4
*/; End_IEBCO:me=mark(-1);Return put_lines()

l_INSA:ms=mark(1) /* ISREDIT Insert a line in Edit session
)A *
"Isredit Scan = Off"
"Isredit Caps Off"

Do i = 1 to queued()
  parse pull stmt
  'ISREDIT LINE_AFTER' dest' = DATALINE (stmt)'
  dest = dest + 1
End
)N   "ISREDIT LINE_AFTER 0 = '######'    /* Place at top */
)N   "ISREDIT LINE_AFTER 1 = var1
)N   "ISREDIT INSERT 3 50"            /* Create blank lines for insert*/
)N
)N   "ISREDIT (LAST) = LINENUM .ZLAST"
)N   "ISREDIT LINE_AFTER .ZL = '***'"  /* Insert after last line */
)N   "ISREDIT LINE_AFTER .ZL = '//       EXEC PGM=IEBCOPY'"
)N
)N   'ISREDIT LINE 1 = (LINEDATA)'     /* To replace a line      */
)N   "ISREDIT LINE " i "= LINE  + <1" '**' ">"
)C 1,7
)RC 4
*/; End_INSA:me=mark(-1);Return put_lines()

l_LEF: /* Left Justify */
"(line) = LINE" line#
line=strip(line,"L")    /* Left justify */
"LINE" line# "= (line)";
Return 0
End_LEF:

l_LMPX:ms=mark(1) /* LINEMAC command with parameter example           */
    Address ISPEXEC "VGET (lmp#) SHARED"
    #lmp#=lmp#;lmp#=;Address ISPEXEC "VPUT (lmp#) SHARED"
    "(cl1,dl2)=CURSOR"
    "(dl1,dl2)=DISPLAY_LINES";If cl1=dl1 & dl1>1 Then dl1=dl1+1;Else dl1=cl1
    If #lmp#='' Then Do
    x1=Mark(+1) /*
  You have not passed a parameter to "LMPX".

  Command "LMPX" demonstrates the use of the "LMP" command as follows:
    LMP:  LineMac command Parameter(s).

    This command-line macro is used to pass parameter to LINEMAC and/or
    LMEXITxx.
    Simply enter the LINEMAC comand and on the command line, enter
       LMP parameter(s)
    If your LINEMAC command is cursor position based, ensure you
    either enter the LMP command first and then the LINEMAC command
    or re-position the cursor back on the appropriate line.
    */;x2=Mark(-1)
        Do i=x1 To x2;xx=Sourceline(i);"LINE_BEFORE" dl1"=NOTELINE (xx)";End
    End
    Else Do
        xx='Parameter passed --->'#lmp#'<-';"LINE_BEFORE" dl1"=NOTELINE (xx)"
    End
    "CURSOR="cl1 0
    Return 0
End_LMPX:

l_PARSE:ms=mark(1) /* Parse - a collection of sample codes as NOTELINES
)A *
)N
)N parse var incmd.i cmd cmdlen actcmd
)N parse var dsn quote 2 the_rest
)N parse upper arg compdsn
)N
)N OPTS = 'PR123'
)N parse upper value ' 'opts with ' pr' +1  prword ' '
)N
)N parse var loc '+' offset '(' olength ')' .
)N If offset ¬= ''  Then
)N   Do
)N      adr = d2x(x2d(ploc)+offset)
)N      If olength = ''  then olength = 4
)N      loc = c2x(storage(adr,olength))
)N   End
)C 1,7
)RC 4
*/; End_PARSE:me=mark(-1);Return put_lines()

l_POPMA:ms=mark(1) /* Popup window for messages
)A *

)N -------------------------------------------
)N Requires routine QSFmtMsg and panel QSPMSG2
)N -------------------------------------------
If sysdsn("'"tdsn"'") /= 'OK'  Then
  Call MessageW sysdsn("'"tdsn"'")

/**********************************************************************/
/* Puts messages into pop-up window                                   */
/**********************************************************************/
MessageW:
  Parse Arg msg1
 "Addpop ROW(15) COLUMN(3)"
  Msg1 = QSFmtMsg(Msg1)
 "Display Panel(QSPMSG2)"
 "Rempop"
Return
)RC 4
*/; End_POPMA:me=mark(-1);Return put_lines()

l_POPMB:ms=mark(1) /* Popup window for messages with response
)A *

)N -------------------------------------------
)N Requires routine QSFmtMsg and panel QSPMSG1
)N -------------------------------------------
Call MessageWQ 'Are you sure you want to delete' ,
     'the item?'
If Ans = 'Y' then
   Call Delete_member

/**********************************************************************/
/* Puts messages onto pop-up window and returns response              */
/**********************************************************************/
MessageWQ:
  Parse Arg Msg1
  Address Ispexec
 "Addpop ROW(15) COLUMN(3)"
  Msg1 = QSFmtMsg(Msg1)
 "Display Panel(QSPMSG1)"
 "Rempop"
Return

)RC 4
*/; End_POPMB:me=mark(-1);Return put_lines()

l_QS:ms=mark(1) /* Quick search for dataset functions
)R dsn=XB('/R')
)R Address TSO "%QS " "'"dsn"'"
)RC 4
*/; End_QS:me=mark(-1);Return put_lines()

l_RIT: /* Right Justify */
"(dw)  = Data_Width"         /* get the width of the editable data  */
If dw > 72 Then
  dw = 72
"(line) = LINE" line#
line=right(strip(line,"T"),dw) /* Right justify */
"LINE" line# "= (line)";
Return 0
End_RIT:

l_RL: /* Reverse line */
"(line) = LINE" line#
line=reverse(line)          /* Reverse  */
"LINE" line# "= (line)";
Return 0
End_RL:

l_SELA:ms=mark(1) /* Select when sample codes
)A *
Select
  When (mode='B') Then
    "Browse Dataset("tdsn")"
  When (mode='E') Then
    "Edit Dataset("tdsn")"
  When (mode='V') Then
    "View Dataset("tdsn")"
  When (mode='S') Then
    Do
      Call MessageWQ 'Are you sure you want to submit job?'
      If ans = 'Y' Then
        Address Tso "Submit" tdsn
    End
  Otherwise Nop
End  /* Select */
)RC 4
*/; End_SELA:me=mark(-1);Return put_lines()

l_SUB:ms=mark(1) /* Submit job
)R dsn=XB('/R')
)R dsn=strip(dsn,,"'")
)R Address TSO "SUBMIT '"dsn"'"
)R If rc=0 Then Do; zedsmsg = 'Job submitted';End
)R If rc=0 Then Do; Address Ispexec "Setmsg Msg(Isrz000)";End
)R If rc<>0 Then Do; zedsmsg = 'Job Not submitted';End
)R If rc<>0 Then Do; Address Ispexec "Setmsg Msg(Isrz000)";End
)RC 4
*/; End_SUB:me=mark(-1);Return put_lines()

l_SYSDS:ms=mark(1) /* TSO Sysdsn to check existence od dataset
)A 1
/*--------------------------------------------------------------------*/
/*  Sysdsn - check existence of dataset and member                    */
/*--------------------------------------------------------------------*/
)A *
If sysdsn("'"Database"("memname")'") /= 'OK'  Then
  Do
    Zedsmsg = sysdsn("'"Database"("Memname")'")
    Zedlmsg = 'Dataset/member does not exist'
    "Setmsg Msg(Isrz001)"
    Return
  End

)N msg = sysdsn("'"idxdsn"'")
)N If msg /= 'OK'  Then
)N   Do
)N     If msg = 'MEMBER NOT FOUND' Then
)N       Do
)N       End
)N     If msg = 'DATASET NOT FOUND' Then /* Check */
)N       Do
)N       End
)N   End
)RC 4
*/; End_SYSDS:me=mark(-1);Return put_lines()

l_TFX:ms=mark(1) /* Redirection to ISPF option 3.4
)R dsn=XB('/R')
)R dsn=strip(dsn,,"'")
)R parse var dsn dsn '(' .
)R Address Ispexec "Control NonDispl Enter"
)R Address TSO "%OPT 3.4" dsn
)RC 4
*/; End_TFX:me=mark(-1);Return put_lines()

l_TRA:ms=mark(1) /* Trace ?R
)A 1
Trace ?R
)RC 4
*/; End_TRA:me=mark(-1);Return put_lines()

l_TRI:ms=mark(1) /* Insert Trace ?I
)A 1
Trace ?I
)RC 4
*/; End_TRI:me=mark(-1);Return put_lines()

l_ZEDSM:ms=mark(1) /* Pop ISPF message Zedsmsg/Zedlmsg Setmsg
)A *

If sysdsn(dsname) ¬= 'OK'  Then
   Do
      Zedsmsg = "Can't allocate dataset"
      Zedlmsg = "Can't allocate dataset" dsname
      Address Ispexec "Setmsg Msg(Isrz001)"
      exit
   End

)RC 4
*/; End_ZEDSM:me=mark(-1);Return put_lines()

l_LMV:ms=mark(1) /* LINEMAC (infrastructure component) versions
)A 4
)R 'ISREDIT UP MAX'
)R 'ISREDIT X ALL'
)R          'ISREDIT F "lm1_ver=" 1 30 FIRST'
)R          'ISREDIT F "lm2_ver=" 1 30 FIRST'
)R          'ISREDIT F "lm3_ver=" 1 30 FIRST'
)C 0,0
)RC 4
*/; End_LMV:me=mark(-1);Return put_lines()

End_User_Code:lm2_ver='V3.11'               /* LM2 copybook version   */
/*--------------------------------------------------------------------*/
/* DO NOT change any code after this line (or the above line).        */
/*--------------------------------------------------------------------*/

Process:
    Address ISREDIT
    "MACRO (LCMD) NOPROCESS"
    action='RETURN'
    Address ISPEXEC "CONTROL ERRORS" action
    zedsmsg=

    "(lev) = MACRO_LEVEL"
    If lev=1 Then Do
        "(lcmd1stl)=LINE .ZCSR";"(lcmd1l#,lcmd1c#)=CURSOR";
        Address ISPEXEC "VPUT (lcmd1stl,lcmd1l#,lcmd1c#,xcmd#) SHARED"
        "PROCESS RANGE" lcmd         /* Get range for command           */
        If rc>0 Then Do;Address ISPEXEC "SETMSG MSG(ISRZ002)";Exit 8;End
        "(ls) = LINENUM .ZFRANGE";"(le) = LINENUM .ZLRANGE"
        "(dw) = DATA_WIDTH"
        ima_master=1
    End
    Else Do
        Address ISPEXEC "VGET (lcmd1stl,lcmd1l#,lcmd1c#,xcmd#) SHARED"
        Parse VAR lcmd ls ',' le ',' lcmd
        ima_master=0
    End

    If lcmd='`' & ima_master Then Do
         Address ISPEXEC "VGET (prevlcmd) PROFILE"
         If prevlcmd/='' Then lcmd=prevlcmd
    End
    prevlcmd=lcmd;Address ISPEXEC "VPUT (prevlcmd) PROFILE"
    #lcmd=lcmd
    sp_chrs='!+/`%'
    sp_olay='12345'
    where_e='LINE_AFTER A LINE_AFTER B LINE_BEFORE R LINE N LINE'
    where_n='LINE_BEFORE A LINE_AFTER B LINE_BEFORE'
    If Verify(lcmd,sp_chrs,'M')>0 Then lcmd=label_gen(lcmd,'E')

    #msg=Msg('Off')
    retlab=error_off_01
    Signal on Syntax Name error_off_01
    line#s=ls;line#e=le
    #lcmd@=Address()
    "(lline)=LINENUM .ZLAST"
    i=ls-1
    Do While i<le
        i=i+1;line#=i;"(line@)=LINE" i
        Interpret 'x=l_'lcmd'()'
        Address(#lcmd@)
        If x/=0 Then Leave;Else Iterate
error_off_01:Signal Off Syntax
        If ima_master | next_exit/='' Then Do
            Signal on Syntax Name error_off_01a
            Interpret '"'next_exit'"' "ls','le','#lcmd"
            Signal Off Syntax
            If rc=4 Then Exit 4
            If rc>4 Then Do
               "CURSOR =" ls 0
                zinfo=lcmd;Address ISPEXEC "SETMSG MSG(ISRE041)";Exit 8
            End
            Exit rc
        End
        "CURSOR =" ls 0
        zinfo=lcmd;Address ISPEXEC "SETMSG MSG(ISRE041)";Exit 8
    End
    Return 0

error_off_01a:
    Signal Off Syntax
    Zedsmsg=
    Zedlmsg='Exit "next_exit" not found.  Line command terminated.'
    Address Ispexec "Setmsg Msg(Isrz001)"
    Exit

put_lines:
    i_pl=i
    col=1;maskline=;source_line=1;i_memb=0
    g_cc=                                   /* Global Control Char   */
    x_rc=def_exit_rc                        /* Exit rc set by )RC    */
    Do j=ms by 1 Until j>=me
/*      If s_b_s=j Then Do                                            */
/*          j=s_b_e;ms=s_b_e                                          */
/*          Parse VAR s_blocks s_b_s '-' s_b_e s_blocks               */
/*          Iterate                                                   */
/*      End                                                           */
        If j>me Then Leave
        If source_line  Then line=Sourceline(j)
        Else                 line=g_cc||linei.j
        cc=Substr(line,1,3)                 /* Control character     */
        Parse VAR cc cc1 +2 cc3
        where='LINE_AFTER';pmask=;smask=
        pad=Substr(' ',1,col-1)
        Select
            When cc1=')*' Then Iterate
            When cc=')A' Then Do
                col=Word(line,2);diff=Word(line,3)
                If diff='' Then diff=0
                If col='*' Then Do
                    "(linec) = LINE" ls
                    col=Verify(linec,' ')+diff;If col=0 Then col=1
                End
                Iterate
            End
            When cc=')E#' Then Do
                linex=pad||Substr(line,4)
                nol=(le-ls)
                where='LINE_AFTER'
                Do nol
                    where i_pl '=' pmask '(linex)' smask
                    i_pl=i_pl+1
                End
                Iterate
            End
            When cc1=')E' Then Do
                If g_cc='' Then linex=pad||Substr(line,4)
                Else            linex=pad||Substr(line,Length(g_cc)+1)
                where=Trans(cc3,1,where_e)
                If cc3='N' Then "LINE_BEFORE" i_pl"=NOTELINE (lcmd1stl)"
            End
            When cc1=')N' Then Do
                pmask='NOTELINE'
                where=Trans(cc3,1,where_n)
                If g_cc='' Then linex=pad||Substr(line,4)
                Else            linex=Substr(line,Length(g_cc)+1)
            End
            When cc=')C' Then Do
                rpc=0
                Parse Var line '+' c_l .
                If c_l/='' Then Do;i_pl=i_pl+c_l;Drop c_l;rpc=1;End
                Parse Var line '-' c_l .
                If c_l/='' Then Do;i_pl=i_pl-c_l;Drop c_l;rpc=1;End
                Parse Var line . c_l ',' c_c .
                If Substr(Translate(Strip(c_l)),1,1)='L' Then Do
                    "(x) = LINENUM .ZLAST";i_pl=x
                    Drop c_l;rpc=1
                End
                If rpc Then "CURSOR =" i_pl
                Iterate
            End
            When cc=')RC' Then Do
                If Datatype(word(line,2))='NUM' Then x_rc=Word(line,2)
                Else x_rc=0
                Iterate
            End
            When cc=')RL' Then Do
                "(line)=LINE .ZCSR"
                If line/=lcmd1stl Then "LINE &lcmd1l#=(lcmd1stl)"
                Iterate
            End
            When cc=')WA' Then Do
                "(iline)=LINE .ZCSR";"(,col#)=CURSOR"
                Interpret Word(line,2)'=$wordat(iline,col#)'
                Iterate
            End
            When cc=')M' Then Do
                macro=Word(line,2);macro_parms=Subword(line,3)
                Interpret "ISREDIT" macro "'"ls","le","#lcmd macro_parms"'"
                x_rc=rc
                Iterate
            End
            When cc=')H' Then Do
                xx=Subword(line,2)
                zedlmsg=zedlmsg Strip(xx,'t')
                Address ISPEXEC 'SETMSG MSG (ISRZ001)'
                Iterate
            End
            When cc=')D' Then Do
                line=Subword(line,2)
                If Strip(line)='' Then line='*'
                Do While line/=''
                    l#=Word(line,Words(line))
                    line=Delword(line,Words(line))
                    If l#/='*' Then "CURSOR =" ls+l# 0
                    "XSTATUS .ZCSR = NX"
                    "DELETE ALL NX .ZCSR .ZCSR"
                    Iterate
                End
                Iterate
            End
            When cc=')R' Then Do
                Interpret Subword(line,2)
                Iterate
            End
            When cc=')O' Then Do
                xx=Subword(line,2)
                Parse VAR xx '+' maskline
                If maskline/='' Then smask='+ MASKLINE'
                Else Do
                    Parse VAR xx maskline '+'
                    pmask='MASKLINE +'
                End
                "MASKLINE = "maskline
/*              "(linex) = LINE" ls                                   */
                linex=line@
                where='LINE'
            End
            When cc=')T' Then Do
                Parse VAR line . t1 t2 .
                If t1/='' & t1/='.' Then Interpret 'Trace' Word(line,2)
                If t2/='' Then Do
                    If t2/='C' Then cactn="CANCEL"
                    Else            cactn="RETURN"
                    Address ISPEXEC "CONTROL ERRORS" cactn
                End
                Iterate
            End
            When cc1=')I' Then Do
                i_#ms=j+1;i_#me=me
                Parse Value Subword(line,3) With s_b_s '-' s_b_e s_blocks
                xx=import_data(Word(line,2))
                If xx/=0 Then Leave
                i_memb=1;i=i+1
                Iterate
            End
            Otherwise Do
                If g_cc='' Then linex=pad||line
                Else            linex=pad||Substr(line,Length(g_cc)+1)
            End
        End
        where i_pl '=' pmask '(linex)' smask
        If cc1/=')N' Then i_pl=i_pl+1
    End
    If i_memb Then Do
         ms=i_#ms;me=i_#me;i=i-1
         Signal put_lines
    End
    If c_l/='C_L' Then Do
        c_c=c_c+Length(pad)-1;If c_c<0 Then c_c=0
        "CURSOR =" ls+c_l c_c
    End
    If maskline/='' Then "MASKLINE = ''"
    Return x_rc

import_data: Arg dsn
    dd='ID'Time('s')
    If Sysdsn(dsn)/='OK' Then Do
        zedlmsg=dsn "-" Sysdsn(dsn)"."
        Address ISPEXEC "SETMSG MSG(ISRZ001)"
        Exit 12
    End
    Address TSO "ALLOC F("dd") DSN("dsn") SHR REU"
    Address TSO "EXECIO * DISKR" dd "(STEM linei. FINIS)"
    rc1=rc
    Address TSO "FREE F("dd")"
    j=0;me=linei.0
    source_line=0
    Parse Value Word(line,1) With '(' xx ')'
    If xx='' | xx = '*' Then g_cc=;Else g_cc=')'xx' '
    If s_b_s='' Then Return 0
    If Datatype(s_b_s,'W') & Datatype(s_b_e,'W') Then Nop
    Else Do
        Parse VAR s_b_s s_b_s '(' o1 ')';Parse VAR s_b_e s_b_e '(' o2 ')'
        If \Datatype(o1,'w') Then o1=0;If \Datatype(o2,'w') Then o2=0
        dlm=0;i_i=0;s1=0;s2=0
        Do While dlm<2
            i_i=i_i+1
            If \s1 Then Do
                If Index(linei.i_i,s_b_s,1)=1 Then Do
                    s_b_s=i_i+o1;s1=1;dlm=dlm+1
                End
            End
            If \s2 Then Do
                If Index(linei.i_i,s_b_e,1)=1 Then Do
                    s_b_e=i_i+o2;s2=1;dlm=dlm+1
                End
            End
        End
        If \s1 Then s_b_s=1
        If \s2 Then s_b_e=linei.0
    End
    j=s_b_s-1;me=s_b_e
    Return rc1

/*--------------------------------------------------------------------*/
/* Special character's lebel encriptor/decriptor                      */
/*--------------------------------------------------------------------*/
label_gen: Arg v1,v2
    sp_subs='E  P  F  B  C '                /* 'EX PL FS BQ CP'       */
    If v2/='D' Then Do;s1=sp_chrs;s2=sp_olay;End
    Else            Do;s2=sp_chrs;s1=sp_olay;End
    Do Forever
        xx=Verify(v1,s1,'M')
        If xx=0 Then leave
        ch=Substr(v1,xx,1)
        yy=Index(s1,ch)
        v1=Overlay(Substr(s2,yy,1),v1,xx)
    End
    Return v1

/*--------------------------------------------------------------------*/
/* In-built help that should not be removed/mistaken as sample code.  */
/* This uses the command feature but should stay part of the infra.   */
/* You may place your own help version in the user area.              */
/*--------------------------------------------------------------------*/
l_HELP: /* Disp avail cmds as NL in edit session. Part of LINEMAC.    */
    If ¬ima_master Then Signal Help_Exit
Help_Master: ms=mark(1)    /*

*----------------------------------------------------------------------*
*                                                                      *
* Line commands are brought to you with the compliments of Choon Lim,  *
* Doug Nadel and Alex Kara.  - 2003 -                                  *
*                                                                      *
*----------------------------------------------------------------------*

  The following line commands have been self extracted out of the
  LINEMAC macro. They are alphabetic sequenced for presentation purposes
  if the '$SORT' command is available. Nevertheless, they should be
  organised as the most used first.

  Cmd    Description
  ------ ---------------------------------------------------------------
*/;   me=mark(-1);Signal Help_Process

Help_Exit: ms=mark(1)    /*

  LMEXIT line commands:
  ---------------------

*/;   me=mark(-1);Signal Help_Process

Help_Process:
    "(caps)=CAPS";"CAPS=OFF"
    "(last)=LINENUM .ZLAST";If ls<last Then ls=ls+1
    Do i_h=ms To me
        line=(Sourceline(i_h))
        If Index(line,' LMEXIT line commands: ')>0 Then Do
            Parse SOURCE . . xcmd#_h .;zz=xcmd#_h 'line commands:'
            x=n_b('  'zz);i_h=i_h+1;line=('  'Copies('-',Length(zz)))
        End
        x=n_b(line)
    End
#tr=Trace('o')

l_HELP_R:lmh=;x_sep='01'x        /* Help return                       */
    excl='HELP_R HELP'
    If \ima_master Then excl=excl 'HELPX HELP+ / `'
    #tr=Trace(o)
    hstr=;sort=0;Signal on Syntax Name error_off_02;x=$sort();sort=1
error_off_02:Signal off Syntax
    Do i_h=1 To Sourceline()
        line=Sourceline(i_h)
        If Translate(Substr(line,1,2))/='L_' Then Iterate
        Parse Var line '_' cc ':' . '/*' line
        If Verify(cc,sp_olay,'M')>0 Then cc=label_gen(cc,'D')
        If Wordpos(cc,excl)>0 Then Iterate
        If line='' Then line='????? - Not documented...'
        If Word(line,Words(line))='*/' Then line=Delword(line,Words(line))
        If lcmd='HELP_R' Then lmh=lmh cc Strip(line) x_sep
        Else If sort Then hstr=hstr||Substr(Substr(cc,1,6) Strip(line),1,70)
             Else x=n_b('  'Substr(cc,1,6) Strip(line))
    End
    If sort Then Do
        s_hstr=$sort(hstr,,,70)
        Do While s_hstr/=''
          Parse VAR s_hstr oline +70 s_hstr;x=n_b('  'oline)
        End
    End
    If Verify(#tr,'NO')>0 Then x=Trace('r')
    If lcmd='HELP_R' Then Do;Address ISPEXEC "VPUT (lmh) SHARED";Return 4;End
    x=n_b(' ')
    If next_exit/='' Then Do
        Interpret '"'next_exit'"' " ls-1','le','#lcmd"
        "CURSOR=" ls-1 0
    End
    Return 4

l_HELPX: /* HELP eXpanded. Help for line commands in greater detail */
    Signal Off Syntax
    "(caps)=CAPS";"CAPS=OFF"
    If help_expd='HELP_EXPD' | help_expd='' Then Nop
    Else Do
         "(last)=LINENUM .ZLAST";If ls=last Then ls_o=ls;Else ls_o=ls+1
         Interpret help_expd ls_o
    End
    If next_exit/='' Then Interpret '"'next_exit'"' " ls','le','#lcmd"
    "CAPS=(caps)";"CURSOR=" ls 0
    Return 4

Mark:If Datatype(Arg(1))/='NUM' Then Arg(1)=1;Return sigl+Arg(1)
n_b:xx=Arg(1);"LINE_BEFORE" ls "= NOTELINE (xx)";Return 0
n_bm:xx=Arg(1);"LINE_BEFORE" ls"=NOTELINE (xx) + MASKLINE";Return 0
n_a:xx=Arg(1);"LINE_AFTER"  ls "= NOTELINE (xx)";Return 0
d_b:xx=Arg(1);"LINE_BEFORE" ls "= (xx)";Return 0
d_a:xx=Arg(1);"LINE_AFTER"  ls "= (xx)";Return 0
d_o:xx=Arg(1);"LINE"        ls "= (xx)";Return 0
Trans: Arg v1,v2,v3;Return Word(v3,Wordpos(Substr(v1,1,v2),v3)+1)

l_HELP2:lm3_ver='V3.04'   /* Display HELP for building line commands. */
    "(caps)=CAPS";"CAPS=OFF"
    "(last)=LINENUM .ZLAST";If ls<last Then ls=ls+1
    "LMM ?" ls
    "CAPS=(caps)";"CURSOR=" ls-1 0;Return 4

