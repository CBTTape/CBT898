/*--------------------------ooo00 REXX 00ooo--------------------------*/
/*                                                                    */
/* LMM: LineMac Manager.                                              */
/*                                                                    */
/*--------------------------------------------------------------------*/
    lmm_ver='3.13'
    Arg parm#;Address ISPEXEC;"CONTROL ERRORS RETURN";ima_macro=0
    If parm#/='' Then Signal byp1
    "ISREDIT MACRO (parm#) NOPROCESS";If rc=0 Then ima_macro=1

byp1:
/*  "CONTROL ERRORS CANCEL"                                           */

    zedsmsg=
    Parse Upper VAR parm# parm#

    If ima_macro Then Address ISREDIT
    If Word(parm#,1)='?' Then Signal help_me
    If Substr(parm#,1,2)='TC' Then Signal TC_Trace_Chain
    If Substr(parm#,1,1)='A' Then Signal Analyse

/*--------------------------------------------------------------------*/
/* Qick special character converter                                   */
/*--------------------------------------------------------------------*/
    natan='ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$'
    sp_chrs='!+/`%';sp_olay='12345'
    If Verify(parm#,sp_chrs,'M')>0 Then Do
        xx=label_gen(parm#,'E')
        zedlmsg=Substr('l_'xx,1,8),
            '- Encripted. Use this as label in LINEMAC.',
            'Stored in member "#'xx'"'
        Address ISPEXEC "SETMSG MSG(ISRZ001)"
        Parse source opsys env xcmd . xdsn .
        If env='FUNCTION' Then Return xx;Else Exit
    End

/*--------------------------------------------------------------------*/

    "(status)=USER_STATE";"(dsnc)=DATASET";"(membc)=MEMBER"
    sug_excl='$LMM* $$$INDEX LINEMAC LMEXIT*' /*Suggested excl lst*/
    pref=Sysvar(Syspref)
    phlq="'"pref".";phlql=Length(phlq)
    dsnc="'"dsnc"'"
    rc1=rc                                  /*                        */
    sep='/*'Copies('-',68)'*/'              /*                        */
    dd='LM'Time('s')
    oneline=;oneline2=

    If Wordpos(parm#,'I1 I2 I3 I F1 F2 F3 F')>0 Then Do
        If parm#='I' Then parm#='I1 I2 I3'
        If parm#='F' Then parm#='F1 F2 F3'
        p_loop=parm#
        Do While p_loop/=''
            Parse VAR p_loop inf# p_loop
            x=Import_infra(inf#)
        End
/*      If oneline/='' Then Do                                        */
/*          "F 'next_exit=' FIRST"                                    */
/*          "LINE_BEFORE .ZCSR=NOTELINE (oneline)"                    */
/*          If oneline2/='' Then Do                                   */
/*              "F 'help_expd=' FIRST"                                */
/*              "LINE_BEFORE .ZCSR=NOTELINE (oneline2)"               */
/*          End                                                       */
/*      End                                                           */
        Signal exi1
    End

    "(line1) = LINE 1"
    If Word(line1,1)=')O' Then Signal Build
    If Word(line1,1)=')B' Then Signal Configure
    "(line2) = LINE 2"
    If Word(line2,2)=')X' Then Do
        dsno=Word(line2,3)
        Signal Extract
    End

    If Substr(parm#,1,1)='B' Then Signal Build
    If Substr(parm#,1,1)='C' Then Signal Configure
    If Substr(parm#,1,1)='X' Then Signal Extract

    zedlmsg='Either edit a member with the appropriate control data',
          'or enter X(eXtract), C(onfigure) or B(uild) to perform all',
          'out of the current dataset 'dsnc'. Enter "HELP+" in any',
          'line (overtype the number) to get help.'
    Address ISPEXEC "SETMSG MSG(ISRZ001)"
exi1:
    "ISREDIT USER_STATE=(status)"
    dummy_find='$' || '@@###alslksksksksksks'
    "ISREDIT F '"dummy_find"' FIRST"
    Exit

/*--------------------------------------------------------------------*/
/* Build LINEMAC from member $LMMB                                    */
/*--------------------------------------------------------------------*/
Build:
    "F ')O' 1 FIRST"
    If rc=0 Then "(lineo) = LINE .ZCSR"
    Else lineo=")O" "'"Strip(dsnc,,"'")"(LMEXIT)'"
    Parse VAR lineo lineo '/*'
    Parse VAR lineo . dsno o_memb .
    If dsno='*' Then dsno=dsnc
    If Substr(dsno,1,1)="'" Then dsno=Strip(dsno,,"'")
    Else                         dsno=pref'.'dsno
    If Index(dsno,'(')>0 Then Parse VAR dsno dsno '(' o_memb ')'
    If o_memb='' Then o_memb='LMEXIT'

    "F ')I' 1 FIRST"
    If rc=0 Then "(linei)=LINE .ZCSR";Else linei=")I" dsnc
    Parse VAR linei . Dsni .
    If dsni='*' Then dsni=dsnc
    If Substr(dsni,1,1)="'" Then dsni=Strip(dsni,,"'");Else dsni=pref'.'dsni
    If o_memb='LINEMAC' Then ima_master=1
    Else                     ima_master=0

    #cmds=;i=0;Drop lineo.
    i_memb='LM1'
    x=insert_infra("'"dsni"("i_memb")'")

    "(last)=LINENUM .ZLAST"

    Do i_b=1 To last
        "(line)=LINE" i_b
        Select
           When (Word(line,1)=')*') Then Iterate
           When (Word(line,1)=')U') Then,
               x=insert_user(Subword(line,2))
           When (Word(line,1)=')END') Then Leave
           Otherwise Nop
        End
    End
    i_memb='LM2';x=insert_infra("'"dsni"("i_memb")'")
    If ima_master Then Do
        i_memb='LM3';x=insert_infra("'"dsni"("i_memb")'")
    End
    "ISREDIT USER_STATE = (status)"
    lineo.0=i
    dsn="'"Strip(dsno,,"'")"("o_memb")'"
    Address TSO "ALLOC F("dd") DSN("dsn") SHR REU"
    Address TSO "EXECIO * DISKW "dd" (STEM lineo. FINIS)"
    Address TSO "FREE F("dd")"
    Address ISPEXEC "EDIT DATASET(&DSN)"

    Exit

/*--------------------------------------------------------------------*/
/* Insert user members from ")U" lines                                */
/*--------------------------------------------------------------------*/
insert_user: Arg parm
    @adr1=Address();Address ISPEXEC
    Parse VAR parm dsnu "(" membmask ")" . "-" exclude
    exclude=exclude 'LINEMAC LMEXIT*'       /* Force exclusion        */
    If substr(dsnu,1,1)="'" Then,
        dsnu=Strip(Strip(dsnu),,"'");Else dsnu=pref"."dsnu
    If Sysdsn("'"dsnu"'")/='OK' Then Do
        zedlmsg="Error processing file '"dsnu"',",
               Sysdsn("'"dsnu"'")
        "SETMSG MSG(ISRZ001)"
        Exit
    End

    "LMINIT DATAID(DATA1) DATASET('&DSNU')"
    "LMOPEN DATAID(&DATA1) OPTION(INPUT)"
    rc1=rc
    If Index(membmask,'*')>0 Then mask=1;Else mask=0
    Parse VAR membmask membmask '*'
    member=membmask;ml=Length(membmask)
    #tr=Trace('o')
    Do While rc1=0
        "LMMLIST DATAID(&DATA1) OPTION(LIST) MEMBER(MEMBER)"
        rc1=rc
        If rc1/=0 Then Leave
        member = Strip(member)
        If ml>0 Then Do
            If mask Then If Substr(member,1,ml)>membmask Then Leave
                         Else Nop
            Else         If member/=membmask Then Leave
        End
        If exclude/='' Then If exm(member) Then Iterate
        If Wordpos(member,#cmds)>0 Then Do
            Say "Duplicate member '"dsnu"("member")'."
            Iterate
        End
        #memb=member
        If Verify(member,sp_olay,'M')>0 Then member=Substr(member,2)
        If Wordpos(member,#cmds)>0 Then Iterate
        Else #cmds=#cmds member
        xx=read("'"dsnu"("#memb")'",'linei3.')
        If xx/=0 Then Do
            Say "Error processing file" dsnu", rc="rc1
            Iterate
        End
        j=2;labl='l_'member':'
        If Substr(linei3.1,1,1)='@' Then Do
            If Wordpos('@R',linei3.1)=0 Then labl=labl'ms=mark(1)'
            If Wordpos('@A',linei3.1)>0 Then Do
                linei3.1=Strip(linei3.1)
                Do j=j To linei3.0
                    If Substr(linei3.j,1,1)/='@' Then Leave
                    If Wordpos('@',linei3.j)>0 Then Leave
                    linei3.1=linei3.1'='Strip(Subword(linei3.j,2))
                End
            End
            linec=;k=j
            If j<linei3.0 Then,
                Do k=k To linei3.0
                    Parse VAR linei3.k d1 desc
                    If d1/='/*' Then Iterate
                    lp=Lastpos('*/',desc)
                    If lp>0 Then linec=Substr(desc,1,lp-1);Else linec=desc
                    Leave
                End
            linec=Strip(linec)
            If linec='' Then Do
                Say "Bypassing description less '"dsnu"("member")'."
                Iterate
            End
            If Wordpos('@R',linei3.1)>0 Then Do
                xx=length(labl '/*' linec '*/')
                If xx>80 Then linec=Substr(linec,1,Length(linec)-(xx-80))
                linec=linec '*/'
            End
        End
        Else Do
            labl=labl'ms=mark(1)'
            linec=linei3.2
            Parse VAR linec . linec
            linec=Strip(Delword(linec,Words(linec)))
            linec=Strip(linec)
            k=3
        End
        If Wordpos('@A',linei3.1)>0 Then x=Process_multi()
        Else                             x=ol(labl '/*' linec)
        Do While Substr(linei3.k,1,2)='/*'
            k=k+1
        End
        Do j=k to linei3.0
            x=ol(linei3.j)
        End
        If labl='l_'member':' Then x=ol('End_'member':')
        Else x=ol('*/; End_'member':me=mark(-1);Return put_lines()')
        x=ol(' ')
    End
    If Verify(#tr,'NO')>0 Then x=Trace('r')
    "LMMLIST DATAID(&DATA1) OPTION(FREE)"
    "LMCLOSE DATAID(&DATA1)"
    "LMFREE  DATAID(&DATA1)"
    Address(@adr1)
    Return 0

/*--------------------------------------------------------------------*/
/* Insert infrastructure members from ")I" lines                      */
/*--------------------------------------------------------------------*/
insert_infra: Arg dsn
    If Sysdsn(dsn)/='OK' Then Do
        Say dsn 'not found and is not included'
        Parse VAR dsn '(' i_mem ')'
        dsn=$ddalloc('SYSPROC,SYSEXEC',,i_mem)
        If dsn='' Then Do
            Say 'Could not find infrastructure member "'i_mem'" in the',
                    'SYSPROC/SYSEXEC concatenations.'
            Return 4
        End
        dsn="'"Word(dsn,1)"("i_mem")'"
        Say dsn 'found in SYSPROC'
    End
    xx=read(dsn,'linei2.')
    If xx/=0 Then Do
        zedlmsg="Error processing file" dsn", rc="rc1
        Address ISPEXEC "SETMSG MSG(ISRZ001)"
        Exit
    End
    Do j=1 to linei2.0
        If i_memb='LM1' Then Do
          If Word(linei2.j,2)=')X' Then Do
            xx="<- Output (created if NF)"
            linei2.j=Substr("/* )X " uq("'"dsno"("o_memb")'") xx,1,70)"*/"
          End
        End
        x=ol(linei2.j)
    End
    x=ol(' ')
    Return 0

/*--------------------------------------------------------------------*/
/* Process multi command "aliases"                                    */
/*--------------------------------------------------------------------*/
Process_multi:
    multi=Word(linei3.1,Wordpos('@A',linei3.1)+1)
    Parse VAR labl ':' xx .
    xp=Substr(' ',1,Length(xx))
    Do while multi/=''
        Parse VAR multi m '=' multi
        If Wordpos(m,#cmds)=0 Then #cmds=#cmds m
        If multi/='' Then x=ol('l_'m':'xp '/*' linec '*/')
        Else              x=ol('l_'m':'xx '/*' linec)
    End
    Return 0

/*--------------------------------------------------------------------*/
/* This routine configures the LINEMAC "builder" member $LMMB from    */
/* from $LMMC.                                                        */
/*--------------------------------------------------------------------*/
configure: Arg parm
/*  level,dstype,panel,table                                          */
/*  dsn=$dsnsel('*.linemac.**','n')                                   */
    "F ')B' 1 FIRST"
    If rc=0 Then "(lineb) = LINE .ZCSR"
    Else lineb=")B "dsnc
    "F ')I' 1 FIRST"
    If rc=0 Then "(linei) = LINE .ZCSR"
    Else linei=")I1 "dsnc
    "F ')O' 1 FIRST"
    If rc=0 Then "(lineo) = LINE .ZCSR"
    Else lineo=")O "dsnc

    Parse VAR lineo lineo '/*'
    Parse VAR lineo . dsno o_memb .
    If dsno='*' Then dsno=dsnc
    If Substr(dsno,1,1)="'" Then dsno=Strip(dsno,,"'")
    Else                         dsno=pref'.'dsno
    If Index(dsno,'(')>0 Then Parse VAR dsno dsno '(' o_memb ')'
    If o_memb='' Then o_memb='LMEXIT'

    Parse VAR lineb lineb '/*'
    Parse VAR lineb . dsnb b_memb .
    If dsnb='*' Then dsnb=dsnc
    If Substr(dsnb,1,1)="'" Then dsnb=Strip(dsnb,,"'")
    Else                         dsnb=pref'.'dsnb
    If Index(dsnb,'(')>0 Then Parse VAR dsnb dsnb '(' b_memb ')'
    If b_memb='' Then b_memb='$LMMB'

    Parse VAR linei linei '/*'
    Parse VAR linei . dsni .

    "F ')U' 1 FIRST"
    If rc=0 Then "(lineu) = LINE .ZCSR";Else lineu=")U "dsnc

    If Substr(dsni,1,1)="'" Then
        dsni=Strip(dsni,,"'");Else dsni=pref'.'dsni
    Drop lineo.;i=0
    x=ol(')*'Copies('-',69)'*')
    xx=' Build member for the exit - use "LMM B" to create'
    x=ol(')*'Substr(xx,1,69)'*')
    x=ol(')*'Copies('-',69)'*')
    x1=")O" uq("'"dsno"("o_memb")'")
    x2="/* This is IT!..                  */"
    x=ol(Substr(x1,1,72-Length(x2))x2)
    x=ol(")*")
    x=ol(")I"  uq("'"dsni"'") "<- Infrastructure members")

    Address ISPEXEC
    #tr=Trace(o)
    Do Forever
        x=ol(")*")
        Parse VAR lineu lineu '/*'
        Parse VAR lineu . dsnu  '-' exclude
        Parse VAR dsnu dsnu '(' .
        xxx=sug_excl
        Do while xxx/=''
            Parse VAR xxx xx xxx
            If Wordpos(xx,exclude)=0 Then exclude=exclude xx
        End
        dsnu=strip(dsnu)
        If dsnu='*' Then dsnu=dsnc
        If Substr(dsnu,1,1)="'" Then;
            dsn=Strip(dsnu,,"'");Else dsn=pref"."dsnu
        "LMINIT DATAID(DATA1) DATASET('&DSN')"
        If rc/=0 Then x=ol(")* Dataset" dsn "could not be opened.")
        Else Do
            x=ol(")*")
            x=ol(")U" uq("'"dsn"(*)'") "-" sug_excl)
            x=ol(")* Members after the '-' are to be ignored (can wildcard*)")
            x=ol(")*      or")
            x=ol(")* Delete above and include from following members. Move")
            x=ol(")* most used to top for those few MIP savings.")
            x=ol(")*")
            "LMOPEN DATAID(&DATA1) OPTION(INPUT)"
            rc1=rc
            member=
            Do While rc1=0
                Address ISPEXEC "LMMLIST DATAID(&DATA1) OPTION(LIST)",
                    "MEMBER(MEMBER) STATS(YES)"
                rc1=rc
                If rc1/=0 Then Leave
                member=Strip(member)
                If exclude/='' Then If exm(member) Then Iterate
                x=ol(")U" uq("'"dsn"("member")'"))
            End
            Address ISPEXEC
            "LMMLIST DATAID(&DATA1) OPTION(FREE)"
            "LMCLOSE DATAID(&DATA1)"
            "LMFREE  DATAID(&DATA1)"
        End
        "ISREDIT F ')U' 1"
        If rc/=0 Then Leave
        "ISREDIT (lineu) = LINE .ZCSR"
    End
    x=ol(")*")
    x=ol(")END")
    lineo.0=i
    dsn="'"Strip(dsnb,,"'")"("b_memb")'"
    Address TSO "ALLOC F("dd") DSN("dsn") SHR REU"
    Address TSO "EXECIO * DISKW "dd" (STEM lineo. FINIS)"
    Address TSO "FREE F("dd")"
    Address ISPEXEC "EDIT DATASET(&DSN)"

    "ISREDIT USER_STATE = (status)"
    Exit

/*--------------------------------------------------------------------*/
/* This section analyses all the user "commands" in the LINEMAC/LMEXIT*/
/* commands and reports on all "l_" without a complimentart "End_"    */
/* label.  It will look either side to see if there are grouped labels*/
/* around the missing label and advise accordingly.                   */
/*                                                                    */
/* Unless a "l_" has a complimentary "End_" label the functionality   */
/* will be lost during the next "LMM E" operation.                    */
/*--------------------------------------------------------------------*/
Analyse:
    "(status)=USER_STATE";"RESET"
    "F 'Start_User_Code:' 1 FIRST";If rc/=0 Then "CURSOR= 1 0"
    Do Forever
        "F 'l_' 1 NEXT"
        If rc/=0 Then Leave
        "(line)=LINE .ZCSR";"(lin#)=LINENUM .ZCSR"
        Parse VAR line '_' memb ':' mk .
        If Wordpos(memb,'HELP HELPX HELP2 HELP_R')>0 Then Iterate
        "F 'End_"memb":' NEXT";If rc=0 Then Iterate
        "(lineP)=LINE" lin#-1;"(lineN)=LINE" lin#+1
        If Substr(lineP,1,2)='l_' | Substr(lineN,1,2)='l_' Then Do
            Say Substr('"l_'memb'"',1,12)'without a complimentary',
                Substr('"End_'memb'".',1,17)'Is it blocked?'
            "CURSOR="lin#+1 0;Iterate
        End
        "CURSOR="lin#+1 0;"F 'l_' 1 NEXT"
        If rc/=0 Then "(ls)=LINENUM .ZLAST"
        Else Do
            "(ls)=LINENUM .ZCSR";ls=ls-1
            If mk/='ms=mark(1)' Then linex='End_'memb':'
            Else linex='*/; End_'memb':me=mark(-1);Return put_lines()'
        End
        Do Forever
            "(lineC)=LINE" ls;If rc/=0 Then Leave
            If Strip(lineC)/='' Then Leave
            ls=ls-1;Iterate
        End
        x=nla(linex)
        Say Substr('"l_'memb'"',1,12)'without a complimentary',
            Substr('"End_'memb'",',1,17)'NOTELINE inserted.'
        "CURSOR="lin#+1 0;Iterate
    End
    Signal exi1

/*--------------------------------------------------------------------*/
/* This routine extracts all the user "commands" out of LINEMAC into  */
/* current dataset.                                                   */
/*                                                                    */
/* SUGGESTION:                                                        */
/*                                                                    */
/* Copy your copy of LINEMAC into a new PDS, insert ")X" as line 1    */
/* and then use the LMM (this) macro against it. Suggest you call the */
/* copied member $ALLIN1.  Or just extract the lines between labels   */
/* "Start_User_Code:" and "End_User_Code:" into $ALLIN1>              */
/*--------------------------------------------------------------------*/
Extract:
    Signal on Syntax Name error_off_$ALKUVOL
    unitvol="UNIT(SYSALLDA)";unitvol=$ALKUVOL()
error_off_$ALKUVOL:Signal off Syntax
    "(dsnc) = DATASET"
    ext_exclude='LMEXIT'                    /* Exit member not etract */
    "F '/* )X' 1 FIRST"
    If rc=0 Then Do
        "(line)=LINE .ZCSR"
        dsno=Word(line,3)
        Parse VAR dsno dsno "(" o_memb ")"
        If substr(dsno,1,1)="'" Then dsno=Strip(dsno,,"'")
        Else                         dsno=pref"."dsno
        dsno=dsno
    End
    "F '/* )I' 1 FIRST"
    If rc=0 Then Do
        "(line)=LINE .ZCSR"
        dsni=Word(line,3)
        Parse VAR dsni dsni "(" i1 ")"
        If substr(dsno,1,1)="'" Then dsni=Strip(dsni,,"'")
        Else                         dsni=pref"."dsni
    End
    Else dsni=dsnc

    If dsno='*' | dsno='' | dsno='DSNO' Then dsno=dsnc
    Else Do
        If Sysdsn("'"dsno"'")/='OK' Then,
            Address TSO "ALLOC DSN('"dsno"') NEW CATALOG" unitvol,
                        "RECFM(F B) LRECL(80) BLKSIZE(27920) DSORG(PO)",
                        "TRACKS DIR(50) SPACE(60,15)"
    End
    "F 'Start_User_Code:' 1 FIRST";If rc/=0 Then "CURSOR= 1 0"
    Do Forever
        spc=                                /* SPecial Command        */
        "F 'L_' 1 NEXT"
        If rc/=0 Then Leave
        "(line)=LINE .ZCSR";"(ls)=LINENUM .ZCSR"
        Parse VAR line '_' memb ':' rest
        "F 'End_"memb":' NEXT"
        If rc=0 Then "(le) = LINENUM .ZCSR"
        Else Do;"CURSOR =" ls+1 0;Iterate;End
        If Wordpos(memb,ext_exclude)>0 Then Iterate
        alias=memb
        If Verify(memb,sp_olay,'M')>0 Then memb='#'memb
        dsn="'"dsno"("memb")'"
        Do ls=ls+1 To le
            "(line) = LINE" ls
            Parse VAR line '_' xx ':' yy
            If Substr(line,1,2)/='l_' Then Do;ls=ls-1;Leave;End
            rest=yy
            alias=alias'='xx
        End
        If Substr(rest,1,3)/='ms=' Then spc='@R ' || spc
        If Index(alias,'=')>0 Then spc=spc || @A alias' '
        Parse Var rest '/*' rest
        If Word(rest,Words(rest))='*/' Then rest=Delword(rest,Words(rest))
        Address TSO 'NEWSTACK'
        #spc=spc
        If length(spc)>72 Then Do
            spc=Strip(spc)
            Do While spc/=''
                xx=Lastpos('=',spc,72)
                If xx=0 Then Do;Queue Strip(spc);Leave;End
                p1=Substr(spc,1,xx-1);spc='@A' Substr(spc,xx+1)
                Queue Strip(p1)
            End
        End
        Else If spc/='' Then Do
                 Queue spc
                 Queue '@  /* Leave lines starting with "@" ASIS please. */'
             End
        Queue sep
        Queue '/*' Substr(rest,1,67)'*/'
        Queue sep
        Do i=ls+1 To le-1
            "(line)=LINE" i
            Queue line
        End
        Queue ''
        x=Write(dsn,'Q')

        "CURSOR="le 0
    End
    Address TSO 'DELSTACK'
    If o_memb='LINEMAC' Then Do
        b_memb='$LMMB';c_memb='$LMMC'
    End
    Else Do
        b_memb='$LMMBX';c_memb='$LMMCX';o_memb='LMEXIT'
    End
    Address TSO 'NEWSTACK'
    Queue Substr(')*-',1,71,'-')'*'
    yy="-" sug_excl
    Queue Substr(')* Configure member - use "LMM C" to create.',1,71)'*'
    Queue Substr(')*-',1,71,'-')'*'
    Queue ")B" uq("'"Strip(dsno,,"'")"("b_memb")'") "<- build member"
    Queue ')*'
    Queue ")O" uq("'"Strip(dsno,,"'")"("o_memb")'") "<- finaloutput"
    Queue ')*'
    Queue ")I" uq("'"Strip(dsni,,"'")"'") "<- infrastructure members"
    Queue ')*'
    Queue ")U" uq("'"Strip(dsno,,"'")"(*)'") yy
    Queue ')*'
    Parse var dsno . '.' xx "'"
    Queue ")*  Add any other datasets to use for the build member"
    Queue ")*U 'other."xx"(*)'" yy
    Queue ')END'
    Queue ''
    dsn="'"dsno"("c_memb")'"
    memb=c_memb;rest=' Configure member....'
    x=Write(dsn,'Q')
    Address ISPEXEC "EDIT DATASET(&DSN)"

    Signal exi1

dl: Parse Arg nl1;"LINE_AFTER .ZLAST=(nl1)";Return 0
nl: Parse Arg nl1;"LINE_BEFORE" ls "=NOTELINE (nl1)";Return 0
nla: Parse Arg nl1;"LINE_AFTER" ls "=NOTELINE (nl1)";Return 0
ol: Parse Arg ol1;i=i+1;lineo.i=ol1;Return 0
uq:Arg v1;If Substr(v1,1,phlql)=phlq Then Parse VAR v1 "." v1 "'";Return v1
Mark: Arg diff;If Datatype(diff)/='NUM' Then diff=1;Return sigl+diff

read: Arg dsn,stem
    Address TSO "ALLOC DD("dd") DS("dsn") SHR REU"
    rc1=rc
    Address TSO "EXECIO * DISKR" dd "(STEM" stem "FINIS"
    If rc>rc1 Then rc1=rc
    Address TSO "FREE DD("dd")"
    If rc>rc1 Then rc1=rc
    Return rc1

Write: Arg dsn,stem
    Say Substr(memb,1,8) rest
    Address TSO "ALLOC DD("dd") DS("dsn") SHR REU"
    rc1=rc
    If stem/='Q' Then,
        Address TSO "EXECIO * DISKW" dd "(STEM" stem "FINIS"
    Else,
        Address TSO "EXECIO * DISKW" dd "(FINIS"
    If rc>rc1 Then rc1=rc
    Address TSO "FREE DD("dd")"
    If rc>rc1 Then rc1=rc
    Return rc1

/*--------------------------------------------------------------------*/
/* Replace appropriate code with members LM1, LM2 and/or LM3.         */
/*--------------------------------------------------------------------*/
Import_infra:Arg inf#
    dsni=
    Parse VAR inf# i_o +1 i_s
    If i_o/='F' Then "F '/* )I' 1 FIRST";Else rc=4
    If rc=0 Then Do
        "(linei)=LINE .ZCSR"
        Parse VAR linei . . Dsni .
        If dsni='*' Then dsni=dsnc
        If Substr(dsni,1,1)="'" Then dsni=Strip(dsni,,"'")
        Else dsni=pref'.'dsni
        If Sysdsn("'"dsni"(LM1)'")/='OK' Then dsni=
    End
    If dsni='' Then Do
        dsni=$ddalloc('SYSPROC,SYSEXEC',,'LM1')
        If dsni='' Then Do
            zedlmsg='Could not find infrastructure member "LM1" in the',
                    'SYSPROC/SYSEXEC concatenations.'
            Address ISPEXEC "SETMSG MSG(ISRZ001)"
            Exit
        End
    End
    l_m='LM'i_s
    xx=read("'"dsni"("l_m")'",'linei1.')
    Select
        When l_m='LM1' Then Do
            "F ' next_exit=' FIRST"
            If rc=0 Then Do
                "(ll)=LINENUM .ZCSR";"(oneline)=LINE .ZCSR";ll=ll+0
                Parse VAR oneline 'next_exit=' olay .
                olay=Translate(Strip(olay,,"'"));olay=Strip(olay,,'"')
                If Verify(olay,natan,'N')>0 Then olay=
                If olay='' Then oneline=;Else olay="'"olay"'"
            End
            Else Do;ll=8;oneline=;olay=;End
            linei1.ll=Overlay(olay,linei1.ll,15,11)
            "F ' help_expd=' FIRST"
            If rc=0 Then Do
                "(ll)=LINENUM .ZCSR";"(oneline2)=LINE .ZCSR";ll=ll+0
                Parse VAR oneline2 'help_expd=' olay .
                olay=Translate(Strip(olay,,"'"));olay=Strip(olay,,'"')
                If Verify(olay,natan,'N')>0 Then olay=
                If olay='' Then oneline2=;Else olay="'"olay"'"
            End
            Else Do;ll=9;oneline2=;olay=;End
            linei1.ll=Overlay(olay,linei1.ll,15,11)
            "(oline2)=LINE 2";"(oline3)=LINE 3"
            "LABEL 1=.FLINE"
            "F 'Start_User_Code:' 1 FIRST"
            If rc/=0 & i_o/='F' Then Do
                zedlmsg='Does not apear to be a LINEMAC/LMEXIT member.',
                        '"Start_User_Code:" not found in column 1.'
                Address ISPEXEC "SETMSG MSG(ISRZ001)"
                Exit
            End
            If i_o/='F' Then Do
                "F 'l_' 1 NEXT";"(lin#)=LINENUM .ZCSR" /* 1st. user label */
                "LABEL" lin#-2"=.TLINE"
            End
            where='LINE_BEFORE 1'
        End
        When l_m='LM2' Then Do
            "F 'End_User_Code:' 1 FIRST"
            If rc/=0 & i_o/='F' Then Do
                zedlmsg='Does not apear to be a LINEMAC/LMEXIT member.',
                        '"End_User_Code:" not found in column 1.'
                Address ISPEXEC "SETMSG MSG(ISRZ001)"
                Exit
            End
            If i_o/='F' Then Do
                "LABEL .ZCSR=.FLINE"
                "F 'Trans:' 1 LAST";"(lin#)=LINENUM .ZCSR"
                "LABEL .ZCSR=.TLINE"
                where='LINE_BEFORE' lin#+1
            End
            Else Do
                "(xx)=LINE .ZLAST";If Strip(xx)/='' Then "LINE_AFTER .ZLAST=' '"
                "LABEL .ZLAST=.XLINE";where='LINE_AFTER .XLINE'
            End
        End
        Otherwise Do
/*          If membc='LMEXIT' Then Do                                 */
/*              zedlmsg='LM3 does not need to be copied into LMEXIT.' */
/*              Address ISPEXEC "SETMSG MSG(ISRZ001)"                 */
/*              Return 4                                              */
/*          End                                                       */
            "F 'l_HELP2:' 1 LAST"
            If rc/=0 Then Do
/*              zedlmsg='Is this a LINEMAC member as "l_HELP2:" not', */
/*                      "found in column 1? If you want 'LM3', append",*/
/*                      'it manually.'                                */
/*              Address ISPEXEC "SETMSG MSG(ISRZ001)"                 */
/*              Return 4                                              */
                "(xx)=LINE .ZLAST";If Strip(xx)/='' Then "LINE_AFTER .ZLAST=' '"
                "(lin#)=LINENUM .ZLAST";where='LINE_BEFORE' lin#
                Signal Insert_infra_lines
            End
            "LABEL .ZCSR=.FLINE";"(lin#)=LINENUM .ZCSR"
            where='LINE_BEFORE' lin#
            "(lin#)=LINENUM .ZLAST";"LABEL" lin#-1"=.TLINE"
        End
    End
    "RESET";If i_o/='F' Then "X ALL .FLINE .TLINE"
Insert_infra_lines:
    Do i=linei1.0 By -1 To 1
        line=linei1.i;where "=(line)"
    End
    "DELETE ALL X"
    If l_m='LM1' Then Do
        "LABEL 1=.FLINE";"LABEL 3=.TLINE";"CURSOR=2 0"
        "C '(LINEMAC)' '("membc")' ALL .FLINE .TLINE"
    End
/*  If l_m='LM2' Then Do                                              */
/*      "F '  LMEXIT line commands:'"                                 */
/*      If rc=0 Then "C 'LMEXIT' '"membc"' ALL .ZCSR .ZCSR"           */
/*  End                                                               */
    Return 0

/*--------------------------------------------------------------------*/
/* Special character to valim member name encription/decription       */
/*--------------------------------------------------------------------*/
label_gen: Arg v1,v2
    If v2/='D' Then Do;s1=sp_chrs;s2=sp_olay;End
    Else            Do;s2=sp_chrs;s1=sp_olay;End
    Do Forever
        xx=Verify(v1,s1,'M')
        If xx=0 Then leave
        ch=Substr(v1,xx,1)
        yy=Index(s1,ch)
        v1=Overlay(Substr(s2,yy,1),v1,xx)
    End
    Return v1

/*--------------------------------------------------------------------*/
/* Exlude mamber process. Check for mask match.                       */
/*--------------------------------------------------------------------*/
exm:
    If exclude='' Then return 0
    If Wordpos(member,exclude)>0 Then Return 1
    xxx=exclude
    Do While Index(xxx,'*')>0
        Parse VAR xxx xx xxx
        If Index(xx,'*')=0 Then Iterate
        Parse var xx xx '*'
        ll=Length(xx)
        If Substr(member,1,ll)=xx Then Return 1
    End
    Return 0

/*--------------------------------------------------------------------*/
/* Trace chain starting at LINEMAC and ending when next_exit=''.      */
/*--------------------------------------------------------------------*/
TC_Trace_Chain:
    ls=1;path=;nexit='LINEMAC'
    x=nl('Trace of LINEMAC chain:');x=nl('-----------------------')
    Do While nexit/=''
        dsname=$ddalloc('+SYSEXEC',,nexit)
        If dsname='' Then dsname=$ddalloc('SYSEXEC',,nexit)
        If dsname='' Then dsname=$ddalloc('+SYSPROC',,nexit)
        If dsname='' Then dsname=$ddalloc('SYSPROC',,nexit)
        If dsname='' Then Leave
        dsn=dsname'('nexit')'
        x=nl(Substr(nexit,1,8) '-' Substr(dsname,1,30) dsn)
        path=path '->' dsn
        dd='EI'Time('s')
        Address TSO "ALLOC F("dd") DSN('"dsn"') SHR REU"
        Address TSO "EXECIO 20 DISKR "dd" (STEM linei. FINIS)"
        Address TSO "FREE F("dd")"
        nexit=
        Do i=7 To linei.0
            If Index(linei.i,' next_exit=')=0 Then Iterate
            Parse VAR linei.i 'next_exit=' nexit .
            nexit=Translate(Strip(nexit,,"'"));nexit=Strip(nexit,,'"')
            If Verify(nexit,'ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$','N')>0 Then nexit=
            Leave
        End
    End

    path=Strip(Substr(path,4))
    If Wordpos('/R',parm#)>0 Then Return path
    x=nl(' ');x=nl('Fullpath:');x=nl('---------')
    Do While path/=''
        xx=$Wordat(path,72,'l');x=nl(xx)
        path=$Wordat(path,72,'t')
    End
    x=nl(' ')

    Return 0

Help_me:ms=mark(1); /* Display HELP in building line commands.

G'day.

*----------------------------------------------------------------------*

LINEMAC/LMEXIT/LMAC.
--------------------
LMAC is an "IBM" supplied line command processor.

LINEMAC is a set of predefined line commands and LMEXIT is colloqualy
refered to as 'chained' exit(s) anchored off LINEMAC to execute user
defined line commands.

While LINEMAC can readily be user customise, any modifications will not
be supported, however, limited support (advice) will be provided for
user modified LMEXIT.  LINEMAC commands will be executed before any
LMEXIT command.

LMAC permits user customised line commands outside of the LINEMAC and
LMEXIT format which will not be supported.

LINEMAC/LMEXIT is site customised and the only supported interface with
LMAC.

*----------------------------------------------------------------------*
Quick ref:
==========
LMM options:
------------
  A - Analyse LINEMAC/LMEXIT for valid format.
  E - Extract from LINEMAC/LMEXIT into individual members.
  C - Configure build member.
  B - Build LINEMAC/LMEXIT.
  TC- Trace Chain. Lists all the exits in the LINEMAC chain. Additional
      parameter of '/R' will return the chains in a string, eg.
         path=LMM('TC /R')    - then parse the path.
      Sample path returned:
         ALK2567.$$(LINEMAC) -> ALK2567.$$(LMEXITAK) -> ALK2567.$$(...
                  ****
  I - Update infrastructure code from members LM1, LM2 and LM3.
      You may control the member update by using format 'In',
      where "n" can have the following values:-
        1 - Replace appropriate code with new LM1 member.
        2 - Replace appropriate code with new LM2 member.
        3 - Replace code with new LM3 member.
  F - Update infrastructure code from members LM1, LM2 and LM3.
      Similar to 'I' except that the infrastructure did not have to
      exist.  This "Forces" build and is ideal for creating a new
      exit.
      You may control the member update by using format 'Fn',
      where "n" can have the following values:-
        1 - Replace appropriate code with new LM1 member.
        2 - Replace appropriate code with new LM2 member.
        3 - Replace code with new LM3 member.
                  ****
  n - Non-National characters "!+/`%" translated and returned in
      ISPF message.
                  ****
  ? - This tutorial (also accessible using the "HELP+" line command).
                  ****

Control Commands summary:
-------------------------
  )*    :comment.
  )A    :column Alignment.
  )C    :Cursor placement.
  )D    :Delete line.
  )E    :Dataline (after).
  )EB   :Dataline before.
  )EA   :Dataline after.
  )ER   :Dataline replace.
  )E#   :Repeated Dataline.
  )H    :Help message (ISPF message).
  )I    :Import dataset(member).
  )M    :execute Macro. (Parms - "linef,linet,lcmd parms")
  )N    :Noteline (before).
  )NA   :Noteline after.
  )NB   :Noteline before.
  )O    :Overlay line.
  )R    :Rexx command.
  )RC   :set RC on exit.
  )RL   :Restore line from original value.
  )S    :(Not fully developed.)
  )T    :rexx Trace.
  )WA   :Word At cursor. (Requires command "$WORDAT".)

Instream routines:
------------------
   mark    - Returns the relative line number.
   n_b     - Noteline before with value of Arg(1)
   n_bm    - Noteline before with value of Arg(1) + preset maskline
   n_a     - Noteline after with value of Arg(1)
   e_b     - Dataline before with value of Arg(1)
   e_a     - Dataline after with value of Arg(1)
   e_o     - Dataline (replace) with value of Arg(1)
   Trans   - Translate Arg(1).
Available variables:
   line#   - Current line number
   line@   - Current line content. (Including overtypes)
   line#s  - Start of line range
   line#e  - end of line range
   lcmd    - line command entered (unencripted)
   #adr@   - entry address mode
   lcmd1stl- original value of the cursor line
   lcmd1l# - original 1st. line number
   lcmd1c# - original column value of the 1st. line
   xcmd#   - Name of the command being exeuted. The line command member.

*----------------------------------------------------------------------*

LINEMAC and its associated exit(s) (LMEXITxx) permit users to design
their own line commands for common used code, JCL, copybooks, templates
etc.  and keep all those fiddly little edit macros in one member.
Can readily be used similar to the ISPF's "Model" feature, BUT from a
line command with smarts.

The main driver is LINEMAC and it consists of all the established site
supplied and user customised commands.  Exit LMEXIT is provided for
users to develop and play with their own commands before "importing"
them into LINEMAC. These exit commands cannot override the LINEMAC
commands, however, once established under a different command name, they
may be used to replace the same command in linemac during a rebuild
process.  (The rebuild process using "LMM" will be discussed later.)

You may chain a number of LMEXIT modules together using the "next_exit"
variable defined in the top few lines of a built member (or member LM1).
This variable is set to the next exit that is to be executed if no match
is found for the line command in the current LINEMAC/exit.  The chain is
terminated by the setting of the "next_exit" variable to NULL.
(You may interrogate the up-front exit chain using the "LMM TC" command
in any edit/view session.)

You can provide a dedicated line command to invoke detailed
tutorials/instructions for selective line commands (or provide your own
designed function documentation).  Alternatively each exit may be used
generically to "automatically" provide expanded details for those more
complex line commands that the one-liner provided by the "HELP" line
command displays. This expanded help will be provided for all documented
line commands (If this is not acceptable stay with the dedicated line
command method.)  Each exit will launch a member that can contain
expanded details for line commands intercepted by that exit. The member
launched is pointed to by variable "help_expd" setting in that exit.  By
default this variable's setting is LMHELP00 and LMHELP01 for LINEMAC and
LMEXIT respectively.  It is recommended to use member names LMHELxx
where 'xx' is the same last two bytes as the exit (if using LMEXITxx
formats).  It is the resposibility of the exits author/owner to provide
as much or as little expanded details for individual line commands for
that exit and to ensure that the expanded help is synchronised between
the correct exit and expanded help member.  Use member LMHELP00 as a
sample expanded help member.  It will be included as part of the LINEMAC
distribution.


For the purposes of this tutorial:
- LINEMAC will be referred to, however, all applies to LMEXIT as well.
- LMEXIT will be colloqually used for any exit identified by the
  "next_exit" variable.  While it can be any member name, it is
  recommended that format LMEXITxx is used where 'xx' is the initials of
  the author.
- 'expanded help' is colloqually used for any exit's "LMHELPxx" member
  (pointed to by the "help_expd" variable in the exit).
- ISPF considers a repetition command as the numerics following the
  line command itself. Eg. FRED81 infers a repetition of 81 lines
  following the line the command was placed on.
- ISPF considers a block command as a duplication of the last
  character. Eg. A block command for FRED would be identified by lines
  bounded by FREDD on two seperate lines. By this feature, you cannot
  have a command with the last two characters the same.
- Cursor and lines will be referred to as details returned by either a
  block command or line repetition command.

LINEMAC controls processing by passing control to an instream label
of the format "l_command:". (This will be covered in detail later.)

LINEMAC has 3 processing options, refered to as PO1, PO2 and PO3
respectively:
  1. Interpretive code.
     ------------------
     This consists of a series of control characters unique to LINEMAC
     and controls the processing of the data on the particular line.
     In its simplicity anything coded will be inserted after the
     line(s).  You can then control processing options by control
     characters. Eg. ")N" in column 1 will generate a NOTELINE while
     ")E" (or by default no control) a DATA line.
     While an overview of all available commands may seem daunting
     most are optional and should be used once you are comfortable with
     the basic commands.

  2. Instream REXX.
     --------------
     Pass control to the appropriate instream REXX routine and execute
     it. This should be relatively short code and only used if some
     processing logic is required. For mega-smarts use the ")M" feature.
     (See below for variables and routines available to instream REXX
     code.)

  3. External function.
     ------------------
     Invoke other pre defined code (should be an edit macro if you want
     access to the data). The easiest way to use this concept is by
     using the ")M" feature under "Interpretive code" option.
     Control is now in your hands and you are God. Do whatever you like.
     Effectively your program will be passed the following parameter
     string:
         "linef,linet,lcmd parms"
     where -
         linef  - Starting line.
         linet  - Ending line. Will be the same as linef if not a block.
         lcmd   - Line command entered. This is required for multiple
                  aliases.
         parms  - any aditional parameters required by program as set up
                  in LINEMAC.
     Note: linef, linet and lcmd are separated by commas and the full
     parameter passed should be parsed as follows:
         Parse VAR parm linef ',' linet ',' lcmd parms

     Different commands (refered to as aliases) may call the same
     program, hence the availability of the line command (lcmd and
     potential parameters) used to instigate the process. It is the
     responsibility of the receiving program to take the appropriate
     action.

     If you utilise an existing macro some modifications need to be
     made:
       a) Insert an "Address ISPEXEC 'CONTROL ERRORS RETURN'" command
          before the "ISREDIT MACRO ()" command. (Depending on your
          coding style this may not be required but it is a safety net.)
       b) If you do 'range processing' this will need to be bypassed
          when invoked through LINEMAC as the range processing has
          already been done by LINEMAC. However the line ranges are
          provided as described above.
          A line command "LEV" has been provided in LINEMAC to enter
          on the line BEFORE your range processing commands and follow
          the prompts.  Try it and you'll get the hang of it as it will
          practically hold your hand for you.

LINEMAC Command's additional parameters.
----------------------------------------
     You may wish to pass additional variable details to your program.
     The following options are available:
     1. This can be achieved by tabbing into the dataline (column 1) and
        typing in appropriate data required by your program. (You may be
        overtyping valid required data.) Fear not fair adventurer as a
        snapshot of the original data is available in variable
        "lcmd1stl" in the shared pool. The original line number and
        column number are in variables "lcmd1l#" and lcmd1c#
        respectively, issue a "VGET (lcmd1stl,lcmd1l#,lcmd1c#) SHARED"
        and if the line has changed, replace it with the original value.
        Eg.
           Address ISPEXEC "VGET (lcmd1stl,lcmd1l#,lcmd1c#) SHARED"
           If line/=lcmd1stl Then "ISREDIT LINE &lcmd1l#=(lcmd1stl)"
     2. Alternatively use the ')RL' command.
        Note:-This feature can only be used for a single line and it is
              the one the cursor is on. If a line is changed and you
              want it restored the cursor MUST NOT move from that line.
              Do not attempt this feature in a block command where when
              you hit [ENTER], the cursor is on the "to" line.  If you
              wish to do this, return the cursor to the "from" line.
             -This feature will register as a change in the Edit/View
              session and stats will be updated accordingly if the
              approprate bouncing ball is followed.
     3. Another option made available just recently is to use command
        "LMP" (LineMac Parameter) to pass parameters.
        Simply enter the LINEMAC comand and on the command line enter,
           LMP parameter(s)
        then in your exit enter,
           Address ISPEXEC "VGET (lmp#) SHARED"
        and now you have the value or the parameters that you can then
        parse/process to your heart's content.


Control Commands summary:
-------------------------
  )*    :comment.
  )A    :column Alignment.
  )C    :Cursor placement.
  )D    :Delete line.
  )E    :Dataline (after).
  )EB   :Dataline before.
  )EA   :Dataline after.
  )ER   :Dataline replace.
  )E#   :Repeated Dataline.
  )H    :(Help) message.
  )I    :Import dataset(member).
  )M    :execute Macro.
  )N    :Noteline (before).
  )NA   :Noteline after.
  )NB   :Noteline before.
  )O    :Overlay ine.
  )R    :Rexx command.
  )RC   :set RC on exit.
  )RL   :Restore line from original value.
  )S    :(Not fully developed.)
  )T    :rexx Trace.
  )WA   :Word At cursor. (Requires command "$WORDAT".)

Control Commands syntax: (must start in column 1).
------------------------
  )*    :Comment card. '*' by itself becomes a valid data/note line.
         Used for doco purposes and is ignored.
  )A    :Align with column:
     *   Align with previous line. Can have +/-n for offset from auto
         align to force indentation.
     n   Align to column number 'n'
  )C    :Place Cursor on line where:
     l,c 'l' Lines from initial line, column 'c'. Initial line is used
         and this format should be the last ")C" command for that
         professional cursor placement and final presentation.
     +n  Advance cursor 'n' lines for next process.
     -n  Regress cursor 'n' lines for next process.
         You can substitute "L" for 'l' or 'n' to indicate last line.
  )D nn :Delete line. Can pass a number of individual lines to delete.
         Number should be in ascending order with '*' representing
         the curent cursor positioning. The numbers will be processed in
         reverse order and are lines relative to the line the command
         was entered on.
  )E    :Dataline (after).
  )EA   :Dataline after.
  )EB   :Dataline before.
  )EN   :Dataline noteline. Replace current line and display original
         value in NOTELINE above it.
  )ER   :Dataline replace current line.
  )E#   :Repeated Dataline to repetition-1
  )H     ISPF (Help) message. Text of message to be displayed on exit.
         ")H" commands are stackable for large messages (>line length).
  )I(c) dsn(member) range
        :Import member for block.template
     c   Generic LINEMAC command. Use this command for all lines
         in the imported member. Valid values are E, M or N where,
            E - Each imported line is a data line
            M - Each imported line is to be executed as a macro
            N - Each imported line is a NOTELINE (or NA or NB)
         Other values will be rejected and treated as blanks. 'blanks'
         infer use the control commands (or lack of) from the imported
         dataset whose format should be the same as in this line command
         block code.  You can use the 'NA' and 'NB' for the Notelines.
     dsn Import member (seq file) and process it.
     range
         Range of lines to include from dsn(member). The range format
         is:
            from-to   where:-
               from - May be either a line number or a literal (usually
                      a label).  If the literal is used, the first
                      occurance of the literal is used as the start so
                      make sure it is unique.  You may specify an offset
                      from this literal by,
                         literal(offset)
                      where "offset" can be a positive or negative
                      displacenet from the literal line. Default is 0
                      (zero).
               to   - Same format as the "from" but is the terminating
                      line.
         Eg. )I(N) REXX($EXECIOL) 25-74
             Import as NOTELINES member 'userid.REXX($EXECIOL)' and do
             NOT include lines 1 to 24 and lines 75 to end of file.
             )I(N) REXX($EXECIOL) Start_proc#1:(1)-End_proc#1:(-1)
             Include 1st. line after label "Start_proc#1:" to the
             line before label "End_proc#1:"
         Notes:- You may repeat this block format to build your
                 inclusions, however, each inclusion will be treated
                 seperately and the same file may be read multiple
                 times.
               - Invalid parameter format may cream your member with
                 unplanned data.
  )M m p:Execute an existing macro 'm'. Will pass it parameter of
         start_line,end_line,line_command_entered 'p' (any data entered)
         Eg. )M FRED /E=(1,2)
  )N    :Noteline (before)
  )NA   :Noteline after.
  )NB   :Noteline before.
  )O m  :Overlay line with a valid edit macro MASK 'm'. 'm' can be
         represented as '+m' or 'm+'. The default is '+m' indicating
         line overlaid by mask. Use the 'm+' format to stop overlay if
         there is data.
         Eg. To place open clossing REXX comments in cols 45-72,
              ")O +<45 '/*' 71 '*/'>"  <-overlay data if there
              ")O <45 '/*' 71 '*/'>+"  <-maintain original data in cols
                                         45-46 and 71-72.
         For futher details, refer to the ISPF Edit Macros MASKLINE
         command.
  )R    :Interpret line as a REXX command. (KISS... If you want complex
         code use instream REXX.)
  )RC   :Set return code. Refer below for use/non-use of this control
         command. Ignoring return codes may cause unpredictable
         results.
  )RL   :Restore Line to original value. With this feature you can
         overtype the line to use as parameters to your command.
         LINEMAC will not utmatically restore value.  You know what can
         be overtyped, you control restoration....
  )S    :Self re-execution. Stack multi functions into 1. (NOT YET
         DEVELOPED.)
  )T r i:Turns trace on. "r" can be any valid REXX trace value. "i" can
         be either CANCEL/RETURN for ISPEXEC CONTROL command. If CONTROL
         is required without REXX tracing use a '.' paceholder for the
         REXX trace indicator.
  )WA v :Returns the space delimeted word at the cursor placement and
         places it in variable 'v'.

Control Commands positioning (relative to active line):
----------------------------
  )A    - N/A (sets prefix pad).
  )C    - Current.
  )D    - Current.
  )E    - After.
  )EA   - After.
  )EB   - Before.
  )EN   - Current.
  )ER   - Current.
  )E#   - After (or repetition -1).
  )H    - N/A
  )I    - Determined by "C" value. No additional control statements
          will be accepted after procesing
  )M    - Curent line passed to macro. Macro decides action.
  )N    - Before.
  )NA   - After.
  )NB   - Before.
  )O    - Current with MASK.
          refer to the ISPF Edit Macros MASKLINE command.
  )R    - N/A
  )RC   - N/A
  )RL   - Current
  )S    - Dependant on function it calls.
  )T    - N/A
  )WA   - Current
  no )  - Treated as ")D" with full line output.

Instream routines:
------------------
If you code your own instream REXX, refer to "CL" instream example, (you
would do this to save having heaps or 1 or 2 liners in your REXX dataset
reserving precious 1-3 character member names), the following routines
are already in affect: <why duplicate?>
   mark    - Returns the relative line number relative to Arg(1),
             eg. xx=Mark(2)  /* 2nd. line number after executing line */
   n_b     - Noteline before with value of Arg(1)
   n_bm    - Noteline before with value of Arg(1) + preset maskline
             (Follow ISPF standards and please DO NO forget to turn it
              off or users will curse LINEMAC.)
   n_a     - Noteline after with value of Arg(1)
   e_b     - Dataline before with value of Arg(1)
   e_a     - Dataline after with value of Arg(1)
   e_o     - Dataline (replace) with value of Arg(1)
   Trans   - Translate Arg(1), truncated to Arg(2) from matrix of Arg(3)
             of format 'default t1 val1 t2 val2 t3 val3 .. tn valn'
Available variables:
   line#   - Current line number
   line@   - Current line content.  Will have any overtyping which may
             be different to "lcmd1stl"
   line#s  - Start of line range
   line#e  - end of line range
   lcmd    - line command entered (unencripted)
   #adr@   - entry address mode
   lcmd1stl- original value of the cursor line
   lcmd1l# - original 1st. line
   lcmd1c# - original column value of the 1st. line
   next_exit
           - Name of the next exit to be executed after the command/exit
             being executed to launch the current line command.
   help_expd
           - Name of the member which list the expanded help details
             ("HELPX" - LMHELPxx) for the exit that intercepted the line
             command.
   xcmd#   - Name of the command/exit being executed to launch the line
             command.

Control syntax and GOTCHAs:
---------------------------
 1. Line command format (controlled by the "LMM" program and you should
    not be concerned with this unless you make direct amendments to
    LMEXEIT outside the "LMM" program):-

    Block start:                                                /*
     "L_cmd:ms=mark(1); /* comment"
      where:
       "L_"  - identifies line as label
       "cmd" - is your line command. Try to keep it short as possible as
               you only have 6 characters and the last character must be
               repeated to identify it as a block command. Also if your
               command is 5 characters you can only indicate a 9 times
               repetition number in the last character.
               Watch accidental creaming of existing commands, eg. "LC"
               ISPF's lower case conversion.
               Special encripted labels will be created for commands
               including the following characters "!+/`%".
       ":ms=mark(1); /*
             - Used to terminate label (:), set a variable to the next
               line number (mark()), command terminator (; - optional)
               and the "/*" for comment starter. This has to be
               terminated with a "*/" if you have a dual label. Note for
               multi labels, only the last requires a "ms=mark(1);".
               For in stream REXX command, this should NOT be used as
               the absence of this identifies the block as an instream
               REXX routine to "LMM". Instream REXX should have a
               terminating "*/" to the comment on the same line.
    Block End:
     "*/ End_cmd:me=mark(-1);Return put_lines()"
      where:
       "*/"  - End of comment block. Not used in instream REXX commands.
       "End_"- Identifies last line of the command block.
       "Return .."
               Code set by ")RC" control parameter ")M" exit value or
               0 default.
      For instream REXX commands, the "me=..." is redundant if used.
 2. Return codes control execution looping. LINEMAC will return the
    start and end lines of a line command. (Let us assume the range is
    >1.)  Generally range processing is repeated for each line and as a
    result the default return from a line command process is rc=0 Which
    results in a repetition loop for the range.  The return code from a
    ")M" edit macro is used. However, your macro may just want to
    process the range of lines only once.  To prevent repetition, exit
    your macro with a non-zero return code, or if it is a generic macro
    where that would not be acceptable, use the ")RC" command to set a
    non-zero return code.  The ")RC" control should be used on any
    command where a deliberate or accidental range command should only
    be executed once.
 3. Certain combinatios of control commands may not permit the desired
    result or give strange results, especilly if you mix ")E" and ")N"
    commands because of placement commands. You may need to reorder some
    lines or reverse orders. Play around till you get the right results.
    Use the ")C +/-" command to keep track of changed line
    sequences and reposition 'active' line.
    Refer to the "LEV" line command to highlight this Gotcha.
 4. For line insertions that have legitimate ")" character in column 1,
    eg, ISPF panels and skeletons, do not use the non-control character
    format, eg. a panel model line should be coded ")E )MODEL ....".
    Alternatively import from a member.
 5. Option ")D" is to tidy up after inserting dummy lines for noteline
    positioning. Minimise its use as misuse can cream good code.
 6. ISPF only returns a range within the confines of your member.
    If you issue a line command, eg. AF23, on line 3 of a 10 line
    member, the range returned will be 7 (3 to 10).
 7. ISPF will not permit imbedded numerics. So dont try to be smart and
    create a command line "A2B" unless the command has special
    characters and is "A+B", (I learnt the hard way.)
 8. If you choose to chain exits, do not call a previouly chainde exit
    otherwise you will go into a recursive loop.


    LMM:
    ----

    Program LMM (LineMac Manager) has been provided to partially
    automate the management of the LINEMAC and LMEXIT programs.
    Theoretically LINEMAC should not be modified as any build process
    will regress changes made to LINEMAC.  Any new code should be made
    and tested in LMEXIT and eventaully extracted and built into
    LINEMAC.

    This program has 7 basic functions and will be presented in sequence
    (sometimes refered to LMM-A, LMM-E, LMM-C, LMM-B, LMM-I, LMM-T and
    LMM-H respectively):
     1. Analyse LINEMAC/LMEXIT for syntax to ensure the "extract" phase
        will process correctly.
     2. Extract "line commands" from edit/view session into individual
        members.
     3. Configures the "build" member.
     4. Builds the LINEMAC/LMEXIT edit macro.
                     ****
     5. Replaces code in LINEMAC/LMEXIT with infrastructure members
        LM1, LM2 and/or LM3 and keep the user code intact.  This
        feature eliminates the need to extract and re-build LINEMAC.
        (You still need to perfrom the extract/configure/build steps
        if you wish to merge line commands from different sources.)
                     ****
     6. Translates any potential command containg any (or a mix) of
        the following non-national characters "!+/`%".
                     ****
     7. Display this tutorial. Also called by the "HELP+" line command.
                     ****

    LMM parameters:
    ---------------
     A - Analyse LINEMAC/LMEXIT for valid format.
     E - Extract from LINEMAC/LMEXIT into individual members.
     C - Configure build member.
     B - Build LINEMAC/LMEXIT.
     TC- Trace Chain.
                     ****
     I - Update infrastructure code from members LM1, LM2 and LM3.
         You may control the member update by using format 'In',
         where "n" can have the following values:-
           1 - Replace appropriate code with new LM1 member.
           2 - Replace appropriate code with new LM2 member.
           3 - Replace code with new LM3 member in LINEMAC.
     F - Force infrastructure. Same as 'I' except that it is used
         instead of 'I' when it is a new exit and the infrastructure
         is not present. May use 'Fn', however, it is suggested to
         do all.
                     ****
     n - Non-National charcters "!+/`%" translated and returned in
         ISPF message.
                     ****
     ? - This tutorial (also accessible using the "HELP+" line command.
                     ****

    LMM process cycle:
    ------------------
    LINEMAC ->(LMM-A)-> Correct any errors reported.
    LINEMAC ->(LMM-E)-> $LMMC ->(LMM-C)-> $LMMB ->(LMM-B)-> LINEMAC

    1. Analyse LINEMAC/LMEXIT formats (LMM-A):
    ------------------------------------------
    Edit/View LINEMAC/LMEXIT program. To effectively extract line label,
    where "cmd" is the line command. If a start "l_" label is found
    without it's complimentary "End_" label, it will be insereted as a
    NOTELINE before the next "l_" label. However, if it has a "l_" label
    either before or after it infering that it may be a label in a block
    command, it will be signalled accordingly for subsequent manual
    analysis and correction.   If it is a block command ignore it
    otherwise you may convert the noteline to data and delete any
    incorrect labels.
    If the 'start' of the blocked command has a complimentary "End_"
    label (1st. "l_" label should match the "End_" label) no error
    is reported.

    2. Extract "line commands" (LMM-E):
    -----------------------------------
    Edit/View LINEMAC/LMEXIT program. Either edit the second line, the
    one with ")X dataset" commented, to change the output dataset or
    accept the default 'userid.LINEMAC.COMMANDS'. If the output dataset
    does not exist it will be created. Note, the extraction will
    overwrite any like members in the output dataset.
    Enter "LMM E" on the command line to extract all members and create
    the configure member (default is $LMMC for LINEMAC and $LMMCX for
    LMEXIT).
    The third line, The one with the ")I dataset commented, points to
    the dataset that contains the code to wrap around your build of
    LINEMAC/LMEXIT during the build process. These are members 'LM1',
    'LM2' and 'LM3'.

    The extract process will process the viewed/editted member as
    follows:
      - Will look for a "l_" and "End_" blocks and create/replace any
        like members in the output dataset.
        Gotcha:  If the "End_" label is not found, the code will not be
        extracted into a member. The command part of the label will be
        used for member names.
      - If you use any of the special characters "!+/`%" in the command
        and these characters cannot be used in member names, the
        characters are traslated to "12345" respectively. To permit a
        valid member name, the member is prefixed with a "#". While "#"
        is a permissable line command any members starting with a "#"
        and contain numbers, will include from the above characters in
        whatever combination.  If this is confusing, DONT use them.
        NOTE - "/" is reserved for SuperSearch. Use it and suffer the
               wrath of Mr. Lim.
             - The labels will be removed and will not appear in the
               extracted member.
             - The comment on the label will be inserted in a 3 line
               comment box in the member.
             - @R on line 1 is generated to indicate instream REXX and
               should not be removed/changed
             - @A on line 1 (and following if applicable) indicate multi
               aliases for that block code. It's the same code (member)
               initiated by different line commands. The first label is
               used to generate the member name.

    The extract process will automatically generate the configure
    member $LMMC/$LMMCX.
    The following lines will be generated:
     )B Destination of the build member. BY default this will be the
        dataset identified by the ")X" line in the extract process
        and member $LMMB for LINEMAC and $LMMBX for LMEXIT.
     )O Destination of the final build and the member name. The member
        name should be either LINEMAC or LMEXIT.
        (It is suggested the build is made to the same dataset as the
        extraction and copied to the appropriate SYSPROC/SYSEXEC
        dataset.)
     )I Infrastructure dataset. Residence of default members LM1 and
        LM2. These dataset is taken from the ")I" line 3 from the member
        being extracted.
     )U User dataset to use for finding build members.
        The extract process will use the extract dataset with "(*)" to
        identify all members. An ignore string as follows will be placed
        on the line:
             "- $LMM* $$$INDEX LINEMAC LMEXIT*"
        The '-' identifies ignore command followed by an ignore member
        list. Members can have a trailing '*' wildcaring indicator.
        Note, the '$LMM*' will automatically exclude the $LMMC, $LMMCX,
        $LMMB and $LMMBX members.
     )END Terminator.
     )* Are treated as comments.
     You can include any other datasets to be included when configuring
     the build member.
     Place any data you want to keep for reference but not process after
     the ")END" line.
     To generate a build member enter the "LMM C" on the command line.
     This will configure the build member and present it under the
     editor. (For further details, refer below.)

     Sample $LMMCx member:
     ---------------------
     col1
     |
     )*----------------------------------------------------------*
     )* Configure member - use "LMM C" to create.                *
     )*----------------------------------------------------------*
     )B LINEMAC.COMMANDS($LMMBX) <- build member
     )*
     )O LINEMAC.COMMANDS(LMEXIT) <- final output
     )*
     )I 'site.LINEMAC.REXX'      <- infrastructure members
     )*
     )U LINEMAC.COMMANDS(*) - $LMM* $$$INDEX LINEMAC LMEXIT*
     )*
     )*  Add any other datasets to use for the build member
     )*U 'site.LINEMAC.COMMANDS(*)'  - $LMM* $$$INDEX LINEMAC LMEXIT*
     )END
     )U 'other.LINEMAC.COMMANDS(*)' - $LMM* $$$INDEX LINEMAC LMEXIT*


    3. Configure the build member (LMM-C):
    --------------------------------------
    Edit/View $LMMC/$LMMCX members. Modify re-arrange lines if/as
    required.
    Enter "LMM C" on the command line to create the build member.

    The configure process will automatically generate the build member
    $LMMB/$LMMBX.
    The following lines will be generated:
     )O Output destination of the build process. As detected in the
        extract process. Taken directly from the ")O" in the configure
        member or defaults to current.dataset(LMEXIT) if not present.
     )I Infrastructure dataset as percolated through the extract and
        configure dataset.
     )U dataset(*) - exclude.list /* comments */
        One for each unique dataset in the configure member one of these
        lines will automatically be generated with an exclusion list
        as you supplied an '$LMM* @* LINEMAC' added if not supplied.
        Below this will be a list of all members in the dataset with
        the exception of those matching the configure exclusion list.
        This pattern will be repeated for all dataset (unique or not)
        in the config member.
        This is the hard part. You either accept all members form all
        the
        "..(*)  - exclude.list" or order and delete individual members
        till you get that warm fuzzy satisfied feeling. If you choose
        this path, back it up as the next configure run will cream all
        your hard work.  Delete any redundant lines as all specified
        members (explicit or implicit) will be included in your
        customised LMEXIT build member.  Any duplicates will be
        highlighted and ignored (at a processing overhead).
     )END
        Terminateds processing. Rather than deleting lines, suggest
        place after an ")END" control to keep for later reference
        without being processed.
     )* Comment lines that are ignored.
     Use the ")U" feature to swap macros/line commands with your
     friends.
     Enter "LMM B" on the command line to create the final LINEMAC or
     LMEXIT command. Copy this into your SYSPROC/SYSEXEC concatenation.
     Note - watch the build list as all members detected, whether
            explicitly or implicitly, will be include.
          - Paragraphs and aliases and comments will automatically be
            performed by the build process.

     Sample $LMMB member:
     --------------------
     col1
     |
     )*----------------------------------------------------------*
     )* Build member for the exit - use "LMM B" to create        *          *
     )*----------------------------------------------------------*
     )O LINEMAC.COMMANDS(LINEMAC)        /* This is IT!..                  */
     )*
     )I $$ <- Infrastructure members
     )*
     )*
     )U LINEMAC.COMMANDS(*) - $LMM* $$$INDEX LINEMAC LMEXIT*
     )* Members after the '-' are to be ignored (can wildcard*)
     )*      or
     )* Delete above and include from following members. Move
     )* most used to top for those few MIP savings.
     )*
     )U LINEMAC.COMMANDS($S)
     .........
     )U LINEMAC.COMMANDS(ZEDSM)
     )*
     )END

    4. Build the LINEMAC edit macro (LMM-B):
    ----------------------------------------
    Edit/View $LMMB/$LMMBX members. Make last minute touches to arrange
    lines if/as required.
    Note: The ")I dataset" has percolated down through all the previous
          processes and caused no adverse grief if the incorect dataset
          was entered.  At this point an invalid dataset could be
          catastrophic so make sure it contains members LM1, LM2 and
          LM3.
    Enter "LMM B" on the command line to create the appropriate LINEMAC
    or LMEXIT member.
    Copy this member(s) into your SYSPROC/SYSEXEC concatenated dataset
    if the above dataset is not in the concatenation.


    5. Trace chain (LMM-TC):
    ------------------------
    Traces the chaining of exits starting at LINEMAC and ending when the
    following exit has variable "next_exit" set to nulls. The display
    will be presented in notelines at the top of the editted/viewed
    member.

    6. Update Infrastructure (LMM-I):
    ---------------------------------
    Update the infrastructure code from members LM1, LM2 and LM3 leaving
    your line command code intact.  This feature is used to apply
    shipped patches to LINEMAC/exits without the need to re-build the
    command.  (Alternatively you may re-build/rationalise LINEMAC and
    any additional exits.)
    You may control the member update by using format 'In', where "n"
    can have the following values:-
      1 - Replace appropriate code with new LM1 member.
      2 - Replace appropriate code with new LM2 member.
      3 - Replace appropriate code with new LM3 member.

    7. Translates Special characters (LMM-n):
    -----------------------------------------
    If you choose to use any of the following special characters "!+/`%"
    in your command, enter your proposed command after "LMM" to generate
    a label you can use to manually edit and modify your exit without
    going through the build extract/configure/build process.
        Eg.  LMM CP%A   -> "l_CP5A" and you will need a "End_CP5A".

    Hints and Tips:
    ---------------
     1. The line command can only be 6 characters long, however, I
        suggest you limit it to 5 to permit block commands and
        repetition.  Block mode is identified as duplicated last two
        characters.  (Thereby you could not have a line command like
        "CRAPP" as it would be considered a block of "CRAP" so I suggest
        you have a short CRAP with a single P.)  ALso a 5 character line
        command would only permit a maximum of 9 repetitions without
        blocking. Line commands cannot have embeded numerics hence the
        exploitation of special characters which are translated to
        numbers for member and program label purposes.
     2. Before executing the extraction phase, run the analysis phase
        to detect any formatting anomalies. Without this analysis and
        subsequent correction, commands may be ignored and lost during
        the build phase.
        (I repeat that I cannot emphasisse this step enough. You have
        been warned snake-eyes.)

     3. On extraction, each paragraph (line command) will be stored in
        a member bearing the commands name. The exception is when
        special characters are used and in that case the name is
        encripted with numerics.
        By design, there is a comment on each command label giving a
        brief description as a comment which is used by the "HELP" line
        command to educate the masses. During extraction, this comment
        will be immortalised in the offloaded member as line 2 skirted
        by a "comment box". This line should always be preserved as a
        short description of the command. You may continue in depth
        doco within comment lines in the head of the member. Line 2
        (with few exceptions) only will be used for internal doco and
        any other doco at the start will not be imported into LINEMAC.
        So, if you spent the last couple of days documenting your
        you-beaut world conquering member, back it up as a extraction
        will cream the member and replace your manuscript with a 3 line
        box comment extracted out of 1 line on LINEMAC.

        NOTE-NOTE - Extraction will cream existing members - NOTE-NOTE

        a) "@R" on line 1 of members indicate it is an executable piece
           of code (opt 2.c above). This is used by the build process to
           indicated that the code is to be executed and not
           interpreted.
           Note - The presence of this control line will make LINE 3 the
                  doco source.
        b) "@A" on line 1 of members indicate it is a multi invocable
           member. The next word will indicate all the commands that
           can be used to execute the original command (member) in the
           format c1=c2=c3... Only one member is created but this
           control line will generate all the appropriate labels in
           LINEMAC.
           Note - The presence of this control line will make LINE 3
                  the doco source.
     4. In block command mode (BULL) or muti-line mode (BUL25) the
        command will be executed multiple times (from-line to to-line).
        If that is your desire then do nothing. However, for example,
        you wish to pass a block to a macro once or you are adamant that
        any accidental repetition is a no-no your salvation is at hand
        as follows:
        a) Leave the REXX block or external edit macro with RC>0.
        b) In the interprative code, finish with an ")RC 4" control
           command.
     5. In executable REXX and invocation of edit macros, you have
        full control. But if you are slack and chose the interprative
        feature (which by the way is a little bewdy) the following
        low profile control command may be usefull:
          )A   - Column alignment
          )C   - Cursor placement
          )D   - Delete cursored line
          )R   - Execute REXX commands by interpreting the line
          )T   - Tracing
     6. LMEXIT will be called after the command entered is not found
        in LINEMAC. LINEMAC commands cannot be overriden through the
        exit.  If you want to use your command instead of one in
        LINEMAC, you will have to rebuild linemac pointing to your
        member in the appropriate $LMMB member.

    Recommended minimum packaging:
    ------------------------------
    The only two mandatory requirements are REXX routine "LINEMAC" and
    load module "LMAC" in their respective ISPF concatenations.

    The following members are recommended as the minimum package set:

    $DDALLOC - Routine to locate members in a DD allocation.
    $SORT    - Sort HELP commands prior to display.
    $WORDAT  - Word at character position identifier. For ")WA" command.
    LINEMAC  - Generic line edit macro command driver.
    LMACLMOD - LMAC load moule XMITed in here for easier distribution.
               Issue a TSO RECEIVE INDA() against this member to unload
               the load module.
    LMALLOC  - Alocate LINEMAC datasets(s).
    LMEXIT   - LINEMAC primary exit.
    LMM      - LINEMAC Member Manager and this tutorial.
    LMP      - LINEMAC parameter supplier. Command used as one of
               several options to pass parameters to linemac commands
               without potentially comprimising the content of the
               member. (For further details, refer to the preamble in
               member "LMP".)
    LMPRMEMB - LINEMAC member processor.
    LMREADME - LINEMAC readme.
    LMREMOVE - Remove line command facility.
    LM1      - LINEMAC front end infrastructure.
               Used by LMM to build LINEMAC or LMEXIT.
    LM2      - LINEMAC back  end infrastructure.
               Used by LMM to build LINEMAC or LMEXIT.
    LM3      - LINEMAC HELP+ infrastructure.
               Used by LMM to build LINEMAC or LMEXIT.
    REAL     - Optional ISPF concatenation allocator used by 'LMALLOC'.

    It is recommended that you browse member 'LM$INDEX' for additional
    suggested members that may be used by a prebuilt LINEMAC/LMEXIT.

*/;   me=mark(-1);
    "(caps) = CAPS";"CAPS = OFF"
    If Datatype(Word(parm#,2))='NUM' Then ls=Word(parm#,2);Else ls=1
    Do i_p=ms To me;x=nl(Sourceline(i_p));End
    "CAPS = (caps)";"CURSOR=" ls-1 0;Return 4
