        /* --------------------  rexx procedure  -------------------- *
         * Name:      lstproc [Version `_version_.]                   *
         *                                                            *
         * Function:  Display active JES2 proclibs                    *
         *                                                            *
         * Syntax:    %lstproc proc {/D | /ND | ? {/T}}               *
         *                                                            *
         *            Where proc is the name of the JES2 proc or      *
         *            blank to default to JES2.                       *
         *                                                            *
         * Assumptions and Caveats:                                   *
         *            1. if proc not specified then use JES2          *
         *            2. only //PROCxx will be looked at              *
         *            3. comments will be ignored                     *
         *            4. symbolics are supported (mostly)             *
         *            5. system symbolics are supported               *
         *            6. only cataloged datasets are supported        *
         *            7. JES2 Dynalloc procs are not supported        *
         *            8. nested symbolics may not work                *
         *            9. if the mstrjcl or jes2 proc changes that     *
         *               is what you will see reflected               *
         *           10. This does NOT report the actual proc usage   *
         *               but what is found from mstrjcl and the       *
         *               jes2 proc.                                   *
         *           11. *IMPORTANT* It is assumed you have RACF      *
         *               read for the LISTDATA IDCAMS command.        *
         *               If not find *LISTDATA* and make the          *
         *               noted changes.  You will then be limited     *
         *               to the cataloged iplparm dataset.            *
         *                                                            *
         * Author:    Lionel B. Dyck                                  *
         *            Internet: lbdyck@gmail.com                      *
         *                                                            *
         * History:                                                   *
         *                                                            *
         *           19 Sep 08 - Alex Kara                            *
         *                       CSC Australia                        *
         *                       +61-3-9428-1270                      *
         *                       akara@csc.com                        *
         *                                                            *
         *                    -  Provided for ignoring commented      *
         *                       lines (//*).                         *
         *                    -  Provided for debugging traces using  *
         *                       a '/T' parameter.                    *
         *                    -  Hard coded a work around fix for     *
         *                       sysid=PRK1.                          *
         *                                                            *
         *           30 Jul 08 - Alex Kara                            *
         *                       CSC Australia                        *
         *                       +61-3-9428-1270                      *
         *                       akara@csc.com                        *
         *                                                            *
         *                    -  Presented both IEFPDSI and IEFJOBS   *
         *                       under the #PROCMST concatenation with*
         *                       the IEFJOBS concatenated first.      *
         *                    -  Modified code to correct variable    *
         *                       substitution for IEFPDSI/IEFJOBS     *
         *                       concatenated datasets.               *
         *                                                            *
         *           05 May 08 - Alex Kara                            *
         *                       CSC Australia                        *
         *                       +61-3-9428-1270                      *
         *                       akara@csc.com                        *
         *                                                            *
         *                    -  Modified code to read the JES2PARM   *
         *                       member and cater for greater         *
         *                       "INCLUDE" command formats.           *
         *                    -  Added '/ND' parameter option to      *
         *                       disable dynamic parameter search if  *
         *                       variable "aloc_dy" (on line `L#1.) is*
         *                       set to site default of 1.  This      *
         *                       facility is provided to control the  *
         *                       increased processing cycles for      *
         *                       "dynamic"  parsing when the site     *
         *                       does/does not use it.                *
         *                    -  Provided in-line tutorial using      *
         *                       parameter "?".                       *
         *                                                            *
         *           27 Feb 08 - Alex Kara                            *
         *                       CSC Australia                        *
         *                       +61-3-9428-1270                      *
         *                       akara@csc.com                        *
         *                                                            *
         *                     - Included code to read the JES2       *
         *                       HASPPARM dataset and extract any     *
         *                       dynamic allocated proclib.           *
         *                       The dynamic procs are allocated to   *
         *                       #PROCnn$ (suffixed by a $) if a '/D' *
         *                       (Dynamic) parameter is passed.       *
         *                                                            *
         *                     - Parameter '/IA' will use "ISPFALOC"  *
         *                       instead of "ISRDDN" to display       *
         *                       allocations as it has a lot more     *
         *                       options than "ISRDDN".               *
         *                     - My changes can be identified by code *
         *                       between "arrow" line delimiters with *
         *                       " ALK " eye-catchers (or "ALK" as    *
         *                       comment at end of line).             *
         *                                                            *
         *            10/16/07 - If not under ISPF just write         *
         *                       dd and dsnames to screen             *
         *                                                            *
         *            02/20/07 - Correction from Ian Ramage           *
         *                       Fix if JES2 Proc in >2 proclib       *
         *                                                            *
         *            11/27/06 - Hartmut Beckmann                     *
         *                       Changes for better member support    *
         *                                                            *
         *            09/25/06 - Peggy Norton                         *
         *                       Fix call to subroutine for symbolics *
         *                                                            *
         *            05/17/06 - Jeff Dixon                           *
         *                       Support //PROCxxxx instead of PROCxx *
         *                                                            *
         *            05/11/06 - Peggy Norton                         *
         *                       Fix if LOADxx does not have defined  *
         *                       SYS1.PARMLIB                         *
         *                                                            *
         *            01/26/06 - Ian Ramage                           *
         *                       Add Numeric Digits 10 to resolve     *
         *                       issue under z/OS 1.6                 *
         *                                                            *
         *            09/02/03 - John Bloniarz                        *
         *                       McDonald's Corporation               *
         *                       630-623-3224                         *
         *                       john.bloniarz@mcd.com                *
         *                                                            *
         *                       make callable as a function from     *
         *                       REXX to allocate system Parmlibs,    *
         *                       system Proclibs and/or PROCxx's.     *
         *                       Changed DD name #PROCMST to          *
         *                       #PROCLIB when called as a function.  *
         *                                                            *
         *            08/28/03 - John Bloniarz                        *
         *                       McDonald's Corporation               *
         *                       630-623-3224                         *
         *                       john.bloniarz@mcd.com                *
         *                                                            *
         *                       add code to resolve all system       *
         *                       symbols before allocation.           *
         *                                                            *
         *            08/19/02 - correct to work with OS/390 below    *
         *                       2.10 (broke on 8/18 change)          *
         *            08/18/02 - pass ONLY #PROC to ISRDDN            *
         *                       and bypass former ispf msg           *
         *            08/15/01 - support INCLUDE in the Proc          *
         *            04/25/01 - fix from Iam Ramage to correctly     *
         *                       find the parmlib volser.             *
         *                       ian.ramage@rs-components.com         *
         *            02/21/01 - fix if proc symbol has quotes        *
         *            10/24/00 - update to get iplparm vol dyn        *
         *                       thx to Philippe Richard of IBM       *
         *            10/23/00 - update to get iplparm dsn dyn        *
         *                       thx to Philippe Richard of IBM       *
         *            06/20/00 - general release                      *
         *                     - Change dds to #PROCMST & #PROCnn     *
         *            06/15/00 - minor clean up                       *
         *            06/14/00 - various changes                      *
         *                     - add code to dynamically find mstjclxx*
         *                       from Todd Burrell (zpn6@cdc.gov)     *
         *            06/13/00 - creation                             *
         *                                                            *
         * ---------------------------------------------------------- *
         *  codepage 1141                                             *
         *  CHANGE X"BBBB" X"4F4F" ALL .a .zlast (concat)             *
         *  CHANGE X"BB"   X"4F"   ALL .a .zlast (logical OR)         *
         *                                                            *
         * ---------------------------------------------------------- */*/
n_en=mark(-2)                           /* ALK - Mark End of Help     */

         _version_ = "2.3+3"            /* + (with ALK modifications) */
        /* ----------------------------------------------------- *
         * Setup defaults in sub routine                         *
         * ----------------------------------------------------- */
         _x_ = sub_init() ;
        /* -------------------------------------------- *
         * Check for any passed options. The only       *
         * supported option at this time is the name of *
         * the JES2 proc to look for.                   *
         * -------------------------------------------- */
         arg options
/*-\|/------ ALK -----------------------------------------------------*/
        /* -------------------------------------------- *
         * Check for switches passed. Refer to doco by  *
         * Alex Kara.                                   *
         * -------------------------------------------- */
         Parse Upper arg uoptions
         aloc_dy=1                          /* Scan for Dynamic 1/0   */
         l#1=mark(-1)                       /* Mark above line        */
         If Wordpos('?',uoptions)>0 Then Signal Help_me
         If Wordpos('/T',uoptions)>0 Then Do
             Trace r
             options=Delword(options,Wordpos('/T',uoptions),1)
             Parse Upper VAR options uoptions
         End
         If Wordpos('/D',uoptions)>0 Then Do
             aloc_dy=1
             options=Delword(options,Wordpos('/D',uoptions),1)
             Parse Upper VAR options uoptions
         End
         If Wordpos('/ND',uoptions)>0 Then Do
             aloc_dy=0
             options=Delword(options,Wordpos('/ND',uoptions),1)
             Parse Upper VAR options uoptions
         End
         If Wordpos('/IA',uoptions)>0 Then Do
             uisrddn=0
             options=Delword(options,Wordpos('/IA',uoptions),1)
             Parse Upper VAR options uoptions
         End;Else uisrddn=1
         dprocl=
/*-/|\------ ALK -----------------------------------------------------*/

         ddn = "JCL"random(9999)
         Numeric Digits 10

        /* ----------------------------------------------------- *
         * test options and use for procname or use JES2         *
         * ----------------------------------------------------- */
        if substr(options,1,1) = "." then do
           parse value options with "." lstprocm .
           options = null
        end
        if words(options) > 1 then do
           parse value options with opt1 " " opt2 " " opt3 " " opt4
           if opt1 = "*" then do
              options = null
              end
            else do
              options = opt1
              end
           end
         else do
           if options = "*" then do
              options = null
              end
           end
        if options = null then jes2 = "JES2"
                          else jes2 = options
        isfunc = "N"
        allocdd = null
        retstr  = null
        if length(opt2) > 0 then do
           if abbrev("FUNCTION",opt2,1) = 1 then do
              isfunc = "Y"
              if length(opt3) > 0 then do
                 allocdd = opt3
                 end
              end
           end

        /* ----------------------------- *
         * Test for ISPF and if not then *
         * set flag to only echo Parmlib *
         * info to the "screen".         *
         * ----------------------------- */
         sysispf = sysvar(sysispf)
         if sysispf = "ACTIVE" then ispf = 1
                               else do
                                    ispf = 0
                                    isfunc = "F"
                                    end
        /* ----------------------------------------------------- *
         * Code from Todd Burrell to get mstjcl info             *
         * Enhanced by Ian Ramage                                *
         * ----------------------------------------------------- */
        CVT=STORAGE("10",4)
        CVTECVT=STORAGE(D2X(C2D(CVT)+140),4)
        /* GET THE IPL LOADPARMS */
        LOADPARM=STORAGE(D2X(C2D(CVTECVT)+168),8)
        /* address of IHAIPA control block */
        CVTIPA=STORAGE(D2X(C2D(CVTECVT)+392),4)
        /* mstjcl section in IPA */
        MJC=STORAGE(D2X(C2D(CVTIPA)+2448),4)
        /* mstjcl section in IPA length */
        MJCLEN=C2D(STORAGE(D2X(C2D(CVTIPA)+2452),2))
        /* ieasys source in mstjclxx */
        MJCSYS=STORAGE(D2X(C2D(CVTIPA)+2454),2)
        /* mstjcl xx value */
        MJCXX=STORAGE(D2X(C2D(MJC)+0),MJCLEN)
        if left(mjcxx,1) = "(" then
            parse value mjcxx with "(" mjcxx ")" .

         /* address of IHAIPA control block */
         IPLPARM  = Strip(LOADPARM)
         LOADADR  = Substr(IPLPARM,1,4)

        /* mstjcl section in IPA */
        ipalpar  = storage(d2x(c2d(cvtipa)+32), 8)
        ipalpdsn = storage(d2x(c2d(cvtipa)+48),44)
        parmaddr = storage(d2x(c2d(cvtipa)+92), 4)
        LOADVOL  = chk_volser(parmaddr)
        lparm = ""strip(IPALPDSN)"(load"substr(loadparm,5,2)")"
        lparm = ""_apost_""lparm""_apost_""

        /* ----------------------------------------------------- *
         * Read loadparm member to find parmlibs                 *
         * ----------------------------------------------------- */
         if loadvol <> null then
            "Alloc f("ddn") ds("lparm") shr reuse volume("LOADVOL")",
               "unit(sysallda)"
         else
            "Alloc f("ddn") ds("lparm") shr reuse"
         "Execio * diskr" ddn "(finis stem in."
         rcode = rc
         "Free  f("ddn")"
         LPAR = true
         do i = 1 to in.0
            if word(in.i,1) = "LPARNAME" then
               if word(in.i,2) = ipalpar then LPAR = true
                                         else LPAR = false
            if word(in.i,1) = "PARMLIB" & LPAR = true then
               parmlibs = parmlibs word(in.i,2)
            end
        if parmlibs = null then parmlibs = "SYS1.PARMLIB"
        if wordpos("SYS1.PARMLIB",parmlibs) = 0 then     /* PN */
           parmlibs = parmlibs" SYS1.PARMLIB"            /* PN */

        /* ----------------------------------------------------- *
         * Alloc all Parmlibs to DD: #PARMLIB (If Appropriate)   *
         * ----------------------------------------------------- */
         if isfunc = "Y" then do
            if allocdd = sub_allocdd("#PARMLIB") then do
               alloc_parms = null
               do i = 1 to words(parmlibs)
                  parm  = ""_apost_""word(parmlibs,i)""_apost_""
                  alloc_parms = alloc_parms parm
                  end
               if pos("&",alloc_parms) > 0 then do
                  symtext = alloc_parms
                  call fix_sym1
                  alloc_parms = symtext
                  end
               RC = msg("OFF")
               "Free  f(#PARMLIB)"
               RC = msg("ON")
               "Alloc f(#PARMLIB) ds("alloc_parms") shr reuse"
               retstr = strip(retstr "#PARMLIB")
               end
            if allocdd <> null &,
               allocdd = retstr then signal Finish
            end

        /* ----------------------------------------------------- *
         * Find PARMLIB with MSTJCLxx                            *
         * ----------------------------------------------------- */
         do i = 1 to words(parmlibs)
            mstrjcl = ""strip(word(parmlibs,i))"(MSTJCL"mjcxx")"
            mstrjcl = ""_apost_""mstrjcl""_apost_""
            if "OK" = sysdsn(mstrjcl) then leave
            end

        /* ----------------------------------------------------- *
         * Alloc and read master jcl parmlib member              *
         * ----------------------------------------------------- */
        if "OK" <> sysdsn(mstrjcl) then do
           in.0 = 1
           in.1 = "//IEFPDSI DSN=SYS1.PROCLIB  "
           end
        else do
             if pos("&",mstrjcl) > 0 then do
                symtext = mstrjcl
                call fix_sym1
                mstrjcl = symtext
                end
/*
Say mstrjcl
mstrjcl="'SYS3711.$(A)'"
Address ISPEXEC "VIEW DATASET(&MSTRJCL)"
*/
             "Alloc f("ddn") ds("mstrjcl") shr reuse"
             "Execio * diskr" ddn "(finis stem in."
             rcode = rc
             "Free  f("ddn")"
             end

        /* ----------------------------------------------------- *
         * Find all proclibs in IEFPDSI and save them            *
         * Updates by ian.ramage@rs-components.com               *
         * ----------------------------------------------------- */
        hit = 0
        do i = 1 to in.0
          in.i  = TRANSLATE(in.i," ",",")
           if hit = 1 then do
              if substr(in.i,3,1) = "*" Then Iterate           /* ALK */
              if substr(in.i,3,1) = " "
                 then do
                      parse value in.i with . "DSN=" dsn " " .
                      if pos("&",dsn) > 0 then call fix_sym    /* ALK */
                      proc_l.i_dd = proc_l.i_dd dsn            /* ALK */
                      end
                 else hit = 0
              end
           j_dd=left(in.i,9)                                   /* ALK */
           if j_dd = "//IEFPDSI" | j_dd = "//IEFJOBS" then do  /* ALK */
              i_dd=Substr(j_dd,3)                              /* ALK */
              hit = 1
              parse value in.i with . "DSN=" dsn " " .
              dsn = word(strip(dsn),1)                  /* @pn */
              if pos("&",dsn) > 0 then call fix_sym     /* @pn */
              proc_l.i_dd = proc_l.i_dd dsn                    /* ALK */
              end
           end
         proclibs=Space(proc_l.IEFJOBS proc_l.IEFPDSI)         /* ALK */

        /* ----------------------------------------------------- *
         * Alloc all Master JCL Proclibs to DD: #PROCMST         *
         * (or DD: #PROCLIB if called as a function)             *
         * ----------------------------------------------------- */
        alloc_procs = null
        do i = 1 to words(proclibs)
           proc  = ""_apost_""word(proclibs,i)""_apost_""
           alloc_procs = alloc_procs proc
           end
        if pos("&",alloc_procs) > 0 then do
           symtext = alloc_procs
           call fix_sym1
           alloc_procs = symtext
           end
        procddn = "#PROCMST"
        if isfunc = "Y" then do
           if allocdd = sub_allocdd("#PROCLIB") then do
              procddn = "#PROCLIB"
              end
           end
        RC = msg("OFF")
        "Free  f("procddn")"
        RC = msg("ON")
        if ispf = 1
           then "Alloc f("procddn") ds("alloc_procs") shr reuse"
           else call echo procddn alloc_procs
        if isfunc = "Y" then do
           if allocdd = sub_allocdd("#PROCLIB") then do
              retstr = strip(retstr "#PROCLIB")
              end
           if allocdd <> null &,
              allocdd = retstr then signal Finish
           end

        /* ----------------------------------------------------- *
         * Now look thru Master JCL Proclibs for JES2 Proc       *
         * ----------------------------------------------------- */
         call find_lib

        /* ----------------------------------------------------- *
         * Now find all //PROCxx and save proc names             *
         * ----------------------------------------------------- */
         Start:
         procs = null
         hit = 0
         sym = "sym"
         proc = "proc"
         do i = 1 to in.0
/*-\|/------ ALK -----------------------------------------------------*/
            If Substr(in.i,1,10)='//HASPPARM' & aloc_dy Then Do
                Call JES2_dynamic_procs
            End
/*-/|\------ ALK -----------------------------------------------------*/
            if word(in.i,2) = "INCLUDE" then do
               parse value in.i with . "MEMBER="jes2 .
               in.i = "//******** replaced "
               if pos("&",jes2) > 0 then do
                  symtext = jes2
                  call fix_sym1
                  jes2 = symtext
                  end
               call find_lib
               signal start
               end
            if left(in.i,3) = "//*" then iterate
            If hit = 1 then do
               if substr(in.i,3,1) >= "A" then hit = 3
               end
            If pos(" PROC ",in.i) > 0 then hit = 1
            if hit = 3 then
               if left(in.i,6) = "//PROC" then do
                  parse value in.i with "//" w1 .
                  if length(w1) < 9 then
                      hit = 4
                  end
            if hit = 4 then do
               if left(in.i,6) <> "//PROC" then
                  if substr(in.i,3,1) >= "A" then hit = 3
               if left(in.i,6) = "//PROC" then do
                  parse value in.i with "//" w1 .
                  if length(w1) > 8 then hit = 3
                  end
               if hit = 3 then iterate
               if left(in.i,6) = "//PROC" then do
                  nn = substr(in.i,7,2)
                  proc.nn = null
                  procs = procs nn
                  end
               parse value in.i with . "DSN=" dsn ","
               dsn = word(strip(dsn),1)
               if pos("&",dsn) > 0 then call fix_sym
               if dsn <> null then do
                  if left(dsn,1) <> _apost_ then ,
                     dsn = ""_apost_""dsn""_apost_""
                  proc.nn = proc.nn dsn
                  end
               end
            If hit = 1 then do
               If pos(" PROC ",in.i) > 0
                  then test = word(in.i,3)
                  else test = word(in.i,2)
               test = translate(test," ",",")
               if words(test) > 1 then
                 do j = 1 to words(test)
                    parse value word(test,j) with symb "=" dsn ","
                    sym.symb = strip(dsn)
                    syms = syms symb
                 end
               else do
                    parse value test with  symb "=" dsn ","
                    sym.symb = strip(dsn)
                    syms = syms symb
                    end
               end
            if hit >1 then iterate
            end

        /* ----------------------------------------------------- *
         * Now alloc DD: #PROCxx                                 *
         * ----------------------------------------------------- */
           alloc_procs = null
           do i = 1 to words(procs)
              if alloc_procs <> null then do
                 if pos("&",alloc_procs) > 0 then do
                    symtext = alloc_procs
                    call fix_sym1
                    alloc_procs = symtext
                    end
                 doalloc = "N"
                 if isfunc = "Y" then do
                    if allocdd = sub_allocdd("#PROC"nn) then do
                       doalloc = "Y"
                       end
                    end
                  else do
                    doalloc = "Y"
                    end
                 if doalloc = "Y" then do
                    RC = msg("OFF")
                    "Free  f(#PROC"nn")"
                    RC = msg("ON")
                    if ispf = 1
                    then "Alloc f(#PROC"nn") ds("alloc_procs")",
                       "shr reuse"
                    else call echo "#PROC"nn alloc_procs
                    end
                 if isfunc = "Y" then do
                    if allocdd = sub_allocdd("#PROC"nn) then do
                       retstr = strip(retstr "#PROC"nn)
                       end
                    if allocdd <> null &,
                       allocdd = retstr then signal Finish
                    end
                 end
              nn = word(procs,i)
              alloc_procs = null
              do j = 1 to words(proc.nn)
                 pr = word(proc.nn,j)
                 alloc_procs = alloc_procs pr
                 end
              end
           if alloc_procs <> null then do
              if pos("&",alloc_procs) > 0 then do
                 symtext = alloc_procs
                 call fix_sym1
                 alloc_procs = symtext
                 end
              doalloc = "N"
              if isfunc = "Y" then do
                 if allocdd = sub_allocdd("#PROC"nn) then do
                    doalloc = "Y"
                    end
                 end
               else do
                 doalloc = "Y"
                 end
              if doalloc = "Y" then do
                 RC = msg("OFF")
                 "Free  f(#PROC"nn")"
                 RC = msg("ON")
                 if ispf = 1
                 then "Alloc f(#PROC"nn") ds("alloc_procs")",
                       "shr reuse"
                 else call echo "#PROC"nn alloc_procs
                 end
              if isfunc = "Y" then do
                 if allocdd = sub_allocdd("#PROC"nn) then do
                    retstr = strip(retstr "#PROC"nn)
                    end
                 if allocdd <> null &,
                    allocdd = retstr then signal Finish
                 end
              end

        /* ----------------------------------------------------- *
         * If not called as a function, invoke ISRDDN to display *
         * allocations and then free DD names.  if called as a   *
         * function, simply return the names of the allocated    *
         * files to the caller.                                  *
         * ----------------------------------------------------- */
         Finish:
           if isfunc = "N" then do
              Address ISPExec
            If uisrddn Then Do            /* ALK                    */
              lev = mvsvar("sysmvs")
              lev = substr(lev,3,1)
              if lev < 6 then do
                 zedsmsg = null
                 zedlmsg = "System and JES2 Proclibs",
                           "have been identified and allocated",
                           "using #PROCMST for the Master JCL",
                           "Proclibs and #PROCxx for the JES2",
                           "Proclibs.               ",
                           "Issue ONLY #PROC",
                           "to display only DDs with PROC in the",
                           "ddname."
                 "Setmsg msg(isrz001)"
                 "Select cmd(isrddn)"
                 end
              else do
                   "vget (zdel)"
                   zopt = "Only #PROC"
                   if lstprocm /= null then do
                      zopt = zopt""zdel"long"zdel" member "lstprocm
                   end
                   "control errors return"
                   zmsg000l = _my_env_" - "_sysenv_""
                   "setmsg msg(ispz000) cond"
                   "Select cmd(isrddn" zopt")"
                   end
/*-\|/------ ALK -----------------------------------------------------*/
            End
            Else Do
                zopt="DDNAME(#PROC*) ALL"
                Address TSO "%ISPFALOC" zopt
                #m=Msg('Off')
            End
/*-/|\------ ALK -----------------------------------------------------*/

             /* -------------------------- *
              * Now free all allocations   *
              * -------------------------- */
              if ispf = 0 then exit 0
              Address TSO
              "Free f(#PROCMST)"
              do i = 1 to words(procs dprocl)             /* ALK      */
                 "Free f(#PROC"word(procs dprocl,i)       /* ALK      */
                 end
              retstr = 0
              end
            else do
              if ispf = 0 ,
              then retstr = 0 ;
              else do ;
                      RC = msg("OFF")
                      "Free  f(#PROCMST)"
                      rerse value in.i with . "DSN=" dsn " " .
                      if retstr = null then do
                         retstr = 16
                         end
                   end;
              end
           Exit retstr

        /* ----------------------------------------------------- *
         * Fix up symbolics in the dsname                        *
         * ----------------------------------------------------- */
           Fix_Sym: procedure expose dsn syms sym. null
           do forever
              parse value dsn with left "&" symbol "." right
              syssym = mvsvar("symdef",symbol)
              if syssym <> null then do
                 dsn = left""syssym""right
                 end
              else do
                 if wordpos(symbol,syms) = 0 then leave
                 wp   = wordpos(symbol,syms)
                 symb = word(syms,wp)
                 hlq  = sym.symb
                 if left(hlq,1) = _apost_ then ,
                    parse value hlq with (_apost_) hlq (_apost_)
                 dsn  = left""hlq""right
                 end
              if pos("&",dsn) = 0 then leave
              end
           return

        /* ----------------------------------------------------- *
         * Fix up symbolics in an expression (symtext)           *
         * ----------------------------------------------------- */
           Fix_Sym1:
           /* shift the symbols and their values to an array */
           symb.0 = words(syms)
           do i = 1 to symb.0
                jj = word(syms,i)
                symb.i.1 = word(syms,i)
                symb.i.2 = sym.jj
           end
           fixstart = 1
           srchdone = "N"
           do until srchdone = "Y"
              p1 = pos("&",symtext,fixstart)
              if p1 > 0 then do
                 parse value symtext with left"&"fixsymb
                 if left(fixsymb,1) = "&" then do
                    p1 = p1 + 1        /* ignore "&&" */
                    end
                  else do
                    right = null
                    symdone = "N"
                    do r=1 to length(fixsymb) until symdone = "Y"
                       if datatype(substr(fixsymb,r,1),"ALPHA") = 0 ,
                       then do
                          right = substr(fixsymb,r)
                          if left(right,1) = "." then do
                             right = substr(right,2)
                             end
                          fixsymb = substr(fixsymb,1,r-1)
                          symdone = "Y"
                          end
                       end
                    if length(fixsymb) > 0 then do
                       syssym = null
                       do symidx = 1 to symb.0
                          if fixsymb = symb.symidx.1 ,
                          then do
                                   syssym = symb.symidx.2
                                   leave
                               end
                       end
                       if syssym = null then ,
                          syssym = mvsvar("symdef",fixsymb)
                       if syssym <> null then do
                          symtext = left""syssym""right
                          end
                       end
                    end
                 fixstart = p1 + 1
                 if fixstart > length(symtext) then do
                    srchdone = "Y"
                    end
                 end
               else do
                 srchdone = "Y"
                 end
              end
           return

        /* ----------------------------------------------------- *
         * Fix volser for IPLPARM volume                         *
         * ----------------------------------------------------- */
           chk_volser: procedure
           parse arg unitnbr
           stat. = null
           dumy = outtrap("stat.")
               "LISTDATA STATUS UNITNUMBER("strip(UNITNBR)")"
                 parse var stat.3   "VOLUME" volser "DEVICE" .
                 If rc/=0 Then Do
                   sysid=Strip(storage(d2x(x2d(c2x(storage(10,4)))+x2d(154)),8))
                   Select
                       When sysid='PRK1' Then volser='FS0006'
/*                     When sysid='SYSD' Then volser='FS0006'         */
                       Otherwise Nop
                   End
                 End
           dumy = outtrap("off")
           return strip(volser)

        /* --------------------------------------------------------- *
         * Find Library for Proc                                     *
         * --------------------------------------------------------- */
         find_lib:
         do ip = 1 to words(proclibs)
            proc  = ""_apost_""word(proclibs,ip)"("jes2")"_apost_""
            if pos("&",proc) > 0 then do
               symtext = proc
               call fix_sym1
               proc = symtext
               end
            if "OK" = sysdsn(proc) then leave
            end

        /* --------------------------------------------------------- *
         * Read in the JES2 Proc                                     *
         * --------------------------------------------------------- */
        "Alloc f("ddn") ds("proc") shr reuse"
        "Execio * diskr" ddn "(finis stem prc."
        rcode = rc
        "Free  f("ddn")"
        if in.0 = 0 then
           do i = 0 to prc.0
              in.i = prc.i
              end
        else do
             c = in.0
             do i = 1 to prc.0
                c = c + 1
                in.c = prc.i
                end
              in.0 = c
              end
        return

        /* -------------------------------- *
         * Echo to the Terminal all DSnames *
         * -------------------------------- */
         Echo: Procedure expose null echo. _my_env_ _sysenv_
         Parse Arg dd dsns
         echo.0 = echo.0 + 1
         if echo.0 = 1 ,
         then do ;
                   hl = 62
                   _info_    = copies("=",hl)
                   info.1    = "*"left(_info_,hl)"*"
                   _info_    = null
                   _info_    = _info_" "_my_env_
                   info.2    = "*"left(_info_,hl)"*"
                   _info_    = null
                   _info_    = _info_" "_sysenv_
                   info.3    = "*"left(_info_,hl)"*"
                   info.4    = info.1
                   _info_    = null
                   _info_    = _info_""left("*DD",10)""
                   _info_    = _info_""left("VOLSER",10)""
                   _info_    = _info_"DSNAME"
                   info.5    = _info_
                   _info_    = null
                   _info_    = _info_""left("*"copies("-",08),10)
                   _info_    = _info_""left(copies("-",06),10)
                   _info_    = _info_""copies("-",44)
                   info.6    = _info_
                   info.0    = 6
                   do i = 1 to info.0
                      say ""info.i""
                   end
              end;
         dsn.0 = words(dsns) ;
         do i = 1 to dsn.0 ;
            if i = 1 ,
            then dsn.i.1 = dd
            else dsn.i.1 = null
            dsn.i.2 = word(dsns,i)
            _rc_ = listdsi(""dsn.i.2"")
            if _rc_ = 0 ,
            then     dsn.i.3 = sysvolume
            else     dsn.i.3 = "N/A"
         end
         do i = 1 to dsn.0 ;
             say left(dsn.i.1,10)""left(dsn.i.3,10)""dsn.i.2
         end
         return

  sub_allocdd: procedure expose null
     parse arg alloc_dd
     select  ;
       when ( alloc_dd = alloc_dd_def ) then r_string = alloc_dd ;
       when ( alloc_dd = null         ) then r_string = alloc_dd ;
       otherwise do  ;
                                             r_string = null     ;
                 end ;
     end ;
     return r_string ;

  sub_init:
         parse value "" with null ddn test mstrjcl proclibs,
                             proc syms procs parmlibs,
                             opt1 opt2 opt3 opt4 lstprocm
         _apost_ = "'"
         proc_l.=                                              /* ALK */
         parse source xenv xtype xmyname xddname xdsname .
         _sysplex_ = mvsvar("sysplex")
         _sysname_ = mvsvar("sysname")
         _sysmvs_  = MVSVAR("SYSMVS")
         if _sysmvs_ > "SP7.0.5" ,
         then do ;
                 /* null if not defined           *
                  *  other variables can be added */
                 _more_     = null
                 _morevars_ = null
                 do _i_ = 1 to words(_morevars_)
                    _morekey_ = word(_morevars_,_i_)
                    _moreval_ = mvsvar('symdef',_morekey_)
                    if _moreval_ /= null ,
                    then do ;
                              _more_ = ""_morekey_"="_moreval_" "
                         end;
                 end;
                 _more_ = strip(_more_)
              end;
         _sysenv_  = null
         _sysenv_  = ""_sysenv_"SYSPLEX="_sysplex_" "
         _sysenv_  = ""_sysenv_"SYSNAME="_sysname_" "
         _sysenv_  = ""_sysenv_""_more_
         _sysenv_  = strip(_sysenv_)
         _my_env_  = ""xmyname" "_version_""
         echo.0 = 0
     return 0

/*-\|/------ ALK -----------------------------------------------------*/
        /* --------------------------------------------------------- *
         * Processes the HASPPARM dataset and performs variable      *
         * substitution if required then serches for dynamic         *
         * procedures in the first 500 lines of the member.          *
         * --------------------------------------------------------- */
JES2_dynamic_procs:
    nat='ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$0123456789'
    linei=Strip(in.i);ii2=i;quick_var=
    Do While Index(linei,'DSN=')=0
        ii2=ii2+1;linei=linei||in.ii2
    End
    Parse VAR linei 'DSN=' jes2_parm ',';Parse VAR jes2_parm jes2_parm .
    If Index(jes2_parm,'&')>0 Then jes2_parm=$Evalamp(jes2_parm)
    Parse VAR jes2_parm jes2_dsn '(' inc_list ')'
    inc_list=jes2_parm
    dd='J2'Time('s')
    Do While inc_list/=''
        rc1=Extract_Dynamic_procs()
        If dynproc Then Leave
        If rc1/=0 Then Return
    End
    Do j=1 To Words(dprocl)
        dproc='PROC'Word(dprocl,j)
        Interpret,
          "Address TSO 'ALLOC DD(#'dproc') DSN('Strip("dproc")') SHR REU'"
    End
    Return

Extract_Dynamic_procs:
    Parse VAR inc_list jes2_memb inc_list
    jes2_parm="'"jes2_memb"'"
    If Sysdsn(jes2_parm)/='OK' Then Do
        Say jes2_parm" not found."
        Return 8
    End
    Address TSO "ALLOC F("dd") DSN("jes2_parm") SHR REU"
    Address TSO "EXECIO * DISKR "dd" (STEM linei. FINIS)"
    Address TSO "FREE F("dd")"
    dynproc=0
    linei=500                           /* Limit search           */
    x=
    Do j=1 To linei.0
        Parse VAR linei.j w1 . 1 'MEMBER='memb .
        If w1='INCLUDE' Then Do
            If memb='' Then Do
                If Index(linei.j,'DSN=')>1 | Index(linei.j,'DSNAME=')>1 Then Do
                    Parse VAR linei.j '=' dsn '(' memb ')'
                    If Index(dsn,'&')>0 Then dsn=$Evalamp(dsn)
                    memb=dsn'('memb')'
                End
            End
            Else memb=jes2_dsn'('memb')'
            inc_list=inc_list memb;Iterate
        End
        If Substr(linei.j,1,2)='/*' | Substr(linei.j,1,2)='  ' Then Iterate
        If Substr(linei.j,1,8)/='PROCLIB(' Then Do
            If dynproc Then Leave;Else Iterate
        End
        dynproc=1
        Parse VAR linei.j '(PROC' dproc ')' .'DSN=' dsn . '/*' .
        If dsn='' Then,
            Parse VAR linei.j '(PROC' dproc ')' .'DSNAME=' dsn . '/*' .
        If Substr(dsn,Length(dsn))=',' Then cont=1;Else cont=0
        dsn=Space(Translate(dsn,'   ',',()'))
        If Index(dsn,'&')>0 Then dsn=$Evalamp(dsn)
        dproc=dproc'$'
        If Index(dprocl,dproc)=0 Then Do
             dprocl=dprocl dproc;Interpret "PROC"dproc"="
        End
        Interpret "PROC"dproc"=PROC"dproc "'''"Word(dsn,1)"'''"
        If cont Then Do;k=j+1;linei.k=Word(linei.j,1) linei.k;End
    End
    Return 0

$Evalamp:Arg dsn_p
    If Wordpos(dsn_p,quick_var)>0 Then,
        Return Word(quick_var,Wordpos(dsn_p,quick_var)+1)
    s_t=0
    Do Forever
        s_t=s_t+1;s_t=Index(dsn_p,'&',s_t);If s_t=0 Then Leave
        Parse VAR dsn_p p1 '&' p2
        col#=Verify(p2,nat,'N');valu=;dot=
        var_fnd=Substr(p2,1,col#-1);p2=Substr(p2,col#)
        If Substr(p2,1,1)='.' Then Do;p2=Substr(p2,2);dot='.';End
        Do ii2=i By -1 To ii2=1
            If Substr(in.ii2,1,3)='//*' Then Iterate
            col#=Index(in.ii2,var_fnd'=')
            If col#=0 Then Iterate
            If Verify(Substr(in.ii2,col#-1,1),', ','N') Then Iterate
            equate=Substr(in.ii2,col#+Length(var_fnd'='))
            col#=Verify(equate,nat"'.&",'N')
            If col#>0 Then equate=Substr(equate,1,col#-1)
            valu=Strip(Strip(Strip(equate),,"'"));Leave
        End
        If valu='' Then valu=Mvsvar('Symdef',var_fnd)
        If valu='' Then dsn_p=p1'&'var_fnd||dot||p2
        Else Do
            dsn_p=p1||valu||p2
        End
    End
    quick_var=quick_var Arg(1) dsn_p
    Return dsn_p

Help_me:
    chgchar='`'
    Do i=2 To n_en
        line=Sourceline(i)
        Do While Index(line,chgchar)>0
            Interpret "Parse VAR line p1 '"chgchar"' var '.' p2"
            If Index(var,'(')>0 Then Do
                Parse VAR var var '(' vl ')'
                If \Datatype(vl,'W') Then vl=Length(var)
                Interpret 'line=p1||Substr('var',1,vl)||p2'
            End
            Else Interpret 'line=p1||'var'||p2'
        End
        Say ' *    'Substr(Strip(Strip(line),,'*'),1,72)'*'
    End
    Exit
Mark:Arg diff;If \Datatype(diff,'W') Then diff=1;Return sigl+diff
