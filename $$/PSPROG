/******************************** REXX ********************************/
/**********************************************************************/
/* TRACE r                                                            */
/*--------------------------ooo000OOOO000ooo--------------------------*/
/*                                                                    */
/* PSPROG:                                                            */
/* Routine to read the current programs and extract details that will */
/* go to the log.                                                     */
/*                                                                    */
/* It will then compare the results with the output generated by the  */
/* PICIT command.                                                     */
/* It will update that output replacing XXXX with the appropriate     */
/* field code.                                                        */
/* It will also ensure that the correct log name is output.           */
/*                                                                    */
/* Permissable parameters:                                            */
/*  CP     - Change prefix.                                           */
/*  ALL    - Process all lines (otherwise line command select lines)  */
/*                                                                    */
/*--------------------------------------------------------------------*/
    Parse Upper ARG parm#
    If parm# /= "" Then Signal byp1
    Address ISPEXEC
    "ISPEXEC CONTROL ERRORS RETURN"
    "ISREDIT MACRO (parm#) NOPROCESS"

byp1:
    cactn = "RETURN"
/*  cactn = "CANCEL"                                                  */
    "ISPEXEC CONTROL ERRORS" cactn

ini1:
    Parse UPPER VAR parm# parm#
    If parm# = "HELP" | parm# = "?" | parm# = '/?' Then Do
        "ISPEXEC SELECT PGM(ISPTUTOR) PARM(AFH000)"
        Exit
    End

    panel = 'PSPROGP'
    fix   = 'N'
    vars  = 'PSLOGSRC PSLOGFIX'
    "ISPEXEC VGET ("vars") PROFILE"
    If pslogsrc = '' Then pslogsrc = "'M.CMS.DTDB804.PF.CPYLIB(AMRTRX)'"
    If pslogfix = '' Then pslogfix = 'N'
    csr1 = 'PSLOGSRC'

scr1:
    zcmd = ''
    "ISPEXEC DISPLAY PANEL(&PANEL) CURSOR(&CSR1)"
    If rc /= 0 Then Do
        gc009 = "Parameter entry screen abandoned."
        Signal erx2
        Exit
    End
    If Sysdsn(pslogsrc) /= 'OK' Then Do
        gc009 = Sysdsn(pslogsrc)"."
        Signal scr1
    End
    "ISREDIT (dsn) = DATASET"
    "ISREDIT (mem) = MEMBER"
    If "'"dsn"("mem")'" = pslogsrc Then Do
        gc009 = 'This member cannot be the same as the PICIT source.'
        "ISPEXEC SETMSG MSG(GC009)"
        Signal scr1
    End
    If zcmd = 'V' Then Do
        "ISPEXEC VIEW DATASET("pslogsrc")"
        Signal scr1
    End

    updated = 'N'
    pref    = 'AML1'

    "ISREDIT (caps) = CAPS"
    "ISREDIT CAPS   = OFF"
    "ISREDIT (last) = LINENUM .ZLAST"
    "ISREDIT (status) = USER_STATE"

    "ISREDIT RESET"
    "ISREDIT X ALL"

    Call set_of_matrix2

    "ISREDIT CURSOR = 1 0"
    Do Forever
        "ISREDIT F ' AML1-FIELD-CODE ' NEXT"
        If rc /= 0 Then Leave
        "ISREDIT (lin#1) = LINENUM .ZCSR"
        "ISREDIT (line1o) = LINE .ZCSR"
        If Index(line1o,' TO ') > 0 Then,
            "ISREDIT LABEL" lin#1+1 "= .MARKF"
        Else,
            "ISREDIT LABEL" lin#1+2 "= .MARKF"
        "ISREDIT F 'END-IF.' 12"
        If rc /= 0 Then Leave
        "ISREDIT LABEL .ZCSR = .MARKT"
        line1 = Substr(line1o,8,65)
        If Datatype(Word(line1,2)) /= 'NUM' Then Iterate

        "ISREDIT F ' AML1-VARIABLE-LENGTH ' FIRST .MARKF .MARKT"
        "ISREDIT (line2o) = LINE .ZCSR"
        "ISREDIT (lin#2) = LINENUM .ZCSR"
        line2 = Substr(line2o,8,65)
        If Word(line2,1) /= 'MOVE' Then Do
            lin#2 = lin#2-1
            "ISREDIT (line2o) = LINE" lin#2
            "ISREDIT XSTATUS" lin#2 "= NX"
            line2 = Substr(line2o,8,65)
        End
        If Datatype(Word(line2,2)) /= 'NUM' Then Do
            xx = Wordindex(line2,2)
            Interpret "Parse VAR line2 line2 +"xx-1" vln ."
            no = Strip(Substr(vln,Lastpos('-',vln)+1))
            line2 = line2 || no*2
        End
        Else vln = ''

        "ISREDIT F ' TO AML1-VL' FIRST .MARKF .MARKT"
        "ISREDIT F ' AML1-VARIABLE-LENGTH ' NEXT .ZCSR .ZCSR"
        If rc = 0 Then
            "ISREDIT F ' TO AML1-VL' NEXT .MARKF .MARKT"
        "ISREDIT (line3o) = LINE .ZCSR"
        line3 = Substr(line3o,8,65)
        "ISREDIT (lin#3) = LINENUM .ZCSR"
        If Word(line3,1) /= 'MOVE' Then Do
            "ISREDIT (line) = LINE" lin#3-1
            "ISREDIT XSTATUS" lin#3-1 "= NX"
            line  = Substr(line,8,65)
            line3 = line line3
            "ISREDIT CURSOR =" lin#3+1 0
        End
        "ISREDIT (csr) = LINENUM .ZCSR"
        "ISREDIT LABEL" csr+1 "= .MARKF"

        "ISREDIT F ' AML1-VL' NEXT .MARKF .MARKT"
        "ISREDIT F ' AML1-VARIABLE-LENGTH ' NEXT .ZCSR .ZCSR"
        If rc = 0 Then
            "ISREDIT F ' AML1-VL' NEXT .MARKF .MARKT"
        "ISREDIT (line4o) = LINE .ZCSR"
        "ISREDIT (lin#4) = LINENUM .ZCSR"
        line4 = Substr(line4o,8,65)
        Call process_line
    End

erx1:
    If updated = 'Y' Then Call execio_rl_update
erx2:
    "ISPEXEC VPUT ("vars") PROFILE"
    "ISPEXEC SETMSG MSG(GC009)"

ext1:
    "ISREDIT USER_STATE = (status)"
    "ISREDIT CAPS = (caps)"
    Exit

process_line:
    seq#  = Word(line1,2)
    len   = Word(line2,2)
    ofld  = Word(line3,2)
    Parse VAR line3 . ' TO ' bfld .
    If words(line4) > 1 Then Parse VAR line4 . ' TO ' line4 .
    afld  = Strip(line4)
    Call eval_bfld
    If val = 'ERROR' Then Return 0
    nfldb = pref"-"val
    nflda = nfldb
    nflda = Overlay('-A-',nflda,Index(nflda,'-B-'),3)
    lineo = Right(seq#,4,'0') Right(len,2) Substr(ofld,1,30),
                                           Substr(bfld,1,20),
                                           Substr(afld,1,20)
    xx = nl(lineo)
    If bfld /= nfldb | afld /= nflda Then Do
        If pslogfix = 'Y' Then xtra = 'Should be AND now IS --->'
        Else                   xtra = 'Should be --->'
        lineo = Right(xtra,38),
                Substr(nfldb,1,20) nflda
        xx = nl(lineo)
    End
    If len+0 /= pl*2 Then Do
        yy = Wordindex(line2,2)
        vv = Word(Substr(line2o,8,65),2)
        lineo = Overlay(Right(pl*2,2,'0'),line2o,yy+7,Length(vv))
        lin# = lin#2
        xx = nl1(lineo)
    End
    If bfld /= nfldb Then Do
        xx = Index(line3o,' 'bfld' ',8)
        lineo = Overlay(nfldb,line3o,xx+1,30)
        lin# = lin#3
        xx = nl1(lineo)
    End
    If afld /= nflda Then Do
        xx = Index(line4o,' 'afld' ',8)
        lineo = Overlay(nflda,line4o,xx+1,30)
        lin# = lin#4
        xx = nl1(lineo)
    End

    Return 0

nl: Parse Arg ntl
    "ISREDIT LINE_BEFORE .ZFIRST = NOTELINE (ntl)"
    Return 0

nl1: Parse Arg ntl
    If pslogfix = 'Y' Then,
        "ISREDIT LINE" lin# "= (ntl)"
    Else,
        "ISREDIT LINE_BEFORE" lin# "= NOTELINE (ntl)"
    Return 0

eval_bfld:
    If linei.0 = 'LINEI.0' Then Call execio_rl

    val = ''
    Do j=1 To linei.0
        If Index(linei.j,' 'ofld' ') = 0 Then Iterate
        val = linei.j
        Leave
    End
    If val = '' Then Do
        val = 'ERROR'
        xx = i "Field '"ofld"' not found in RL extract "pslogsrc"."
        Call nl(xx)
        Return 8
    End
    Parse VAR val fc . xfn pt . pl dp occurs .
    Parse VAR val 57 oval .
/*-------------------------------------------------------------------*/
/* Work out name's low level qualifier from picture clause.          */
/*-------------------------------------------------------------------*/
    key1 = Substr(pt,1,2)
    If dp = 'D' Then dp = '.'
    key2 = Right(pl,4) || Right(pl,4) dp
    key  = key1 || key2
    pos = Index(of_matrix2,key)
    If pos > 0 Then Do
        xx = Substr(of_matrix2,pos+Length(key))
        Parse VAR xx . ':' val pl .
    End
    Else Do
        If pt = 'X' Then Do
           If pl // 10 > 0 Then inc = 1
           Else                 inc = 0
           pl = pl%10
           pl = (pl+inc)*10
           val = 'VL'pl'-B-DATA-X'
        End
        Else Do
            key = Substr('9',1,2) || key2
            pos = Index(of_matrix2,key)
            If pos > 0 Then Do
                xx = Substr(of_matrix2,pos+Length(key))
                Parse VAR xx . ':' val pl .
            End
            Else Do
                xx = Substr(of_matrix2,1+Length(key))
                Parse VAR xx . ':' val pl .
            End
        End
    End

    If oval = '' Then Do
        ol2 = Right(len,2)'>'Substr(bfld,6)
        linei.j = Overlay(ol2,linei.j,57,30)
        updated = 'Y'
    End
    If pslogfix = 'Y' Then Do
        ol1 = Right(pl*2,2)'>'val
        linei.j = Overlay(ol1,linei.j,57,30)
        updated = 'Y'
    End
    If fc = 'XXXX' Then Do
        linei.j = Overlay(seq#,linei.j,1,4)
        updated = 'Y'
    End
    Else Do
        If fc /= seq# Then Do
            xx = '***' seq# 'already used by' fc 'for' xfn'.'
            linei.0 = linei.0 +1
            y       = linei.0
            linei.y = Overlay(seq#,linei.j,1,4)   /* Sequence number  */
            linei.y = Overlay('D',linei.y,6,1)    /* Duplicate flag   */
            linei.y = Overlay('  ',linei.y,54,2)  /* Remove occurances*/
            xx = nl(xx)
            updated = 'Y'
        End
    End
    Return 0

execio_rl:
    dd = 'PSLOGDD'
    Address TSO "ALLOC F("dd") DSN("pslogsrc") SHR REU"
    Address TSO "EXECIO * DISKR "dd" (STEM linei. FINIS)"
    Address TSO "FREE F("dd")"
    Return 0

execio_rl_update:
    dd = 'PSLOGDD'
    Address TSO "ALLOC F("dd") DSN("pslogsrc") SHR REU"
    Address TSO "EXECIO * DISKW "dd" (STEM linei. FINIS)"
    Address TSO "FREE F("dd")"
    gc009 = "Dataset" pslogsrc "has been updated with the new log numbers."
    Return 0


set_of_matrix2:
    of_matrix2 =,
        '9   17  17 .       :VL20-B-NBR-NO-DEC 20 ',
        '9   17  17 .1      :VL20-B-NBR-V901   20 ',
        '9   17  17 .2      :VL20-B-NBR-V902   20 ',
        '9   17  17 .4      :VL20-B-NBR-V904   20 ',
        '9    1   1 .       :VL01-B-DATA-9      1 ',
        '9    2   2 .       :VL02-B-DATA-9      2 ',
        '9    3   3 .       :VL03-B-DATA-9      3 ',
        '9    4   4 .       :VL04-B-DATA-9      4 ',
        '9    5   5 .       :VL05-B-DATA-9      5 ',
        '9    6   6 .       :VL06-B-DATA-9      6 ',
        '9    7   7 .       :VL07-B-DATA-9      7 ',
        '9S   7   7 .       :VLS907-B-DATA-9    7 ',
        '9    8   8 .       :VL08-B-DATA-9      8 ',
        '9    9   9 .       :VL09-B-DATA-9      9 ',
        '9   10  10 .       :VL10-B-DATA-9     10 ',
        '9   11  11 .       :VL11-B-DATA-9     11 ',
        '9   15  15 .       :VL15-B-DATA-9     15 ',
        '9   16  16 .       :VL16-B-DATA-9     16 ',
        '9   17  17 .       :VL17-B-DATA-9     17 ',
        'X    1   1 .       :VL01-B-DATA-X      1 ',
        'X    2   2 .       :VL02-B-DATA-X      2 ',
        'X    3   3 .       :VL03-B-DATA-X      3 ',
        'X    4   4 .       :VL04-B-DATA-X      4 ',
        'X    5   5 .       :VL05-B-DATA-X      5 ',
        'X    6   6 .       :VL06-B-DATA-X      6 ',
        'X    7   7 .       :VL07-B-DATA-X      7 ',
        'X    8   8 .       :VL08-B-DATA-X      8 ',
        'X    9   9 .       :VL09-B-DATA-X      9 ',
        'X   10  10 .       :VL10-B-DATA-X     10 ',
        'X   11  11 .       :VL11-B-DATA-X     11 ',
        'X   15  15 .       :VL15-B-DATA-X     15 ',
        'X   16  16 .       :VL16-B-DATA-X     16 ',
        'X   17  17 .       :VL17-B-DATA-X     17 ',
        'X   19  19 .       :VL19-B-DATA-X     19 ',
        'X   20  20 .       :VL20-B-DATA-X     20 ',
        'X   30  30 .       :VL30-B-DATA-X     30 ',
        'X   40  40 .       :VL40-B-DATA-X     40 ',
        'X   50  50 .       :VL50-B-DATA-X     50 ',
        'X   60  60 .       :VL60-B-DATA-X     60 ',
        'X   70  70 .       :VL70-B-DATA-X     70 ',
        'X   80  80 .       :VL80-B-DATA-X     80 ',
        ''

    Return 0
