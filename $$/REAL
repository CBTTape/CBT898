/*--------------------------ooo00 REXX 00ooo--------------------------*/
/*                                                                    */
/* REAL(LOC)                                                          */
/*                                                                    */
/* Doco  : This EXEC will place a user specified dataset or list of   */
/*         datasets at the head or tail of the concatenation of       */
/*         datasets currently allocated to a user specified DDNAME.   */
/*         Use this routine to allocate personalised ISPF             */
/*         environmental datasets to system allocated DSNs at logon   */
/*         time.                                                      */
/*         Also used for removing unwanted datasets from allocations. */
/*                                                                    */
/*         For more detailed doco, enter "TSO %REAL ?" on the command */
/*         line (or "TSO EX 'non.sysexec.dataset(REAL)'" no parm).    */
/*                                                                    */
/* Author: Alex Kara (ASYSTS Pty.Ltd.) - 1995.                        */
/*                                                                    */
/*--------------------------------------------------------------------*/
    real_ver='V3.5'                         /* REAL version number    */
    cname1st=1                           /* 1=ChrisSurn, 0=SurnChris  */

    Parse Upper ARG parm#
    Parse VAR parm# parm1 parm2 parm3 parm4 parm5 parm6 parm7 parm8
    Parse SOURCE . . x_cmd .

init:
    Numeric Digits 20
    userid  = Userid()

    cvt     = c2x(storage(10,4))
    sysid   = Strip(storage(d2x(x2d(cvt)+x2d(154)),8))
    sysid#  = sysid
    ascb    = Storage(d2x(548),4)
    asxb    = Storage(d2x(c2d(ascb)+c2d(x2c(6c))),4)
    acee    = Storage(d2x(c2d(asxb)+c2d(x2c(c8))),4)
    grpn    = x2c(d2x(c2d(Storage(d2x(c2d(acee)+c2d(x2c(1e))),8))))
    group   = Strip(grpn)

    If Wordpos(parm1,'? /? HELP /H')>0 | parm1='' |,
       Substr(parm1,1,2)='/H' Then Signal help

    dfltdsn = "'TSGAK.REXX(@DEFAULT)'"
    dfltsys = 'N'                           /* System defaults        */

    posdef  = 'HEAD'                        /* Default position       */
    revmin# = 'HEAD'                        /* Reverse of MINUS pos   */
    syspref = Sysvar(Syspref)
    pref    = userid
    prex    = pref
    time1   = Time()

    Call parse_parms
    If trace_r = 'Y' Then Trace r

    If not_fy = 'Y' Then Do
        Say '*'
        Say '* REALLOC 'real_ver' executing'
        Say '*'
        Say 'Entry prefix is set to "'pref'".'
        Say '*'
        If var_list/='' Then Do
            Say 'Variable equates passed:'
            Do While var_list/=''
                Parse VAR var_list var var_list
                If Length(var)<8 Then var=Left(var,8)
                Interpret 'Say "  "var "->"' var
            End
            Say '*'
        End
    End

    Call get_existing_allocations
    Call existing_allocations_list
    Call build_add_list
    Call build_new_list

    Exit

/*--------------------------------------------------------------------*/
/* Build a list of file allocations for each DD found in the file     */
/* according to the allocation specifications, ie. HEAD/TAIL and      */
/* FORCE if applicable.                                               */
/*--------------------------------------------------------------------*/
build_add_list:
    If ids# /= '*' Then Call get_addon_data

    j  = DUMMY.HEAD
    i# = 0
    m# = 0
    Do i1=1 To line.s.0
        xx = line.s.i1
        If Substr(xx,1,14) = '*-> Prefix set' Then Do
            Parse VAR xx . '"' pref '"' .
            Iterate
        End
        If Substr(xx,1,1) = '*' Then Iterate
        If Strip(xx)      = ''  Then Iterate
        If Substr(xx,1,1) = ' ' Then Parse VAR xx    dsna posy force_1 .
        Else                         Parse VAR xx dd dsna posy force_1 .
        posy1=Substr(posy,1,1)
        Select
            When (Index(' 'dsna,' SYSOUT(') > 0) Then Do
                If Substr(xx,1,1) = ' ' Then Do
                    If not_fy /= 'N' Then Do
                        Say 'Must have a DDNAME with a SYSOUT()',
                            'allocation. Data not processed.'
                        Say '*'
                    End
                    Iterate
                End
                m# = m# +1
                misc_aloc.m# = dd dsna posy force_1 "REU"
                Iterate
            End
            When (Index(' 'dsna' ',' DUMMY ') > 0) Then Do
                If Substr(xx,1,1) = ' ' Then Do
                    If not_fy /= 'N' Then Do
                        Say 'Must have a DDNAME with a DUMMY',
                            'allocation. Data not processed.'
                        Say '*'
                    End
                    Iterate
                End
                m# = m# +1
                misc_aloc.m# = dd dsna "SHR REU"
                Iterate
            End
            When (posy1='H') Then pos='HEAD'
            When (posy1='T') Then pos='TAIL'
            When (posy1='R') Then pos='REPL'
            When (posy1='M' | posy='-') Then pos='MINUS'
            Otherwise pos=posdef
        End
        If pos='MINUS' Then Do
            If Wordpos(force_1,'TAIL HEAD')=0 Then revmin=revmin#
            Else Do;revmin=force_1;force_1=;End
        End
        If force_o/='' & pos/='MINUS' Then pos='FORC'pos
        Else If force_1/='' & pos/='MINUS' Then pos='FORC'pos
             Else If poso/='' Then If poso='MINUS' & pos='MINUS' Then pos=revmin
                                   Else pos=poso
        If dd /= '' Then Do
            dda = Strip(dd)
            If Value('DDS'.dd) /= 'SET' Then Do
                Call verify_ddname
                If ddok Then NOP
                ELse Do
                    If not_fy /= 'N' Then Do
                        Say 'Invalid DD name ->' dda
                        Say 'Replaced by #ERROR#....'
                        Say '*'
                    End
                    dda='#ERROR#'
                End
                i#=i#+1;ii.i#=dda;dds.dd='SET'
            End
        End
        If dda = 'ISPPROF' | dda = 'ISPTABL' Then Do
            If dda = 'ISPTABL' & pos = 'MINUS' Then j = dda'.'pos
            Else Do
                j = dda'.FORCREPL'
                If pos = 'FORCREPL' Then a_dsn.j = ''
            End
        End
        Else j = dda'.'pos
        If Substr(dsna,1,1) /= "'" Then dsna = "'"pref"."dsna"'"
        If A_DSN.j = 'A_DSN.'j Then a_dsn.j = ''
        x=Listdsi(dsna)
        If x/=0 Then Do
            If not_fy/='N' Then Do
                If sysreason=9 | sysreason=25 Then
                     xxx='Dataset 'dsna' has been *MIGRATED*.'
                Else xxx='Dataset 'dsna' not found.'
                Say xxx 'Will not be allocated to' dda'.'
                Say '*'
            End
        End
        Else a_dsn.j = a_dsn.j Strip(dsna)
    End

    Return 0

/*--------------------------------------------------------------------*/
/* Get current allocation 'listing' from the TSO STATUS command.      */
/*--------------------------------------------------------------------*/
get_existing_allocations:
    x = Outtrap('line.',1000,'NOCONCAT')
    x = MSG('On')
    Address TSO "LISTALC STATUS"
    x = OUTTRAP('Off')
    x = MSG('Off')
    Return 0

/*--------------------------------------------------------------------*/
/* Parse the output from the STATUS command to build a list of current*/
/* allocations per DD. Also intercepts DSN for ISPPROF.               */
/*--------------------------------------------------------------------*/
existing_allocations_list:
    Do i=2 To line.0
        xx = Strip(line.i,'t')

        If Substr(xx,1,1) = '*' Then line.i = Substr(xx,2)
        If Substr(xx,1,1) /= ' ' Then Iterate
        If Substr(xx,3,1) /= ' ' Then Do
            Parse VAR xx dda .
            j = dda
            If dda = 'ISPPROF' Then Do
                k = i -1
                iprof = "'"Strip(line.k)"'"
            End
            If freeall = 'Y' | free.j = 'Y' Then Do
                If not_fy = 'Y' Then Do
                    Say "Freeing all '"dda"' allocations."
                    Say '*'
                End
                If do_alloc = 'Y' Then Address TSO 'FREE F('dda')'
                Iterate
            End
            dd.j  = dda
            k     = i -1
            e_dsn.j = "'"Strip(line.k)"'"
        End
        Else Do
            If freeall = 'Y' | free.j = 'Y' Then Iterate
            k     = i -1
            e_dsn.j = e_dsn.j "'"Strip(line.k)"'"
        End
    End

    Return 0

/*--------------------------------------------------------------------*/
/* Build a new list to concatenate from all the various sources.      */
/* This list is quad parsed. {                                        */
/*   1 - reverse order for HEAD then forced HEAD concats.             */
/*   2 - forward order for TAIL then forced TAIL concats.             */
/*   3 - forward order for removals (MINUS).                          */
/*   4 - forward order for replacements (REPLACE) then forced REPLACE.*/
/*--------------------------------------------------------------------*/
build_new_list:
    Do i=i# By -1 To 1                      /* HEAD in reverse order  */
        dd  = ii.i
        dsnto = e_dsn.dd
        dsnfr = ''
        If Index(dsnto,'_') > 0 Then dsnto = ''

        If Index(Value('A_DSN.'dd'.HEAD'),'_') = 0 Then Do
            ids# = Strip(Value('A_DSN.'dd'.HEAD'))
            j = Words(ids#)
            Do k=j By -1 To 1
                ids = Word(ids#,k)
                x = Index(dsnto,ids)
                If x = 0 Then Do
                    dsnto = ids dsnto
                    dsnfr = dsnfr ids       /* Order unimportant      */
                End
                If ids# = '' Then Leave
            End
        End
        If Index(Value('A_DSN.'dd'.FORCHEAD'),'_') = 0 Then Do
            ids# = Strip(Value('A_DSN.'dd'.FORCHEAD'))
            j = Words(ids#)
            Do k=j By -1 To 1
                ids = Word(ids#,k)
                x = Index(dsnto,ids)
                If x > 0 Then Do
                    p1 = Substr(dsnto,1,x-1)
                    p2 = Substr(dsnto,x+Length(ids)+1)
                    dsnto = ids Strip(p1) Strip(p2)
                End
                Else dsnto = ids dsnto
                dsnfr = dsnfr ids           /* Order unimportant      */
                If ids# = '' Then Leave
            End
        End
        e_dsn.dd = Strip(dsnto)
        c_dsn.dd = Strip(dsnfr)
    End

    Do i=1 To i#                            /* TAIL in forward order  */
        dd  = ii.i
        dsnto = E_DSN.dd
        dsnfr = c_DSN.dd
        If Index(dsnto,'_') > 0 Then dsnto = ''
        If Index(dsnfr,'_') > 0 Then dsnfr = ''

        If Index(Value('A_DSN.'dd'.TAIL'),'_') = 0 Then Do
            ids# = Strip(Value('A_DSN.'dd'.TAIL'))
            Do Forever
                Parse Var ids# ids ids#
                x = Index(dsnto,ids)
                If x = 0 Then Do
                    dsnto = dsnto ids
                    dsnfr = dsnfr ids       /* Order unimportant      */
                End
                If ids# = '' Then Leave
            End
        End
        If Index(Value('A_DSN.'dd'.FORCTAIL'),'_') = 0 Then Do
            ids# = Strip(Value('A_DSN.'dd'.FORCTAIL'))
            Do Forever
                Parse Var ids# ids ids#
                x = Index(dsnto,ids)
                If x > 0 Then Do
                    p1 = Substr(dsnto,1,x-1)
                    p2 = Substr(dsnto,x+Length(ids))
                    dsnto = Strip(p1) Strip(p2) ids
                End
                Else dsnto = dsnto ids
                dsnfr = dsnfr ids           /* Order unimportant      */
                If ids# = '' Then Leave
            End
        End
        e_dsn.dd = Strip(dsnto)
        c_dsn.dd = Strip(dsnfr)
    End

    Do i=1 To i#                            /* MINUS 2nd. last        */
        dd  = ii.i
        dsnto = E_DSN.dd
        dsnfr = c_DSN.dd
        If Index(dsnto,'_') > 0 Then dsnto = ''
        If Index(dsnfr,'_') > 0 Then dsnfr = ''

        If Index(Value('A_DSN.'dd'.MINUS'),'_') = 0 Then Do
            ids# = Strip(Value('A_DSN.'dd'.MINUS'))
            Do Forever
                Parse Var ids# ids ids#
                x = Index(dsnto,ids)
                If x > 0 Then Do
                    p1 = Substr(dsnto,1,x-1)
                    p2 = Substr(dsnto,x+Length(ids))
                    dsnto = Strip(p1) Strip(p2)
                End
                x = Index(dsnfr,ids)
                If x > 0 Then Do
                    p1 = Substr(dsnfr,1,x-1)
                    p2 = Substr(dsnfr,x+Length(ids))
                    dsnfr = Strip(p1) Strip(p2)
                End
                If ids# = '' Then Leave
            End
            If dsnto = '' & dsnfr = '' Then dsnto = 'FREE-DD'
            If Strip(dsnfr) = '' Then dsnfr = '-'
        End
        e_dsn.dd = Strip(dsnto)
        c_dsn.dd = Strip(dsnfr)
    End
    Do i=1 To i#                            /* REPLACE last           */
        dd  = ii.i
        dsnto = E_DSN.dd
        dsnfr = c_DSN.dd
        If Index(dsnto,'_') > 0 Then dsnto = ''
        If Index(dsnfr,'_') > 0 Then dsnfr = ''

        If Index(Value('A_DSN.'dd'.REPL'),'_') = 0 Then Do
            ids# = Strip(Value('A_DSN.'dd'.REPL'))
            Do Forever
                Parse Var ids# ids ids#
                x = Index(dsnfr,ids)
                If x = 0 Then Do
                    dsnfr = dsnfr ids
                    dsnto = dsnfr
                End
                If ids# = '' Then Leave
            End
        End
        If Index(Value('A_DSN.'dd'.FORCREPL'),'_') = 0 Then Do
            ids# = Strip(Value('A_DSN.'dd'.FORCREPL'))
            Parse Var ids# ids ids#
            dsnfr = ids
            dsnto = dsnfr
        End
        e_dsn.dd = Strip(dsnto)
        c_dsn.dd = Strip(dsnfr)
    End

/*--------------------------------------------------------------------*/
/* Perform an allocation to the file '$$TALLOC' of the datasets to be */
/* allocated to ensure that allocation is possible. If an error       */
/* occurs, the error is notified to the user and allocation is        */
/* abandoned.                                                         */
/*--------------------------------------------------------------------*/
/*  If not_fy /= 'N' Then x = MSG('On')                               */
    Address TSO
    Do i=1 To i#
        dd  = ii.i
        dsnto = E_DSN.dd
        If dd = '#ERROR#' Then Do
            Say '*'
            Say 'The following DSNAMES were not allocated due to',
                'erroneous DD name definition/build:'
            Say Strip(dsnto)
            Say '*'
            Iterate
        End
        dsnfr = c_DSN.dd
        If dsnfr = '' Then Iterate
        dsnto = E_DSN.dd
        If dsnto = '' Then Iterate
        If dsnto = 'FREE-DD' Then Do
            If do_alloc = 'Y' Then,
                "FREE F("dd")"
            Else ,
                Say 'Dummy -' "FREE F("dd")"
            If not_fy = 'Y' Then Do
                Say ' '
                Say "Changing <"dd"> allocations to:"
                Say 'Freed...'
                Say ' '
                Say '*'Copies('-',77)'*'
            End
            Iterate
        End
        rc1 = 0
        If dsnfr /= '-' Then Do
            If do_alloc = 'Y' Then,
                "ALLOC F($$TALLOC) DA("dsnfr") SHR REU"
            If rc /= 0 & not_fy /= 'N' Then Do
                Say 'Error in concatenating to DD('dd') detected.'
                Say 'The following datasets have not been processed.'
                Say '  'dsnfr
            End
            If do_alloc = 'Y' Then,
                "FREE FILE($$TALLOC)"
        End
        If do_alloc = 'Y' Then Do
            "ALLOC F("dd") DA("Strip(dsnto)") SHR REU"
            rc1 = rc
            If rc1 /= 0 Then Do
                x = Msg('On')
                Say 'Error in allocating "F('dd')" :-'
                "ALLOC F("dd") DA("Strip(dsnto)") SHR REU"
                x = Msg('Off')
            End
        End
        Else ,
            Say 'Dummy -' "ALLOC F("dd") DA("Strip(dsnto)") SHR REU"
        If not_fy = 'Y' & rc1 = 0 Then Do
            Say ' '
            Say "Changing <"dd"> allocations to:"
            Say Strip(dsnto)
            Say ' '
            Say '*'Copies('-',77)'*'
        End
    End

    Do i=1 To m#
        Parse VAR misc_aloc.i dd dsna xtra
        rc1 = 0
        If do_alloc = 'Y' Then Do
            "ALLOC F("dd")" dsna xtra
            rc1 = rc
            If rc1 /= 0 Then Do
                x = Msg('On')
                Say 'Error in allocating "F('dd')" :-'
                "ALLOC F("dd")" dsna xtra
                x = Msg('Off')
            End
        End
        Else ,
            Say 'Dummy -' "ALLOC F("dd")" dsna xtra
        If not_fy = 'Y' & rc1 = 0 Then Do
            Say ' '
            Say "Changing <"dd"> allocations to:"
            Say Strip(dsna)
            Say ' '
            Say '*'Copies('-',77)'*'
        End
    End

/*--------------------------------------------------------------------*/
/* Execute any routines passed through the )EXEC control parameter    */
/* that have defaulted to after the allocations.                      */
/*--------------------------------------------------------------------*/
    If execit /= '' Then Do
        xx = execit
        Call exec_rtns
    End

    Return 0

/*--------------------------------------------------------------------*/
/* If invoked with direct allocation, 'ids#' is set to '*' and lines  */
/* set up by 'parse_parms' routine.                                   */
/* Otherwise 'ids#' will contain a list of PDS(members) and/or        */
/* sequential files with additional allocations and a routine is      */
/* called to read each file.                                          */
/* From each file read, a list of file allocations is built for each  */
/* DD found in the file according to the allocation specifications,   */
/* ie. HEAD/TAIL and FORCE if applicable.                             */
/*--------------------------------------------------------------------*/
get_addon_data:
    s = 1
    If ids# /= '**' Then Do                 /* DATA(DD=..) indicator  */
        Do i=1 To 9999
            Parse VAR ids# ids ids#
            line.s.i = ')IM' ids
            If ids# = '' Then Leave
        End
        line.s.0 = i
    End

    idd     = '$'Time('s')
    lllmax  = 50                            /* To limit recursion     */
    lll     = 5                             /* To limit recursion     */
    ll1     = 0                             /* To limit recursion     */
    execit  = ''
    exec1s  = ''
    Do Forever
        d#      = 0
        d       = (s // 2) +1
        im      = 'N'
        ifelse  = 'ENDIF'
        ifsysid = sysid
        inc_sys = 'Y'
        Do i=1 To line.s.0
            If Index(line.s.i,'&') > 0 Then Do
                dsno = line.s.i
                Call set_amper_in_line
                line.s.i = dsno
            End

            Parse UPPER VAR line.s.i r_cmd r_parm


            If change_sel() = 'Y' Then Iterate
            If inc_sys = 'N' Then Iterate

            If r_cmd = ')PREF' Then Do
                Parse VAR r_parm xx .

                If xx = '*' Then Do
                    xx = userid
                    xt = '(re)'
                End
                Else xt = ''
                x = NameVer(xx)
                If x /= 0 Then Do
                    If x = 16 Then,
                        mm = 'Passed string > 44 bytes.'
                    If x = 12 Then,
                        mm = 'A qualifier > 8 bytes.'
                    If x = 8 Then,
                        mm = '1st. byte numeric or invalid',
                             'character found.'
                    mm = '"'xx'" invalid -' mm
                End
                Else Do
                    mm = 'set'xt 'to "'xx'" by )PREF.'
                    prex = xx
                    pref = xx
                End
                d# = d# +1; line.d.d# = '*'
                d# = d# +1; line.d.d# = '*-> Prefix' mm
                d# = d# +1; line.d.d# = '*'
                im = 'Y'
                Iterate
            End
            If r_cmd = ')FREE' Then Do
                Parse VAR r_parm dd .
                If dd = '*' Then freeall = 'Y'
                Else free.dd = 'Y'
                im = 'Y'
                Iterate
            End
            If r_cmd = ')REXX' Then Do
                Parse Var r_parm data 73 .
                If not_fy = 'Y' Then Do
                    d# = d# +1; line.d.d# = '*'
                    d# = d# +1; line.d.d# = '*-> Processing:' data
                    d# = d# +1; line.d.d# = '*'
                End
                If not_fy='Y' Then Do
                    Say '*'
                    Say '* Executing REXX command:'
                    Say r_parm
                    Say '*'
                End
                Interpret r_parm
                im='Y'
                Iterate
            End
            If r_cmd = ')IM' Then Do
                Parse UPPER VAR r_parm ids lllnew f_im .
                If ids = 'SYSTEM' Then Do
                    dfltsys = 'Y'
                    Iterate
                End
                If ids = 'NOSYSTEM' Then Do
                    dfltsys = 'N'
                    Iterate
                End
                d# = d# +1; line.d.d# = '*'
                d# = d# +1; line.d.d# = '*-> 'Strip(line.s.i)
                d# = d# +1; line.d.d# = '*'
                If Datatype(lllnew) = 'NUM' & Index(lllnew,'.') = 0 &,
                                             lllnew <= lllmax Then Do
                    If not_fy /= 'N' Then,
                        Say "Changing the ')IM' limit from" lll,
                            "to" Strip(lllnew)"."
                    lll = lllnew
                    If ids = '.' Then Iterate
                End
                ll1 = ll1 +1
                If lllnew = 'FORCE' Then f_im = 'FORCE'
                If not_fy = 'Y' Then Do
                    If f_im = 'FORCE' Then x = ' with FORCE'
                    Else x = ''
                    Say "Including data from dataset",
                        ids || x ||"."
                End
                If ll1 > lll Then Do
                    im = 'N'
                    Leave
                End
                im = 'Y'
                y  = i +1
                If Substr(line.s.y,1,1) = ' ' &  f_im /= 'FORCE' Then Do
                    If not_fy /= 'N' Then Do
                        Say "Cannot use ')IM' in the middle of a",
                            "concatenation."
                        Say '     'Strip(line.s.i)' <--- being ignored.'
                        Say "     Correct or use the 'FORCE' parameter."
                    End
                End
                Else Call read_im_file
                Iterate
            End
            If r_cmd = ')EXEC' Then Do
                Call parse_exec
                If ifelse /= 'ELSE' Then execsid = ifsysid
                Else                     execsid = '<NOT> ->' ifsysid
            End

            d# = d# +1
            line.d.d# = line.s.i

        End
        If im = 'N' Then Do
            If dfltsys = 'N' Then Do
                s = d
                line.s.0 = d#
                Leave
            End
            dfltsys = 'N'
            d# = d# +1
            line.d.d# = ")IM" dfltdsn
            If not_fy = 'Y' Then Do
                Say 'Adding system defaults (see below).'
                Say '*'
            End
        End
        s = ((d+1) // 2) +1
        line.s.0 = d#
    End
    If ll1 > lll Then Do
        If not_fy /= 'N' Then Do
            Say "************************** Error ****************" ||,
                "**************************"
            Say "Limit of "lll" ')IM' passed by last inclusion.",
                "Check for possible recursion."
            Say "You may up the limit by appending a new limit on",
                "the ')IM' statement."
            Say " "
            Say "Concatenation processing terminated. Original",
                "allocations retained."
            Say "*"
        End
        Exit
    End

    If iddfree = 'Y' Then Address TSO 'FREE F('idd')'

    If not_fy = 'Y' | not_fy = 'A' Then Do
        Say '*'Copies('-',77)'*'
        Say "The following dataset have been extracted from the",
            "'DATA()' statement and any"
        Say "related ')IM' statements:"
        Do i=1 To line.s.0
            Say Strip(line.s.i,'t')
        End
        If exec1s /= '' Then Do
            Say ' '
            Say 'The following routines will be executed FIRST, on',
                execsid':'
            xx = exec1s
            Do Forever
                Parse VAR xx yy ':' xx
                Say '    'yy
                If xx = '' Then Leave
            End
        End
        If execit /= '' Then Do
            Say ' '
            Say 'The following routines will be executed after',
                'allocations on 'execsid':'
            xx = execit
            Do Forever
                Parse VAR xx yy ':' xx
                Say '    'yy
                If xx = '' Then Leave
            End
        End
        Say '*'Copies('-',77)'*'
        Say ' '
    End

/*--------------------------------------------------------------------*/
/* Execute any routines passed through the )EXEC control parameter    */
/* that have been explicitle requested prior to allocations           */
/*--------------------------------------------------------------------*/
    If exec1s /= '' Then Do
        xx = exec1s
        Call exec_rtns
    End

    Return 0

/*--------------------------------------------------------------------*/
/* Parse EXEC routine for execution sequence                          */
/*--------------------------------------------------------------------*/
parse_exec:
    Parse VAR line.s.i . xx 'POS(' posx seq ')' trail
    xx = Strip(xx) Strip(trail)
    If Substr(xx,1,1) = "!" Then xx = Substr(xx,2)
    Else,
        If Substr(xx,1,1) /= "'" Then Do
            Parse VAR xx yy
            xx = "'"prex"."xx"'" yy
        End
    If Substr(seq,1,1) /= 'F' Then Do
        If Substr(posx,1,1) = 'H' Then execit = xx':'execit
        Else                           execit = execit xx':'
    End
    Else Do
        If Substr(posx,1,1) = 'H' Then exec1s = xx':'exec1s
        Else                           exec1s = exec1s xx':'
    End

    Return 0

/*--------------------------------------------------------------------*/
/* Execute EXEC routines                                              */
/*--------------------------------------------------------------------*/
exec_rtns:
    If not_fy = 'Y' Then Say ' '
    Do Forever
        Parse VAR xx xproc ':' xx
        If not_fy = 'Y' Then Do
            Say "Executing" xproc
        End
        xproc = Strip(xproc)
        If Substr(xproc,1,1) = "'" Then xproc = 'EXEC' xproc
        If do_alloc = 'Y' Then Address TSO xproc
        If xx = '' Then Leave
    End
    If not_fy = 'Y' Then Do
        Say ' '
        Say '*'Copies('-',77)'*'
    End

    Return 0

/*--------------------------------------------------------------------*/
/* Read any )IM files found in the DATA() statements.                 */
/*--------------------------------------------------------------------*/
read_im_file:
    x=Listdsi(ids "NORECALL")
    If x=0 & Index(ids,'(')>0 Then If Sysdsn(ids)/='OK' Then x=8
    If x/=0 Then Do
        If not_fy /= 'N' Then,
            Say 'Dataset 'ids' not found or migrated. Will not be',
                "')IM' processed."
        Return 4
    End
    Address TSO 'ALLOC F('idd') DA('ids') SHR REU'
    iddfree = 'Y'
read_dd_file:
    Address TSO 'EXECIO * DISKR 'idd' (STEM line. FINIS)'
    Do j=1 To line.0
        If in_stream = 'Y' Then Do
            Parse UPPER VAR line.j 1 y ':' plus .
            If y = 'INSTREAM' Then,
                in_stream = 'N'
            Iterate
        End
        If line.j = ')END' Then Leave
        If Substr(line.j,1,1) = '+' Then Do
            line.d.d# = Strip(line.d.d#) Strip(Substr(line.j,2))
            Iterate
        End
        d# = d# +1
        line.d.d# = line.j
    End

    Return 0


/*--------------------------------------------------------------------*/
/* Parse parameters.                                                  */
/*--------------------------------------------------------------------*/
parse_parms:
    trace_r   = 'N'
    not_fy    = 'E'
    do_alloc  = 'Y'
    in_stream = 'N'
    force_1   = 'N'
    pos       = 'HEAD'
    poso      = ''
    force_o   = ''
    dd        = ''
    execit    = ''
    exec1s    = ''

    If Index(' 'parm#' ',' TRACE ')    > 0 Then trace_r   = 'Y'
    If Index(' 'parm#' ',' INSTREAM ') > 0 Then in_stream = 'Y'

    Parse VAR parm# . 'NOTIFY(' +7 not_fy +1 .
    If not_fy = 'T' Then Do
        not_fy   = 'Y'
        do_alloc = 'N'
    End

    Parse VAR parm# . 'POS(' +4 posy +1 .
    If posy /= '' Then Do
        Select
            When (posy = 'H')              Then pos = 'HEAD'
            When (posy = 'T')              Then pos = 'TAIL'
            When (posy = 'R')              Then pos = 'REPL'
            When (posy = 'M' | posy = '-') Then pos = 'MINUS'
            Otherwise NOP
        End
        poso=pos
    End

    If Index(' 'parm#' ',' FORCE ') > 0 Then Do
        force_1 = 'Y'
        force_o = 'Y'
    End

    If Index(parm#,'PREF(') > 0 Then Do
        Parse VAR parm# . 'PREF(' pref ')'
        If pref = '' Then pref = userid
    End

/*--------------------------------------------------------------------*/
/* If 'VARS()' id extract from files.                                 */
/*--------------------------------------------------------------------*/
    If Index(parm#,'VARS(')>0 Then Do
        Parse Value parm#' ' With 'VARS(' vars# ') ' .
        var_list=
        Do While vars#/=''
            Parse VAR vars# var '=' vars#;Parse VAR vars# ch1 +1 vars#
            Select
                When ch1="'" Then Do;sep='"'',"';sepd="'";End
                When ch1='"' Then Do;sep="'"",'";sepd='"';End
                Otherwise Do;vars#=ch1||vars#;sep="','";sepd=;End
            End
            Interpret "Parse VAR vars# val" sep "vars#"
            Interpret var'='sepd||val||sepd;var_list=var_list var
        End
    End

/*--------------------------------------------------------------------*/
/* If 'DATA()' id extract from files.                                 */
/*--------------------------------------------------------------------*/
    If Index(parm#,'DATA(')>0 Then Do
        Parse VAR parm# 'DATA(' data#
        lb=1;rb=1
        Do While lb>0
            rb=Index(data#,')',rb+1);lb=Index(data#,'(',lb+1)
            If lb>rb Then lb=0
        End
        If rb=0 Then Do
            ids#='*';line.s.0=0
            Say ' '
            Say 'Invalid "DATA(...)" format. Unmatched "(" in expression.'
            Say ' '
            Say '*'Copies('-',77)'*'
            Return 0
        End
        data#=Substr(data#,1,rb-1)
        If Substr(data#,1,3)='DD=' Then Do
            idd_s=idd;idd=Substr(data#,4)
            d#=0;d=1
            Call read_dd_file
            idd=idd_s;ids#='**'
            s=d;line.s.0=d#
        End
        Else Call dsn_seperation
        Return 0

    End

/*--------------------------------------------------------------------*/
/* Test for 'DD(' id. Also for 'F(' id.                               */
/*--------------------------------------------------------------------*/
    If Index(' 'parm#,' DD(') > 0 |,
       Index(' 'parm#,' F(') > 0 Then Do
        If Index(' 'parm#,' DD(') > 0 Then Do
            Parse VAR parm# . 'DD(' dd ')'
            xx = 'DD'
        End
        Else Do
            Parse VAR parm# . 'F(' dd ')'
            xx = 'F'
        End
        ids# = '*'

        If dd = '*' Then Do
            If pos /= 'MINUS' Then Do
                If not_fy /= 'N' Then,
                    Say "No 'POS(-)' defined with '"xx"(*)'."
                Exit
            End
            freeall  = 'Y'
            line.s.0 = 0
            Return 0
        End
    End

/*--------------------------------------------------------------------*/
/* If 'DD(' id then build the format expected from files and other    */
/* indicators.                                                        */
/*--------------------------------------------------------------------*/
    If dd = '' Then Do
        If not_fy /= 'N' Then,
            Say "No 'DD(' or 'F(' parameter defined, reallocation",
                "abandoned."
        Exit
    End

    If Index(parm#,'DSN(') > 0 |,
       Index(parm#,'DA(') > 0 Then Do
        If Index(parm#,'DSN(') > 0 Then Parse VAR parm# . 'DSN(' data# ')'
        Else                            Parse VAR parm# . 'DA(' data# ')'
        If data# /= '*' Then Do
            Call dsn_seperation

/*--------------------------------------------------------------------*/
/* Let us establish the DSN's to be concatenated.                     */
/*--------------------------------------------------------------------*/
            s = 1
            If not_fy = 'Y' Then,
                Say '*'Copies('-',77)'*'
            If Substr(pos,1,1) = 'M' | pos = '-' Then ,
                 com = 'removed from'
            Else com = 'allocated to'
            If not_fy = 'Y' Then,
                Say "The following dataset(s) will be" com "'"dd"':"
            Do i=1 To 999
                Parse VAR ids# ids ids#
                If ids /= '' Then Do
                    line.s.i = Substr(dd,1,8) Strip(ids) pos
                    dd       = ''
                End
                Else line.s.i = ''
                If not_fy = 'Y' Then Say line.s.i
                If ids# = '' Then Leave
            End
        End
        Else Do
            ids#  = ''
            If pos /= 'MINUS' Then Do
                If not_fy /= 'N' Then,
                    Say "No 'POS(-)' defined with 'DSN(*)'."
                Exit
            End
            i       = 0
            free.dd = 'Y'
        End
    End
    Else If dd /= '' Then Do
             Say "No 'DSN/DA(...)' parameter associated with 'DD/F(...)'",
                 "parameter."
             Exit
         End
    line.s.0 = i
    ids#     = '*'                          /* Parameter source indic */

    Return 0

/*--------------------------------------------------------------------*/
/* Seperate DSN string into individual DSNs.                          */
/*--------------------------------------------------------------------*/
dsn_seperation:
    ids#  = ''
    If syspref = '' Then prefd = userid
    Else                 prefd = syspref
    Do Forever
        Parse VAR data# ids data#
        If Substr(ids,1,1) /= "'" Then ids = "'"prefd"."ids"'"
        x = Listdsi(ids "NORECALL")
        If x /= 0 Then Do
            If not_fy /= 'N' Then,
                Say 'Dataset 'ids' not found. Cannot extract',
                    'allocation data.'
            If data# = '' Then Leave
            Iterate
        End
        ids# = ids# ids

        If data# = '' Then Leave
    End
    ids# = Strip(ids#)
    Return 0

/*--------------------------------------------------------------------*/
/* Change any variable                                                */
/*--------------------------------------------------------------------*/
set_amper_in_line:
    dsno = Strip(dsno,'t')
    dsn# = dsno
    x = Index(dsno,'&')
    y = Index(dsno,'.',x)
    If y = 0 Then Do
        y = Index(dsno,"'",x)
        If y = 0 Then y = Index(dsno,' ',x)
        If y = 0 Then dsno = dsno'.'
        Else          dsno = Insert('.',dsno,y-1)
    End
    p1 = ''; sub = ''
    Do Forever
        st = Length(P1||sub) +1
        sp = Index(dsno,'&',st)
        If sp = 0 Then Leave
        ep = Index(dsno,'.',sp)
        If ep = 0 Then Do
            l    = Length(dsno)
            If substr(dsno,l,1) = "'" Then Do
                ep   = l
                dsno = Substr(dsno,1,ep-1)".'"
            End
            Else do
                ep   = l +1
                dsno = dsno'.'
            End
        End
        var  = Substr(dsno,sp+1,(ep-sp)-1)
        p1   = Substr(dsno,1,sp-1)
        p2   = Substr(dsno,ep+1)
        sub  = Value(var)
        dsno = p1 || sub || p2
    End
    If not_fy = 'Y' Then Do
        Say 'Data changed from:'
        Say '  'dsn#
        Say 'To:'
        Say '  'dsno
        Say ' '
    End

    Return 0

/*--------------------------------------------------------------------*/
/* Verify ddname format.                                              */
/*--------------------------------------------------------------------*/
verify_ddname:
    ddok = 0
    alfa = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$'
    numb = '0123456789'
    If Length(dda) > 8 Then Return
    char = Substr(dda,1,1)
    If Index(alfa,char) = 0 Then Return
    alfa = alfa || numb
    Do i=2 To 8
        char = Substr(dda,i,1)
        If char = '' Then Leave
        If Index(alfa,char) = 0 Then Return
    End
    ddok = 1
    Return 0

/*--------------------------------------------------------------------*/
/* Establish any changes in system or selection criteria to establish */
/* data to be included according to reuested system.                  */
/*--------------------------------------------------------------------*/
change_sel:
    Select
        When (r_cmd = ')SYSID') Then Do
            Parse UPPER VAR r_parm sysid .
            Parse VAR sysid sysid ',' .
            inc_sys = activ_include(ifelse)

            d# = d# +1; line.d.d# = '*'
            d# = d# +1; line.d.d# = '*-> Sysid permanently',
                                    'set to "'sysid'" by )SYSID.'
            d# = d# +1; line.d.d# = '*'
            Return 'Y'
        End
        When (r_cmd = ')IF') Then Do
            Parse UPPER VAR r_parm ifsysid .
            inc_sys = activ_include('IF')

            d# = d# +1; line.d.d# = '*'
            d# = d# +1; line.d.d# = '*-> For "'ifsysid'" only, set',
                                    'by )IF.'
            d# = d# +1; line.d.d# = '*'
            Return 'Y'
        End
        When (r_cmd = ')ENDIF') Then Do
            ifsysid = sysid
            inc_sys = 'Y'
            ifelse  = 'ENDIF'

            d# = d# +1; line.d.d# = '*'
            d# = d# +1; line.d.d# = '*-> Back to "'ifsysid'" systems.'
            d# = d# +1; line.d.d# = '*'
            Return 'Y'
        End
        When (r_cmd = ')ELSE') Then Do
            If ifelse = 'ELSE' Then ifelse = 'IF'
            Else                    ifelse = 'ELSE'
            inc_sys = activ_include(ifelse)
            d# = d# +1; line.d.d# = '*'
            If ifelse = 'ELSE' Then Do
                d# = d# +1
                line.d.d# = '*-> <NOT> "'ifsysid'" flipped by )ELSE.'
            End
            Else Do
                d# = d# +1
                line.d.d# = '*-> For "'ifsysid'" only toggled by',
                            ')ELSE.'
            End
            d# = d# +1; line.d.d# = '*'
            Return 'Y'
        End
        Otherwise Return 'N'
    End

/*--------------------------------------------------------------------*/
/* Test whether to include or exclude.                                */
/*--------------------------------------------------------------------*/
activ_include:
    ARG ifelse
    isid = Translate(ifsysid,' ',',')
    xx = Index(' 'isid' ',' 'sysid' ')
    If ifelse = 'IF' Then Do
        If xx > 0 Then inc_sys = 'Y'
        Else           inc_sys = 'N'
    End
    Else Do
        If xx > 0 Then inc_sys = 'N'
        Else           inc_sys = 'Y'
    End

    Return inc_sys

/*--------------------------------------------------------------------*/
/* Verify prefix/qualifier(s) name.                                   */
/*--------------------------------------------------------------------*/
NameVer: Procedure
    ARG parm1
    If Length(parm1)>44 Then Return 16

    uper='ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$';nums='0123456789'
    Do Forever
        Parse VAR parm1 qual '.' parm1
        If Length(qual)>8 Then Return 12
        xx=Verify(Substr(qual,1,1),nums)
        If xx=0 Then Return 8
        If Verify(qual,uper||nums)/=0 Then Return 8
        If parm1='' Then Leave
    End
    Return 0

/*--------------------------------------------------------------------*/
/* Help instructions.                                                 */
/* The instream help is extracted from data contained in the last     */
/* '/*....*/' pair in this routine. So don't place any code at the    */
/* end.                                                               */
/*--------------------------------------------------------------------*/
help:
    v_c='ABCDEFGHIJKLMNOPQRSTUVWXYZ' ||,
        'abcdefghijklmnopqrstuvwxyz' ||,
        '0123456789'                 ||,
        '@#$_'

    name=$Whoami()
    If cname1st Then Parse VAR name cname sname .
    Else           Parse VAR name sname cname .
    uline=Copies('-',Length(x_cmd' - Version 'real_ver'.'))
    Trace o

n_st=mark(2)                                /* Mark next line         */
/*

   Hello `cname..

   `x_cmd. - Version `REAL_VER..
   `ULINE.

   FUNCTION:
         The REAL (REALloc) routine can place a user specified dataset
         (or list of datasets) at the head/tail of the concatenation of
         datasets currently allocated to a specific DDNAME.
         It can also be use to remove a dataset from or replace the
         entire concatenation.
         This routine will remove redundancies out of each concatenation
         to improve performance.

   ENVIRONMENT:
         Execute the REALloc routine in native TSO only. REALloc can
         be invoked from within a higher level procedure.

   SYNTAX:
         %REALloc DD(ddname)
                  DSN('dsname' | list-of-'dsnames') | DUMMY | SYSOUT()
                            - or -
                  DATA('dsname' | list-of-'dsnames' | DD=ddnam) INSTREAM

                  POS(HEAD | TAIL | MINUS | REPLACE)
                  PREF(q1 | q1.q2..qn)
                  VARS('var-equate' | list-of-'var-equate's)
                  FORCE | *
                  HELP
                  TRACE

   OPERANDS:
         DATA('dsname' | list-of-'dsnames' | DD=ddnam)

                    - You may specify members in either the DSNAME or
                      LIST-OF-DSNAMES format.

                    - If DD=ddnam format is used, the 'ddname' must be
                      preallocated and should also be freed by the user.

                    - The FORCE and POS() parameters external to the
                      DATA() parameter will overwrite any internal
                      POS() and FORCE specifications.
                      Eg. Use an external POS(MINUS) to remove all
                      datasets concatenated  by a DATA() expansion. Use
                      this feature to enable allocation/de-allocation
                      using the same data member.

                    - While the DD() DSN() combination is usually used
                      for a one off or simple concatenation change, you
                      can build up quite a comprehensive list of
                      concatenations using the DATA() parameter, usually
                      at logon time.

                    - You can set up datasets on application basis etc.

                    - For dataset format, refer below.

         DA(..)     - Refer to DSN( below.

         DD(ddname | *)

                    - Specifies the DDNAME you wishe to concatenate
                      to.

                    - You may specify DD(*) with the POS(MINUS)
                      parameter to free all allocated ddnames. If this
                      feature is used, no DSN() parameter is required.

         DSN('dsname' | list-of-'dsnames' | *)     - or -

                    - DSNAME is the fully qualified name of the
                      dataset to be placed at the head or tail of the
                      concatenation of datasets currently allocated
                      to the ddname specified by the DD operand.

                    - Similarly for LIST-OF-DSNAMES. Separate each
                      dataset name with a blank and enclose each dataset
                      in quotes if fully qualified.

                    - All fully qualified datasets must be quoted
                      otherwise the user's prefix will be used as the
                      high level qualifier (HLQ).
                      NOTE - you may need to double up on quotes to
                      satisfy syntax checking depending on method of
                      calling, eg.

                       TSO EX 'PROD.REXX(REAL)' -
                          'DATA(''user.CLIST(user)'') NOTIFY(AUDIT)'

                                     - or -

                       TSO %REAL -
                          DATA('user.CLIST(user)') NOTIFY(AUDIT)

                    - If the dataset to be allocated is already in the
                      concatenation, it will be ignored unless it is
                      combined with the FORCE and associated default
                      POS() parameter in which case it will be removed
                      from the proposed concatenation and placed at the
                      appropriate position (head/tail).

                    - You may specify DSN(*) with the POS(MINUS)
                      parameter to free all datasets allocated to the
                      associated ddname.

                    - You may specify dsname of DUMMY for a dummy
                      allocation.

                               ----------------------------------

         F(..)      - Refer to DD( above.

         FORCE | *  - Forces concatenation reordering if it is already
                      present.  Parameter will cause removal and
                      insertion at the appropriate position (HEAD by
                      default).

                    - Any non-blank positional character will infer
                      FORCE in a DATA() invoked parameter list unless
                      position is MINUS and TAIL or HEAD will be used
                      in case of allocation reversal.

         HELP | ?   - Use the HELP keyword to display this information
                      text, then exit (but you already know this).

         INSTREAM   - Used to indicate that the DATA() statements are
                      within the invoking REXX/CLIST at the end.

                    - If this feature is used, the instream data must
                      adhere to DATA() syntax and must follow the label
                      "INSTREAM:" for REXX or "INSTREAM: +" for CLISTs.
                      All lines after the label must only be DATA()
                      format statements.

         NOTIFY(ERRORS | NO | YES | AUDIT | TEST)

                    - Specifies whether any actions/errors are to be
                      notified to the user. The default is AUDIT.

                      AUDIT  - Only displays data to be processed by
                               routine.  Will not provide executed
                               actions. It will display all errors.
                      ERRORS - Only displays error messages (default).
                      NO     - Suppresses all messages including errors.
                      TEST   - Displays all messages (as for YES) but
                               does not perform final allocation.
                      YES    - Displays all messages.

         POS(HEAD | TAIL | REPLACE | MINUS)

                    - Specifies whether the dataset(s) are to be
                      concatenated to the head or the tail of the
                      current allocation.

                    - HEAD concatenations will be processed in reverse
                      order so that the first definition (if unique or
                      forced for non-unique) will be at the front of
                      the concatenation.
                      Watch out for conflicts when using the DATA()
                      ')IM' option.

                    - MINUS (or '-') will remove the dataset from the
                      concatenations. This will be processed last to
                      ensure it is not re-allocated by a subsequent
                      entry.
                      Notes:-
                      - MINUS will not remove your ISPPROF allocation.
                        If you have changed the allocation, it must be
                        reversed outside the MINUS parameter reversal.
                      - MINUS cannot reverse any allocations made using
                        the REPLACE command. Any such reversals must be
                        made outside the MINUS parameter reversal.
                      - MINUS cannot restore removed redundancies when
                        a REAL allocated dataset generates or is part of
                        a redundancy set.
                      - MINUS cannot be used on a )IM statement.

                    - REPLACE will replace the original concatenation
                      with the list it builds from all the REPLACE
                      parameters. If REPLACE is used with the FORCE
                      parameter, the first occurrence of the REPLACing
                      dataset will be allocated to that DD and all other
                      references ignored, ie. only one dataset allocated.

         PREF(q1 | q1.q2..qn)

                    - Specify the prefix to be used instead of the
                      userid, for un-quoted dataset names. The qualifier
                      may be multiple levels, however, it should conform
                      to naming standards. No verification is performed
                      and invalid data may cause syntax errors in
                      processing the expanded dataset name.

                    - The qualifier(s) will replace the userid for the
                      entire processing, unless a ')PREF' DATA() control
                      statement is encountered.

                    - This parameter will change the value of variable
                      &PREF..

         TRACE      - Use the TRACE keyword if you wish to view the
                      TSO commands and REXX statements as they are
                      executed.
                      For debug purposes suggest use with NOTIFY(TEST).

         VARS('var-equate' | list-of-'var-equate's)

                    - You can specify variable equates or a list of
                      variable equates.  Use this as an interface
                      between the invoking REXX routine and REAL.  This
                      is different from the )REXX variable setting
                      function as that is static and this permits the
                      caller to set variable values.

                    - A list MUST be comma seperated and any imbedded
                      spaces (or commas) MUST have the equate bounded by
                      same starting and ending quotes (double or
                      single).
                      Starting quote MAY NOT be used in the expression
                      (doubling up is NOT acceptable).

                    - Format of a 'var-equate' is,
                         var=value
                      where:
                         var   - name of the variable to be used by
                                 REAL. (Refer to variable naming
                                 suggestions under the )REXX details.)
                         '='   - Equate literal seperator.
                         value - Value to assign the variable and can be
                                 any expression but any equates
                                 containing imbedded commas or space
                                 must be between single or double
                                 quotes.
                      Eg.
                         VARS(head1='Headline #1',sub1='Subline #1',..
                              lit1='Comma used,here',blk1=10*#lecl)


         Required operands - DD() and DSN() combination

                                    ** or **
                                     DATA()

                                    ** or **
                                   POS(MINUS)

         Default operands  - POS(HEAD)
                           - NOTIFY(ERRORS)
                           - PREF(userid)
                           - TRACE is off
                           - FORCE is off
                           - INSTREAM is off

   DATA() dataset format and use:
         Free format, however, DD must start in column 1 otherwise it
         will be treated as a DSN with a ripple effect down the
         parameters list.

         Format:
           Col_1
           |
           ddname dsname position qualifier

           - Position can be any of the following valid POS() values:
               HEAD, TAIL, REPLACE or MINUS (or '-')

           - qualifier can be any of the following values:
               FORCE | * or HEAD | TAIL

           - If the position is MINUS and the DATA() format is invoked
             with a POS(MINUS) option, any HEAD/TAIL datasets will be
             remove, however, with MINUS datasets the original
             concatenation order could not be guaranteed so a qualifier
             of HEAD or TAIL can be provided to indicate the
             re-insertion point. The default is HEAD.

           - If FORCE is to be used it must have an explicit POS
             parameter. You may use a '*' instead of the literal FORCE.

           - DDname of ISPPROF or ISPTLIB will automatically imply a
             parameter combination of REPLACE/FORCE whereby the first
             encounter will be effected (FIFO principle).  However, an
             explicit REPLACE/FORCE combination will override the last
             setting (LIFO) in cases where either of these two DD
             allocations are duplicated.

           - For dsname, you may specify "SYSOUT(class) parm1 parm2...".
             All data following the SYSOUT( will be included in the
             allocate command, eg.

                SYSOUT(A) DEST(LPR31004) COPIES(10) BURST

             Note, you cannot use the position of FORCE parameters as
             all parameters are treated as SYSOUT( parameters.
             This format is only available under DATA() input.

         Datasets not quoted will be prefixed by the user's TSO userid
         or the prefix explicitly set by the PREF() parameter or the
         )PREF command.

         While control statements are claimed to be case sensitive free,
         not all permutations have been tested.

   DATA() control statements (starting in column 1):

         Col_1
         |
         blank line
          - Used as separator (will be ignored).

         *
          - Comment line (will be ignored).

         +
          - Continuation of the previous line. Used mainly for lengthy
            )EXEC and )REXX commands.

         )ELSE

          - This statement is the converse of the previous )IF.

          - The )ELSE statement will flip the condition established
            by either the default or previous )IF. Concurrent )ELSE
            commands will toggle the condition test.

          - NOTE: An else statement for an )IF with multiple sysids is
            redundant as a hit will occur with one of the non current
            sysids (processing limitation).

         )ENDIF

          - This will terminate an )IF or )ELSE statement.  It will
            explicitly reset the system id to it's original value or
            the last )SYSID set value.

         )END

          - Explicitly ends the DATA() processing. Use this command
            if you want to build a data member with various combinations
            and only want partial execution.
            Any statements after this command are ignored.

         )EXEC dsname | progname parameters POS({HEAD | TAIL } | FIRST)

          - You may use this command to execute either a specific member
            or a program in the ISPLLIB/linklist or SYSEXEC/SYSPROC
            concatenations.

          - If the statement is > 80 bytes you may continue it on the
            next line by use of a '+' character in column 1 of the next
            line.

          - Prefix programs with a '!' to differentiate between programs
            and dataset(members).  Add a '%' after the '!' to restrict
            the search to SYSEXEC/SYSPROC. (Refer to examples.)

          - You may pass parameters to it just as you would under normal
            execution.

          - You may fine tune the order of execution by using the
            POS(HEAD/TAIL) parameter. The default is POS(TAIL).
            A further sub-parameter of FIRST can be used with the POS()
            parameter. This will force execution before any allocations
            are made. If FIRST is required then it must be the second
            sub-parameter after the HEAD/TAIL.  You may use a dot '.'
            placeholder in lieu of HEAD/TAIL if sequence is not
            important.

          - All routines to be executed will be actioned either before
            or after allocation processing.  The position of the )EXEC
            command during processing will only determine their order as
            modified by the HEAD/TAIL and FIRST sub-commands.

          - The main use of this function is in an )IM member that
            may require additional initialisation other than the initial
            library concatenation, eg. dataset creation (FIRST) prior to
            allocation.

         )FREE ddname | *

          - Frees all datasets in that DD concatenation.

          - If you use the '*' parameter, all DD concatenations will be
            freed leaving no allocations.

         )IF sysid1,sysid2....sysidn | value1,value2...valuen

          - This command will only include the datasets if you are on
            the specified system id(s) (or variable values set) on the
            ')SYSID' command).

          - This can be terminated with and )ENDIF command, changed with
            a new )IF statement or toggled with an )ELSE statement.

          - If an )ENDIF or new )IF statement is not found, processing
            continues till the end of file.

         )IM dsname | dsname(member) | SYSTEM | NOSYSTEM {new_im_limit}
             {FORCE}

          - This command will include processing of concatenation
            specifications from that dataset/dataset(member).

          - The concatenations from an )IM presented dataset will take
            their hierarchy where they lay between the DDs in the
            currently processed dataset.

          - You cannot include an )IM statement between datasets for the
            same DD concatenation, ie. the next line must have a DDname
            in column 1.  You may however repeat the DDname on the
            following line to redefine the DD to the processor.
            However, if the syntax is followed but the rule is broken,
            you may pass FORCE as a 2nd./3rd. parameter to force
            acceptance of the command. Eg. Near end of commands where
            blank lines are used for presentation purposes.

          - There is a limit of 10 )IM statements to protect against
            recursive invocation causing a runaway loop. If you wish to
            up this value, place the new value as the 3rd. parameter on
            the card.  This value must be a digit and < 50. You may
            dummy the dataset name with a '.' to indicate the )IM
            statement is only being used to up the limit.

          - SYSTEM will include the system allocated datasets. This is
            the default. The system defauls are )IM'd from a pre-defined
            dataset.

          - NOSYSTEM will bypass the system allocated datasets. Use this
            parameter if another system allocation routine is active.

         )PREF qual | *

          - You may use this command to change high level qualifier(s).

          - This will stay in effect until the next )PREF statement.

          - Use parameter of '*' to restore to original userid value.

          - This parameter is independent of )IF and )ELSE statements.

          - This parameter will change the value of variable &PREF..

         )REXX valid_REXX_syntax

          - You may code your own rex logic to be executed during the
            parsing of the DATA() statements. This can be used to set
            variables to be substituted into data presented to this
            routine.

          - While you cannot branch around statements using this logic
            you may set variables that can be substituted into a
            combination of )SYSID and )IF/)ELSE statements to branch
            around data.

          - Any variables set by these REXX commands may be used in
            control statement substitution by referring to the variable
            as &var_name.. The variable must start with an & and end
            with a '.'.
            It is recommended that variable names be prefixed (after the
            &) by a '#' to ensure no internal variables are changed, as
            no internal variables begin with a '#'.  For example of use
            refer below.

          - The following system variables may be used without
            predefinition and should not be changed.  A leading '&' and
            trailing '.' are still required:

              &GROUP.   - RACF group name.
              &PREF.    - Prefix set by PREF() or )PREF parameters.
                          (Default set to Userid.)
              &SYSID.   - System id.
              &SYSPREF. - TSO prefix.
              &USERID.  - Userid.
              &IPROF.   - ISPPROF dataset allocated prior to invoking
                          this routine (if pre-alloctade).

         )SYSID system_id | * | &variable.

          - Only one system_id will be accepted.

          - You may use this command to change/fake sysids (or set
            condition according to a variable).

          - This will stay in effect until the next )SYSID statement.

          - All subsequent )IF/)ELSE statements will be affected by this
            statement including any active IF/ELSE conditions when
            this command is encountered.

          - Use parameter of '*' to restore original system id.


         Examples of DATA() statements:

            ----+----1----2----+----3----+----4----+----5----+-
            * This will allocate at front after FORCED entries
            ISPPLIB 'SYS2.ISPPLIB'

            * This will allocate 'userid.ISPPLIB' at front
            ISPPLIB ISPPLIB HEAD FORCE

            * This will allocate after 'SYS2.ISPPLIB' under ISPPLIB
                    'SYS3.ISPPLIB' HEAD
            * This will allocate at ultimate end under ISPPLIB (forced)
                    'SYS4.ISPPLIB' TAIL *
            * This will remove the dataset from ISPPLIB and indicates
            * that it should be placed at the end of ISPPLIB in case or
            * a "reversel"
                    'SYS9.ISPPLIB' MINUS TAIL
            * This will include all definitions in specified dataset
            )IM 'SYSTEM.ALLOC(ABENDAID)' HEAD

            * Note - ISPPLIB has been broken by the )IM
            * Explicit continuation of ISPPLIB at end (no FORCE)
            ISPPLIB 'SYS9.PANELS'

            * After 'SYS3.ISPPLIB' dependant on contents of )IM dataset
            * because of HEAD default
                    'userid.PANELS.FIX'

            * Allocate dataset according to system id and ensure only
            * dataset in allocation
            ISPPROF 'userid.&SYSID..ISPPROF' REPLACE FORCE

            * Restrict selection to MVS1
            )IF MVS1
            ISPMLIB 'PROD.&SYSID..MESSAGES'
            )ELSE
            ISPMLIB 'TEST.&SYSID..MESSAGES'
            )SYSID MVS9
            * Add if MVS9 only to ISPMLIB (as the )ELSE refers to
            * not MVS1 and )SYSID sets the 'not processing' to MVS9)
                    'SYS2.ISPMLIB'
            * Terminate previous )IF )ELSE combination (actually )ELSE).
            * Sysid is still MVS9.
            )ENDIF
            * Return to actual systemid
            )SYSID *
            * Execute program ABCDINIT from linklist before allocations
            )EXEC !ABCDINIT POS(. FIRST)
            * Execute program ABCDFINL from ISPLLIB/linklist
            * SYSEXEC/SYSPROC where ever found last
            )EXEC !ABCDFINL NATURAL POS(TAIL)
            )EXEC 'SYS3.ABENDAID.EXEC(INITDATA)' 'EDIT' POS(HEAD)
            * Execute INITGDDM from SYSEXEC/SYSPROC only
            )EXEC !%INITGDDM
            )EXEC 'SYS3.CLIST(STARTXX)' ''SYS3.PARMLIB(&SYSID.)''
            *\|/*******************************************************
            *
            * To include datasets according to DOW
            *
            )REXX #sid = sysid                    /* Save current setg*/
            )REXX #xxx = Translate(Date('w'))     /* Convert to upper */
            )SYSID &#XXX.
            )IF MONDAY,TUESDAY,WEDNESDAY,THURDAY,FRIDAY
            ISPMLIB 'SYS3.MIDWEEK.&#XXX..MESSAGES'
            )IF SATURDAY,SUNDAY
            ISPMLIB 'SYS3.WEEKEND.&#XXX..MESSAGES'
            )ENDIF
            )REXX sysid = #sid                    /* Restore current  */
            */|\*******************************************************
            etc....
            )SYSID *                              /* Restore original */
            SYSPRINT SYSOUT(A) DEST(LPR31004) COPIES(10) BURST
            etc....
            )END
            * Kept here for later use.
            )EXEC !%INITPROD


   EXAMPLE OF USE:
      1. During or after logon you wish to allocate your datasets. Issue
         the following TSO command.

          %REAL DATA('`userid..ALLOCS(member)')

      2. The above command (or INSTREAM processing) can be reversed by
         issueng the following TSO command.

          %REAL DATA('`userid..ALLOCS(member)') POS(MINUS)

         This will remove any inserted datasets and re-insert any
         removed datasets.

      3. Consider an existing allocation to the ddname ISPPLIB as
         provided by the standard TSO logon procedure. When you
         logon to TSO, the following concatenation of datasets will
         be allocated to ddname ISPPLIB...

          SYS1.SYSPLIB
          PROG.PROD.ISPPLIB

         Executing the REALLOC clist as follows...

          %REAL DD(ISPPLIB) DSN('"sysuid".PANELS')

         ...will result in the following concatenation of datasets
         being allocated to ddname ISPPLIB...

          `userid..PANELS
          SYS1.SYSPLIB
          PROG.PROD.ISPPLIB

      4. Assume example 3 above and you wish to remove SYS1.SYSPLIB from
         the concatenation. Issue the following under native TSO:

          %REAL DD(ISPPLIB) DSN('SYS1.SYSPLIB') POS(-)

         ...will result in the following concatenation of datasets
         being allocated to ddname ISPPLIB...

          `userid..PANELS
          PROG.PROD.ISPPLIB

      5. Again, assume example 3 above and you wish to replace all the
         dataset:

          %REAL DD(ISPPLIB) +
              DSN('my.PANELS' 'SYS3.ALL.PREPROC.PANELS') POS(REPLACE)

         ...will result in the following concatenation of datasets
         being allocated to ddname ISPPLIB...

          "my".PANELS
          SYS3.ALL.PREPROC.PANELS


   SAMPLE DATA:
       ----+----1----2----+----3----+----4----+----5----+-
       )PREF &USERID.
       SYSPROC  REXX                          HEAD *
                '&USERID..REXX'               HEAD
                '&USERID..CLIST'              HEAD
       *
       ISPTLIB  '&USERID..ISPTLIB'            HEAD
       *
       ISPLLIB  '&USERID..LOADLIB'            HEAD
       *
       ISPSLIB  '&USERID..ISPSLIB'            HEAD
       *
       ISPMLIB  '&USERID..ISPMLIB'            HEAD
       *
       ISPTABL  '&USERID..ISPTLIB'            REPLACE
       *
       ISPPLIB  '&USERID..ISPPLIB'            HEAD
                '&USERID..ISPPLIB.IBM'
                '&USERID..ISPPLIB.TUTORIAL'
       *        '`USERID..ISPPLIB.PDS'
       *
       *USERTABL '`USERID..`SYSID..ISPPROF'
       )IF MVS5
       ISPLLIB  'SYS4.TEST.LOADLIB'           TAIL *
       )IM      'SYS4.ALLOC.DATA(ABENDAID)'
       )ELSE
       ISPLLIB  'SYS3.PROD.LOADLIB'           TAIL *
       )IM      'SYS3.ALLOC.DATA(ABENDAID)'
       )ENDIF
       *
       )IM      'SYS3.ALLOC.DATA(SMPE)'


   SAMPLE self-executing LOGON EXEC with instream allocations:
       Executed at TSO READY prompy by,
         EX '`USERID..EXEC(MYALLOC)'
       Where member '`USERID..EXEC(MYALLOC)' contains,
       ----+----1----2----+----3----+----4----+----5----+-
       /* REXX */
       Arg parm#
       Parse SOURCE . . xcmd_name dd_name dsn_name .
       xdat=dsn_name;xcmd=xdat

       nfy='NOTIFY(YES)';pos=;trc='NOTRACE'

       Address TSO
       "EX '"xcmd"(REAL)'",
           "'DATA(''"xdat"("xcmd_name")'') INSTREAM",
           "VARS(#infra="xcmd")",
           pos nfy trc,
           "'"
       sysid=Strip(storage(d2x(x2d(c2x(storage(10,4)))+x2d(154)),8))
       "PDF"
       Exit

       Instream:
       SYSEXEC   '&INFRA.'                        HEAD
                 '&USERID..EXEC'                  HEAD
       SYSPROC   '&USERID..EXEC'                  HEAD
                 '&USERID..CLIST'                 HEAD
       ISPMLIB   '&USERID..ISPMLIB'               HEAD
       ISPSLIB   '&USERID..ISPSLIB'               HEAD
       ISPLLIB   '&USERID..ISPLLIB'               HEAD
       ISPPLIB   '&USERID..ISPPLIB'               HEAD
       ISPTLIB   '&USERID..ISPTLIB'               HEAD
                 &IPROF.                          HEAD
       ISPTABL   '&USERID..ISPTLIB'               REPLACE FORCE
       SYSHELP   '&USERID..HELP'                  HEAD
       )END


   GOTCHAs:
      1. If you use REAL to remove datasets be aware of the potential
         problems that may arise if the MINUS command is used to remove
         previous allocations that now have to be re-inserted. You may
         approximate insertion point by using a parameter of HEAD/TAIL
         folowing the MINUS position indicator.

*/
n_en=mark(-2)                               /* Mark prev 2 line       */
/*  Address TSO "CLEAR"                                               */
    chgchar='`'

    Say Centre(' ooo000OOOO000ooo ',79,'*')
    Do i=n_st To n_en
        line=Sourceline(i)
        Do While Index(line,chgchar)>0
            Interpret "Parse VAR line p1 '"chgchar"' var '.' p2"
            If Index(var,'(')>0 Then Do
                Parse VAR var var '(' vl ')'
                If \Datatype(vl,'W') Then vl=Length(var)
            Interpret 'line=p1||Substr('var',1,vl)||p2'
            End
            ELse Interpret 'line=p1||'var'||p2'
        End
        Say '*'Substr(line,1,77)'*'
    End
    Say Centre(' End ',79,'*')

    Exit

$Whoami:Parse Upper Arg parm#
    nam@=Storage(d2x(c2d(acee)+x2d('64')),4)
    name=Storage(c2x(nam@),30)
    len=c2d(Substr(name,1,1));name=Substr(name,2,len-1)
    If Index(name,',')>0 Then sep=','
    Else If Index(name,'.')>0 Then sep='.';Else sep=
    Interpret "Parse var name cname '"sep"' sname ."
    name=cname sname                        /* toggle cname/sname     */
    Return $U2Lower(name,2,'*')
$U2Lower:Arg text,pos,rep
    lc='abcdefghijklmnopqrstuvwxyz';uc='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    If Datatype(rep,'W') Then Nop;Else rep=99999
    If Datatype(pos,'W') Then Nop;Else pos=2
    rname=
    Do i=rep by -1 To 1
        Parse VAR text name text
        If pos>1 Then Do
            pref=Substr(name,1,pos-1);suff=Substr(name,pos);End
        Else Do;pref=;suff=name;End
        rname=rname pref||Translate(suff,lc,uc)
        If text='' Then Leave
    End
    Return Strip(rname text)
Mark: Arg diff;If Datatype(diff)/='NUM' Then diff=1;Return sigl+diff
