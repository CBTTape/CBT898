%headline=' Virtual Storage Display '
*%hyper_link=2
%Address ISPEXEC "VGET (stfinc) PROFILE"
%If finc='' Then xxx=4096;Else xxx=finc
&Hello &CNAME..
!      y

.1. Display outlay:
!G
 The following display is the typycal display screen with it's default colours:

 -------- ----- 0------- 4------- 8------- C-------  0---4---8---C---  --------
!y
=r        !     g                                   p                  !
 00000000 +0000 040C0000 8141B568 00000000 00000000 *....a...........* 00000000
 00000010 +0010 00FBA140 00000000 078D0000 83A4E4DE *..¢ ........cuU.* 00FBA140
 00000020 +0020 078D1000 80E4BDF2 078D2000 92C27AEA *.....U.2....kB:.* 00000000
!r        !     g                                   p                  w
 00000030 +0030 070C0000 80FDDEA4 078D2000 83A14DF2 *.......u....c!(2*
=

 You may change the above colour scheme using the /COLOR {color_mode} command.
!                                                 y      !y         !

 The first column shows the address of memory. The second displays the offset
 from the initially entered address, which can be either positive or negative
 depending on the scroll direction. The next four columns are a HEX
 representation of the data in 4x4 byte lots. It is then followed by the actual
 value (limited by displayable character sets delimited in *). The final column
!                                                          y!
 is the address/dot command chain of all the addresses previously displayed or
 all the dot commands, depending on display mode. This chain is a wraparound in
 address mode. (Dot commands will be discussed in depth later.)

 You can use the UP|DOWN PF keys to scroll up and down the memory display.
!                y !y    !
 Use the LEFT/RIGHT PF keys to move up and down the address chain (rightmost
!        y   !y     !
 column, the current active address is a different colour) and diplay memory at
 that address.


.2. Valid commands:
!G

 @xxxxxxx  o Display memory at address X'xxxxxxxx'.
!y         w!                          y          !
 #ddddddd  - Display memory at decimal address dddddddd.
!y         w!                                  y       !
 &xxxx{,n} o Use address at offset X'xxxx' from the base address for a length of
!y         w!                      y       !
             n characters. The default is 4 bytes (8 characters).
!            y!
 +xxxx     o Display memory at offset X'xxxx' from the base address. New base.
!y         w!                         y       !
 +&xxx{,n} o Display memory by adding the length at offset X'xxxx' from the base
!y         w!                                              y       !
             address to the base address. The default is 2 bytes (halfword).
=y         w!                         y       !
 -xxxx     o Display memory at offset X'xxxx' before the base address. New base.
 )xxxx     - Display memory at offset X'dddd' from the base address. Same base.
 (xxxx     - Display memory at offset X'dddd' before the base. Same base.
=y         w!                         y           !
 >dddd     - Display memory at offset decimal dddd from the base address.
             (Note: Because of ISPF idiosyncrasies you may need to double up on
!
                    the > (>>).
!                       y !y !
 <dddd     - Display memory at offset decimal dddd before the base address.
=
 ?st,l,p   - Change data at address at top of screen to character/HEX st for
!y         w!                                                         y !
 ?X'st,l,p   length l padded with p. For further details see later screens.
!y           !      y!            y!
 ¬         - Reverse the ? changes. (Thereafter toggles changes.)
!y         w!            y!
 *         o Mark this location as new home address. New base.
!y         w!
 H         o Return to the address marked by the * command.
!y         w!                                    y!
 F*        - Mark last memory search location (find) as the base address.
!y         w!
%"ISPEXEC VGET (stfinc) PROFILE"
%If stfinc /= '' Then xxx=stfinc;Else xxx=4096
&F  string - Find the first string in the next &XXX.  bytes of available memory.
!y         w!               y      !           g     !
&FA string - Find all occurances of string in the next &XXX.  bytes.
!y         w!                       y !                g     !
&FN        - Find previously entered string in the next &XXX.  bytes.
!y         w!                                           g     !
&FP        - Find previously entered string in the previous &XXX.  bytes.
!y         !                                                g     !
 RF        - Re-issues the F string command from +1 byte from the last hit.
!y         w!              y       !

 Commands marked with a o instead of - in the previous tutorial screen can be
!                       w!           w!
 used in stacked commands. Stacked commands are any combination of valid o
!                                                                        w
 commands seperated by :(colon(s)). (Also refer to dot commands.)
!                      y!                          y           !
 The remaining commands (-) may only be used as the last command in the stack.
!                                                   y    !

&Regardless of the direction, a find command will process the next &XXX.   bytes
!                                                                  g      !
 data. If there is a storage violation (memory data not returned) the search
 for will be decremented by 512 byte lots until a valid range is available.
&(Note - The &XXX.   scope above is determined by the /FINC setting.)
! w     !    g      !                                y    !

 For commands F and ? you may prefix string with LC' to indicate lower case
!             y!    y!               y      !    y  !
 string and prevent upper case translation or prefix it with X' to indicate a
!                                                            y !
 HEX string. If you wish to us strings LC' or X' use LC'LC or LC'X'. Do not use
!                                      y  !   y !    y     !  y    !
 closing ' unless you explicitly want it included in your string.
!        y!

.2a. Further on the ? (change) command:
!g                  yg
 If the pad character is missing and a length is present, the data will be
!       y   !
 padded out with spaces. If the pad character(s) is present, the data will be
 padded out by 'copies' of the pad string to the length limit.

 If the st character is missing and a length is present, the data will be padded
!       y  !
 out with either spaces or 'copies' of the pad string to the length limit.

 If the length is missing, any padding is ignored.

 For character changes the pad characters may be prefixed by LC'  to indicate
!                                                            y  !
 lower case.

 For HEX changes the pad charecter should be a multiple of two character hex
 value.

 Check the changes to ensure what you have changed is what you want.  If not
 statisfactory, re ? it.
!                  y!

??
 If you enter ? by itself, you will be presented with a unprotected mass change
!             2!
 input screen. For 100% accuracy, you should always fill in the HEX values. (The
!                                                               y  !
 HEX values take priority over the character changes.) Each character line (16
!y   !                             y        !
 bytes) and each HEX fullword (8 byte representation) will be treated as a full
 entity replacement with the HEX field being zero padded and the character field
 spaces.  It is recommended that you watch the use of the [EOL] (Erase end Of
!                                                         y    ! y!        y!
 Line) key. While the results are predictable, it may not be what you desire.
!y!

 If you overtype the character display, watch spaces and full stops (the later
 being a non-displayable character representation). Any non-displayable
 character represented by a full stop will be interpreted as a full stop during
 the processing of the full 16 bytes/line if any change is made to the line.
 After mass character entries, you may fine tune your result by changing the
 appropriate address in the HEX display.

 During mass character entry, you may protect the HEX display by using the /LOCK
!                                                                          y
 command. This will enable wraparound in the text area rather than encroacing
 into the HEX display at end of line wrap. You may toggle the HEX display
 protect by each us of the /LOCK command.
!                          y    !

 The changes will not be saved until the END PF key is entered to exit the mass
 change screen or SAVE is entered on the command line which will change the
!                 y   !
 memory but stay in the display.  If you do not want your changes to be
 transposed over memory, enter CANcel on the command line to exit the display
!                              y      !
 without changing memory. If a prior SAVE was entered, it's changes cannot be
!                                    y    !
 cancelled.
 Note - Under mass change more may be changed than you wish. This can be
!e    y r                                                    !
        catastrophic for dynamically changeable storage. If your storage is
        subject to such change, execute the finite line command change.
        Mass change update will be as follows:
        - Any changes made to any of the 4 blocks of HEX data over the displayed
!       y!
          16 lines will replace the full 8 byte block. Any blocks not altered
          will be left alone.
        - Any changes made to the 16 byte character display in the screen, on
!       y!
          any of the 16 lines, will replace the full 16 bytes regardless of what
          was changed.
          Remember: Non displayable characters will get transleted to a . dot.
!r                wr                                                    yr
                    If a line is changed, these "non displayable" .'s will not
!r                                                                yr
                    be the same as the hex value and all the .'s (including the
!r                                                           yr
                    placeholders) will be translated to X'4B' which may not be
!r                                                      y    r
=r
                    what you want and could cause catastrophes when changing
                    code.
          As a rule:Only make changes in the 16 byte charater display for
!r                 wr
                    data/code that do not have non-displayable data. If there
                    is make HEX changes longhand in the HEX display section.
=
        - The change reverse command (¬) cannot be used to reverse mass changes.
!       y!                            y!


.3. Direct addressing (dot commands):
!G

 -------- ----- 0------- 4------- 8------- C-------  0---4---8---C---  --------
!y
=r        !     g                                   p                  g
 00FC6200 -0040 C9C5C1E5 C3E5E340 F0F361F2 F261F0F1 *IEAVCVT 03/22/01* .CSD
 00FC6210 -0030 40C8C2C2 F7F7F0F5 E2D7F74B F04BF240 * HBB7705SP7.0.2 * >CVT
=r        !     g                                   p                  w
 00FC6220 -0020 C8C2C2F7 F7F0F540 40404040 40404040 *HBB7705         * .CVTU
 00FC6230 -0010 40404040 40404040 00009672 F0F3F840 *        ..oÊ038 * .DACA
 00FC6240 +0000 00000218 00FDF2E4 00FC61BC 00FC6828 *.....Ù2U.Ü/¯.ÜÇ.* .DLCBC
 00FC6250 +0010 00000000 00FD2CFC 00FE744E 00FD6480 *.....Ù.Ü.ÚÈ+.ÙÀØ* .DLCBU
=

 (The above display is achieved by entering /MAp(CVT);UP 4 command.)
!                                           y        gy    !

 Note: - If default colourisation is used, dot commands that have DSECT maps
!w       !
         will be coloured green and those without will be white.
!                         g    !                          w    !
       - The current active dot command will be tagged with a > replacing the .
!        !                                                    y!              y
         prefix.


 There are a number of pre defined addresses that can be easily acessed using
 predefined stacked commands (known as dot commands).  The format of these
 commands are:
     .ccccccc where ccccccc is an up to 8 byte identifier.
!y            !     y       !
 By entering .. on the command line, the address chain column will be replaced
!            y !
 by the predefined ids, to the screen limit placing the address chain column
 into dot chain mode.  (For further detains refer to the .. command later in the
!                                                        y !
 tutorial. (Note - For first time use, issue the .. command twice.)
!           w    !                               y !

 You can interrogate the value of the predefined id by entering .cccc= on the
!                                                               y     !
 the command line or you may overtype the . with a = in the dot chain column and
!                                         y!       y!
 the command line will be set to the appropriate stacked value(s).  You can then
 doctor it to launch a new stacked command or prefix it with your own id
 (eg. .myid=...) to generate your customised short cut. This new id will be put
!     y        !
 on top of the dot chain column, however, it will be lost at session end.  You
 may extend a dot-command by appending a command seperator (:) and your own
!                                                           y!
 commands, eg.
     .mytiot=.TIOT:&24,3:*
!y

 Rather than defining your own dot commands per session you may set up your own
 in a dataset and point to it. To activate your dot commands, issue command
     ..='dsname { (member) }'
!y
 which will be placed on top of and display on the dot command chain column.
 To replace the entire command chain column with yours, issue command
     .=='dsname(member)'         (note subtle change in mix of . and =)
!y                               !                             y!    y!
 These will stay in effect until the next session.  Substitute * for
!                                                              y!
 dsname { (member) } to restore original values.
!y      ty         t!

 Use the following format to define your dot commands:
  #.ACEE  =A'@0:&224:&6C:&C8' M /* Accessor Environment Element */
!y         ry                 gy
  - use #. prefix, quote the stacked commands and enclose description in /* */.
!       y !
  - use an A between the = ' to indicate that it is a command usable if you have
!          r!            y   !
    the authorised option available for cross-memory mode.
  - use an M between the ' /* to indicate that a map is available.  This is used
!          g!            y   !
    to colourise the display accordingly.

 Dot commands may contain imbedded dot commands (watch out for recursion).

 If the dot commands are active and span more than one screen, you can scroll up
 or down the chain as normal using the UP|DOWN PF keys provided the cursor is in
!                                      y !y   !
 column => 72. Alternatively, you may enter .n where n is the number of lines
!       w    !                              y !     y !
 to scroll and hitting the appropriate PF key. . and PF key  will scroll a full
!                                              y!
 screen. This eliminates the need to place the cursor over the command chain
 column. This feature is disabled in address chain mode as the chain is a
 wraparound and all values should be displayed (if NOT in split screen mode).
 The use of the LEFT|RIGHT PF keys will execute the prev|next dot command in the
!               y   !y    !                         t   !t   !
 in the chain respectively.
 Enter R to repeat the same dot command. Use this if you want to execute a
!      y!              t    !
 "next/prev" formatted dot command (less typing than re-issueing the full dot
 command).

 The following are valid overtypes in the dot command chain display:
=y  w!
  ? - Return the name of the dot command in ISPF's long message. (Same base.)
  = - Place the expansion of the dot command on the command line.
  * - Map the current display with the associated DSECT. (This option will
      bypass the expansion of any associated stacked commands.)
  B - Browse the DSECT associated with the dot command.
  C - Map the DSECT after the dot command is evaluated using COBOL map.
  E - Edit the DSECT associated with the dot command.
  F - View the DSECT associated with the dot command (full listing). This
      command will search the DSECT dataset/concatenation for dot command name
!
      prefixed by a @. (Eg. for CVT, you will need a member @CVT.)
!                   y!          g  !                        yg  !
  M - Map the DSECT after the dot command is evaluated (assembler).
  V - View the DSECT associated with the dot command (abbreviated).
=
 Any other character will display storage after dot command evaluated.
 If the default colours used for dot commands are not changed, all dot commands
 that have a mapping DSECT will be displayed in green. (Extrated from the dot
!                                               g    !
 command matrix.)

 The source used to map (M) the DSECT is an abbreviated set of DSECT assembly
!                        y!
 entries with the continuation and comment lines removed. This is designed to
 give a one to one mapping between the source and display lines. This
 abbreviated member is presented using the V,E or B overlay.
!                                          y!y!   y!
 A seperate member prefixed by @ may be maintained of the full listing and this
!                              y!
 will be viewed if F is used as the overtype.  If the member name is 8 bytes
!                  y!
 long, the first character is replaced by the @.  For this feature, you must
!                                             y!
 duplicate copies of heritage IBM/3PP DSECTs in your DSECT dataset and thereby
 you can name the DSECT anything you like.

.3a. Authorisation cross-memory access using ASN.
!g
 SHOWSTOR may be used on a foreign address space using the ASN command.
!                                                          y   !
 However to use this feature you must have the facility installed at your site
 (availability of program XMEMSTOR) and have the appropriate authority to
!                         y       !
 execute it as it uses cross-memory facilities.  Any dot command that requires
 this type of authorisation will be coloured in yellow if authorised
!                                               y      !
 cross-memory program is available or red if not (or if you do not come in using
!                                     r   !
 the ASN facility).  These colourings will be in affect even for the active
!    r   !
 command.
 To define authorised dot commands, use the following format:
     #.MTTABLE=A'.BASEA:&8C:*'  M /* Master Trace TABLE (mapping macro) */
!y             ry
 This is simmilar to the non-authorised command but has an A between the = and
!                                                          r!           y !
 the first '(quote) for identification.
!          y!

=w
 If you devise any handy little stacked command, contact your dialog developer
 to get it included in your site's defaults.
=


?Direct_Addressing (SHOWDH1) *
.4. Direct addressing ids with their respective stacked command:
!G

 Use Direct_Addressing hyper_links for list of direct addressing commands.
!    2                !


.5. Miscellaneous features.
!G

 The following topics are presented in sequence or may be selected by code.

= 22y             w!
. 5a  ..          - Dot commands.
. 5b  /AUDIT      - Audit/replay past displays.
. 5c  /COLOR      - Display color schemes.
. 5d  /DISASM     - Disassembler.
. 5e  /DOFF       o Turn display off.
. 5f  /DUMP       - Dump memory in HEX to a file as assembler 'DC' statements.
. 5g  /FINC       - Find increment scope processing.
. 5h  /LOCK       - Lock HEX display fields to facilitate tabbing.
. 5i  /MAP(dsect) - Storage mapping using predefined DSECTS.
. 5j  /MSG        o Re-display entry message.
. 5k  /MTT        o Master trace table (in *MASTER* address space only).
. 5l  /PDE        o Program Dump End (for PDUMPR code).
. 5m  /PDS        o Program Dump Start (for PDUMPR code).
. 5n  /PRINT      - Print storage to a temporary dataset (and view).
. 5o  /QUIT       o Quit SHOWSTOR and return QUIT to calling program in R15.
. 5p  /SIS(nn)    - Store In Stack.
. 5q  /SS(name)   - Locate Sub-system.
. 5r  /SVC(nnn)   - Locate SVC in memory.
. 5s  /ZOOM       - Zoom into the cursor placed address.
. 5t  /ZSTOP      - Stop stacked commands on X'00' address generation.
=

 Topics marked with an o are only applicable with PDUMPR invocation.
!                      y!

.5a. .. { ON | OFF }
!g   y
 Set the address chain column to the dot commands. Toggle without parameters.
 Toggling will also toggle the converse setting of the /LOCK command. For
!                                                      y     !
 further details refer to the /LOCK command.
!                             y     !

.5b. /AUDIT parameter
!g   y
 With this command you can keep track of your displays accross sessions.  You
 can play them back or mirror them (if feasible).  The following are valid
 parameters:
=y       !
  BRowse - Browse the audit dataset.
  CLEAR  - Clear the audit dataset.
  MIrror - Applies the locations from the entries captured in the audit dataset
=
           to the current memory.  Note any illegal addresses will not be
           resolved. During mirroring, all SHOWSTOR features are available.
           With this feature you can only advance forwards to the next display.
           This feature will automatically de-activate auditing.  (It is not
           recommended to re-activate the audit feature during mirroring.)
=y       !
  OFF    - De-activate the audit feature.
  ON     - Activate the audit feature. If the audit dataset does not exist, it
           will be created.
!!
  PRINT  - Print/expand all the screens into an 80 byte dataset.
  PLay n - Redisplays the records in the audit dataset. You may bring up the
=
           previous/next record by the UP/DOWN PF keys respectively.  This is
           only a display of the captured screen and consequently no SHOWSTOR
           command are affective in this screen. However, you may enter APPLY on
!                                                                       y     !
           the command line to mirror the displayed memory in the current
           address space.
 Any invalid parameters will display the status of the audit feature.
 For both MIrror and PLay commands, you can pass a record number parameter to
!         y      !   y    !
 start mirroring/displays at.

.5c. /COLOR parameter
!g   y
 With this command you may customise the colours in the display area.  A panel
 will be presented on which there are input fields alligned with the data with
 the literal of the colour. Just overtype with the first character of the
 desired colour. The following predefined schemes are available:
=y           !
    CONserv  - Conservative colours.
    DEFault  - Default colours.
    NEUtral  - Get neutral colours.
    colour   - Turn all the display to one colour (1st character).
=

.5d. /DISASM
!g   y
 Disassemble data in memory.

 The following topics will only be presented if selected by code.

?A1 (SYSEXEC=SHOWDADH)
. A1. Connect to DisAssembler Tutorial.
! 2 y!

.5e. /DOFF
!g   y
 This facility is only applicable to PDUMPR macro invocation.  Turns display
 facility off. Usefull in a program when you no longer require memory displays
 (eg. in a loop). It can be re-activated by explicitly invoking macro PDUMPR (in
 program) with parameter DISP=Yes. (For further details, refer to section on
 PDUMPR macro.

.5f. /DUMP { no.-of-bytes {bytes-per-line {data-type {COBOL}}}}
!g   y
 This command will dump memory into a editable dataset in assembler 'DC' define
 constant format.
 Parameters:
     1. Number of bytes to dump (default is 1024).  Can use X'xxx to represent
!    g!                                                     y     !
        length in HEX.
     2. The number of bytes per line (default is 16, max is 23 - suggest use
!    g!
        default).
     3. Data format (Char/Hex).
!    g!
     4. COBOL literal to convert the assembler to COBOL format.  This is a
!    g! y     !
        keyword parameter.
 Parameters are positional so use .(dot) placeholders for defaulted parameters.
!                                 y!

.5g. /FINC( nnnn | D | space )
!g   y
 Use this command to set or interrogate the find scope size. The default memory
!                                           y    !
 search on any variant of the find command is 4096 bytes.  Enter any valid
 numeric value for nnnn to increase/decrease the size.  Enter D to reset to the
!                  y    !                                     y!
 default or leasve blank to interrogate the current setting.
!                  y    !

.5h. /LOCK { ON | OFF }
!g   y
 Use this command to lock/unlock the HEX display area. The default is the
 converse of the .. command.
!                y  !
 By locking the HEX display area you can more readily use the TAB/CRLF keys to
 access the dot chain column fields for quick moves (in dot mode).
 LOCK ON is automatically set when the .. command (dot commands in chain column)
!                                      y  !
 is on. ..OFF will turn lock off.
!       y     !
 With lock OFF, you can more readily tab to addresses in the HEX display and go
 to that address by hitting [ENTER].

.5i. /MAP(dsect {,* {,'dsname'}})
!g   y
 You can set up your own maps and map the dsect using this command. The
 parameters are as follows:
 dsect  - Predefined DSECT in default dataset.  Associated with dot commands and
!y      !
          may also be mapped by overtyping the . in the dot chain mode with an
!                                              y!
          M. The DSECT address is established from the dot command.
!         y!
 *      - Indicates to use the current address as the DSECT base. This is
!y      !
          required for user/customised DSECTs and should not be quoted.  Without
          the *, a . will be placed before the dsect name and an attempt will be
!             y!   y!
          made to derive the address from the dot commands.
 dsname - Dataset where customised DSECT maps are kept.  Should be fully
!y      !
          qualified and quoted. Use * to restore to original default.
!                                   y!

 You may enter /M to map the current display against the last MAP used.
!              y  !                                           y   !

?DS1
 DSECT display screen:
!g
 In the DSECT map panel, you may home into an address by placing the cursor in
 the value field and pressing [ENTER] (it is unprotected for this convenience).
 The first fullword will be used as the base address. If the value field is not
 a valid address, you may get unpredictable results.  If you enter /ZOOM (or the
!                                                                  y    !
 appropriate PF key) with the cursor on a selected line, you will zoom in using
 that displacement into the DSECT as the base.  You will be returned to the
 DSECT panel (unless you end with EXIT).  The above features invoke a new layer
!                                 y   !
 of this facility and any current session setting will revert to defaults until
 returned to previous layer. (Note: When you return to your DSECT, you will be
!                             w    !
 positioned back at the top of the DSECT and you will have to scroll down to
 to get to your original position before calling up the new address.)

 For DSECT table entries, you can place the cursor on the next table entry
 pointer, enter REPEAT (PF18) on the command line and the current DSECT will
!               y            !
 be overlaid using the new address.  Alternatively enter &offset on the
!                                                        y      !
 command line with the REPEAT PF key to achieve the same result.
!                      y      !

 The following are are valid commands:
!w
 BITs {OFF}
!y
     - Turn bit pattern for first character of a HEX field on/off.  No
       parameter will toggle between ON/OFF states (default OFF).
 CHAR {OFF}
!y
     - Turn character display ON/OFF. OFF will explicitly turn it OFF. No
       parameter will toggle between ON/OFF states (default OFF).
 DESC {OFF}
!y
     - Turn descrition display ON/OFF. OFF will explicitly turn it OFF. No
       parameter will toggle between ON/OFF states (default OFF).
       (PF11 will turn DESC on and PF10 will turn it off.)
 F string NEXT/PREV
!y
     - Find string in variable name. The string must match from the first
       character unless the string is prefixed with an * whereby it is non
!                                                      y!
       positional.  NEXT/PREV determine the search direction.
 FN  - Find next occurence of string.
!y   !
 FP  - Find previous occurence of string.
!y   !
 HEX {OFF}
!y
     - Turn hex display ON/OFF. OFF will explicitly turn it OFF. No parameter
       will toggle between ON/OFF states (default ON).
 RF  - Refind previous find string (or use appropriate PF key).
!y   !

 /L( size | D )
!y
     - Use this parameter to set the length of the storage to get for DSECT
       mapping. This feature/hindrance was introduced to cater for DSECT
       mapping when in cross memory mode to minimise storage gets. The
       current size is displayed at the top right of the heading and can be
       changed up or down using this parameter. Suggest to keep in multiples
       of 1024 bytes.  The default is 4096 bytes which shoud cover most
       DSECTS. Use D to reset to default.
!                  y!
       If you up it don't forget to drop it back to realistic values
       to minimise processing.
       In most cases 1024 bytes should be enough.

 Note - Addressing for multiple DSECTS in the one map is derived on the fly
!w    !
        if there is a pointer from a field in a previous DSECT. If qualified
        scrolling is performed (ie.  other than CSR with UP/DOWN) address,
        evaluation may be bypassed giving unpredictable results.
        As you scroll up through a change in DSECT the previous DSECT's
        values may be set to unavailable (??) as the base address will be
!                                         y !
        unknown until it is encountered in the UP scroll.  Alternatively do a
        MAX UP and scroll down. If a total screen pass is performed to the
        end, may use qualified scrolling.

 DSECT customisation:
!g
 You may customise your own DSECT as follows:
 - Assemble your program with PRINT ON, LIST=YES for your desired DSECT (IBM,
   3PP or your own).
 - Edit the held output and hit it with macro SHOWD. If it is NOT a macro
!                                             y    !
   DSECT manually overlay a + in column 41 (which is the eye-catcher for the
!                           y!          w !
   processing macro).
   If it is a COPY member enter SHOWD /C on the command line to change the =
!             t    !            y        !                                 y
   copy indicator to + in column 41.
!  t    !            y!          w !
 - IEHIBALL the result and delete any continuation lines that do not
   have a valid field definition attributes, ie. comment lines.
   Each valid line should have either a DSECT, DS, DC or EQU as the operator.
 - Copy it into a dataset with member name same as the DSECT name. (You may need
   to customise the DSECT name as some newer DSECTS take advantage of the >8
   character names.)
 You should now have an operational user/customised DSECT.

 If you wish you can set up your own dot command to utilise your new DSECT as
 follows:
 - Build a stacked command to get you to your DSECT address. If the stacked
   command is not your DSECT name, eg. you have 2 stacked commands to get to
   prev or next entry create a dummy DSECT with the stacked command name(s)
   and point it to the actual DSECT with a 1 line entry as follows, eg. dot
   command .SVC1ST and .SVCNXT (dsect members SVC1ST and SVCNXT contain),
     # SVCENTRY      /* point to proper DSECT    */
!y
 - Define your dot command in a user dataset and include as described
   previously or have it added to the predefined dot commands.

 You can invoke this feature of SHOWSTOR over a VIEWed session of a dump
 using the DSECT edit macro. Specify a block or line command and enter
!          y     !
 DSECT dsect-name on the command line.
!y                !
 Note - The DSECT macro does not cater for occurances of
!w    !
           00000060   LINES TO 000000C0 SAME AS ABOVE
!r
         and manual doctoring needs to be made for those lines.

.5j. /MSG
!g   y
 Re-displays the original entry message.  This facility is only applicable to
 PDUMPR macro invocation.

.5k  /MTT{(nnnn)}
!g   y
 Format and display the Master Trace Table (in *MASTER* address space only). Can
 pass parameter of the number of lines to display.  Default is 100 lines.

.5l. /PDE
!g   y
 Go to Program Dump Start. Goes to the first instruction of the PDUMPR code
!      t!      t!   t!                                          y      !
 being executed. The purpose of this command is to provide a quick path anchor
 to position at the start of the code and scroll up to look at any
 storage/eye-catchers that has been manipulated without having to waste the base
 address or set/corrupt a register.  Normally this storage would be branched
 around.
 Example of use would be a flag that could be zapped and if coded properly
 could, for example, branch around that particular display next time
 through.
 This facility is only applicable to PDUMPR macro invocation.

.5m. /PDS
!g   y
 Go to Program Dump End. Used for a similar purpose as /PDS (in "reverse").
!      t!      t!   t!                                 t   !
 This facility is only applicable to PDUMPR macro invocation.

.5n. /PRINT {nnnn { A }}
!g   y
 Print storage to a temporary dataset. The screen is dumped to a temporary
 dataset. nnnn is the number of bytes to print. The default is screen lines x16.
!         y    !
 A is used to indicate appending to a previous print (this session only). The
!y!
 append indicator is positional so to append, you MUST enter the nnnn parameter.
!                                                                y    !

.5o. /QUIT
!g   y
 Terminate SHOWSTOR session with QUIT status. Only applicable if invoked using
!                                y    !
 the PDUMPR macro. For further details on QUIT, refer to instructions under
 /REGS.

.5p. /SIS(nn)
!g   y
 Store In Stack. Store the next nn'th 4 byte addresses at top of address stack
!                               y !
 (dot command OFF).  This way those addresses can be quickly navigated using the
 LEFT/RIGHT PF keys.

.5q. /SS(ssname)
!g   y
 Find sub-system ssname and present it under /MAP(SSCT,*) command.
!                y      !                    y            !

.5r. /SVC(nnn | S)
!g   y
 Go to the SVC nnn executable code in memory. If literal S entered, you will be
!             y   !                                      y !
&placed in view mode for SVC S(ource) dataset '&SVCPLIB.'.
!                                             y

.5s. /ZOOM
!g   y
 The address at the cursor will become the top display. Cursor can be placed in
 the HEX display or actual value. Note that the base address will remain
 unchanged. Quick alternative to the )nnn command
!                                    y    !

.5t. /ZSTOP { ON | NOMSG | OFF }
!g   y
 Use this command to stop stacked command expansion in it's tracks when the the
 return address is X'00000000'(PSA) or X'FFFFFFFF' often indicating end of chain
!                  y          !        y           !
 and you do not want to be repositioned from your last address location. Set to
 OFF on entry. Set on NOMSG to set it on without displaying a message on
!y  !                 y     !
 interception.

.6. Register processing:
!G
 /REGS, /Rn, /REGP, /R13P and /REGS*
!y                        !  y
!y
 These commands are used to manipulate registers:
 /REGS   - Go to register display screen.  Here you can change the registers'
!y       !
           values by overtyping the displayed values and entering SAVE on the
!                                                                 y    !
           command line. This will change the register savearea at address
           pointed to by the /REGS* command respectively. Be carefull as this
!                            y      !
           could cause the calling program to abend on return.
 /Rn     - Go to address pointed to by register n, where n can have the value 0
!y       !                                      y!       y!                   y
           to 15. This command may be used in a stacked command.
!             y !
 /REGP * - Use current address as a linear register save area. Ie, the next 16
!y       !
           full words are savearea for registers 0 to 15 respectively.
 /R13P * - Use current address as a circular register save area. Ie, the next 16
!y       !
           full words are savearea for registers saved using command:
                STM   R14,R13,savearea+12
!y
           (It is assumed the displayed area is savearea+12 and NOT saveare+0.
!                                               y       w   !       y      w !
           If you only STM R14,R12,... then ignore settings for R13.)
!                      t              !
 /REGS*  - Go to address established on entry as the passed address for the
!y       !
           register savearea. You can directly zap register values at this
           address or use the SAVE command in the /REGS display screen.
!                             y    !              y     !
           Registers are stored in the linear /REGP format (0 to 15) by the
!                                             y     g      !
           PDUMPR assembler macro.
!y                !
           Note - This command is only valid if this facility was invoked by the
!y         w    !
                  PDUMPR assembler macro.
!y                       !

                - This storage is different to that pointed to by R13 as the
                  registers are stored on invoking the PDUMPR macro at this
!                                                      y      !
                  address and re-loaded from the address when returning from
                  then macro.

                - This address is preserved even if the register values are
                  changed using the /REGP or /R13P commands.
!y                                  y     !  y     !

 In the register display screen, if invoked using PDUMPR, you can either enter
 QUIT on the command line or change and save R15 with the literal QUIT.  This
!y    !                                                           y   !
 will cause the invoking program to branch to the label specified on the QUIT=
!                                                                        y
 keyword parameter of the PDUMPR macro.

.7. Program Invocation:
!G
 PDUMPR assembler macro:
!g
 This facility can be called from an assembler program to display memory. (Not
 APF authorised program as ISPF services cannot be used.)

 All parameters are keyword parameters except the first which is the only
 positional parameter for the address to be displayed. The format is as
 follows:
     PDUMPR addr,kw1=..,kw2=..,kwn=...
!y

 The following are permissable parameters/keywords:
     addr         - Address to be displayed. (Register format is not available
!y                !
                    because if you let the REGP= parameter default, you can use
!y                                         y     !
                    the /Rn command.)
!y                      y   !
     REGP=Yes|No  - Set REGP= parameter on entry. This will enable the the
!y           !y   !     y     !
                    /REGS* command.
!y                         !
     MSG='text'   - Message to be displayed on entry into SHOWSTOR. Alternative
!y                !
                    to a text literal, you may use a label(length) parameter.
!                                                    y             !

     TYPE=Var|Con - CONstatnt/VARiable type for MF=L format. VAR is the default.
!y           !y   ! g  !      g  !
     ISPI=Yes|No  - Invoke the ISPEXEC macro with the INIT option in the macro.
!y           !y   !            y       !              y    !
                    Defult is Yes. Set to No if you explicitly use the ISPEXEC
!y                                                                     y
                    INIT=Y macro in your program.
!                   y      !
     REXX=SHOWSTOR
!y
                  - REXX EXEC to be executed from the macro. This should not be
                    changed.
     QUIT=label   - Label to branch to if QUIT is invoked in register display
!y                !
                    panel. (Refer to topic /REGS.)
!                                          y    !
     DISPLAY=Y|N  - Display using SHOWSTOR. Used for control diplay logic within
!y            !y  !
                    loops. Combines with the /DOFF feature.
!                                            y     !
     HELP=No|Yes  - HELP in expansion of the macro
!y          !y    !
     LIST=No|Yes  - LIST expansion
!y          !y    !
     MF=          - Exec/List format
!y                !

 To use this feature you will also need access to macros ISPEXEC and HEXCHMAC as
!                                                        y       !   y        !
 well as the PDUMPR macro.
!            y      !
 Note - The PDUMPR is continually being developed/enhanced. Refer to the doco
!w    !     y      !
        within the macro for more up to date details.

.8. Fast moves:
!G
 You may fast move to an address in the display by tabbing to that address and
 hitting [ENTER]. This feature also applies to the chain of addresses in the RH
 column. If you wish to fast move using the address chain you may lock the HEX
 display area by using the /LOCK command.
!                          y     !


.9. PF Key definitions:
!G

 PF KEYS:
!g
   PF07 - UP      Scroll up in main display. If combined with ..n on the
!y      !y       !
                  command line, scrolls the command chain column only, not
                  applicable in address chain column mode.
   PF08 - DOWN    scroll down in main display. Same rules as for UP.
!y      !y       !
   PF10 - LEFT    Previous entry in the address/command chain column.
!y      !y       !
                  Turn DESC off in DSECT display.
   PF11 - RIGHT   Next entry in the address/command chain column.
!y      !y       !
                  Turn DESC on in DSECT display.
=y      !y       !
   PF13 - /LOCK   Toggle LOCK ON/OFF.
   PF14 - /ZOOM   ZOOM in on address.
   PF15 - ..      Toggle dot commands ON/OFF.
   PF16 - H       Home.
   PF17 - RF      Re-Find.
   PF18 - REPEAT  REPEAT last command.
=

                             (End of Instructions.)
!G
*
* This should be the last entry.
*
* Note the index is not paragraphed but manually positioned as the
* start of the Index is before the "I.".
*
=G!                                                                            G
#                                  I. Index:
!G

&  Hello &CNAME..                                              Version: &VT..

   This facility permits you to display accessible memory.  The display is a
   scrollable table with the following outlay.

   The following topics are presented in sequence or may be selected by code.

=G!  2!                                                                        G
     1  Display outlay.
     2  Valid commands.
     2a Further on the ? (change) command.
!Gy  2 !               y!                                                      G
     3  Direct addressing (.. dot commands).
!Gy  2!                    y !                                                 G
     3a Authorisation cross-memory access using ASN.
!Gy  2 !                                                                       G
     4  Direct addressing ids with their respective stacked (dot) commands.
     5  Miscellaneous features.
=G!  22y         w!                                                            G
     5a  ..      - Dot commands.
     5b  /AUDIT  - Audit/replay past displays.
     5c  /COLOR  - Display color schemes.
     5d  /DISASM - Disassembler.
     5e  /DOFF   o Turn display off.
     5f  /DUMP   - Dump memory in HEX.
     5g  /FINC   - Find increment scope processing.
     5h  /LOCK   - Lock HEX display fields to facilitate tabbing.
     5i  /MAP    - Storage mapping using predefined DSECTS.
     5j  /MSG    o Re-display entry message.
     5k  /MTT    o Master trace table (in *MASTER* address space only).
     5l  /PDE    o Master trace table (in *MASTER* address space only).
     5m  /PDS    o Master trace table (in *MASTER* address space only).
     5n  /PRINT  - Print storage to a temporary dataset (and view).
     5o  /QUIT   o Quit SHOWSTOR and return QUIT to calling program.
     5p  /SIS    - Store In Stack.
     5q  /SS     - Locate Sub-system.
     5r  /SVC    - Locate SVC in memory.
     5s  /ZOOM   - Zoom into the cursor placed address.
     5t  /ZSTOP  - Stop stacked commands on X'00' address generation.
=Gy  2!                                                                        G
     6  Register processing.
     7  Program invocation.
     8  Fast move.
     9  PF KEY settings.
=Gy                                                                            G


                               (End of Index.)
!G

%helpdd='Alex'
?TN (HELPTN) *
    TN  Tutorial Navigation.
!Gy 2 !                    y !                                                 G


!G
