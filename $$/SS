/*--------------------------ooo00 REXX 00ooo--------------------------*/
symsub:sysmsub_ver='1.27'
ms=mark(1)                                  /* TF68 (max text flow)   */
/*--------------------------ooo000OOOO000ooo--------------------------*/
/*                                                                    */
/*  SYMSUB: SYMbolic SUBstitution.                                    */
/*                                                                    */
/*  Macro to do variable substitution on JCL. By default, this macro  */
/*  will replace all the symbols, including system symbols, and       */
/*  rewrite the line. Symbolic substitution will also be made in      */
/*  instream data.                                                    */
/*                                                                    */
/*  Notes:                                                            */
/*    - System (JESx interpreters) will not susbstitute system        */
/*      symbols in jobs as jobs may be subjected to XEQ action which  */
/*      could result in different values.                             */
/*    - Symbols are not globally substituted, eg. DDname. Cannot have */
/*      '//&DDNAME DD ...'. "SYMSUB" will process it if you use the   */
/*      '/A' option (which is more powerfull than the '/AI' option).  */
/*                                                                    */
/*  You may pass the following parameters to control output:          */
/*    /A   - Apply. Expand all variable substitutions and replace the */
/*           original line. This will force the setting of the        */
/*           "expand" flag above.                                     */
/*           (Will NOT substitute on comment lines. Use '/EC' to      */
/*           force comment line substitution.)                        */
/*    /AI  - Apply sysIn.  Expand SYSIN variables only. Will only     */
/*           process lines that do not have '//' in column 1.         */
/*           (Note: Previous equivalent command of "/RI" is no        */
/*                  longer applicable.)                               */
/*    /CS  - Comment SET command.  This is for sites where there are  */
/*           exits preventing use of the set command.  After the      */
/*           variable substitution, all "SET" commands are commented  */
/*           out.                                                     */
/*    /DEbug                                                          */
/*         - Discrete "SAY" statements for debugging.                 */
/*    /E   - expand all variable substitutions and rEset              */
/*           member to remove notelines.                              */
/*    /EC  - Even in Comment lines.  Will substitute variables on     */
/*           "//*" lines.                                             */*/
/*    /F   - Forward scan of variable substitution.  (Not yet         */
/*           developed.)                                              */
/*    /L   - Backward scan from the last card.  Use this for things   */
/*           like instream procs or members where the variables       */
/*           definitions are after the place it's used.               */
/*    /R   - Same as "/A". (For backward compatability. Avoid using   */
/*           as it will be removed from later releases.)              */
/*    /S   - Simulate. Expand all variable substitutions and place    */
/*           them in a noteline before the current line (default).    */
/*           Will substitute on comment lines.                        */
/*    /SX  - Same as "/UX". (For backward compatability. Avoid using  */
/*           as it will be removed from later releases.)              */
/*    /TRace | TRACE                                                  */
/*         - Trace REXX code, for debugging.                          */
/*    /X   - Same as "/S". (For backward compatability. Avoid using   */
/*           as it will be removed from later releases.)              */
/*    /UX  - sUbmit and eXit. This parameter will also infer a '/A'   */
/*           parameter.  Suggest using this for repetative tasks to   */
/*           substitute, submit and exit temp copy.                   */
/*                                                                    */
/*  You may pass the following parameters to assist in building the   */
/*  JCL (as opposed to pre-submit processing):                        */
/*    /D   - Insert disclaimer after the cursor-line (as a noteline   */
/*           that can be "MD"d as required).                          */
/*    /DD  - Insert disclaimer after the cursor-line as data.         */
/*                                                                    */
/*  Extra features:                                                   */
/*  1. All changes (permanent or temporary) will be made to a copy    */
/*     of your current edit/view member thereby protecting the        */
/*     integrity of the original member. The copy will be to a unique */
/*     dataset of the format syspref{.userid}.$TEMPnn.TEMP.  The      */
/*     limit of nn is 30 and you will be warned accordingly.          */
/*  2. You can automatically set a variable to today's date on a set  */
/*     command using the following equate "=DATE()",eg.               */
/*         //VAR1 SET DATE=DATE()                                     */
/*         //......                                                   */
/*         //DD1 DD DISP=(NEW,CATLG),DSN=SYS9.PROCLIB.BACKUP.D&DATE   */
/*     This will instruct SYMSUB to actually change the above SET     */
/*     command as follows:                                            */
/*         //VAR1 SET DATE=yymmdd         (of todays date)            */
/*  3. Similar to today's date, you can set the current time (time    */
/*     of job submission) using format "=TIME()", eg.                 */
/*         //VAR2 SET TIME=TIME()     -> hhmmss                       */
/*  4. You can automatically set a variable to a "$DATEMAN"           */
/*     substituted value on a set command using the following format  */
/*     "=$DATEMAN(...)" ,eg.                                          */
/*       //VAR1 SET DATEJ=$DATEMAN(E2J,,2,N)                          */
/*       //......                                                     */
/*       = This equate will generate date in julian format without    */
/*         the '.', ie. yyddd.                                        */
/*       //VAR2 SET DATES=$DATEMAN(REV,,2,D)                          */
/*       = This equate will generate date in sort (reverse) format    */
/*         without the '/', ie. yymmdd.                               */
/*       //VAR3 SET DATED=$DATEMAN(E2D,,3,U) Day of week              */
/*       = This would generate the day of the week in uppercase       */
/*         truncated to 3 characters.                                 */
/*     Note - To use this feature, you must have $DATEMAN available.  */
/*            To determine if it is available and get help on it's    */
/*            usage, enter "TSO $DATEMAN ?" on any command line. If   */
/*            help is returned it is available.                       */
/*  5. You may use line commands "C" or "CC" to limit scope of        */
/*     substitute processing.                                         */
/*  6. You may also selectively stack "SYMSUB" commands and combine   */
/*     with feature #5 to progressively build JCL.                    */
/*  7. You can see what JES2 (or JES3 for the unfortunate) will       */
/*     substitute to do a validation check prior to submission.       */
/*  8. Use this facility to generate static JCL against customised    */
/*     variables.  Simply copy the generated JCL into your permanent  */
/*     member.                                                        */
/*                                                                    */
/*  If the line is replaced, the original line will be placed as a    */
/*  noteline above the new line.                                      */
/*                                                                    */
/*  GOTCHAs:                                                          */
/*  1. DO NOT use variable names the same as JCL component names,     */
/*     eg. &DSN, &DCB, &VOL, &SPACE, &UNIT etc... Variable            */
/*     substitution is done in a backward manner from the current     */
/*     line to pick up any late "SET" settings.  To overcome this,    */
/*     use the "/F" parameter.                                        */
/*  2. If you have recursive substitution (eg. in "SET" commands),    */
/*     you may need to append what seems like a redundant '.' to      */
/*     terminate the equate than just the standard space.  This will  */
/*     be obvious if it occurs, but this is the explanation (will be  */
/*     fixed next release).  Eg.,                                     */
/*      Instead of:                                                   */
/*        //VARS SET SUFF=CPU2                                        */
/*        //     SET PROCLIB=SYS1.PROCLIB.&SUFF                       */
/*      Use:                                                          */
/*        //VARS SET SUFF=CPU2                                        */
/*        //     SET PROCLIB=SYS1.PROCLIB.&SUFF.     <- trailing '.'  */
/*  3. If the substituted line is longer than 71 bytes, the line      */
/*     will be split over multiple lines. If you have trailing        */
/*     commnets on the line, these will overflow as a continuation    */
/*     line with a "//*" in column 1. This will not be an issue       */*/
/*     unless the line being processed contains "PARM=" with          */
/*     imbedded spaces and you are replacing the line. You may need   */
/*     to manually adjust the continuation line(s).                   */
/*  4. Will not expand external procedures.                           */
/*  5. Will not substitute execution variables over instream procs.   */
/*     A workaround this is to delete all the variables on the PROC.  */
/*     This will force a wraparound scan (starting from the end).     */
/*     If you use this method DO NOT FORGET to CANcel out of the      */
/*     session.                                                       */
/*  6. Does not like multiple "C" (or/and block) line command.        */
/*  7. Allocates its own temporary files so you may stack up to 30    */
/*     SYMSUB commands (which is higher than most sites ISPF temp     */
/*     file limit).                                                   */
/*  8. '/S' (simulate) option will substitute in comment lines (not   */
/*     optional.  However, if you want substitution on commnet lines  */
/*     under '/A' (apply) function you must explicitly request the    */
/*     '/EC' (even commnets) option.                                  */
/*                                                                    */
/*  If you don't like these gotcha's lobby IBM to permit symbolic     */
/*  substitution in SYSIN.                                            */
/*                                                                    */
/*--------------------------------------------------------------------*/
me=mark(-1)
    Address ISPEXEC "CONTROL ERRORS RETURN";ima_macro=0
    Arg parm#;If parm#/='' Then Signal ini1
    Address ISREDIT
    "MACRO (parm#) NOPROCESS"
    If rc=0 Then ima_macro=1

ini1:
    Parse SOURCE . . xcmd .

    zedsmsg=
    If Wordpos(Word(parm#,1),'? /? /H /HELP HELP')>0 Then Do
        If ima_macro Then Do;"(caps)=CAPS";"CAPS=OFF";End
        Do i=ms To me
            line=Sourceline(i)
            If ima_macro Then "LINE_BEFORE .ZFIRST=NOTELINE (line)"
            Else Say Substr(line,1,79)
        End
        If ima_macro Then "CAPS=(caps)"
        Return 0
    End
    "(STATUS)=USER_STATE";"(caps)=CAPS";"CAPS=OFF"

    ssvars='ssmacro,ssmember,ssparm,ssfline,sstline'
    Address ISPEXEC "VGET ("ssvars") SHARED"
    Parse Upper VAR parm# parm#
    If Wordpos('/D',parm#)>0 Then Signal slip_in_disclaimer
    If Wordpos('/DD',parm#)>0 Then Signal slip_in_disclaimer
    If ssmacro/='Y' Then Signal copy_and_process
    ssmacro=;Address ISPEXEC "VPUT (ssmacro) SHARED"

    parm#=ssparm
    "(status)=USER_STATE";"RESET"
    nat='ABCDEFGHIJKLMNOPQRSTUVWXYZ' ||,
        'abcdefghijklmnopqrstuvwxyz' ||,
        '0123456789@#$'
    val_cmd='DD EXEC JOB PROC SET'
    p_var=;simulate=0;apply=0;missing_var=
    If parm#='' Then parm#='/S'
    #tr=Trace('o');Call Parse_parms;x=Trace(#tr)
    Select
        When apply    Then noteline=
        When simulate Then noteline='NOTELINE'
        Otherwise          noteline=
    End

    "SEEK ' SET ' FIRST";If rc=0 Then Do
        lin#s=0
        Do Forever
            "CURSOR="lin#s+1 0
            "SEEK ' SET '";If rc/=0 Then Leave
            "(lin#s)=LINENUM .ZCSR";"(line)=LINE .ZCSR"
            If Index(line,'&')=0 Then Iterate
            Parse VAR line . w2 . 1 c12 +2 c3 +1
            If w2/='SET' Then Iterate
            If c12/='//' Then Iterate
            If c3='*' & \even_com Then Iterate
            Parse Value Translate(line,' ',',')With . 'SET ' linei
            Do While linei/=''
                Parse VAR linei x_x linei
                If Index(x_x,'&')=0 Then Iterate
                #lin#s=lin#s;y_y=$evalamp(x_x,,s_order);lin#s=#lin#s
                Parse VAR y_y var '=' val .
                If debug Then Say 'VAS_'var'='val
                If Verify(var,nat,'N')=0 Then Interpret 'vas_'var'=val'
            End
        End
    End

    "X ALL";lin#=ssfline-1
    Do While lin#<sstline
        "CURSOR=" lin#+1 0
        "F '&' NEXT";If rc/=0 Then Leave
        "(linei)=LINE .ZCSR";"(lin#)=LINENUM .ZCSR"
        If lin#>sstline Then Leave
        If noteline='' Then,
           If Substr(linei,1,3)='//*' & \even_com Then Iterate
        If ainsi & Substr(linei,1,2)='//' Then Iterate
        linei=Strip(Substr(linei,1,72),'t')
        If debug Then Say Substr(linei,1,72)
        #lin#=lin#;linex=Eval_amper(linei,,s_order);lin#=#lin#
/*                                                                    */
/* Redo in case a variable contained a variable.                      */
/*                                                                    */
        If Index(linex,'&')>0 Then Do
            If debug Then Say Substr(linei,1,72)
            #lin#=lin#;linex=Eval_amper(linei,,s_order);lin#=#lin#
        End
/*                                                                    */
        If linex/=linei Then Do
            If apply | sysvar Then "LINE_BEFORE" lin# "=NOTELINE (linei)"
            If Substr(linei,1,2)='//' Then Do
                If Substr(linei,3,1)='*' Then pref='//*';Else pref='//'
                prefl=15
            End
            Else Do
                If Strip(linei)='' Then prefl=0
                Else prefl=Verify(linei,' ')-1
                pref=
            End
            If Length(linex)>71 Then Do
                If Substr(linex,1,2)='//' Then Do
                    If Wordpos(Word(linex,2),val_cmd)>0 Then w#=3;Else w#=2
                    Parse VAR linex . . .
                    Interpret "Parse VAR linex" Copies('. ',w#) "com"
                    linex=Strip(Delword(linex,w#+1),'t')
                    If Length(linex)<72 Then linex=Substr(linex Strip(com),1,71)
                    If Length(linex)>71 Then Do
                        y=Lastpos(',',Substr(linex,1,71))
                        xx=Substr(linex,y+1)
                        linex=Substr(linex,1,y)
                        Call o_l
                        sstline=sstline+1
                        If Substr(xx,1,1)=' ' & pref='//' Then pref='//*'
                        linex=Substr(pref,1,15)Strip(xx)
                    End
                End
                Else Do
                    linex=Strip(linex,'t')
                    ls=Length(linex)-Length(Strip(linex))
                    linex=Substr(' ',1,ls)Space(linex)
                    If Length(linex)>71 Then linex=Space(linex)
                End
            End
            Call o_l
            If noteline='' Then Do
                "CURSOR="lin# 0
                "DELETE ALL .ZCSR .ZCSR"
                lin#=lin#-1
            End
        End
    End
    If com_set Then Do
        "CURSOR=1 0"
        Do Forever
            "SEEK ' SET '";If rc/=0 Then Leave
            "(line)=LINE .ZCSR"
            Parse VAR line . w2 . 1 c12 +2 c3 +1
            If w2/='SET' Then Iterate
            If c12/='//' Then Iterate
            If c3='*' Then Iterate
            line=Substr($cstring(line,'//','//*',1),1,71)
            "LINE .ZCSR=(line)"
        End
        xtra='All "SET" statements have been commented out.'
    End;Else xtra=
    If subex Then Do;"SUBMIT";"CANCEL";Exit;End
    If reset Then "RESET"
    If missing_var/='' Then Do
        x=nl(Substr('//*',1,71,'*'))
        x=nl(Substr('//*',1,70)'*')
        x=nl(Substr('//* Sybstitute valid values for the following missing',
             'variables',1,70))'*'
        x=nl(Substr('//* and re execute command:',1,70))'*'
        x=nl(Substr('//*'   missing_var,1,70)'*')
        x=nl(Substr('//*',1,70)'*')
        x=nl(Substr('//*',1,71,'*'))
    End
    "USER_STATE=(status)"
    zedlmsg='Copy of' ssmember'.'
    If noteline='' Then Do
        "(sesn)=SESSION"
        If sesn/='VIEW' Then Do
            zedlmsg=Substr(zedlmsg,1,79),
                  'Note: Member has been modified by the "'xcmd'"',
                  'command. Ensure that you CANcel out of the session',
                  'if it is not a copy.'
        End
        zedlmsg=zedlmsg xtra
    End
    Address ISPEXEC "SETMSG MSG(ISRZ001)"
    Exit

nl:Parse Arg n#;"LINE_BEFORE .ZFIRST=NOTELINE (n#)";Return 0

$EVALAMP:$evalamp_ver='2.12'
/*--------------------------------------------------------------------*/
/* Parse the line looking for variables startingt with an '&'.        */
/* If found, extract the variable name and than calls anouther sub-   */
/* routine to see if the variable has been set.                       */
/* If the variable name is returned it is not a system symbol and no  */
/* substitution is made.                                              */
/* Parameters:                                                        */
/*  1. Text to parse.                                                 */
/*  2. Column to parse from.                                          */
/*  3. Literal 'LAST' to start from last line rather than current     */
/*     position. Designed when parm is passed to instream proc.       */
/* Use command "$RU $EVALAMP" ($Routine Upgrade) to update with the   */
/* latest infrastructure copy of $EVALAMP.  Use command               */
/* "$RU $EVALAMP ?" to display latest infrastructure version.         */
/*--------------------------------------------------------------------*/
eval_amper: Parse Arg text,v_p,s_order;If text='?' Then Return $evalamp_ver
    loop_lim=50                             /* Arbitary loop limit    */
    If debug/=1 Then debug=0
    "ISREDIT (xx)=DATASET"
    If rc/=0 Then Do
        If Verify(text,nat,'N')=0 & Length(text)<=8 Then val=Mvsvar(Symdef,text)
        Else val=
        If val/='' Then Return val;Else Return text
    End
    #tr=Trace()
    expand=1
    nat='ABCDEFGHIJKLMNOPQRSTUVWXYZ' ||,
        'abcdefghijklmnopqrstuvwxyz' ||,
        '0123456789@#$'
    If lin#='LIN#' Then "ISREDIT (lin#)=LINENUM .ZCSR"
    If s_order='LAST' Then "ISREDIT (lin#)=LINENUM .ZLAST"
    If \Datatype(v_p,'W') Then v_p=1
    Do Forever
        v_p=Index(text,'&',v_p)
        If v_p=0 Then Return text
        next_char=Substr(text,v_p+1,1)
        If next_char='&' | next_char=' ' Then Do;v_p=v_p+2;Iterate;End
        If v_p=1 Then p1=;Else p1=Substr(text,1,v_p-1)
        p2=Substr(text,v_p)
        lc=Verify(p2' ',nat,'N',2)
        var=Substr(p2,1,lc-1)
        If Substr(p2,lc,1)='.' Then Do
            lc=lc+1
            var=var'.'
        End
        p2=Substr(p2,lc)
        If debug Then Say Space(var Substr(text,1,72))
        var_v=Get_equate(var)
        If var_v/=var Then Do
            If var_v/='' Then Do
                If Index(var_v,"''")>0 Then var_v=$cstring(var_v,"''","'",,'*')
                text=$cstring(text,var,var_v,v_p,'*')
            End
            Else Do
                x=Index(text,var)
                If x>0 Then text=Delstr(text,x,Length(var))
            End
        End
        If var_v/='' Then v_p=v_p+1
    End
    Return text

/*--------------------------------------------------------------------*/
/* Receive a variable name as the argument and seacrh the JCL for any */
/* variable equate statements, eg. "varname=". If such an equate is   */
/* found it is assumed it is a user variable. If no equate is found   */
/* a MVS symbolic evaluation is undertaken.  If successfull, the      */
/* new value is returned else the original variable name is returned. */
/* Variable "findtry" is used in case we are not in JCL and get into  */
/* an indefinite loop.                                                */
/*--------------------------------------------------------------------*/
Get_equate: Parse Arg var_v
    Parse VAR var_v '&' xxx '.' var_suf
    sysvar=0
    If xxx='SYSUID' Then Return var_v
    Interpret "If vas_"xxx"/='VAS_"xxx"' Then Return vas_"xxx
    lin@=lin#;col@=0;find=xxx'='
    findtry=0                               /* Stop indefinite loop   */
    Do Forever
        findtry=findtry+1;If findtry>loop_lim Then Do
            yy=var_v
            If Substr(yy,Length(yy))='.' Then yy=Substr(yy,1,Length(yy)-1)
            If Wordpos(yy,missing_var)=0 Then missing_var=missing_var yy
            Say 'Recursive loop limit "'loop_lim'" reached processing:'
            Say '  'Space(yy Substr(text,1,72))
            Say 'Check your source and try again.'
            Leave
        End
        "ISREDIT CURSOR=" lin@ col@
        "ISREDIT SEEK '"find"' PREV"
        If rc/=0 Then "ISREDIT SEEK '"find"'"
        If rc=0 Then Do
            "ISREDIT (liney)=LINE .ZCSR"
            "ISREDIT (lin@,col@)=CURSOR"
            If Verify(#tr,'NO')>0 Then Say lin@+1 Col@+0 Substr(liney,1,70)
            If Substr(liney,1,3)='//*' | Substr(liney,1,2)/='//' Then,
                Do;col@=col@-1;Iterate;End
            If Verify(liney,nat,'M',col@-1)=col@ & expand Then Do
                If \expand Then Return var_v
                Interpret "Parse VAR liney '"find"' liney"
                If Substr(liney,1,1)/="'" Then Do
                    If Substr(liney,1,1)=' ' Then liney=
                    Parse VAR liney val .
                    Parse VAR val val ',' .
                End
                Else val=get_quote_delim(liney)
                If Substr(val,1,1)='&' Then Do
                    Parse VAR val '&' xxx '.' zzz;xxx=Strip(xxx,,"'")
                    var_suf=var_suf||zzz;find=xxx'='
/*                  findtry=0                                         */
                    col@=col@-1;Iterate
                End
                Select
                    When val='DATE()' Then Return $DATEMAN('REV',,2,'D')
                    When val='TIME()' Then Do
                        Parse Value Time() with hh ':' mm ':' ss
                        Return hh||mm||ss
                    End
                    When Substr(val,1,8)='$DATEMAN(' Then Do
                        Parse VAR liney '$DATEMAN(' dmv ')' .
                        Interpret "xx=$DATEMAN("dmv")"
                        If Word(xx,1)/='Error' Then Return xx
                        Else Return val
                    End
                    Otherwise Return val||var_suf
                End
            End
            Else Do;col@=col@-1;Iterate;End
        End
        Leave
    End
Return_Var_val:
    If Verify(xxx,nat,'N')=0 & Length(xxx)<=8 Then val=Mvsvar(Symdef,xxx)
    Else val=
    If val='' Then Return var_v||var_suf
    Else Do;sysvar=1;Return val||var_suf;End

/*--------------------------------------------------------------------*/
/* It has been established that the first character of a value is a   */
/* quote and the value is parsed for a valid SINGLE quote terminator. */
/*--------------------------------------------------------------------*/
get_quote_delim:
    yyy=Substr(Arg(1),2);nq=1
    Do Forever
        nq=Index(yyy,"'",nq)
        If nq=0 Then nq=Length(Strip(yyy))+1
        Else If Substr(yyy,nq+1,1)="'" Then Do
                 nq=nq+2;Iterate
             End
        val=Substr(yyy,1,nq-1)
        yyy=Substr(yyy,nq+1);If yyy='' Then Leave
        Parse VAR yyy . ',' yyy
        Leave
    End
    Return val
$EVALAMP_end:

o_l:"LINE_BEFORE" lin#"=&NOTELINE (linex)"
    If noteline='' Then lin#=lin#+1;Return 0
Mark:If Datatype(Arg(1))/='NUM' Then Arg(1)=1;Return sigl+Arg(1)

/*--------------------------------------------------------------------*/
/* Parse parameters (Expects parameter list in variable "parm#")      */
/*--------------------------------------------------------------------*/
Parse_parms:If Arg(1)='?' Then return
    zedsmsg=
    #tr=parse_cons('TRACE','R','O')
    If #tr='O' Then #tr=parse_cons('/TR','R','O',3)
    simulate=parse_cons('/S',1,0)
    If \simulate Then,
        simulate=parse_cons('/X',1,0)       /* Back compat with '/S'  */
    reset=parse_cons('/E',1,0)
    apply=parse_cons('/A',1,0)
    If \apply Then,
        apply=parse_cons('/R',1,0)          /* Back compat with '/A'  */
    ainsi=parse_cons('/AI',1,0)             /* Apply IN SysIn         */
    subex=parse_cons('/UX',1,0)
    If \subex Then,
        subex=parse_cons('/SX',1,0)         /* Back compat with '/UX' */
    debug=parse_cons('/DE',1,0,3)
    If ainsi Then apply=1
    If apply Then simulate=1
    com_set=parse_cons('/DS',1,0)
    even_com=parse_cons('/EC',1,0)
    s_order=parse_cons('/L','LAST')

    Return 0

$Parms:
err01:
    Address ISPEXEC "SETMSG MSG(ISRZ001)";Exit 8
/*--------------------------------------------------------------------*/
/* Ensure there is a blank line before the "Parse_parms_ver=" line    */
/* (following) for use by the '$PPC' macro parser.                    */
/*--------------------------------------------------------------------*/

Parse_parms_ver='2.01';If Arg(1)='?' Then Return Parse_parms_ver
/*--------------------------------------------------------------------*/
/* Parse variable 'parm#' for a constant 'mask'.                      */
/* Parameters:                                                        */
/*   1. Mask to search for. (May be truncated, refer parameter 4).    */
/*      If the mask is matched, it WILL be removed out of the "parm#" */
/*      variable.                                                     */
/*   2. Positive return value. Value to return if mask found. Default */
/*      is 'Y'.                                                       */
/*   3. Negative return value. Value to return if mask is NOT found.  */
/*      Default is 'N'.                                               */
/*   4. Mask qualifier with one of the following values:              */
/*      - Numeric length of the mask prefix.                          */
/*      - Literal 'W' to return the word that contain that mask (note */
/*        the word does not need to start with mask).                 */
/*      - Literal 'W#' to return the word numb that contain that mask */
/*        (note the word does not need to start with mask).           */
/* Notes:                                                             */
/*   1. For parameters 2 and 3:                                       */
/*      - Set to literal 'NULL' to return null values.                */
/*      - Set to '*' to return the mask as the negative/positive      */
/*        condition.  (Suggest using 'NULL' for the other value.)     */
/*                                                                    */
/*   2. Comma delimit to pad out if prior parameters are not          */
/*      supplied.                                                     */
/*   3. Use command "$RU $PARMS" ($Routine Upgrade) to update with    */
/*      the latest infrastructure copy of $PARMS. Use command         */
/*      "$RU $PARMS ?" to display latest infrastructure version.      */
/*--------------------------------------------------------------------*/
parse_cons: Procedure Expose parm#;Arg mask,posr,negr,maskl
    If posr=''     Then posr='Y' ;If negr=''     Then negr='N'
    If posr='NULL' Then posr=    ;If negr='NULL' Then negr=
    If posr='*'    Then posr=mask;If negr='*'    Then negr=mask
    Select
        When (Substr(maskl,1,1)='W') Then Do
            y#=0;xxx=parm#
            Do i=1 To Words(xxx)
                Parse VAR xxx x_x xxx
                If Index(x_x,mask)>0 Then Do;y#=i;posr=x_x;Leave;End
            End
        End
        When (Datatype(maskl,'W')) Then Do
            y#=0;xxx=parm#
            Do i=1 To Words(xxx)
                Parse VAR xxx x_x xxx
                If Substr(x_x,1,maskl)=Substr(mask,1,maskl) Then Do
                    y#=i;Leave
                End
            End
        End
        Otherwise y#=Wordpos(mask,parm#)
    End
    If y#>0 Then Do
        parm#=Delword(parm#,y#,1);If maskl='W#' Then posr=y#;Return posr
    End
    If maskl='W#' Then Return 0;Else Return negr

/*--------------------------------------------------------------------*/
/* Parse string 'parm#' for a variable 'mask'.                        */
/* Parameters:                                                        */
/*   1. Mask to search for prefixing the word.                        */
/*      If the mask is matched, it WILL be removed out of the "parm#" */
/*      variable.                                                     */
/*   2. Negative return value. Value to return if mask is NOT found.  */
/*      Default is 'N'.                                               */
/*   3. Literal 'NUM' to check for numerics and return negative       */
/*      result if not numeric.                                        */
/* Notes:                                                             */
/*   1. For parameters 2:                                             */
/*      - If the prefix is found, the returned value is the full      */
/*        word less the prefix.                                       */
/*      - NULLs is a valid returned value.                            */
/*      - pass a unique negative result substitution to ensure mask   */
/*        missing (eg.  '?????').                                     */
/*--------------------------------------------------------------------*/
parse_varb: Procedure Expose parm#;Arg mask,negr,dt
    If negr='' Then negr='N'
    parm##=' 'parm#;m#=' 'mask;y#=Index(parm##,m#)
    If y# > 0 Then Do
        If Substr(parm##,y#+Length(m#),1)='' Then Do
            px='';data="Parse VAR parm## p1 '"m#"' p2"
        End
        Else data="Parse VAR parm## p1 '"m#"' px p2"
        Interpret data
        parm#=Strip(p1) Strip(p2)
        If dt='NUM' & Datatype(px)/='NUM' Then Return negr
        Else                                   Return px
    End
    Return negr
Parse_parms_End:
$Parms_End:

/*--------------------------------------------------------------------*/
/* Take a copy of member (with changes) into a temporary file and then*/
/* apply the symbolic substitutions.                                  */
/*--------------------------------------------------------------------*/
copy_and_process:
    "(lev)=MACRO_LEVEL"
    If lev>1 Then Do
        Parse VAR parm# ssfline ',' sstline ',' lcmd parm#
        Address ISPEXEC "VGET (lcmd1stl,lcmd1l#) SHARED"
        If line/=lcmd1stl Then "LINE &lcmd1l#=(lcmd1stl)"
        "(line)=LINE .ZCSR"
    End
/*--------------------------------------------------------------------*/
/* Toggle comments if using as "selectable lines" vs "all lines"      */
/* (block CLL lines 113 to 123).                                      */
/*--------------------------------------------------------------------*/
    Else Do
        "PROCESS RANGE C M";"(cmd) = RANGE_CMD"
        If cmd='C' Then Do
            "(ssfline)=LINENUM .ZFRANGE";"(sstline)=LINENUM .ZLRANGE"
        End
        Else Do
            "(ssfline)=LINENUM 1";"(sstline)=LINENUM .ZLAST"
        End
    End
/*  Else Do;ssfline=1;"(sstline)=LINENUM .ZLAST";End                  */
/*--------------------------------------------------------------------*/
    "(last)=LINENUM .ZLAST";"(dsn)=DATASET";"(memb)=MEMBER"
    ssmember="'"dsn"("Strip(memb)")'"
    Address TSO "NEWSTACK"
    #tr1=Trace('o')
    Do i=1 To last;"(line)=LINE" i;Queue line;End;Queue ''
    x=Trace(#tr1)
    ztempf=$ztempf()
    If Datatype(ztempf,'W') Then Do
        zedlmsg="You have reached the limit ("ztempf") of temporary",
                "dataset of format 'syspref{.userid}.$TEMPnn.TEMP'.",
                "Delete some and try again."
        Address ISPEXEC "SETMSG MSG(ISRZ001)";Exit
    End
    dd='SS'Time('s')
    Address TSO
    "ALLOC F("dd") DSN('"ztempf"') SHR REU"
    "EXECIO * DISKW "dd" (FINIS"
    Address ISPEXEC "LMINIT DATAID(DATAID) DDNAME("dd")"
    ssparm=parm#
    ssmacro='Y';Address ISPEXEC "VPUT ("ssvars") SHARED"
    Address ISPEXEC "EDIT DATAID(&DATAID) MACRO("xcmd")"
    ssmacro=;Address ISPEXEC "VPUT (ssmacro) SHARED"
    Address ISPEXEC "LMFREE DATAID(&DATAID)"
    "FREE F("dd")";x=$ztempf(ztempf,'/D')
    Exit

$cstring:Version='1.04';If Arg(1)='?' Then Return Version
    Parse ARG string,fstrg,tstrg,start,rep,f_n
    Numeric Digits 10
    If tstrg='' & Length(tstrg)=0 Then change=0;Else change=1
    If f_n/='' Then change=1                /* Force change no matter */
    If Datatype(rep)='NUM' & change=0 Then rpos=1;Else rpos=0
    If rep='*' Then rep=9999999999
    If \Datatype(rep,'W') Then rep=1
    If \Datatype(start,'W') Then start=1
    fl=Length(fstrg);tl=Length(tstrg);ct=0
    Do i=1 To rep
        start=Index(string,fstrg,start);r_pos=start;If start=0 Then Leave
        If change Then Do
            string=Delstr(string,start,fl)
            string=Insert(tstrg,string,start-1,tl)
            rep=rep-1;start=start+tl
        End
        Else Do;ct=ct+1;start=start+fl;End
    End
    If rpos Then Return r_pos;Else If change Then Return string;Else Return ct

/*--------------------------ooo000OOOO000ooo--------------------------*/
/* $CSTRING:                                                          */
/* Function to change occurances of a string in a string to another   */
/* string.                                                            */
/*    - or -                                                          */
/* Return the number of occurrances of a string in another string.    */
/*    - or -                                                          */
/* Return the pointer to the nth. occurance of a string within a      */
/* string starting from a particular position (if not found 0)        */
/*                                                                    */
/* Format:                                                            */
/*  $CSTRING(string,fr_string,to_string,start_col,repetition,f_nulls) */
/*                                                                    */
/*     where (positional) parameters are:-                            */
/*       1. string      - Original string                             */
/*       2. fr_string   - Character(string) in original string to     */
/*                        change from.                                */
/*       3. to_string   - New value, character(string). If this       */
/*                        parameter is omitted (NULLS) then a count   */
/*                        of the occurrances of the from_string is    */
/*                        returned. Note, space(s) is NOT 'NULL'.     */
/*       4. start_col   - Starting column. Default is 1.              */
/*       5. Repetition  - Occurances to change. Default is 1. '*'     */
/*                        changes all occurances or acts as a tally   */
/*                        indicator if 'to_string' is missing.        */
/*                      - If the to_string is missing and this value  */
/*                        is numeric, the pointer to the valued       */
/*                        occurance after the start is returned (acts */
/*                        as an Index of occurance command).          */
/*                      - If both the to_string and this value is     */
/*                        missing, it will be set to '*' to make it   */
/*                        act like a 'tally' and return the number of */
/*                        occurances (after the start column).        */
/*       6. f_nulls     - In case to_string is nulls, any non blank   */
/*                        value will indicate that the 'to_string' is */
/*                        literally NULLs and not missing to control  */
/*                        a tally function. Leave this and to_string  */
/*                        as blanks to perform a tally.               */
/*                        eg. tally=$CSTRING(string,find_chars,,,,)   */
/* Use command "$RU $CSTRING" ($Routine Upgrade) to update with the   */
/* latest infrastructure copy of $CSTRING.  Use command               */
/* "$RU $CSTRING ?" to display latest infrastructure version.         */
/*--------------------------------------------------------------------*/
$cstring_End:

slip_in_disclaimer:
    "(lin#)=CURSOR";
    If lin#=0 Then lin#=1
    "(caps)=CAPS";"CAPS=OFF";noteline='NOTELINE'
ms=mark(1)
/*--------------------------------------------------------------------*/
/*  Use macro "SYMSUB /A" on the command line if any of the variables */
/*  are used in SYSIN instream data or used in non standard JCL       */
/*  format. The macro will apply variables to //SYSIN and any other   */
/*  location. (Will also handle recursive substitution.)              */
/*  Enter "SYMSUB ?" on the command line for help.                    */
/*--------------------------------------------------------------------*/
me=mark(-1)
    If Wordpos('/DD',parm#)>0 Then noteline=
    Do i=ms To me
        Parse Value Sourceline(i) With linex '*/';linex='/'linex
        x=o_l(linex)
    End
    "CAPS=(caps)"
    Exit

/*--------------------------------------------------------------------*/
/* Use command "$RU $ZTEMPF" ($Routine Upgrade) to update with the    */
/* latest infrastructure copy of $ZTEMPF.   Use command               */
/* "$RU $ZTEMPF ?" to display latest infrastructure version.          */
/*--------------------------------------------------------------------*/
$ztempf:$ztempf_ver='1.09';If Arg(1)='?' Then Return $ztempf_ver
    Parse Upper Arg p#1,p#2,p#3,p#4;If p#4/='' Then Trace r
    Address TSO;temp_limit=30;If p#1='/F' Then temp_limit=999
    Address ISPEXEC "CONTROL ERRORS RETURN"
    If Wordpos(p#2,'/D D')>0 Then Do
        #msg=Msg('Off')
        "DELETE  '"Strip(p#1,,"'")"'"
        If Wordpos(p#3,'/FT FT')>0 Then "FREE F(ISPFILE)"
        x=Msg(#msg)
        Return 0
    End
    pref=Sysvar(Syspref);userid=Userid()
    If pref/=userid Then Do
        If pref/='' Then pref=pref'.'userid;Else pref=userid
    End
    If p#1='/CLEAR' Then Do
        #msg=Msg('Off')
        Do i=1 To temp_limit
            dsname="'"pref".$TEMP"Right(i,3,'0')".TEMP'"
            If Sysdsn(dsname)='OK' Then "DELETE" dsname
        End
        x=Msg(#msg);Return 0
    End
    If Wordpos('/PO',p#1)>0 Then Do
        po_org=1;p#1=Delword(p#1,Wordpos('/PO',p#1),1)
    End;Else po_org=0
    Do i=1 By 1 Until i>temp_limit
        dsname=pref".$TEMP"Right(i,3,'0')'.TEMP'
        If Sysdsn("'"dsname"'")/='OK' Then Leave
    End
    If i>temp_limit Then Return temp_limit
    Signal on Syntax Name error_off_$ALKUVOL
    unit_vol='UNIT(SYSDA)';unit_vol=$alkuvol('$ZTEMPF')
error_off_$ALKUVOL:Signal off Syntax
    If Wordpos('NAME',p#1)>0 | Wordpos('/N',p#1)>0 Then Nop
    Else Do
        If Wordpos(p#2,'/M M')>0 Then Do
            xx=Listdsi("'"p#1"' DIRECTORY")
            If xx<5 | sysreason=9 | sysreason=25 Then Nop;Else Signal def_file
            If sysdsorg='PO' Then po_org=1;Else po_org=0
            Parse VAR sysrecfm rf1 +1 rf2 +1 rf3
            lrecl=syslrecl;blksize=sysblksize
            pri=sysprimary;sec=sysseconds;typ=sysunits;dir=sysadirblk
            If typ='BLOCK' Then typ='BLOCK('pri')'
        End
        Else Do
def_file:   rf1='F';rf2='B';rf3=
            Address ISREDIT "(lrecl)=LRECL";If rc/=0 Then lrecl=80
            blksize=(6200%lrecl)*lrecl;pri=15;sec=15;typ='TRACKS';dir=5
        End
        rfm=Space(rf1 rf2 rf3)
        If po_org Then,
            "ALLOC DS('"dsname"')" typ "SPACE("pri","sec")",
                "DSORG(PO) DIR("dir")",
                "RECFM("rfm") LRECL("lrecl") BLKSIZE("blksize")",
                unit_vol
        Else,
            "ALLOC DS('"dsname"')" typ "SPACE("pri","sec") DSORG(PS)",
                "RECFM("rfm") LRECL("lrecl") BLKSIZE("blksize")",
                unit_vol
        "FREE DS('"dsname"')"
    End
    If Wordpos(p#3,'/FT FT')>0 Then "ALLOC F(ISPFILE) DS('"dsname"') SHR REU"
    Return dsname
/*--------------------------ooo000OOOO000ooo--------------------------*/
/* $ZTEMPF - Routine to create a temporary file with name of:         */
/*    userid.$TEMPunique-suffix.TEMP - attrib PS FB 80/6160           */
/* (Attrib=FB,lrecl,blksize<6200.)                                    */
/* If "unique-suffix" > 30, you have too many temporary datasets      */
/* hanging around and a ruturn code equal to the limit will be set.   */
/* Numeric dsname indicates error - limit reached, eg.                */
/*  ztempf=$ztempf();If Datatype(ztempf,'W') Then Say ztempf 'used'   */
/* If the dataset has been created it's name will be returned. It is  */
/* the responsibility of the calling program to delete the dataset or */
/* copy it before deleting.                                           */
/* Parameters (positional):                                           */
/* 1st:                                                               */
/*   NAME   - Only the unique "dsname" will be returned without       */
/*            creation. (Useful when you want non standard RECFM and  */
/*            SPACE allocation.)                                      */
/*   /CLEAR - Clear all temp datasets.  Only the first 30 will be     */
/*            cleared, however, all the 30 datasets will be cleared.  */
/*            If "/F" was used to permit allocation of additional     */
/*            datasets, they will have to be manually deleted.        */
/*   /F     - Force past limit of 30. With this no need to check      */
/*            numeric return. Sets a max limit of 999 datasets.       */
/*   /N     - Same as "NAME".                                         */
/*   /PO    - Make a DSORG=PO dataset with 5 dir blocks.              */
/*   blank  - Create a unique dataset and return the dataset name     */
/*            (default).                                              */
/*   dsname - If the second parameter is "/D" or "/M". Must be fully  */
/*            qualified. May or may not be quoted.                    */
/* 2nd:                                                               */
/*   D      - Delete file. (Toggles message status during deletion.)  */
/*   M      - Use dsname (first parameter) as model for new one. If   */
/*            model not found, file is allocated with default values. */
/*   /D     - Same as "D".                                            */
/*   /M     - Same as "M".                                            */
/* 3rd:                                                               */
/*   FT     - Used for File Tailoring. Allocate to ddname ISPFILE.    */
/*            Deallocate if 2nd. parameter is "/D".                   */
/*   /FT    - Same as "FT".                                           */
/* 4th:                                                               */
/*   nb     - Any non-blank value turns trace on.                     */
/*--------------------------------------------------------------------*/
$ztempf_End:
