/******************************** REXX ********************************/
CSDA:csda_ver='1.26'                        /* CSDA version           */
    v1=            ,                        /* Set following in CSDA$ */
    readcsd        ,                        /* Read CSD if available  */
    listdesc       ,                        /* Site list Desc default */
    listdate       ,                        /* Site list changed date */
    datefmt        ,                        /* E(urop), U(SA) J(ulian)*/
    callign        ,                        /* Automatically allign   */
    nrcolor        ,                        /* CSD NoRead color       */
    isort_limit    ,                        /* "Internal"sort limit   */

    Interpret "Parse Value Csda$(v1) With" v1
/*--------------------------ooo000OOOO000ooo--------------------------*/
/*  CSDA: CSD Analyser.                                               */
/*                                                                    */
/*  This macro is designed to analyse the contents of a viewed/edited */
/*  listing of a CSD (not OBJECT as it would be too large).           */
/*                                                                    */
/*  For further details browse the comments at the bottom of this     */
/*  member or invoke with a paremeter of "?".                         */
/*--------------------------------------------------------------------*/
    Parse SOURCE . xenv xcmd xdd xdsn .
    Arg parm#;Address ISPEXEC;"CONTROL ERRORS RETURN";ima_macro=0
    If parm#/='' Then Signal byp1
    "ISREDIT MACRO (parm#) NOPROCESS";If rc=0 Then ima_macro=1

byp1:
/*  "CONTROL ERRORS CANCEL"                                           */

ini1:
    w1=Word(parm#,1);If Wordpos(w1,"? ??")>0 Then Signal help_#1

No_help_#1:
    Address ISREDIT;"(status)=USER_STATE";"SCAN=OFF";"CAPS=OFF"
    "(dataset)=DATASET"

    key_w=;pfield=0;append=0;f_oper.=;f_val.=;m_fields=;cicsv=

    If Wordpos('/T',Translate(parm#))>0 Then Do
        Trace r;parm#=Delword(parm#,Wordpos('/T',Translate(parm#)),1)
    End
    If Wordpos('/#',Translate(parm#))>0 Then Do
        in_error=1;parm#=Delword(parm#,Wordpos('/#',Translate(parm#)),1)
        key_w=key_w '/#'
    End;Else  in_error=0
    If Wordpos('/13',Translate(parm#))>0 Then Do
        cicsv=13;parm#=Delword(parm#,Wordpos('/13',Translate(parm#)),1)
        key_w=key_w '/13'
    End;Else cicsv=21
    If Wordpos('/21',Translate(parm#))>0 Then Do
        cicsv=21;parm#=Delword(parm#,Wordpos('/21',Translate(parm#)),1)
        key_w=key_w '/21'
    End
    If Wordpos('/A',Translate(parm#))>0 Then Do
        append=1;parm#=Delword(parm#,Wordpos('/A',Translate(parm#)),1)
        key_w=key_w '/A'
    End
    If Wordpos('/B',Translate(parm#))>0 Then Do
        batch='Y';parm#=Delword(parm#,Wordpos('/B',Translate(parm#)),1)
        key_w=key_w '/B'
    End;Else batch='N'
    If Wordpos('/BE',Translate(parm#))>0 Then Do
        batch_emulate=1;parm#=Delword(parm#,Wordpos('/BE',Translate(parm#)),1)
        key_w=key_w '/BE'
    End;Else batch_emulate=0
    If Wordpos('/C',Translate(parm#))>0 Then Do
        listdate=1;parm#=Delword(parm#,Wordpos('/C',Translate(parm#)),1)
        key_w=key_w '/C'
    End
    If Wordpos('/CA',Translate(parm#))>0 Then Do
        callign=1;parm#=Delword(parm#,Wordpos('/CA',Translate(parm#)),1)
        key_w=key_w '/CA'
    End
    If Wordpos('/CE',Translate(parm#))>0 Then Do
        listdate=1;parm#=Delword(parm#,Wordpos('/CE',Translate(parm#)),1)
        key_w=key_w '/CE';datefmt='E'
    End
    If Wordpos('/CJ',Translate(parm#))>0 Then Do
        listdate=1;parm#=Delword(parm#,Wordpos('/CJ',Translate(parm#)),1)
        key_w=key_w '/CJ';datefmt='J'
    End
    If Wordpos('/CU',Translate(parm#))>0 Then Do
        listdate=1;parm#=Delword(parm#,Wordpos('/CU',Translate(parm#)),1)
        key_w=key_w '/CU';datefmt='U'
    End
    If Wordpos('/NCA',Translate(parm#))>0 Then Do
        callign=0;parm#=Delword(parm#,Wordpos('/NCA',Translate(parm#)),1)
        key_w=key_w '/NCA'
    End
    If Wordpos('/D',Translate(parm#))>0 Then Do
        listdesc=1;parm#=Delword(parm#,Wordpos('/D',Translate(parm#)),1)
        key_w=key_w '/D'
    End
    If Wordpos('/MG',Translate(parm#))>0 Then Do
        multigp=1;parm#=Delword(parm#,Wordpos('/MG',Translate(parm#)),1)
        key_w=key_w '/MG'
    End;Else multigp=0
    If Wordpos('/NC',Translate(parm#))>0 Then Do
        listdate=0;parm#=Delword(parm#,Wordpos('/NC',Translate(parm#)),1)
        key_w=key_w '/NC'
    End
    If Wordpos('/ND',Translate(parm#))>0 Then Do
        listdesc=0;parm#=Delword(parm#,Wordpos('/ND',Translate(parm#)),1)
        key_w=key_w '/ND'
    End
    If Wordpos('/NF',Translate(parm#))>0 Then Do
        no_flds=1;parm#=Delword(parm#,Wordpos('/NF',Translate(parm#)),1)
        key_w=key_w '/NF'
    End;Else no_flds=0
    If Wordpos('/NS',Translate(parm#))>0 Then Do
        sep_it=0;parm#=Delword(parm#,Wordpos('/NS',Translate(parm#)),1)
        key_w=key_w '/NS'
    End;Else sep_it=1
    If Wordpos('/O',Translate(parm#))>0 Then Do
        batch='O';parm#=Delword(parm#,Wordpos('/O',Translate(parm#)),1)
        key_w=key_w '/O'
    End
    If Wordpos('/TS',Translate(parm#))>0 Then Do
        time_s=1;parm#=Delword(parm#,Wordpos('/TS',Translate(parm#)),1)
        key_w=key_w '/TS'
    End;Else time_s=0
    If Wordpos('/XT',Translate(parm#))>0 Then Do
        xontally=1;parm#=Delword(parm#,Wordpos('/XT',Translate(parm#)),1)
        key_w=key_w '/XT'
    End;Else xontally=0
    If Index(Translate(' 'parm#),' /CSD(')>0 Then Do
        Parse Value Translate(parm#) With p1 '/CSD(' dsnvsam ')' p2
        If dsnvsam/='' Then Do
            parm#=Space(p1 p2);key_w=key_w '/CSD('dsnvsam')'
        End
    End;Else dsnvsam=
    If Wordpos('/CSDC',Translate(parm#))>0 Then Do
        parm#=Delword(parm#,Wordpos('/CSDC',Translate(parm#)),1)
        If Wordpos('/M',Translate(parm#))>0 Then csdc_funct='/M'
        Else csdc_funct='/MA'
        If Wordpos('/NJ',Translate(parm#))>0 Then CSDC_jcl='/NJ'
        Else CSDC_jcl=
        x_CSDC=1
        Signal Extract_CSD
    End;Else x_CSDC=0
#tr=Trace('o')
/*--------------------------------------------------------------------*/
/* After 'no_flds' set as uses it.                                    */
/*--------------------------------------------------------------------*/
    If \no_flds & Index(Translate(' 'parm#),' /MF(')>0 Then Do
        Parse VAR parm# p1 '/MF(' m_fields ')' p2
        If m_fields='' Then Parse VAR parm# p1 '/Mf(' m_fields ')' p2
        If m_fields='' Then Parse VAR parm# p1 '/mF(' m_fields ')' p2
        If m_fields='' Then Parse VAR parm# p1 '/mf(' m_fields ')' p2
        If m_fields='' Then Parse VAR parm# p1 '/mf(' m_fields ')' p2
        If m_fields/='' Then Do
            m_fields=Translate(m_fields,' ',',')
            parm#=Space(p1 p2);key_w=key_w '/MF('Space(m_fields,,',')')'
            m_fields=Translate(m_fields);pfield=1
            Parse_m_fields()
        End
    End;Else m_fields=
    If \no_flds & Index(Translate(' 'parm#),' /OF(')>0 Then Do
        Parse VAR parm# p1 '/OF(' o_fields ')' p2
        If o_fields='' Then Parse VAR parm# p1 '/Of(' o_fields ')' p2
        If o_fields='' Then Parse VAR parm# p1 '/oF(' o_fields ')' p2
        If o_fields='' Then Parse VAR parm# p1 '/of(' o_fields ')' p2
        If o_fields='' Then Parse VAR parm# p1 '/of(' o_fields ')' p2
        If o_fields/='' Then Do
            o_fields=Translate(o_fields,' ',',')
            parm#=Space(p1 p2);key_w=key_w '/OF('Space(o_fields,,',')')'
            o_fields=Translate(o_fields);pfield=1
        End
    End;Else o_fields=
    If \no_flds & o_fields='' & Index(Translate(' 'parm#),' /SF(')>0 Then Do
        Parse VAR parm# p1 '/SF(' s_fields ')' p2
        If s_fields='' Then Parse VAR parm# p1 '/Sf(' s_fields ')' p2
        If s_fields='' Then Parse VAR parm# p1 '/sF(' s_fields ')' p2
        If s_fields='' Then Parse VAR parm# p1 '/sf(' s_fields ')' p2
        If s_fields='' Then Parse VAR parm# p1 '/sf(' s_fields ')' p2
        If s_fields/='' Then Do
            s_fields=Translate(s_fields,' ',',')
            parm#=Space(p1 p2);key_w=key_w '/SF('Space(s_fields,,',')')'
            s_fields=Translate(s_fields);pfield=1
        End
    End;Else s_fields=
    If Index(Translate(' 'parm#),' /UF(')>0 Then Do
        Parse VAR parm# p1 '/UF(' u_fields ')' p2
        If u_fields='' Then Parse VAR parm# p1 '/Uf(' u_fields ')' p2
        If u_fields='' Then Parse VAR parm# p1 '/uF(' u_fields ')' p2
        If u_fields='' Then Parse VAR parm# p1 '/uf(' u_fields ')' p2
        If u_fields='' Then Parse VAR parm# p1 '/uf(' u_fields ')' p2
        If u_fields/='' Then Do
            u_fields=Translate(u_fields,' ',',')
            parm#=Space(p1 p2);key_w=key_w '/UF('Space(u_fields,,',')')'
            u_fields=Translate(u_fields);pfield=1
        End
    End;Else u_fields=
/*--------------------------------------------------------------------*/
/* Leave this setting last.                                           */
/*--------------------------------------------------------------------*/
    If Wordpos('/NR',Translate(parm#))>0 Then Do
        readCSD=0;parm#=Delword(parm#,Wordpos('/NR',Translate(parm#)),1)
        key_w=key_w '/NR'
    End
/*--------------------------------------------------------------------*/
/* Parse remaining positional parameters for type and item (and any   */
/* global prefixes and suffixed, eg. *(....)*                         */
/*--------------------------------------------------------------------*/
    lsl=$Cstring(parm#,'(',,1,'*')
    If lsl=0 Then Do;findt=parm#;ifind=;End
    Else Do
        If lsl=1 Then Parse VAR parm# findt '(' ifind ')'
        Else Do
            Parse VAR parm# findt '(' p1 '(' ifind ')' p2 ')'
            ifind=p1'('ifind')'p2
        End
    End
/*--------------------------------------------------------------------*/
x=Trace(#tr)                                /* Restore trace setting  */
    If ifind='' Then Parse VAR findt findt ifind
    If ifind='' Then Do;ifind=findt;findt='TRANS';End
    Parse Upper VAR findt findt

    first_time=1;#popr=6;#popc=12;vsamopen=0;#ft=;findtype=
Extract_CSD:
    csdid='CSD file:';inval='????'

    If dsnvsam='' Then Do
        "F '"csdid"' FIRST"; If rc=0 Then Do
            "(line)=LINE .ZCSR"
            Interpret "Parse VAR line '"csdid"' dsnvsam ."
            dsnvsam=Strip(dsnvsam);dsnvsam=Strip(dsnvsam,,".")
            dsnvsam=Strip(dsnvsam,,"'")
        End;Else dsnvsam=
    End

    If x_CSDC Then Signal Call_CSDC

    validtypes=,
               ' 1 CONnections     01F4',
               ' 2 CORbaservers    0226',
               ' 3 DB2Conns        1B58',
               ' 4 DB2Entries      1D4C',
               ' 5 DB2Trans        1EDC',
               ' 6 DJars           0258',
               ' 7 DOctemplates    238C',
               ' 8 Enqmodels       157C',
               ' 9 Files           0320',
               '10 Groups          0006',
               '11 Journalmodels   0384',
               '12 Lsrpools        028A',
               '13 MapSets         03E8',
               '14 PARTItionsets   07D0',
               '15 PARTNers        09C4',
               '16 PROCesstypes    2134',
               '17 PROFiles        0BB8',
               '18 PROGrams        0FA0',
               '19 Requestmodels   2328',
               '20 Sessions        10ED',
               '21 TCpipservices   23F0',
               '22 TDqueues        1770',
               '23 TErminals       123A',
               '24 TRANClasses     1318',
               '25 TRANSactions    1388',
               '26 TSmodels        1F40',
               '27 TYpeterms       11CB',
               ''
    desc_id="Desc"

    csr1=
    If findt/='' Then Do
        ch1=Substr(findt,1,1);ptr=1
        Do Forever
            ptr=Index(validtypes,' 'ch1,ptr);If ptr=0 Then Leave
            xx=$wordat(validtypes,ptr+1)
            yy=Verify(xx,'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789','N')
            pref=Substr(xx,1,yy-1)
            If Index(' 'findt,' 'pref)>0 Then Do;findtype=xx;Leave;End
            ptr=ptr+1
        End
    End
    msgx=
    If findtype='' Then Do
        msgx='Invalid ''itemtype'' "'findt'" entered. Format is',
             '"itemtype(item)" - Where itemtype must be in list:',
             Space(Translate(validtypes,'/',','))'.'
        in_error=1;csr1='CD'
    End;Else cd=Word(validtypes,Wordpos(findtype,validtypes)-1)

    descflds=Csda$('descflds')
    no_wild=Csda$('no_wild')
    csda$_ver=Csda$('csda$_ver')
get_itemflds:
    Address ISPEXEC "VPUT (cicsv) SHARED"
    itemflds=Csda$('itemflds')
/*--------------------------------------------------------------------*/
    ispf=Sysvar(Sysispf);If batch_emulate Then ispf='BATCH'
    If ispf/='ACTIVE' Then Do
        ft=findtype;findtype=Translate(findtype)
        If #ft/=ft Then Call eXpose_fields
        Signal Bypassed_for_batch
    End
/*--------------------------------------------------------------------*/
scr1:
    Address ISPEXEC
/*--------------------------------------------------------------------*/
    If ispf/='ACTIVE' Then Do
        Say 'Error detected:';Say '  'zedlmsg
        Say ' ';Say 'Processing terminated.';Say ' '
        Exit
    End
/*--------------------------------------------------------------------*/
    If ifind='' | findtype='' | in_error Then Do
        If first_time Then Call x_first_time
        zcmd=;zedsmsg=;zedlmsg=
        If o_fields/='' Then,
            zedlmsg='Subset of fields selected for reporting is:',
                    '"'Space(o_fields,,',')'".'
        Else If s_fields/='' Then,
            zedlmsg='The following fields will be suppressed:',
                    '"'Space(s_fields,,',')'".'
        If m_fields/='' Then,
            zedlmsg=zedlmsg 'The following fields have conditions:',
                    '"'Space(m_fields,,',')'".'
        zedlmsg=Space(zedlmsg msgx);If zedlmsg/='' Then "SETMSG MSG(ISRZ001)"
        zwinttl='CSD Analyser';typ#='INPUT'
        "ADDPOP ROW(&#POPR) COLUMN(&#POPC)"
        "DISPLAY PANEL("xcmd"P) CURSOR(&CSR1)";rc1=rc;"REMPOP";csr1=
        If rc1/=0 | Substr(zcmd,1,3)='CAN' Then Do
            zedlmsg='Parameter entry screen abandoned.'
            "SETMSG MSG(ISRZ001)"
            Signal exi2
        End
        msgx=
        If zcmd='?' | ifind='?' Then Do
            Signal on Syntax Name error_on_00
            Interpret 'x=$BR('xcmd' "??")';Signal error_off_00
error_on_00: Address TSO xcmd "??"
error_off_00:Signal off Syntax
            If ifind='?' Then ifind=;Signal scr1
        End
        If Index(zcmd,'/')>0 Then Do
            If Wordpos('/13',Translate(zcmd))>0 Then Do
                cicsv=13;If Wordpos('/13',key_w)=0 Then key_w=key_w '/13'
            End
            If Wordpos('/21',Translate(zcmd))>0 Then Do
                cicsv=21;If Wordpos('/21',key_w)=0 Then key_w=key_w '/21'
            End
            If Wordpos('/A',Translate(zcmd))>0 Then Do
                append=1;If Wordpos('/A',key_w)=0 Then key_w=key_w '/A'
            End
            If Wordpos('/B',Translate(zcmd))>0 Then Do
                batch='Y';If Wordpos('/B',key_w)=0 Then key_w=key_w '/B'
            End
            If Wordpos('/C',Translate(zcmd))>0 Then Do
                listdate=1;If Wordpos('/C',key_w)=0 Then key_w=key_w '/C'
            End
            If Wordpos('/CE',Translate(zcmd))>0 Then Do
                listdate=1;If Wordpos('/CE',key_w)=0 Then key_w=key_w '/CE'
                datefmt='E'
            End
            If Wordpos('/CJ',Translate(zcmd))>0 Then Do
                listdate=1;If Wordpos('/CJ',key_w)=0 Then key_w=key_w '/CJ'
                datefmt='J'
            End
            If Wordpos('/CU',Translate(zcmd))>0 Then Do
                listdate=1;If Wordpos('/CU',key_w)=0 Then key_w=key_w '/CU'
                datefmt='U'
            End
            If Wordpos('/O',Translate(zcmd))>0 Then Do
                batch='O';If Wordpos('/O',key_w)=0 Then key_w=key_w '/O'
            End
            If Wordpos('/NC',Translate(zcmd))>0 Then Do
                listdate=0;If Wordpos('/NC',key_w)=0 Then key_w=key_w '/NC'
            End
            If Wordpos('/NR',Translate(zcmd))>0 Then Do
                readCSD=0;If Wordpos('/NR',key_w)=0 Then key_w=key_w '/NR'
            End
            If Wordpos('/NS',Translate(zcmd))>0 Then Do
                sep_it=0;If Wordpos('/NS',key_w)=0 Then key_w=key_w '/NS'
            End
            If Wordpos('/TS',Translate(zcmd))>0 Then Do
                time_s=1;If Wordpos('/TS',key_w)=0 Then key_w=key_w '/TS'
                key_w=key_w '/TS'
            End
            If Wordpos('/XT',Translate(zcmd))>0 Then Do
                xontally=1;If Wordpos('/XT',key_w)=0 Then key_w=key_w '/XT'
            End
            zedlmsg='Switch change processed.'
            "SETMSG MSG(ISRZ001";in_error=1
            Signal scr1
        End
        If csr='DYNAV' Then ptr=csp;Else ptr=Index(dynav,' 'cd+0)
        ptr=ptr%(ent_len+1)+1;findtype=Word(dynav,ptr*2);cd=Word(dynav,ptr*2-1)
    End
    ft=findtype;findtype=Translate(findtype)

    If #ft/=ft Then Call eXpose_fields

    If o_fields='?' Then Do
        x=nl('Valid field names for "'ft'" are:')
        x=Output(xf,'  Fields(','NoSort')
        Signal exi2
    End
    If o_fields='*' Then o_fields=@xf
    Else If o_fields/='' Then o_fields=ver_fields(o_fields)
    If s_fields='*' Then s_fields=@xf
    Else If s_fields/='' Then s_fields=ver_fields(s_fields)
    If m_fields='*' Then m_fields=@xf
    Else If m_fields/='' Then m_fields=ver_fields(m_fields)
/*--------------------------------------------------------------------*/
/* Field selection screen built from the fields per item.             */
/*--------------------------------------------------------------------*/
    If pfield Then Do
        If first_time Then Call x_first_time
        If  s_fields='' & o_fields='' & m_fields/='' Then o_fields=xf
        #dynav=dynav;#shadv=shadv;xf=@xf;#xf=xf
scr2:
        dynav='¬¬¬'Space(xf,3,'¬')
        If  s_fields/='' Then Do
            ofU=Translate(s_fields);ol1='Y';ol2=' '
        End
        Else Do
            ofU=Translate(o_fields);ol1=' ';ol2='Y'
        End
        dynav=$Cstring(dynav,'¬¬¬','¬'ol1'{',,'*');dynavU=Translate(dynav)
        Do While ofU/=''
            Parse VAR ofU xxx ofU
            xx=Index(dynavU,'{'xxx)
            If xx>0 Then dynav=Overlay(ol2,dynav,xx-1)
        End
        If m_fields/='' Then Do
            ofU=Translate(m_fields)
            Do While ofU/=''
                Parse VAR ofU xxx ofU;Parse Upper VAR xxx uxx
/*
                col#=Verify(xxx,'<>=/','M')
                If col#>0 Then Do
                    Interpret "Parse VAR xxx xxx +"col#-1 "oper +1 val"
                    If oper='/' Then Do;oper='/=';val=Substr(val,2);End
                    Parse Upper VAR xxx uxx
                    f_oper.uxx=oper;f_val.uxx=val
                End
*/
                If f_oper.uxx='' Then ol2='=';Else ol2=f_oper.uxx
                xx=Index(dynavU,'{'xxx)
                If xx>0 Then dynav=Overlay(ol2,dynav,xx-1)
            End
        End
        shadv=;pfield=0;in_error=1;zcmd=
        dynav=Substr(' ',1,57)dynav
        zedlmsg='Enter any non blank against the fields you want',
                'reported. Enter "ALL" on the command line to select',
                'all or "NONE" to unselect all. Enter "SORT" to sort',
                'field names alphabetically.'
        "SETMSG MSG(ISRZ001"
        zwinttl=ft'- Field selection'
        "ADDPOP ROW(&#POPR) COLUMN(&#POPC)";typ#='OUTPUT'
        "DISPLAY PANEL("xcmd"P) CURSOR(DYNAV) CSRPOS(59)";rc1=rc;"REMPOP";csr1=
        If rc1=0 Then Do
            If zcmd='ALL' Then Do
                m_fields=;o_fields=Translate(@xf);Signal scr2
            End
            If zcmd='NONE' Then Do
                o_fields=;Signal scr2
            End
            If zcmd='SORT' Then Do
                xf=$sort(xf);Signal scr2
            End
            o_fields=;dynav=Substr(strip(dynav),2)'¬'
            $dynav='¬'Substr(dynav,1,Length(dynav)-1)
            $dynav=Substr($dynav,1,((Length($dynav)%57)+1)*57)
            $dynav=Substr(' ',1,57)$dynav||Substr(' ',1,57);$dl=Length($dynav)
            bm_fields=
            Do While dynav/=''
                Parse VAR dynav sel '{' fname '¬' dynav
scr3:
                If sel/='' Then Do
/*--------------------------------------------------------------------*/
/* Evaluate what action to take if the selection is not space.        */
/*--------------------------------------------------------------------*/
                    If Wordpos(sel,'> < = /')>0 Then Do
                        @dynav=dynav;If sel='/' Then sel='/='
                        Parse Upper VAR fname uname
                        val=f_val.uname;f_oper.uname=sel
                        zedlmsg='Enter "'sel'" value to process against',
                                "'"fname"'."
                        dynav=$dynav'}'fname'¬'Substr(val,1,55)'{'
                        cp=Lastpos('¬',dynav)+1
                        "SETMSG MSG(ISRZ001"
                        zwinttl=ft'- Field match entry'
                        "ADDPOP ROW(&#POPR) COLUMN(&#POPC)";typ#='OUTPUT'
                        "DISPLAY PANEL("xcmd"P) CURSOR(DYNAV) CSRPOS(&CP)"
                        rc1=rc;"REMPOP"
                        If rc1/=0 Then Do
                            If Wordpos(fname,m_fields)>0 Then m_fields=,
                                delword(m_fields,Wordpos(fname,m_fields),1)
                            f_val.uname=;f_oper.uname=
                            dynav=@dynav;Iterate
                        End
                        Interpret "Parse VAR dynav" $dl "'¬' val '{'"
                        f_val.uname=Space(val)
                        If Index(m_fields,fname)=0 Then,
                            m_fields=m_fields fname
                        If Index(' 'bm_fields,' 'fname)=0 Then,
                            bm_fields=bm_fields fname||sel||Space(val,0)
                        dynav=@dynav;shadv=@shadv
                    End
                    Else If Wordpos(fname,m_fields)>0 Then m_fields=,
                            Delword(m_fields,Wordpos(fname,m_fields),1)
                    o_fields=o_fields fname
                End
/*--------------------------------------------------------------------*/
            End
            o_fields=Translate(Space(o_fields))
            If o_fields='' Then no_flds=1;Else no_flds=0
        End
        pfield=0;dynav=#dynav;shadv=#shadv;xf=#xf;in_error=1
        Signal scr1
    End
/*--------------------------------------------------------------------*/
    If batch='Y' Then Signal set_up_for_batch
/*--------------------------------------------------------------------*/
Bypassed_for_batch:
    in_error=0
    Signal on Syntax Name error_on_05
    If \readCSD Then no_flds=1
    If dsnvsam='' | no_flds Then Signal error_on_05
    dsnvsam=Strip(dsnvsam,,"'")
    xx=Listdsi("'"dsnvsam"'")
    If xx<5 | sysreason=9 | sysreason=25 Then Nop
    Else Signal error_on_05
    If sysdsorg/='VS' Then Do
        Signal off Syntax
        msgx="NOTE:- Dataset is not a VSAM dataset."
        in_error=1;Signal scr1
    End
    Address TSO "EXECIOVS * KSDSLL '"dsnvsam"' (LOG)"
    Parse Pull arecl mrecl
    If arecl/=200 & CICSV=21 Then Do
        Signal off Syntax
        msgx="NOTE:- CSD is pre TS2.1 and version has been set to 1.3."
        in_error=1;cicsv=13;#ft=;Signal get_itemflds
    End
    try2open=CSDR('T',dd,dsnvsam)
    Signal error_off_05
error_on_05: try2open=0;listdesc=0
error_off_05:Signal off Syntax
    Address ISREDIT
    #tr=Trace('o')
/*--------------------------------------------------------------------*/
/* Expand multi entities with global prefix suffix if present         */
/*--------------------------------------------------------------------*/
    Parse VAR ifind p1 '(' xxx ')' p2
    If xxx/='' Then Do
        ifind=;xxx=Translate(xxx,' ',',')
        Do While xxx/=''
            Parse VAR xxx xx xxx
            ifind=ifind p1||xx||p2
        End
        ifind=Space(ifind,,',')
    End
/*--------------------------------------------------------------------*/
    find=ifind;hit1=0;off=0
    If Wordpos('*',Translate(find,' ',','))>0 & batch/='O' &,
       Wordpos(findtype,no_wild)>0 Then Do
        zedlmsg='At least one componponent of "'ifind'" is ''*'' which',
                'may take an unsurmountable time to process and',
                'therefore not permitted for the following blacklisted',
                'items "'Space(no_wild,,',')'".',
                'Batch processing has been enforced.'
        Address ISPEXEC "SETMSG MSG(ISRZ001)";in_error=1;csr1='IFIND'
        batch='Y'
        Signal scr1
    End
    If Substr(find,1,1)='*' Then find=Substr(find,2)
    Else Do;find=' 'find;off=1;End
    ll=Length(find)
    If Strip(find)/='' Then Do
        If Substr(find,ll,1)='*' Then find=Substr(find,1,ll-1);Else find=find' '
    End
/*
    If Strip(find)='' Then Do
        zedlmsg='Invalid ''item'' "'ifind'" entered. Item translates',
                'to "'find'" which is not permitted.'
        Address ISPEXEC "SETMSG MSG(ISRZ001)";in_error=1;csr1='IFIND'
        Signal scr1
    End
*/

    Address ISREDIT
    If \append Then "RESET"
    xx=Date('e')
/*--------------------------------------------------------------------*/
/* If date changed is to be listed, determine if DATEMAN is available */
/* once.                                                              */
/*--------------------------------------------------------------------*/
    If listdate Then Do
        dm_avail=0
        Signal on Syntax Name error_on_DATEMAN
        If datefmt='U' Then xx=Dateman('VUR');Else xx=Dateman('VER')
        dm_avail=1
        Select
            When datefmt='E' Then dm_opt='J2E'
            When datefmt='U' Then dm_opt='J2U'
            Otherwise dm_avail=0
        End
    End
error_on_DATEMAN:Signal off Syntax
/*--------------------------------------------------------------------*/
    x='Start..'Time() '('xx')  '
    y='[ Vers -' xcmd':'csda_ver',' xcmd'$:'csda$_ver '].'
    x=nl(x y);x=nl(' ');x=Time('r')
    "F 'GROUP NAME: ' FIRST"
    If rc/=0 Then Do
        zedlmsg='Cannot find "GROUP NAME:". Is this a valid CSD listing?'
        Address ISPEXEC "SETMSG MSG(ISRZ001)"
        Signal exi1
    End
    "(#lin#)=LINENUM .ZCSR";"(lrecl)=LRECL"
    "F '************************************************' LAST"
    "LABEL .ZCSR=.BLINE"
    findt=Substr($U2lower(findtype),1,Length(findtype))
    If findtype='GROUPS' Then Do
        "F 'GROUP NAMES:' FIRST";"(lin#)=LINENUM .ZCSR"
        linex=
        Do Forever
            "(line)=LINE" lin#
            If Index(line,'***********')>1 Then Leave
            linex=linex line;lin#=lin#+1
        End
        linex=Space(Subword(linex,3))
        groups=;ptr=1
        Parse UPPER VAR find find
        Do Forever
            ptr=Index(linex,find,ptr);If ptr=0 Then Leave
            group=$Wordat(linex,ptr)
            If Wordpos(group,groups)=0 Then groups=groups group
            ptr=ptr+1
        End
        hits=groups;X=output_stats#01()
        If groups='' Then Do
             x=nl('** None Found **')
             x=nl(' ')
             x=nl('**** Used in lists **')
             groups=find
        End
        Else x=nl(' ')
        If groups/='' Then hit1=1
        If Words(groups)>1 Then groups=Output(groups,findt'(')
        x=nl(' ')
        Do While groups/=''
            Parse VAR groups group groups
            lists=find_list(group)
            xx=Substr('  Group('group')',1,18)'- Lists('
            x=Output(lists,xx)
        End
        Signal Get_out
    End
    lin#=#lin#;col#=0;hits=
    afind=Translate(ifind,' ',',')
    Do While afind/=''
        Parse Var afind find afind;ofind=find
        If Index(find,'*')=0 Then find=' 'find' '
        Else Do
            off=0
            If Substr(find,1,1)='*' Then find=Substr(find,2)
            Else Do;find=' 'find;off=1;End
            ll=Length(find)
            If Strip(find)/='' Then Do
                If Substr(find,ll,1)='*' Then find=Substr(find,1,ll-1)
                Else find=find' '
            End
        End
        x=find_wild_item(find,findtype)
    End
    X=output_stats#01()
    x=nl(' ')
    If u_fields/='' Then Do
        x=nl('Unavailable_fields:')
        x=nl('  'Space(u_fields,,','))
        x=nl(' ')
    End
    If gs_fields/='' Then Do
        x=nl('Global_suppressed_fields:')
        x=nl('  'Space(gs_fields,,','))
        x=nl(' ')
    End
    If m_fields/='' Then Do
        x=nl('Match_fields_on:')
        xxx=m_fields
        Do While xxx/=''
            Parse VAR xxx xx xxx;Parse Upper VAR xx ux
            x=nl('  'Substr(xx,1,8) Substr(f_oper.ux,1,2) f_val.ux)
        End
        x=nl(' ')
    End
    If hits/='' Then hit1=1
    If Words(hits)>1 Then Do
          If time_s Then Do
              x_x=Time('s');x=nl('...... Sort start:' Time())
              x=nl(' ')
          End
      hits=Output(hits,findt'(')            /* Lists items found      */
          If time_s Then Do
              y_y=Time('s');x=nl('...... Sort End:  ' Time() '('y_y-x_x'secs)')
              x=nl(' ')
          End
    End
    If xontally Then Signal exi1
    findt=Substr(ft,1,Length(ft)-1)
    wx=Word(itemflds,Wordpos(findtype,itemflds)+1);wx=TRanslate(wx,' ','_')
    If listdesc Then Do
        wd=Word(descflds,Wordpos(findtype,descflds)+1);wd=TRanslate(wd,' ','_')
        wx=wx wd
    End

    If o_fields/='' Then Do
        yyy=;Parse Upper VAR @xf u@xf;Parse Upper VAR o_fields o_fields
        Do While o_fields/=''
            Parse VAR o_fields xx o_fields
            yy=Wordpos(xx,u@xf);If yy>0 Then yyy=yyy Word(@xf,yy)
        End
        xf=Space(yyy)
    End;Else xf=@xf
    m_finds=
    x=nl(' ');If sep_it Then x=nl(Copies('_',72))
    Do While hits/=''
        Parse var hits find hits
        lin#=#lin#;col#=0;groups=
        x=find_groups(find,findtype)
        If multigp Then,
            If Words(groups)=1 Then Iterate
        m_finds=m_finds find
        groups=Space(groups,1,',')
        x=Output(groups,findt'('find') > Groups(')
        If sep_it Then Do;x=nl(' ');s_sep='-';s_pad='  ';End
        Do While groups/=''
            Parse VAR groups group ',' groups
            hd1=Substr('  Group('group')',1,18)
            lists=find_list(group)
            If lists='' Then xx=hd1'- Lists (';Else xx=hd1'+ Lists ('
            x=Output(lists,xx);hd1=Substr(' ',1,18)
            If \no_flds Then,
                If Wordpos(findtype,itemflds)>0 Then xx=Get_CSD_Data()
            If sep_it Then Do
                If groups='' Then Do;s_sep='=';s_pad=;End
                x=nl(s_pad||Copies(s_sep,72))
            End
        End
    End
    If multigp Then Do
        x=nl(' ')
        x=nl('Multi_groups: The following' Words(m_finds) 'items found',
             'in >1 groups.')
        x=Output(m_finds,'  'findt'(')
    End

Get_out:
    If \hit1 Then x=nl('** None Found **')
    x=nl(' ');x=nl(Centre('- *** -',72));x=nl(' ')
exi1:
    x=nl('End...'Time() '('Time('r')' secs)');x=nl(' ')
exi2:
    If vsamopen Then vsamopen=CSDR('f',dd)
    If \first_time Then Do
        #msg=Msg('Off')
        Address ISPEXEC "LIBDEF ISPPLIB";Address TSO "DELETE '"csdadsn"'"
        x=Msg(#msg)
    End
    "ISREDIT USER_STATE=(status)"
    If ispf/='ACTIVE' Then "ISREDIT CANCEL"
    Exit

/*--------------------------------------------------------------------*/
/* Verify fields.                                                     */
/*--------------------------------------------------------------------*/
ver_fields: Arg ifld
    vfld=TRanslate(@xf);rfld=
    Do While ifld/=''
        Parse VAR ifld xx ifld
        If Wordpos(xx,vfld)>0 Then rfld=rfld Word(@xf,Wordpos(xx,vfld))
    End
    Return rfld

/*--------------------------------------------------------------------*/
/* Parse match fields parameter to it's seperate components           */
/*--------------------------------------------------------------------*/
Parse_m_fields:
    yyy=m_fields;m_fields=
    Do While yyy/=''
        Parse VAR yyy xxx yyy
        col#=Verify(xxx,'<>=/','M')
        Interpret "Parse VAR xxx xxx +"col#-1 "oper +1 val"
        If oper='/' Then Do;oper='/=';val=Substr(val,2);End
        Parse Upper VAR xxx uxx
        f_oper.uxx=oper;f_val.uxx=val;m_fields=m_fields xxx
    End
    Return 0

/*--------------------------------------------------------------------*/
/* Determine eXpose Fields (fields to be reported)                    */
/*--------------------------------------------------------------------*/
eXpose_fields:
    xxx=SubWord(itemflds,Wordpos(findtype,itemflds)+1,1);xf=;u_fields=
    gs_fields=
    Do While xxx/=''
        Parse VAR xxx fname '_' . '_' report '_' xxx
        Parse VAR report report1 '/' report2
        If report1='N' & report2/='' Then Do
            u_fields=u_fields fname
            Iterate
        End
        If report1='N' | report2='N' Then Do
            gs_fields=gs_fields fname
            Iterate
        End
        xf=xf fname
    End
    xf=Space(xf desc_id);@xf=xf;#ft=ft
    Return 0

/*--------------------------------------------------------------------*/
/* If CSD available, get extra information for items as per contents  */
/* of variable "itemflds".                                            */
/*--------------------------------------------------------------------*/
Get_CSD_Data:
    If try2open Then Do
        try2open=0;dd='VS'Time('s')
        If \vsamopen Then vsamopen=CSDR('o',dd,dsnvsam);Address TSO "DELSTACK"
    End
    If vsamopen Then Do
        xx=Wordpos(findtype,Translate(validtypes))
        hexoff=Word(validtypes,xx+1)
        key=Substr(group,1,8)||x2c(right(hexoff,12,'0'))||Substr(find,1,8)
        vrc=CSDR('R',dd,key)
        If vrc=12 Then Do
            vsamopen=0;Parse PULL line
            x=nl(' ');x=nl('*'Copies('-',70)'*')
            p1=$wordat(line,69,'L');p2=$wordat(line,69,'T')
            x=nl(Substr('* CSD process error:',1,71)'*')
            x=nl('*'Copies(' ',70)'*')
            x=nl(Substr('* 'p1,1,71)'*')
            x=nl(Substr('*         'p2,1,71)'*')
            x=nl('*'Copies(' ',70)'*')
            x='* This may be due to environmental/site conflicts.'
            x=nl(Substr(x,1,71)'*')
            x=nl('*'Copies('-',70)'*');x=nl(' ')
        End
    End;Else vrc=12
    If vrc=0 Then Do
        Parse PULL line;ll=Length(line)
        i_tm=Strip(Substr(key,15,8));ps=Index(line,i_tm,Length(key)+1)-2
        Parse VAR line 25 cdate +8
    End;Else cdate=inval
    Address TSO "DELSTACK"

    oval=;odesc=;#wx=wx
/*--------------------------------------------------------------------*/
/* Parse the CSD record                                               */
/*--------------------------------------------------------------------*/
    If vrc=8 Then Do
        oval='** Not found in group (may be mistaken case?) **;'
        Signal End_field_process
    End
    Do While #wx/=''
        Parse VAR #wx w1 w2 '/' ml rit #wx
        If Wordpos(w1,xf)=0 Then Iterate
        Parse Var ml ml '(' d_val ')'
        Parse VAR ml ml 'X' xl;Parse VAR ml ml 'R' rl;Parse VAR ml ml 'D' dl
        Parse VAR ml ml 'N' nl;Parse VAR ml ml '*' al
        pp=ps;val=
        If vrc=0 & pp>0 Then Do
            If Index(w2,':')>0 Then Do
                Parse VAR w2 col ':' il '(' matrix ')'
                val=Substr(line,col,il)
                Interpret "Parse VAR matrix '"val"=' val ','"
            End
            Else Do
                Do Forever
                    id=Substr(line,pp,1);il=c2d(Substr(line,pp+1,1))
                    If id=x2c(w2) Then Do
                        val=Substr(line,pp+2,il)
                        Select
                            When nl/='' Then val=c2d(val)
                            When dl/='' Then val=Right(c2d(val),ml,'0')
                            When xl/='' Then val=c2x(val)
                            Otherwise Nop
                        End
                        Leave
                    End
                    pp=pp+2+il
                    If pp>ll Then Leave
                End
                If val='' & d_val/='' Then Do;val=d_val;ml=Length(d_val);End
            End
        End;Else val=inval
        If val='' & al/='' Then Do
            If Datatype(al,'w') Then val=Substr(find,1,al)
            Else val=find
        End
        If rl/='' & val/=inval Then val=Csda$('/R',rl,val)
        If Wordpos(w1,m_fields)>0 Then Do
            Parse Upper VAR w1 uw1
            If f_val.uw1/='' Then Do
                xxx=f_val.uw1
                If Substr(xxx,Length(xxx),1)='*' Then Do
                    Parse VAR xxx xxx '*'
                    vax=Translate(Substr(val,1,Length(xxx)))
                End;Else vax=Translate(val)
                keep=1
                Interpret "If '"vax"'"f_oper.uw1"'"xxx"' Then Nop;Else keep=0"
                If \keep Then Return 0
            End
        End
        If Length(val)>ml Then ml=Length(val)
        If callign & ml<8 Then ml=8
        pad=Substr(' ',1,ml-Length(val))
        If w1/=desc_id Then oval=oval||Substr(w1,1,6,'.')'('val'); 'pad
        Else odesc=val
    End
End_field_process:
    If oval/='' Then Do
        oval=Substr(Strip(oval),1,Lastpos(';',oval)-1)
        x=Output_oval(oval,hd1'» ');hd1=Substr(' ',1,18)
    End
    If odesc/='' & odesc/=inval Then x=nl(hd1'* "'odesc'"')
    If listdate Then Do
        If cdate/=inval Then Do
            cdate=c2x(cdate)
            Parse VAR cdate yy +2 ddd +3 hh +2 mm +2 ss +2
            If dm_avail Then Do
                cdate=Dateman(dm_opt,yy||ddd)
                If Word(cdate,1)='Error' Then cdate=yy'.'ddd
            End;Else cdate=yy'.'ddd
            cdate=cdate 'at' hh':'mm':'ss'.'
        End
        If vrc/=8 Then x=nl(hd1'4A'x cdate)
    End
    Return 0

/*--------------------------------------------------------------------*/
/* Find all entities for wilcarded entry(s).                          */
/*--------------------------------------------------------------------*/
find_wild_item:Arg findit,findtype
    If ofind='*' Then findit="p' ¬'";Else findit="'"findit"'"
    "LABEL" #lin#"=.TLINE";lint=#lin#
    If findtype='FILES' Then col_end=09;else col_end=20
    Do Forever
        "CURSOR="lint 0
        "F '"findtype":' 1 "col_end" .TLINE .BLINE";If rc/=0 Then Leave
        "(line)=LINE .ZCSR";Parse VAR line xx ':';xx=Strip(xx)
        "LABEL .ZCSR=.FLINE";"(linf)=CURSOR";"CURSOR="linf+1 0
        "F ':' 1 20 .ZCSR .BLINE"
        If rc=0 Then "(lint)=CURSOR";Else "(lint)=LINENUM .BLINE"
        "LABEL" lint-1"=.TLINE";"CURSOR="linf 0
        If linf+1=lint Then range=".TLINE .TLINE";Else range=".FLINE .TLINE"
        Do Forever
/*          "F '"findit"' 20" lrecl range;If rc/=0 Then Leave         */
            "F "findit" 20" lrecl range;If rc/=0 Then Leave
            "(line)=LINE .ZCSR";If Word(line,1)='1CICS' Then Iterate
            "(lin#,col#)=CURSOR"
            yy=col#+off;hit=$Wordat(line,yy)
            If Wordpos(hit,hits)=0 Then hits=hits hit
        End
    End
    Return 0
/*--------------------------------------------------------------------*/
/* Find all groups for appropriate entity.                            */
/*--------------------------------------------------------------------*/
find_groups:Arg findit,findtype
    Do Forever
        "CURSOR="lin# col#+1
        "F ' "findit" ' ";If rc/=0 Then Leave;"(lin#,col#)=CURSOR"
        "(line)=LINE .ZCSR";yy=col#+off;hit=$Wordat(line,yy)
        "F ':' 1 20 PREV";If rc/=0 Then Iterate
        "(line)=LINE .ZCSR";Parse VAR line 2 id ':'
        id=Strip(id);If id='GROUP NAME' Then Iterate
        If id/=findtype Then Iterate
        "F 'GROUP NAME:' 1 20 PREV";If rc/=0 Then Leave
        "(line)=LINE .ZCSR";Parse VAR line ':' group .
        If Wordpos(group,groups)=0 Then groups=groups group
    End
    Return 0
/*--------------------------------------------------------------------*/
/* Find all lists for group.                                          */
/*--------------------------------------------------------------------*/
find_list:Arg findit
    lista=
    "F 'GROUP      ' LAST"
    Do Forever
        "F 'GROUP      "group" ' PREV";If rc/=0 Then Leave
        "F 'LIST NAME:' PREV";If rc/=0 Then Leave
        "(line)=LINE .ZCSR";Parse VAR line ':' list .;lista=lista list
    End
    Return Space(lista)
/*--------------------------------------------------------------------*/
/* Output a line and if > 72 chars break up into appropriate lines.   */
/*--------------------------------------------------------------------*/
Output:Parse Arg xxx,pre,dont_sort
    If xxx='' Then Do;x=nl(pre')');Return xxx;End
    Signal on Syntax Name error_off_10
    xxx=Translate(xxx,' ',',')
/*  If dont_sort='' Then xxx=$sort(xxx)                               */
    If dont_sort='' Then Do
        If Words(xxx)>isort_limit Then xxx=sync_sort(xxx)
        Else xxx=$sort(xxx)
    End
error_off_10:Signal off Syntax
    xx=Space(xxx)')'
    Do While xx/=''
        x=$Wordat(xx,72-Length(pre),'l')
        If x='' Then Do;x=nl(xx);xx=;Leave;End
        xx=Strip($Wordat(xx,72-Length(pre),'t'));If xx='' Then y=;Else y=','
        x=nl(pre||Space(x,1,',')y);pre=Copies(' ',Length(pre))
    End
    Return xxx
Output_oval:Parse Arg xxx,pre
    xx=xxx
    Do While xx/=''
        x=$Wordat(xx,72-Length(pre),'l')
        If x='' Then Do;x=nl(xx);xx=;Leave;End
        xx=Strip($Wordat(xx,72-Length(pre),'t'))
        x=nl(pre||x);pre=Copies(' ',Length(pre))
    End
    Return xxx
output_stats#01:
    x=nl('Parameter:' findtype'('ifind') -' Words(hits) 'unique hits.')
    If key_w/='' Then x=nl('Key_words:' Space(key_w))
    If dsnvsam/='' Then x=nl("CSD:       '"dsnvsam"'")
    Else                x=nl("CSD:       Unavailable...")
    Return 0
nl:Parse Arg nl1
    If ispf='ACTIVE' Then "LINE_BEFORE 2=NOTELINE (nl1)";ELse Say nl1
    Return 0
/*nl:Parse Arg nl1;"LINE_BEFORE .ZFIRST=NOTELINE (nl1)";Return 0      */
/*--------------------------------------------------------------------*/
/* Sort using the IBM supplied SORT program                           */
/*--------------------------------------------------------------------*/
sync_sort: Arg yyyy
    i=0;Do While yyyy/='';Parse VAR yyyy xx yyyy;i=i+1;v.i=xx;End
    shlq=Sysvar(Syspref)'.'Userid()'.CSDASORT'
    sortin=shlq'.SORTIN';sortout=shlq'.SORTOU';sysin=shlq'.SYSIN'
    sysout=shlq'.SYSOUT'
    Address TSO;#m=Msg('Off')
    "FREE F(SORTIN,SORTOUT,SYSIN,SORTWK01)"
/*  "FREE F(SORTLIB)"                                                 */
    "DELETE '"sortin"'";"DELETE '"sortout"'";"DELETE '"sysin"'"
    "DELETE '"sysout"'"
    "ALLOC F(SORTIN) DA('"sortin"') CATALOG UNIT(SYSALLDA) NEW REU",
       "SPACE(10,10) CYLINDERS RECFM(F B) LRECL(8) BLKSIZE(0) DSORG(PS)"
    "ALLOC F(SORTOUT) DA('"sortout"') CATALOG NEW REU LIKE('"sortin"')"
    "ALLOC F(SYSIN) DA('"sysin"') CATALOG UNIT(SYSALLDA) DSORG(PS)",
       "SPACE(1) TRACKS RECFM(F) LRECL(80) NEW REU"
    "ALLOC F(SYSOUT) DA('"sysout"') CATALOG UNIT(SYSALLDA) DSORG(PS)",
       "SPACE(1,1) TRACKS RECFM(F) LRECL(80) NEW REU"
    "EXECIO * DISKW SORTIN (STEM v. FINIS)"
    "NEWSTACK";Queue ' SORT FIELDS=(1,8,CH,A)';Queue ''
    "EXECIO * DISKW SYSIN (FINIS"
    "ALLOC FILE(SORTWK01) UNIT(SYSDA) SPACE(5,5) CYLINDERS"
/*  "ALLOC FILE(SORTLIB)  DA('DFSORT.SORTLIB') SHR REU"               */
    Address ISPEXEC "SELECT PGM(SORT)"
    sort_rc=rc
    If time_s & sort_rc=0 Then Do
        Address ISREDIT
        z_z=Time('s');x=nl('...... SyncSorted:' Time() '('z_z-x_x'secs)')
        Address
    End
    "EXECIO * DISKR SORTOUT (STEM v. FINIS)"
    "FREE F(SORTIN,SORTOUT,SYSIN,SORTWK01)"
/*  "FREE F(SORTLIB)"                                                 */
    "DELETE '"sortin"'";"DELETE '"sortout"'";"DELETE '"sysin"'"
    "DELETE '"sysout"'"
    If sort_rc/=0 Then Return $sort(xxx)
    yyyy=;Do i=1 To v.0;yyyy=yyyy v.i;End
    Return yyyy

/*--------------------------------------------------------------------*/
/* First time execution.                                              */
/*--------------------------------------------------------------------*/
x_first_time:
    #tr=Trace('o')
    first_time=0;dynav=validtypes;shadv=;Call build_panel
    noitems=Words(validtypes)%3
    dynav=;xxx=validtypes;ent_len=18
    Do while xxx/=''
        Parse VAR xxx w1 w2 w3 xxx
        yy=Verify(w2,'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789','N')
        w2=Substr(w2,1,ent_len-2)
        dynav=dynav||Right(w1,2) w2
        shadv=shadv||'yy 'Copies('w',yy-1)Copies('t',ent_len-(yy+1))
    End
    x=Trace(#tr)
    Return 0
/*--------------------------------------------------------------------*/
/* Allocate panel                                                     */
/*--------------------------------------------------------------------*/
build_panel:
    u=Sysvar(Sysuid);p=Sysvar(Syspref);If u/=p&p/='' Then u=p'.'u;hlq=u
    csdadsn=hlq'.$$$TEMP.CSDPANEL'
    Address TSO;#msg=Msg('Off');"DELETE '"csdadsn"'"
    "ALLOC DA('"csdadsn"') NEW CATALOG TRACK SPACE(1,1) DSORG(PO) LRECL(80)",
       "BLKSIZE(0) UNIT(SYSALLDA) DIR(1) RECFM(F B) REU"
    "FREE DA('"csdadsn"')";"NEWSTACK";Call make_mem_1;#tr=Trace('o')
    Do i=n_st To n_en;Queue Sourceline(i);End;Queue '';x=Trace(#tr)
    "ALLOC F("dd") DA('"csdadsn"("xcmd"P)') SHR REU"
    "EXECIO * DISKW "dd" (FINIS";"FREE  F("dd")"
    Address
    Address ISPEXEC "LIBDEF ISPPLIB DATASET ID('&CSDADSN') STACK"
    x=Msg(#msg)
    Return 0

/*--------------------------------------------------------------------*/
/* Set up atch jcl and present under viewer.                          */
/*--------------------------------------------------------------------*/
set_up_for_batch:
    parm1=' ISPSTART CMD(%CSDABTCH /BE /O'  ;If cicsv=13 Then parm1=parm1 '/13'
    If xontally Then parm1=parm1 '/XT'
    If time_s   Then parm1=parm1 '/TS'
    acct=$alkacct()
    prognm='CSDA-Batch'
    Signal on Syntax Name error_off_alkjcpg
    x=$Alkjcpg(prognm);If x/='' Then prognm=x
error_off_alkjcpg:Signal off Syntax
    Address "NEWSTACK"
    Queue '//'Substr(Userid()'AB',1,8) 'JOB ('acct'),'
    Queue "//   '"prognm"',MSGCLASS=Z,REGION=0M,"
    Queue '//   CLASS=A,MSGLEVEL=(1,1),TIME=1440,NOTIFY=&SYSUID'
    Queue '/*JOBPARM ROOM=ZTS,LINES=9999'
    Queue '//*'
    Queue '//*----------------------------------------------------------------*'
    Queue '//* Modify as required and manually submit job.                    *'
    Queue '//*----------------------------------------------------------------*'
    Queue '//*'
    Queue '//TSEP1 EXEC PGM=IEBUPDTE,PARM=NEW'
    Queue '//*'
    Queue '//SYSPRINT DD SYSOUT=*'
    Queue '//SYSUT2   DD DSN=&&CLISTS,'
    Queue '//       DISP=(NEW,PASS),UNIT=SYSDA,SPACE=(TRK,(2,1,1)),'
    Queue '//       DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)'
    Queue '//SYSIN  DD DATA,DLM=$$'
    Queue './ ADD NAME=CSDABTCH'
    Queue '/* REXX */'
    Queue '   Arg parm#'
    Queue '   csd="''"'dataset'"''"'
    Queue '   Address ISPEXEC "VIEW DATASET(&CSD) MACRO(CSDA) PARM(parm#)"'
    Queue '   Exit'
    Queue './ ENDUP'
    Queue '$$'
    Queue '//*----------------------------------------------------------------*'
    Queue '//TSEP2    EXEC PGM=IKJEFT01,DYNAMNBR=65'
    Queue '//SYSPROC  DD DISP=(OLD,DELETE),DSN=&&CLISTS'
    Queue '//         DD DISP=SHR,DSN='$alkhlq()'.$$'
    Queue '//*----------------------------------------------------------------*'
    Queue '//* Batch ISPF environment.                                        *'
    Queue '//* (Hit me with command "BE" for site specifics. Use "BE *" to add*'
    Queue "//*  my datasets before system's.)                                 *"
    Queue '//* (Use "BE ALL" to add all then customise.)                      *'
    Queue '//*----------------------------------------------------------------*'
    Call batchisp 'NJ NS NU NI QUEUE CONC(SYSEXEC,SYSPROC)'
/*
    Let "BATCHISP" do all this for you......

    Queue '//ISPPLIB  DD  DISP=SHR,DSN=ISP.SISPPENU'
    Queue '//ISPSLIB  DD  DISP=SHR,DSN=ISP.SISPSENU'
    Queue '//ISPMLIB  DD  DISP=SHR,DSN=ISP.SISPMENU'
    Queue '//ISPTLIB  DD  DISP=SHR,DSN=ISP.SISPTENU'
    Queue '//ISPLLIB  DD  DISP=SHR,DSN='$alkhlq()'.$LOAD'
    Queue '//ISPPROF  DD  DSN=&ISPPROF,SPACE=(TRK,(10,,10)),UNIT=SYSDA,'
    Queue '//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)'
    Queue '//ISPLOG   DD DUMMY'
*/
    Queue '//ISPLIST  DD DUMMY'
    Queue '//SYSTSPRT DD SYSOUT=X'
    Queue '//SYSTSIN  DD *'
    Queue parm1 '+'
    Queue '  /CSD('dsnvsam') +'
    Queue '  'ft'('ifind') +'
    If o_fields/='' Then Queue '  /OF('Space(o_fields,,',')') +'
    If m_fields/='' Then Queue '  /MF('Space(bm_fields,,',')') +'
    If s_fields/='' Then Queue '  /SF('Space(s_fields,,',')') +'
    Queue '  )'
    Queue '/*'
    Queue '//'
    Queue ''
    Address ISPEXEC
    "VGET ZTEMPF"
    Address TSO "ALLOC DD(ZTEMPF) DS('"ztempf"') SHR REU"
    Address TSO "EXECIO * DISKW ZTEMPF (FINIS"
    "LMINIT DATAID(DATAID) DDNAME(ZTEMPF)"
    zedlmsg='JCL to run your report in batch. This JCL needs to be',
            'manually submitted.'
    "SETMSG MSG(ISRZ001)"
    "VIEW DATAID(&DATAID)"
    "LMFREE DATAID(&DATAID)"
    Address TSO "FREE DD(ZTEMPF)"

    Signal exi1

/*--------------------------------------------------------------------*/
/* Invoke CSDC /MA() function.                                        */
/*--------------------------------------------------------------------*/
Call_CSDC:
    Address ISPEXEC
    "VGET (zscreenc)";zscreeni=$Screenc()   /* Original screen        */
    "VGET (zscreeni)"
    line=$Dat@CSR(zscreeni,'/L')
    Parse Value Word(line,4) With '(' groups ')'
    w2=Word(line,2);groups=Translate(groups,' ',',')
    If groups='' Then Do
        zedlmsg=Substr("Data on line appears invalid.",
                "  Does not seem to contain:",1,70),
                "'resource(entry) > Groups(group1,..,groupN)' format data."
        "SETMSG MSG(ISRZ001)"
    End
    Else Do While groups/=''
        Parse VAR groups group groups
        If Words(groups)>0 Then CSDC_jcl='/NJ'
        csdc_parm=csdc_funct'(GROUP('group'):'w2')'
        Address TSO "%CSDC '"dsnvsam"'" csdc_parm CSDC_jcl
        csdc_funct='/MA'
    End
    "ISREDIT USER_STATE=(status)"
    Exit

/*--------------------------------------------------------------------*/
/* Create help panel(s) from sourcelines between the '/* */'          */
/*--------------------------------------------------------------------*/
make_mem_1:
    n_st = mark(2)                          /* Mark start of data     */
/*
)ATTR DEFAULT(%?_)
 _ TYPE(INPUT)   INTENS(HIGH) COLOR(RED)    HILITE(USCORE)
 ` TYPE(&TYP#)   INTENS(HIGH) COLOR(RED)    HILITE(USCORE) CAPS(OFF)
 # TYPE(&TYP#)   INTENS(HIGH) COLOR(RED)    HILITE(USCORE)
 @ TYPE(TEXT)    INTENS(HIGH) COLOR(YELLOW)
 + TYPE(TEXT)    INTENS(LOW)  COLOR(GREEN)
 $ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)
 ! AREA(DYNAMIC)
 ¬ TYPE(DATAIN)  INTENS(HIGH) COLOR(RED) CAPS(ON) HILITE(USCORE)
 { TYPE(DATAOUT) INTENS(LOW)  COLOR(TURQ) CAPS(OFF) SKIP(ON)
 } TYPE(DATAOUT) INTENS(LOW)  COLOR(GREEN) CAPS(OFF) SKIP(ON)
 w TYPE(CHAR) COLOR(WHITE)
 W TYPE(CHAR) COLOR(WHITE) HILITE(USCORE)
 y TYPE(CHAR) COLOR(YELLOW)
 b TYPE(CHAR) COLOR(BLUE)
 B TYPE(CHAR) COLOR(BLUE) HILITE(USCORE)
 r TYPE(CHAR) COLOR(RED)
 t TYPE(CHAR) COLOR(TURQ)
 g TYPE(CHAR) COLOR(GREEN)
)BODY EXPAND(\\) WINDOW(60,22)
%&SID%=>_ZCMD
%
+Enter details below:                             ->@&WEXEC
+Item....`IFIND                    +Mask or comma seperated.
+TYpe....#CD+Enter code from list below (or place cursor):
   !DYNAV,SHADV                                            !
   !                                                       !
   !                                                       !
   !                                                       !
   !                                                       !
   !                                                       !
   !                                                       !
   !                                                       !
   !                                                       !
   !                                                       !
   !                                                       !
+DFHCSD..#DSNVSAM                                     +
+Fields..#Z+Field selection for reporting (Y/N).
+Muti.gp.#Z+Multi group, item in >1 groups (Y/N).
+Desc....#Z+Report description if available (Y/N).
+Allign..#Z+Column allign (where possible) (Y/N).
@ENTER+-process,@END/CANCEL+-abandon,@?+-tutorial.
)INIT
 IF (&READCSD=0)  .ATTR (DSNVSAM)='TYPE(OUTPUT) HILITE(REVERSE)'
 &SID=&ZSYSID
 .ZVARS='(PFIELD,MULTIGP,LISTDESC,CALLIGN)'
 &PFIELD=TRANS(&PFIELD 1,Y 0,N *,N)
 &MULTIGP=TRANS(&MULTIGP 1,Y 0,N *,N)
 &LISTDESC=TRANS(&LISTDESC 1,Y 0,N *,N)
 &CALLIGN=TRANS(&CALLIGN 1,Y 0,N *,N)
 IF (&BATCH='Y') &WEXEC='Batch'
 ELSE &WEXEC='On-line'
 IF (&PFIELD=&Z)
    &PFIELD='N'
 IF (&MULTIGP=&Z)
    &MULTIGP='N'
 IF (&LISTDESC=&Z)
    &LISTDESC='N'
 IF (&CALLIGN=&Z)
    &CALLIGN='N'
)PROC
 &CSR=.CURSOR
 &CSP=.CSRPOS
 &CHAR1=TRUNC(&ZCMD,1)
 IF (&CHAR1 ¬= '/')
    IF (&ZCMD ¬= '?','CANCEL','CAN')
       IF (&TYP# ¬= 'OUTPUT')
          IF (&CSR ¬= DYNAV)
             IF (&PFIELD ¬= 'Y')
                VER(&IFIND,NB)
          IF (&IFIND ¬= '?')
             IF (&CSR ¬= DYNAV)
                VER(&CD,NB,RANGE,1,&NOITEMS)
       VER(&PFIELD,NB,LIST,Y,N)
       VER(&MULTIGP,NB,LIST,Y,N)
       VER(&LISTDESC,NB,LIST,Y,N)
       VER(&CALLIGN,NB,LIST,Y,N)
 &PFIELD=TRANS(&PFIELD Y,1 N,0 *,0)
 &MULTIGP=TRANS(&MULTIGP Y,1 N,0 *,0)
 &LISTDESC=TRANS(&LISTDESC Y,1 N,0 *,0)
 &CALLIGN=TRANS(&CALLIGN Y,1 N,0 *,0)
)END
*/
    n_en = mark(-2)                         /* Mark end of data       */
    Return 0

help_#1:
    n_st=mark(2)    /* Mark Start */
/*

  CSDA: CSD Analyser.

  This macro is designed to analyse the contents of a viewed/edited
  listing of a CSD (not OBJECT as it would be too large and CSDA only
  uses the standard LIST portion.)
  It's primary objective is to give a hierarchical presentation of
  selected entities, eg. what group(s) the entity(s) is defined in and
  which list(s) use those group(s).

  This routine will provide expansion of entity details by directly
  reading the CSD and supplying the appropriate details.  Refer below
  for further details on field formats for entity types.

  If you are analysing TRANsactions and have supplied the CSD name,
  the executing program is reported. This is handy when different
  groups contain the same transaction with a different executable
  program.

  If the CSD is available, you may fine tune your selections by
  setting field comparisons. (For further details, refer to the "/MF"
  parameter.)

  Output summary:
  ---------------
  The following are delimiters used to identify the type of data/fields
  being presented in the report:
    > List of groups the entity belongs to.
    + List of lists the group belongs to.
    - Group not used by any lists.
    » Fields extracted from the CSD (as set up in the field definition
      matrix).
    * Description (extracted from CSD if it is defined in matrix).
    ¢ Date/time last modified.

  The output is presented as NOTE lines and it is recommended that you
  view the CSD list so that the notelines can be converted to data
  using the 'md' line command to permit text/data manipulation without
  accidentally changing the list.
  This tutorial will be placed before line 1 and reports placed after
  line 1 thereby permitting display of the tutorial at the top of the
  file and always before the report.

                             ***********

  Parameters:
  -----------
  Summary Positional:
    1. itemtype(item) | itemtype item | item

  Summary Keyword:
    /#  - Data entry screen.
    /13 - TS1.3 or earlier.
    /21 - CICS TS2.1 or later.
    /A  - Append report.
    /B  - Execute in batch.
    /CA - Column Align.
    /C  - Changed date/time stamp.
    /CE - Date in European format.
    /CJ - Date in Julian format.
    /CSD(csd_dataset)
        - CSD dataset to use.
    /CSDC
        - Invoke CSDC to generete define statements.
    /CU - Date in USA format.
    /D  - List description.
    /MF(match_field_list | *)
        - Match Fields.
    /MG - Multi Group.
    /NC - No Changed date/time stamp.
    /NCA- No Column Align.
    /NF - No Fields.
    /ND - No description.
    /NR - Do not attempt to read/process the CSD, even if the required
    /NS - No seperator lines.
    /O  - On-line execution.
    /OF(only_field_list | *)
        - Only Fields.
    /SF(suppress_field_list | *)
        - Suppress Fields.
    /T  - Turn REXX trace on. Used for debugging.
    /TS - Time Sort.
    /XT - eXit after Tally.
    ?   - This tutorial.

  Detailed:
  ---------
  Keyword parameters will be evaluated first and removed from the
  parameter list as they are encountered.  The remaining string(s)
  will be interpreted as positional parameters.

  Positional parameters:
  Note: While keyword paramaters may precede positional ones, any
        misspelt keyword paramaters will be treated as positional
        parameters.  Consequently get into the practice os using
        keyword as the trailing parameters.

   Positional:
    1. itemtype(item) | itemtype item | item
       Where:
          itemtype - selection of the type of item to report.  Execute
                     CSDA without parameters to display an input panel
                     that will list all the permissable item types and
                     acceptable abbreviations.
          item     - You may enter any combination of items (comma
                     seperated) or you may wildcard "item" by using an
                     optional leading and/or trailing '*'. It is
                     suggested that a more discreet than more generic
                     searches be used as too many hits may blow out
                     response.  (That is why '*' by itself is batch
                     forced as a TRANS(*) batch process for a medium
                     sized CSD took over 3 hours to execute. If fact
                     a "/XT" report on a 8000 transaction CSD to about
                     10 minutes in batch.)
                     Note: 'Item(s)' is not case sensitive and CSDA
                           will report on both upper and lower (and
                           mixed) case items. However, the input
                           screen is case sensitive so if you enter
                           in upper case, only the upper case hit will
                           be reported.
                         : Choosing '*' will force batch processing
                           unless it is overridden using the "/O"
                           parameter.
                         : To extend your search use a combination
                           of wildcarded items (comma seperated).
                           For multi items you can 'globalise' the
                           wildcarding by including the items between
                           brackets with any potential prfix and/or
                           suffix outside the brackets, eg.
                              (d,h,yy)*    -> d*,h*,yy*
                              a(bb,ee,xy)* -> abb*,aee*,axy*.
                           Don't forget the itemtype, eg.
                              trans(*(bb,ee,xy)*)
                           (You may ask why?  Because I can and I
                            needed variety for testing!!!)
       If only one parameter is used, it will be assumed to be 'items'
       and the default is,
           'TRANSactions(items)'

  Keyword parameters:
    Many of the keyword parameters are purely provided to fine tune
    display options and speed up processing.  On slow systems or when
    large amounts or output is anticipated, consider the following and
    either adjust the default settings in the REXX program 'CSDA' or
    supply swithes from the list below.
    1. Disabling the facility to read the CSD will save significant
       the cycles. Either set the variable "readCSD" to 0 (zero) in
       'CSDA$' or use the "/NR" keyword. This is recommended if you
       only want a cross reference of items/groups/lists and DO NOT
       want available item details reported.
    2. Description may provide unnecessary noise (display clutter).
    3. All defined field values, especially when most are not defined
       can clutter displays.
    4. The align feature eliminates/minimises clutter, however, adds
       cycles to processing required.
    5. Date changed report can significantly increase processing time
       espoecially for large outputs.  Consider suppressing it or
       set it to Julian (as either default or parameter) as this will
       bypass invoking 'DATEMAN' for conversion to other formats.

   Keyword parameters may be entered/Changed in the primary input
   screen.  Only those marked with a 'o' are changeable.

   Keywords:
    /#  - Explicitly force data entry screen regardless of parameters
          entered.
          Use this parameter to get into screen display if you wish to
          get into the 'field selection for reporting' display.
    /13 o Indicate that the CSD is for CICS TS1.3 or earlier.  This
          parameter will flag positional parameters as unavailable
          thereby preventing erroneous reporting and speed up
          processing. (Unavailable fields will be summarised in the
          report.)
          Note: EXECIOVS is used to establish average record length for
                the CSDE file. If it is not 200, it will be interpreted
                as pre TS2.1 and this flag will automatically set and
                user notified prior to progressing.
    /21 o Explicitly set CICS version to TS2.1 or later. Use this to
          reverse TS1.3 detection (with reservation as may blow out
          response times).
    /A  o Append report (do not remove previous notelines).
    /B  o Execute in batch.  Use this flag for large CSDs and when you
          expect long execution.  This format will be enforced if '*'
          item is chosen for fields in the "no_wild" parameter list in
          'CSDA$'.  This can be overriden using the "/O" parameter.
          You have been warned, do it at your own peril.
    /C  o Changed date/time stamp. Explicitly display changed date/time
          regardless of default setting.
          Note: Variable "listdate" can be set in routime CSDA$ to set
                default date changed display defaults.
              : Date will be displayed in the format dd/mm/yyyy if
                'DATEMAN' is available otherwise yy.mmm will be used.
              : If 'DATEMAN' is available variable "datefmt" can be
                set in routine CSDA$ to set default format to
                E(uropean), J(lulian) or U(SA).
              : 'DATEMAN' is an external routine and is invoked for
                each hit and may take up larger than desired cycles
                in generating reports.
    /CA - Column Align.  To align columns based on a field length of 8
          if the lenght is <8.  Alternatively rearange the report
          field order in CSDA$ or change the report field length to 8
          (max size except for description and a few WEB related
          fields). Aligning columns will increase the physical size of
          the report.
          Note: Variable "autoalign" can be set in this routine to
                'auto align' without the "/CA" parameter.
    /CE o Changed Date stamp to European format dd/mm/yyyy regardless
          of variable "datefmt" setting.
    /CJ o Changed Date stamp to Julian format yy.ddd regardless of
          variable "datefmt" setting.  This is the default format
          and quickest in processing requirements which may be worth
          consideration on slow systems or high output volumes.
    /CSD(csd_dataset)
        - CSD dataset. This value is used to get additional entity
          details for detailed analysis.
          Without this parameter it will look for eyecatcher
             "  CSD file: 'CSD_dataset....' "
          which has to be manually entered or let "CSDL" do it for you.
    /CSDC
        - Invoke CSDC to generate define statements for the entry the
          on the line the cursor is on.  You use this function to
          generate a DEFINE statement for the resource in the group
          that can be canabilised to nake a customisable ALTER
          statement.  The cursor MUST be on the line that lists both  .
          the resource and it's appropriate group.  You can pass it a
          sub-parameter of '/M' to create a new entry dataset used by
          the CSDC function.  By default a parameter of /MA is passed
          to append to existing dataset.  For fyuther details, refer
          to CSDC documentation.
    /CU o Changed Date stamp to USA format mm/dd/yyyy regardless of
          variable "datefmt" setting.
    /D  - List description if available from CSD dataset.
    /MF(match_field_list | *)
        - Match Fields. Provide a list of field (comma or space
          seperated) to perform a comparison with. This is additional
          to the "/OF" and "/SF" parameters if used.
          For all fields in the list an interim '=' is placed into the
          field selection field for the upcomming field selection
          screen. The remaining fields will be set in accordance with
          the "/OF" and "/SF" field list. (If neither is used, all
          fields will be set to 'Y'.
          You may overtype the system generated parameter by any of
          the following (these are also applicable for the field
          selection/suppression features):
              =  Field value equal to.
              >  Field value greater than.
              <  Field value less than.
              /  Field value not equal to (expanded to '/=').
              Y  Ignore field matching but report field
              b  Blank, Ignore field matching and do not report field.
              x  Any other character will be treated as 'Y'.
          If "=,>,<,/" is entered, a subsequent screen is presented for
          comparison value entry.
          You may enter any value. It will be used in a literal
          comparison.  You may wildcard values by using a trailing '*'
          in which case the '*' will be dropped off and the field
          value truncated to the same length befor the comparisson is
          made.
          Note: You still cannot do a global seach, however you can
                maximise your scope with a two pass of the following,
                   CSDA TRANS((A,B,C,D,E,F,G,H,I,J,K,L,M)*) /MF(X)
                         - followed by -
                   CSDA TRANS((N,O,P,Q,R,S,T,U,V,W,X,Y,Z)*) /MF(X) /A
                (This would cover all the alphabetic transaction,
                however, I'd hate to be the one waiting for completion
                especially on a large CSD.)
    /MG - Multi Group. Only report 'items' that belong to more than 1
          group.  This is to determine what combination of settings
          may be in play (accross systems).
          All items found will be listed, however, only items in more
          than one group will be detailed.
          All multi-group item hits will be summarised at the end of
          the report.
    /NC o No Changed date/time stamp.  Explicitly suppress changed
          date/time regardless of default setting.
    /NCA- No Column Align. (Only provided for completeness because of
          the "/CA" parameter and "autoalign" variable.)
    /NF - No Fields. This is further to the "/D" option. Even if the
          CSD is accessible, do not get and display the 'field'
          details that would be available. (This value forces "/D" so
          it is not required and will negate any "/OF" or "/SF" lists.)
    /ND - No description even if available from CSD dataset.
    /NR o Do not attempt to read/process the CSD, even if the required
          tools are available.  This will automatically activate the
          "/NF" switch.
          Note: Variable "readCSD" can be set in routine CSDA$ to
                either enable or disable the default CSD process.
              : If "/NR" is in effect, the "DFHCSD" field becomes
                protected and the color reversed.
              : If "/NR" is set you will need to exit process to
                reverse it as there is no converse of "/NR".
    /NS - No seperator lines. Removes/adds to the congestion (depending
          on your point of view).
    /O  o On-line execution.  In cases when the system enforces batch
          execution because of full wildcarding (*) on fields in the
          "no_wild" parameter list in 'CSDA$' you can force on-line
          execution.
    /OF(only_field_list | *)
        - Only Fields. Provide a list of field (comma or space
          seperated) to report.  This is an alternative to supressing
          all fields using the "/NF" parameter or playing with the
          "report" flags on the "itemflds" variable in 'CSDA$' member.
          The field list is not case sensitive but must match the full
          spelling of the field which may be obtained from a listing
          of the tutorial of by browsing member 'CSDA$'.
          Alternatively use field name of '?' to provide a list of
          valid fields for that item type.  These values will be used
          to populate the field selection screen if it is selected.
          If '*' is entered, you will either be directed to the field
          selection screen or the field selection screen flag will be
          set in the data entry screen without any fields selected.
    /SF(suppress_field_list | *)
        - Suppress Fields.  Provide a list of field (comma or space
          seperated) to suppress from the report.  This is an
          alternative to supressing fields you don't think are
          meaningfull for your circumstance and you do not wish to use
          the field selection screen.  Alternatively you can either
          suppress the field by setting the "report" flag to 'N'
          against the field on variable "itemflds" in member 'CSDA$'
          if that is acceptable by all at your site or arange for a
          personalised copy of CSDA$.  (If the later option is
          selected, you may miss out on any important future updates
          or repeat the process when an upgrade is isntalled.)
          If '*' is entered, you will either be directed to the field
          selection screen or the field selection screen flag will be
          set in the data entry screen without all fields selected.
          Note: This option actually sets the all fields report flag
                to 'Y' and sets these fields to 'N'.  This will be
                evident if you invoke the field selection panel.
    /T  - Turn REXX trace on. Used for debugging.
    /TS o Time Sort.
          Used for debugging to fine tune the setting for variable
          "isort_limit" in 'CSDA'.  If response is bad, use the "/TS"
          parameter to time the sort reporting start, end and duration
          and "/XT" to exit befor reporting details.  If the sort
          takes > 30 seconds and "isort_limit" has not been exceeded,
          suggest reducing it till a happy comprimise is reached.
          By default the "isort_limit should be set at around 200
          to minimise file creation/deletion and I/O. The break-
          even value between $SORT and SORT is between 100-150 items,
          however, this may be influenced by site responses to
          file creation/deletion and I/O hence the 200 initial
          compromise.
          Note: This should only be an issue if SORT is not available
                at your site.
    /XT - eXit after Tally.  This parameter is designed for batch
          processing to list all the items for a particular item
          type sorted. Once reported processing terminates.
          This is useful to then run more discreet selections.
    ?   - This tutorial. But you already know that. Don't you?
    Parameters "/D" and "/ND" should be used depending on site
    defaults, (ie. if default is to display description then use "/ND"
    to suppress it). This default is set by variable "listdesc" at the
    top of the REXX program 'CSDA$'.
    Use parameters "/D", "/ND" and "/NF" to reduce the "noise" in
    larger analysis reports and/or speed up processing. (Processing
    may take twice as long with full field reporting.)

    Keywords "/A, /C, /CE, /CJ, /CU, /NC, /NR and ?" can be entered
    individualy or en-masse in the data entry screen to avoid exiting
    and re-invoking using the parameters. Other parameters can be
    changed using the input data fields.

  Screen entry fields:
  --------------------
  1. Enter "item" as per above details.
  2. "Itemtype" may be selected by code or place cursor on code or
     description.  The capital (white colored) part of "itemtype" can
     be used under parameter function entry, eg.
         CSDA TRANS(CED*,AA*)
  3. DFHCSD. If you used the "CSDL" routine to list the CSD, it would
     have stamped the list with the source CSD dataset name which
     would then be extracted and inserted here.  Alternatively you can
     manually enter the CSD (unquoted).
     Note: Blanking out the CSD name (if available) will speed up
           processing but not as significantly as the "/NF" or even
           more significantly the "/NR" switches.
  4. Description reporting. Set this to 'N' to suppress descriptions
     from being reported (if available).
  5. Fields to include in the reports. If 'Y' is entered (will be set
     to 'Y' of "/OF" parameters are passed and screen display is
     entered. (See below for field report screen.)
  6. Allign fields in the report. Used for presentation and where
     field sizes adversely affect the esthetics of the report lay-
     out.
  Field selection screen:
  -----------------------
  If option 5 above is set to 'Y' a screen will be displayed with the
  main body part listing all the available fields that may be included
  in the report. If "/OF" parameters are supplied, they will be used to
  set 'Y' values against their respective fields.  If "/SF" parameters
  are supplied, they will be used to set 'Y' values against all fields
  and ' ' (space) against their respective fields.

  On exit (either by using enter or END PF key) control will always be
  passed to the main parameter entry screen even if it was not
  initially displayed.

  Enter any non blank character in the input field before the field
  name to select for reporting.  Return will be passed to the previous
  screen with the fields reported defined as if the "/OF" parameter
  was used.  Once this screen is entered and no fields are selected
  then all fields will be excluded from the report (same as if "/NF"
  parameter used on entry).

  Field selection screen entry commands:
     ALL  - Selects all fields.  Use this command to reset all fields
            in case screen previously exited without a selection.
            (This will negate any "/MF" and "/NF" setting.)
     NONE - Unselect all fields.  Quicker than repetaed TAB overtype
            with space.
     SORT - Sort field name display alphabetically.
            NOTE:- This sort is for selection only and will not alter
                   the field sequences in the report.

  For explanation of the fields refer to the CICS manual. Field sequence
  and tend follow the CEDA display sequence. Field names are limited to
  6 characters so some of them may be somewhat cryptogramic.

  Packaging:
  ----------
  The following members are required to package this function.  Those
  marked with an 'o' seperator are optional and enhance the available
  features:
   REXX:
   -----
    $CSTRING - Change string.  Used to build the field selection
               screen.
    $DDALLOC o Required by BATCHISP (if used).
    $SORT    o Routine top sort a string of space seperated words.  If
               the routine is not found, the transaction item(s)
               report will not be sorted. (For large lists, IBM's sort
               is used.)
    $WORDAT  - Identify text according to column position. Required
               for parsing data to format output.
    BATCHISP o Required to get default ISPF datasets to execute in
               batch.
    BR       o Required to display these instructions under browser
               when help (?) is invoked from panel.
               If unavailable, you will get a red screen.
    CSDA     - This driver.
    CSDA$    - External variable setter. Externally designed to permit
               sites to customise field definitions external to the
               CSDA driver.
    CSDR     o CSD reader.  May be included instream in selective
               packaging of CSDA. Required to list program executed by
               the transcation. (It requires access to EXECIOVS.)
               Unavailability will force the "/NF" option.
    DATEMAN  o Date converter required if the "/C" option is requested
               or defaulted.
    EXECIOVS o EXECIO format VSAM file reader required by CSDR.  Uses
               program RXVSAM (see below).
   Panels:
   -------
    CSDAP    - Self extracted out of this routine.
   Programs:
   ---------
    RXVSAM   o VSAM reader. (Off CBT tape.) Used by EXECIOVS.
    SORT     o IBM sort.  Called upon when number of items to report
               exceed variable "isort_limit" at start of 'CSDA$'.
               This sort is much quicker than the REXX bubble sort
               $SORT but it need to allocate I/O files hence do not set
               "isort_limit" too low unless sort times blow out. Use
               parameter "/TS" to report on sort times.

  Internal secrets:
  -----------------
  1. Variables used for field definitions:
    a) validtypes:-
         Format:- 'nn type hex', where,
           nn   - sequence number
           type - entity identifier
           hex  - hex entity record identifier (cols 13-14 in CSD VSAM
                  dataset).
         This variable is used to build the data entry screen and
         validate request type.
    b) itemflds:-
         Defines all the fields that may be reported against
         individual entity types.  Refer to member CSDA$ for further
         details as it sets the variable values and contains
         processing sub-routines for specialised parsing.
    c) descflds:-
         Can be considered a single field format of
         'itemflds'.  The descriptions have been removed to permit
         exclusion of descriptions as often they are too abstract and
         also using this format they can be forced to the end of the
         report to avoid clutter.
    d) exclflds:-
         Fields to exclude from the defined "itemflds"
         variable during reporting.  Refer to member CSDA$ for setting
         of exclusion list.

------------------------------------------------------------------------
*/
n_en=mark(-2)   /* Mark End   */
    If w1="??" Then Signal Help_me;"ISREDIT (m)=MEMBER";rcm=rc
    If rcm=0 Then Signal Help_me;Signal On Syntax Name Help_me
    Parse Source . . xcmd .;x=$BR(xcmd "??");Return
    Mark:If Datatype(Arg(1))/="NUM" Then Arg(1)=1;Return sigl+Arg(1)
    Help_me:Signal Off Syntax;#tr=Trace("o")
    Do i=n_st To n_en;nl=Sourceline(i)
    If rcm=0 Then "ISREDIT LINE_BEFORE 1=NOTELINE (nl)"
    Else Say Substr(nl,1,79);End
/*  x=Msg('On')                                                       */
    If rcm=0 Then "ISREDIT CSDA$ ?";Else Address TSO "%CSDA$ ??"
    Return 0
