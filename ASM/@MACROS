*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*
*                                                                     *
*  General macros used in programs written by ASYSTS Pty. Ltd.        *
*                                                                     *
*  SUMMARY:                                                           *
*  ~~~~~~~~                                                           *
*    1. KICKOFF  - Initial program entry housekeeping.                *
*    2. RACKOFF  - Final program exit housekeeping.                   *
*    3. UNPACK   - Convert HEX numerics to display format             *
*    4. CLEARV   - Move blanks to variable field (> 255 bytes).       *
*    5  AMODECHG o Addressing MODE CHanGe                             *
*    6. HEXCHMAC - Convert HEX to character.                          *
*    7. CHHEXMAC - Convert character to HEX.                          *
*    8. ISPVDEFX - Define ISPF variables (ISPVDEF) to program.        *
*    9. ISPEXEC  - Invoke ISPLINK using 'ISPEXEC' format commands.    *
*   10. PUTL     o Issue a PUTLINE command within a command processor *
*   11. ADYN     o DYNAMIC allocation/deallocation etc...             *
*   12. PDUMPR   - Program dump with REXX/ISPF presentation.          *
*   13. PDUMP    o Program dump with 3270 datastream presentation.    *
*                                                                     *
*   3270 Data Stream macros:                                          *
*   14. CADC     o Character Attribute Define Constant                *
*   15. ICDC     o Insert Character Define Constant                   *
*   16. RADC     o Repeat to Address Define Constant                  *
*   17. SBA      o Set Buffer Address                                 *
*   18. SBADC    o Set Buffer Address Define Constant                 *
*   19. WCCDC    o Write Control Character Define Constant            *
*       --------
*                                                                     *
*  This member can be rebuilt using the MACBUILD edit macro. To make  *
*  a sub-set, change the '-' after the macro name to the optional     *
*  indicator 'o'.  This will leave the entry without including the    *
*  member. Alternatively pass parameter of ALL to MACBUILD to include *
*  all assembler macros.                                              *
*                                                                     *
*  To find the start of the appropriate macro, enter "F 'MACRO n'".   *
*                                                                     *
*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*
*------- Macro  1. KICKOFF -------------------------------------------*
         MACRO
&NAME    KICKOFF &BASE,&GETMAINS,&GETMAINL,&LIST=NO,&HELP=NO,&DREG=,   X
               &AMODE=31,&RMODE=ANY,&SAVE=,&LOC=
         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'KICKOFF' parameters    *
* and it's use, pass parameter of 'HELP=Yes'.                         *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
*---------------------------------------------------------------------*
* Macro to generate all the house keeping etc.. at start of a program,*
* either re-entrant or not.                                           *
* This macro works in conjunction with the 'RACKOFF' macro.           *
*                                                                     *
* PARAMETERS:
* 1. Base register(s) - Format "(Rx,Ry,Rz)" or "Rx". May have up to   *
*                       3 base registers specified. R13 may not be    *
*                       used for re-entrant programs (refer 2 below). *
*                       For non re-entrant programs, if R13 is used   *
*                       as one of the base registers, it will be used *
*                       as the first base regardless of it's position *
*                       in the parameter string, and the initial base *
*                       will be the conventional register save area   *
*                       NOT the start of the program.                 *
*                       Default is "(R11,R12)".                       *
* 2. First variable,s name in the DSECT of a GETMAINEd area.  This    *
*    parameter is optional, however, if it used (eg. re-entrant       *
*    programs), R13 may not be used as a base register and the first  *
*    18 full words must be used for register save and linkage         *
*    conventions.                                                     *
* 3. Length of the GETMAINEd area (must be an "EQU" variable) and must*
*    be supplied if variable name parameter is supplied.              *
* 4. AMODE=..  - Addressing mode '24/31' (default = 31)               *
* 5. DREG=Rn   - Additional DSECT register on GETMAINEd area. (Use    *
*                only if you have addressability problems on the      *
*                GETMAINE'd DSECT. Do not enclose in brackets.)       *
* 6. HELP=...  - Display help comments. 'YES/NO' (default = NO).      *
* 7. LIST=...  - Display code generated. 'YES/NO' (default = YES).    *
* 8. LOC=....  - Optional loaction for the GETMAINed area if that     *
*                option is used. It must be a valid parameter as      *
*                defined by the IBM GETMAIN macro.                    *
* 9. RMODE=..  - Load  mode '24/ANY' (default = ANY)                  *
*10. SAVE=...  - Variable name of register save area if you wish to   *
*                control it's name. (useful if specialised exit       *
*                in-lieu of 'RACKOFF'.                                *
*                                                                     *
* GENERATES:                                                          *
* 1. Inserts a "program_date_time" stamp at start of module.          *
* 2. Sets up all the register equates.                                *
* 3. Saves callers registers R14 thru R12.                            *
* 4. Points R13 to the programs savearea.                             *
* 5. Establishes addresability thru supplied register(s) or default   *
*     base registers R11 + R12.                                       *
* 6. Workarea is GETMAINEd and the conventional linkage pointers,     *
*     registers saved and R13 pointed to the start of the work area.  *
* 7. As R0 + R1 are used as work registers at start, they are restored*
*     from callers savearea.                                          *
*                                                                     *
*---------------------------------------------------------------------*
.A$HELPE ANOP
         AIF   ('&LIST'(1,1) NE 'N').A$XX
         PUSH  PRINT
         PRINT NOGEN
.A$XX    ANOP
         GBLB  &KO1STR1
         GBLC  &R,&GETMADR,&GETMADL,&SAVREGS
         LCLC  &E,&BASE1,&BASE2,&BASE3,&BASE#,&#DREG,&#GMM
         LCLA  &A,&#BASES,&GETMLEN
         AIF   (T'&GETMAINS EQ 'O').NRENT
         AIF   (T'&GETMAINL EQ 'O').ERR2
.NRENT   ANOP
&GETMADR SETC  '&GETMAINS'
&GETMADL SETC  '&GETMAINL'
.*--------------------------------------------------------------------*
         AIF   (T'&SAVE EQ 'O').DEFSRG      BYPASS IF DEFAULT SAVE NAME
&SAVREGS SETC  '&SAVE'
         AGO   .A$$XX                       BYPASS DEFAULT NAME
.DEFSRG  ANOP
&SAVREGS SETC  '$SAV'.'&SYSNDX'
.A$$XX   ANOP
.*--------------------------------------------------------------------*
         LCLC  &TNAME
         AIF   (T'&BASE EQ 'O').DEFAULT
&BASE1   SETC  '&SYSLIST(1,1)'
&BASE2   SETC  '&SYSLIST(1,2)'
&BASE3   SETC  '&SYSLIST(1,3)'
&#BASES  SETA  N'&SYSLIST(1)
         AIF   (T'&GETMAINS EQ 'O').A$00    NON-R BYPASS
         AIF   ('&BASE1' EQ 'R13').ERRR13
         AIF   ('&BASE2' EQ 'R13').ERRR13
         AIF   ('&BASE3' EQ 'R13').ERRR13
         AIF   ('&BASE1' EQ '13').ERRR13
         AIF   ('&BASE2' EQ '13').ERRR13
         AIF   ('&BASE3' EQ '13').ERRR13
.A$00    ANOP
         AIF   ('&BASE2' EQ 'R13').BASE213
         AIF   ('&BASE2' EQ '13').BASE213
         AIF   ('&BASE3' EQ 'R13').BASE313
         AIF   ('&BASE3' EQ '13').BASE313
         AGO   .CONT1
.BASE213 ANOP
&BASE#   SETC  '&BASE1'
&BASE1   SETC  '&BASE2'
&BASE2   SETC  '&BASE#'
         AGO   .CONT1
.BASE313 ANOP
&BASE#   SETC  '&BASE1'
&BASE1   SETC  '&BASE3'
&BASE3   SETC  '&BASE#'
         AGO   .CONT1
.DEFAULT ANOP
&#BASES  SETA  2
&BASE1   SETC  'R11'
&BASE2   SETC  'R12'
.CONT1   ANOP
         AIF   (T'&GETMAINS EQ 'O').NONR0   NON-R BYPASS
         AIF   (T'&DREG EQ 'O').NONR0       NO 2ND.DSECT REG, BYPASS
         AIF   ('&DREG' EQ '&BASE1').ERDREG IF SAME AS BASE 1, ERROR
         AIF   ('&DREG' EQ '&BASE2').ERDREG IF SAME AS BASE 2, ERROR
         AIF   ('&DREG' EQ '&BASE3').ERDREG IF SAME AS BASE 3, ERROR
         AIF   ('&DREG' EQ 'R13').ERDREG    IF R13, ERROR
         AIF   ('&DREG' EQ '13').ERDREG     IF R13, ERROR
         AIF   ('&DREG' EQ 'RD').ERDREG     IF R13, ERROR
&#DREG   SETC  ',&DREG'                     SET SECONDARY DSECT REG
.NONR0   ANOP
.*--------------------------------------------------------------------*
         AIF      ('&NAME' EQ '').NONAME
&E       SETC     '&NAME'
         AGO      .A
.NONAME  ANOP
&E       SETC    'NULL&SYSNDX'
.A       ANOP
&E       CSECT
.TAMODE  ANOP
         AIF ('&AMODE' NE '31').AM24$
&E       AMODE  31
         AGO    .TRMODE                     Continue
.AM24$   ANOP
&E       AMODE  24
.TRMODE  ANOP
         AIF ('&RMODE' NE 'ANY').RM24$$
&E       RMODE  ANY
         AGO    .BYP#10                     Continue
.RM24$$  ANOP
&E       RMODE  24
.BYP#10  ANOP
&R       SETC     'R'
         AIF ('&BASE1' EQ 'R13').SAVANCH
         AIF ('&BASE1' NE '13').TEST1ST
.SAVANCH ANOP
&E       SETC     '&SAVREGS'                SET REGISTER SAVE AREA BASE
.*--------------------------------------------------------------------*
.TEST1ST ANOP
         AIF   (&KO1STR1).C                 FIRST TIME THRU
&KO1STR1 SETB 1
R0       EQU    0
R1       EQU    1
R2       EQU    2
R3       EQU    3
R4       EQU    4
R5       EQU    5
R6       EQU    6
R7       EQU    7
R8       EQU    8
R9       EQU    9
R10      EQU   10
RA       EQU   10
R11      EQU   11
RB       EQU   11
R12      EQU   12
RC       EQU   12
R13      EQU   13
RD       EQU   13
R14      EQU   14
RE       EQU   14
R15      EQU   15
RF       EQU   15
*---------------------------------------------------------------------*
.C       ANOP
         B     30(&R.15)                    BRANCH AROUND P/D/T STAMP
         DC    CL8'&NAME'                   PROGRAM STAMP
         DC    C'_'                         DELIMITER
         DC    CL8'&SYSDATE'                DATE STAMP
         DC    C'_'                         DELIMITER
         DC    CL8'&SYSTIME'                TIME STAMP
         STM   &R.14,&R.12,12(&R.13)        SAVE REGISTERS
         AIF   (T'&GETMAINS EQ 'O').NONR1   NON-R BYPASS
.*--------------------------------------------------------------------*
.*      RE-ENTRANT PROG                                               *
.*--------------------------------------------------------------------*
         LR    2,15                         LOAD R2 WITH START OF PR
         USING &NAME,2                      USE R2 AS TEMPORARY BASE
.*--------------------------------------------------------------------*
         AIF (T'&LOC EQ 'O').NOGMLOC
*        GETMAIN R,LV=&GETMAINL,&LOC        GETMAIN AREA
         GETMAIN R,LV=&GETMAINL,&LOC        GETMAIN AREA
         AGO   .A$$000
.NOGMLOC ANOP
*        GETMAIN R,LV=&GETMAINL             GETMAIN AREA
         GETMAIN R,LV=&GETMAINL             GETMAIN AREA
.A$$000  ANOP
.*--------------------------------------------------------------------*
         ST    &R.13,4(&R.1)                BACKWARD CHAIN
         ST    &R.1,8(&R.13)                FORWARD CHAIN
.*--------------------------------------------------------------------*
.* The next line does horrible things with 31 bit addressing.         *
.*       NI    12(&R.13),X'00'              CLEAR TRACE BITS
.*--------------------------------------------------------------------*
         LR    &R.13,&R.1                   SAVE AREA @
         AIF   (T'&DREG EQ 'O').NDREG1      NO 2ND.DSECT REG, BYPASS
         LA    &DREG,4095(&R.13)            POINT 2ND. REG 1K PAST
         LA    &DREG,1(&DREG)                 1ST. DSECT BASE
.NDREG1  ANOP
         USING &GETMADR,&R.13&#DREG         ADDRESABILITY TO GETMAIN
         LR    &BASE1,&R.2                  &BASE1 IS 1ST. BASE REG
         DROP  &R.2                         DROP REGISTER 15 AS BASE
         AIF      (&#BASES GT 1).TWOBASE
         USING &E,&BASE1                    USING ONE BASE REGISTER
         AGO      .RESTR0R2
.NONR1   ANOP
.*--------------------------------------------------------------------*
.*      NON RE-ENTRANT PROG                                           *
.*--------------------------------------------------------------------*
         USING &NAME,15                     USE R15 AS TEMPORARY BASE
         ST    &R.13,&SAVREGS.+4            BACKWARD CHAIN
         LA    &R.0,&SAVREGS                OUR SAVEAREA ADDRESS
         ST    &R.0,8(&R.13)                FORWARD CHAIN
.*--------------------------------------------------------------------*
.* The next line does horrible things with 31 bit addressing.         *
.*       NI    12(&R.13),X'00'              CLEAR TRACE BITS
.*--------------------------------------------------------------------*
         LR    13,0                         R13 POINT TO OUR SAVEAREA
         AIF ('&E' EQ '&SAVREGS').NOLOAD1   BUPASS BASE LOAD
         LR    &BASE1,15                    &BASE1 IS 1ST. BASE REG
.NOLOAD1 ANOP
         AIF      (&#BASES GT 1).TWOBASE
         DROP  15                           RELINQUISH ADDRESSABILITY
         USING &E,&BASE1                    USING ONE BASE REGISTER
         AGO      .ADROK
.TWOBASE ANOP
         LA    &BASE2,4095(&BASE1)          POINT 2ND. REG 1K PAST
         LA    &BASE2,1(&BASE2)               1ST. BASE
         AIF      (&#BASES GT 2).THRBASE
         DROP  15                           RELINQUISH ADDRESSABILITY
         USING &E,&BASE1,&BASE2             USING TWO BASE REGISTERS
         AGO      .ADROK
.THRBASE ANOP
         LA    &BASE3,4095(&BASE2)          POINT 3RD. REG 1K PAST
         LA    &BASE3,1(&BASE3)               2ND. BASE
         DROP  15                           RELINQUISH ADDRESSABILITY
         USING &E,&BASE1,&BASE2,&BASE3      USING THREE BASE REGISTERS
.*       AGO      .ADROK
.ADROK   ANOP
         AIF   (T'&GETMAINS NE 'O').RESTR0R2 RE-ENT PROCESSING
         LA    1,&E                         ADDRESS OF CSECT
         LA    0,&SAVREGS                   NEW BASE ADDRESS
         SR    1,0                          SUBTRACT THE DIFFERENCE
         STH   1,KOFFCOMP                   STORE UNDER @ COMPENSATOR
         B     &SAVREGS.+74                 BRANCH AROUND SAVE AREA
&SAVREGS DS    18F
KOFFCOMP DS    H                            KICKOFF BASE @ COMPENSATOR
         XR    &R.0,&R.0                    ZERO REGISTER 0
         ST    &R.0,&SAVREGS.+8             CLEAR FORWARD CHAIN
         L     &R.1,4(&R.13)                LOAD CALLERS SAVEAREA @
         LM    &R.0,&R.1,20(&R.1)           RESTORE PARM REGISTERS
         AGO   .MEXIT1
.*--------------------------------------------------------------------*
.RESTR0R2 ANOP
.*--------------------------------------------------------------------*
.*      RE-ENTRANT PROG                                               *
.*--------------------------------------------------------------------*
         XR    &R.0,&R.0                    ZERO REGISTER 0
         ST    &R.0,8(&R.13)                CLEAR FORWARD CHAIN
         L     &R.1,4(&R.13)                LOAD CALLERS SAVEAREA @
         LM    &R.0,&R.2,20(&R.1)           RESTORE PARM REGISTERS
         AGO   .MEXIT1
.*--------------------------------------------------------------------*
.ERR     MNOTE 8,'MUST SUPPLY WORK-AREA DSECT FOR GETMAIN.'
         AGO   .MEXIT1
.ERR2    MNOTE 8,'MUST SUPPLY WORK-AREA DSECT LENGTH FOR GETMAIN.'
         AGO   .MEXIT1
.ERR3    MNOTE 8,'NO MATCHING RACKOFF FOR PREVIOUS KICKOFF.'
         AGO   .MEXIT1
.ERRR13  MNOTE 8,'R13 CANNOT BE USED AS BASE FOR RE-ENTRANT MACRO.'
         AGO   .MEXIT1
.ERDREG  MNOTE 8,'XTRA DSECT REGISTER MUST NOT BE A BASE OR R13.'
         AGO   .MEXIT1
.MEXIT1  ANOP
         AIF   ('&LIST'(1,1) NE 'N').MEXIT9
         POP PRINT
.MEXIT9  ANOP
*---------------------------------------------------------------------*
         MEXIT
.*--------------------------------------------------------------------*
         MEND
*---------------------------------------------------------------------*
*------- Macro  2. RACKOFF -------------------------------------------*
         MACRO                                                          RAC00010
&NAME    RACKOFF &RC=0,&LIST=NO,&R1=,&HELP=NO                           RAC00020
         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'RACKOFF' parameter     *
* and it's use, pass parameter 'HELP=Yes'.                            *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
*---------------------------------------------------------------------*
* Parameters:                                                         *
*                                                                     *
*        RC=n       - Numeric return code (default = 0)               *
*                             - or -                                  *
*                     RC=(R15) if R15 contains the return code        *
*        LIST=Y/N   - Generate code from macro expansion (def = NO)   *
*        HELP=Y/N   - Display this help box (def = Yes)               *
*        R1=PASS    - 'PASS' infers that R1 contains return parameter *
*                     value to the caller and is to remain as is. Any *
*                     other value will include R1 in the register     *
*                     restoration command 'LM  R14,R12,....'          *
*---------------------------------------------------------------------*
.A$HELPE ANOP
         PUSH  PRINT
         AIF   ('&LIST'(1,1) NE 'N').A$XX
         PRINT NOGEN
.A$XX    ANOP
         AIF   (T'&NAME EQ 'O').NONAME
&NAME    DS    0H                                                       RAC00020
.NONAME  ANOP
         GBLC  &R,&GETMADR,&GETMADL,&SAVREGS
&KO1STR  SETB 0                             TURN 1ST TIME THRU OFF
         AIF   (T'&GETMADL EQ 'O').A$10     NON-R BYPASS
         AIF   (T'&R1 EQ 'O').A$00          DO NOT PASS R1
         AIF   ('&R1' NE 'PASS').A$00       IF R1¬=PASS DO NOT PASS R1
         LR    &R.3,&R.1                    SAVE REGISTER 1 IN CASE
.A$00    ANOP
         LR    &R.1,&R.13                   LOAD GETMAINED AREA ADDRESS
         LR    &R.2,&R.15                   SAVE REGISTER 15 IN CASE
.A$10    ANOP
         L     &R.13,4(&R.13)               LOAD CALLERS SAVEAREA @     RAC00040
         AIF   (T'&GETMADL EQ 'O').A$20     NON-R BYPASS
*        FREEMAIN R,LV=&GETMADL,A=(1)
         FREEMAIN R,LV=&GETMADL,A=(1)
.A$20    ANOP
         AIF   (T'&R1 EQ 'O').A$21          DO NOT PASS R1
         AIF   ('&R1' NE 'PASS').A$21       IF R1¬=PASS DO NOT PASS R1
         LR    &R.1,&R.3                    RESTORE R1
.A$21    ANOP
         AIF   ('&RC' EQ '(R15)').SPEC      R15 CONTAINS RC             RAC00050
         AIF   ('&RC' EQ '(15)').SPEC R15 CONTAINS RC                   RAC00060
         AIF   (T'&R1 EQ 'O').A$22          DO NOT PASS R1
         AIF   ('&R1' NE 'PASS').A$22       IF R1¬=PASS DO NOT PASS R1
         LM    &R.14,&R.0,12(&R.13)         RESTORE REGISTERS 14-0      RAC00070
*                                           LEAVE R1 AS IS
         LM    &R.2,&R.12,28(&R.13)         RESTORE REGISTERS 2-12      RAC00070
         AGO   .A$23                                                    RAC00090
.A$22    ANOP
         LM    &R.14,&R.12,12(&R.13)        RESTORE REGISTERS 14-12     RAC00070
.A$23    ANOP
         LA    &R.15,&RC                    SET RETURN CODE             RAC00080
         AGO   .RET1                                                    RAC00090
.SPEC    ANOP                                                           RAC00100
         AIF   (T'&GETMADL EQ 'O').A$30     NON-R BYPASS
         LR    &R.15,&R.2                   RESTORE R15 FROM ABOVE SAVE RAC00100
.A$30    ANOP
         L     &R.14,12(&R.13)              RESTORE R14                 RAC00100
         AIF   (T'&R1 EQ 'O').A$32          DO NOT PASS R1
         AIF   ('&R1' NE 'PASS').A$32       IF R1¬=PASS DO NOT PASS R1
         L     &R.0,20(&R.13)               RESTORE REGISTER 0          RAC00110
*                                           LEAVE R1 AS IS
         LM    &R.2,&R.12,28(&R.13)         RESTORE REGISTERS 2-12      RAC00110
         AGO   .RET1                                                    RAC00090
.A$32    ANOP
         LM    &R.0,&R.12,20(&R.13)         RESTORE REGISTERS 0-12      RAC00110
.RET1    ANOP                                                           RAC00120
.*--------------------------------------------------------------------*
.* The next line does horrible things with 31 bit addressing.         *
.*       MVI   12(&R.13),X'FF'              SET TRACE BITS ON           RAC00120
.*--------------------------------------------------------------------*
         BR    &R.14                        RETURN                      RAC00130
         POP   PRINT
*---------------------------------------------------------------------*
         MEXIT
.*--------------------------------------------------------------------*
.E1      POP   PRINT
         MNOTE 8,'MACRO KICKOFF MUST BE USED WITH THIS MACRO.'
         MEXIT
.*--------------------------------------------------------------------*
         MEND                                                           KIC00710
*---------------------------------------------------------------------*
*------- Macro  3. UNPACK --------------------------------------------*
         MACRO
&NAME    UNPACK &REG,&PL,&OUT,&MF=,&LIST=NO,&HELP=NO
         AIF   ('&HELP' EQ 'YES').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'UNPACK' parameters     *
* and it's use, pass parameter of 'HELP=Yes'.                         *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
*---------------------------------------------------------------------*
* Macro to unpack a register into a variable.                         *
*                                                                     *
*   PARAMETERS:                                                       *
*       1. Register holding contents                                  *
*       2. Length to unpack                                           *
*       3. Output field (default "upout(8)")                          *
*       4. MF=E/L for re-entrant programs.  (Not required for non     *
*          re-entrant programs.)                                      *
*       5. LIST=YES/NO, to determine generation of macro statements.  *
*                                                                     *
*   NOTE:                                                             *
*       For re-entrant programs the list format only requires the     *
*       MF= parameter,                                                *
*            eg.      UNPACK MF=L                                     *
*                                                                     *
*---------------------------------------------------------------------*
.A$HELPE ANOP
         PUSH  PRINT
         AIF   ('&LIST' NE 'NO').A$XX
         PRINT NOGEN
.A$XX    ANOP
         AIF   (T'&NAME EQ 'O').A$YY
&NAME    DS    0H
.A$YY    ANOP
         AIF   ('&MF' EQ 'L').A$ZZ
         AIF   (T'&REG EQ 'O').E1
         AIF   (T'&PL EQ 'O').E2
.A$ZZ    ANOP
         GBLC  &TNAME
         LCLC  &UPWORK,&UPOUT
         GBLB  &UNPFST1,&UNPFST2
         AIF   (&UNPFST1).A$00
&UNPFST1 SETB  1
&TNAME   SETC  'UPK'.'&SYSNDX'
.A$00    ANOP
&UPWORK  SETC  '&TNAME'.'1'
&UPOUT   SETC  '&TNAME'.'2'
         AIF   ('&MF' EQ 'E').A$99          BYPASS IF EXEC FORM OF MAC
         AIF   ('&MF' EQ 'L').A$11          BYPASS IF LIST FORM OF MAC
         AIF   (&UNPFST2).A$99
&UNPFST2 SETB  1
         B     &TNAME.3                    BRANCH AROUND DATA
.*--------------------------------------------------------------------*
.*       DATA STORAGE                                                 *
.*--------------------------------------------------------------------*
.A$11    ANOP
&UPWORK  DS    D
&UPOUT   DS    CL8
         AIF   ('&MF' EQ 'L').EXIT         BYPASS IF LIST FORM OF MAC
.*--------------------------------------------------------------------*
&TNAME.3 DS    0H
.A$99    ANOP
         CVD   &REG,&UPWORK
         OI    &UPWORK+7,X'0F'
         UNPK  &UPOUT.(8),&UPWORK+8-&PL.(&PL.)
         AIF   (T'&OUT EQ 'O').EXIT
         MVC   &OUT.(&PL.),&UPOUT+8-&PL.
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E1      MNOTE 12,'UNPACK REQUIRES SOURCE A REGISTER'
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E2      MNOTE 12,'UNPACK REQUIRES A LENGTH'
.*--------------------------------------------------------------------*
.EXIT    ANOP
         POP   PRINT
         MEXIT
         MEND
*---------------------------------------------------------------------*
*------- Macro  4. CLEARV --------------------------------------------*
         MACRO
&NAME    CLEARV &OUT,&LENGTH,&PAD=40,&MF=,&LIST=YES,&HELP=NO
         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'CLEARV'  parameters    *
* and it's use, pass parameter of 'HELP=Yes'.                         *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
*---------------------------------------------------------------------*
*                                                                     *
*   Move a particular pad character to any variable. The variable may *
*   be > 256 characters.                                              *
*                                                                     *
*   For variable < 258: uses a ripple move.                           *
*       variable > 257: uses the MVCL instruction.                    *
*                                                                     *
*   NOTE : - All registers are kept in tact by this macro.            *
*                                                                     *
*   PARAMETERS:                                                       *
*     1. Destination variable's name.                                 *
*     2. Length of the variable. To be supplied if the "L'varname"    *
*        function will not return the required length.                *
*     3. PAD=xx - HEX notation of the pad character. The default is   *
*                 X'40' (ie. spaces).                                 *
*     3. MF=E/L - Macro format. For re-entrant programs, MF=L is      *
*                 required as the macro requires a register save area.*
*                 It uses a common save area with other macros,       *
*                 however, the first macro reserves the storage and it*
*                 may be this one.                                    *
*     4. HELP=YES/NO - to generate these comments.                    *
*     5. LIST=YES/NO - to generate a list of commands generated.      *
*                                                                     *
*---------------------------------------------------------------------*
.A$HELPE ANOP
         PUSH  PRINT
         AIF   ('&LIST'(1,1) NE 'N').A$XX
         PRINT NOGEN
.A$XX    ANOP
         LCLC  &CLNAME
         LCLA  &VLENGTH,&LT258L
.*--------------------------------------------------------------------*
         AIF   ('&MF' EQ 'L').A$YY
         AIF   (T'&OUT EQ 'O').E1
         AIF   (T'&LENGTH EQ 'O').NOLEN
.A$YY    ANOP
&VLENGTH SETA  &LENGTH
         AGO   .CONT1
.NOLEN   ANOP
&VLENGTH SETA  L'&OUT
.CONT1   ANOP
         AIF   (&VLENGTH LT 258).A$RD
.*--------------------------------------------------------------------*
         AIF   ('&MF' EQ 'L').A$00
.A$00    ANOP
         GBLB  &CLFIRST
         GBLC  &CLBYP1
.*--------------------------------------------------------------------*
         GBLC  &REGSAVR,&REGSMCR
         GBLB  &REGSFLG,&REGDFLG
         AIF   (&REGSFLG).A$RS
&REGSAVR SETC  'GB'.'&SYSNDX'.'#'
&REGSMCR SETC  'CLEARV'
&REGSFLG SETB  1
.A$RS    ANOP
.*--------------------------------------------------------------------*
         AIF   ('&MF' EQ 'E').A$88
         AIF   (&CLFIRST).A$88
&CLFIRST SETB  1
&CLNAME  SETC  'CL'.'&SYSNDX'
&CLBYP1  SETC  '&CLNAME'.'1'
.*--------------------------------------------------------------------*
.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *
.*--------------------------------------------------------------------*
         AIF   (&REGDFLG).A$RD
&REGDFLG SETB  1
         AIF   ('&MF' EQ 'L').A$77
         B     &CLBYP1                 BRANCH AROUND REGISTER SAVEAREA
.A$77    ANOP
&REGSAVR DS    16F                     REGISTER SAVE AREA
         AIF   ('&MF' EQ 'L').EXIT
&CLBYP1  DS    0H
.A$RD    ANOP
         AIF   ('&MF' EQ 'L').EXIT
.*--------------------------------------------------------------------*
.A$88    ANOP
         AIF   (&VLENGTH GT 257).A$99
*  Ripple move                                                        *
&LT258L  SETA  &VLENGTH-1
         MVI   &OUT,X'&PAD'            MOVE PAD CHARACTER
         MVC   &OUT+1(&LT258L),&OUT    RIPPLE MOVE TO REST OF VARIABLE
         AGO   .EXIT
.A$99    ANOP
*  MVCL instruction move                                              *
         STM   R14,R1,&REGSAVR         SAVE REGISTERS
         LA    R0,&OUT                 LOAD ADDRESS OF VARIABLE
         L     R1,=F'&VLENGTH'         LOAD LENGTH OF VARIABLE
         XR    R14,R14                 CLEAR SOUREC ADDRESS
         XR    R15,R15                 CLEAR SOURCE LENGTH
         ICM   R15,B'1000',=X'&PAD'    MOVE PAD CHARACTER
         MVCL  R0,R14                  SET AREA TO ALL SPACES
         LM    R14,R1,&REGSAVR         RESTORE SAVED REGISTERS
.*--------------------------------------------------------------------*
.EXIT    ANOP
         AGO   .MEXIT1
.*--------------------------------------------------------------------*
.E1      MNOTE 12,'CLEAR BIG REQUIRES A DESTINATION VARIABLE.'
         AGO   .MEXIT1
.E2      MNOTE 12,'CLEAR BIG LONG REQUIRES A LENGTH.'
.MEXIT1  ANOP
         AIF   ('&LIST'(1,1) EQ 'Y').A$ZZ
         POP PRINT
.A$ZZ    ANOP
         MEND
*---------------------------------------------------------------------*
*------- Macro  6. HEXCHMAC ------------------------------------------*
         MACRO
&NAME    HEXCHMAC &SOURCE,&TARGET,&LENGTH,&MF=,&LIST=NO,&LABEL=YES,    +
               &HELP=NO,&INIT=NO,&DSECT=NO
         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'HEXCHMAC' parameter    *
* and it's use, pass parameter 'HELP=Yes'.                            *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
*---------------------------------------------------------------------*
*                                                                     *
* CONVERT HEX TO CHARACTERS.                                          *
* --------------------------                                          *
*           N O T E - N O T E - N O T E - N O T E - N O T E           *
*                                                                     *
*   This routine saves and uses general registers 1, 14 & 15.         *
*   14 will be altered on return from the macro.                      *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*   Parameters:-                                                      *
*       1. Source                                                     *
*       2. Target (the target needs 2 times the length of source)     *
*       3. Length                                                     *
*       4. MF=E/L -  Macro format for re-entrant programs             *
*       5. LABEL=YES/NO - Generate data labels. Used for re-entrant   *
*                         programs with MF=L and you wish to move the *
*                         constant value from the CSECT over the      *
*                         the GETMAIN'ed DSECT.                       *
*                         The default is 'YES'. The parameter can be  *
*                         ignored if NOTE 2 option is observed.       *
*       6. LIST=YES/NO - Option to generate macro expansion or not    *
*       7. HELP=YES/NO - Option to print these help details. Default  *
*                        is 'YES'.                                    *
*       8. INIT=YES/NO - Initialise MF=E macro to repeat common code  *
*                        for multi-DSECT programs. 'NO' is the        *
*                        default.                                     *
*       9. DSECT=Y/N   - If DSECT=Y, the translate table is defided   *
*                        as storage (DS) not constant (DC).           *
*                        Should be used with MF=L.                    *
*                                                                     *
*   NOTE:-                                                            *
*       1. Parameters may be passed in registers using the (Rn)       *
*          notation (Note cannot have digits).                        *
*       2. For execute form of the macro (MF=E) the first occurence of*
*          the macro must be the first one executed. If a branch      *
*          causes a initial loop around it, insert a dummy macro to   *
*          perform a conversion into work areas or use the LABEL=NO   *
*          parameter.                                                 *
*                                                                     *
*---------------------------------------------------------------------*
.A$HELPE ANOP
         AIF   ('&LIST'(1,1) NE 'N').A$XX
         PUSH  PRINT
         PRINT NOGEN
.A$XX    ANOP
&NAME    DS    0H
         LCLC  &#LENGTH,&#SOURCE,&#TARGET
         LCLA  &LEN
         GBLC  &XNAME,&XCBAL,&XCBYPAS,&XCLOOP
         GBLC  &XCBYTES,&XCBYTE1,&XCBYTE2,&XCTABLE,&XCRETAD
         GBLB  &XC1ST,&XC1NAME
.*--------------------------------------------------------------------*
         GBLC  &REGSAVR,&REGSMCR
         GBLB  &REGSFLG,&REGDFLG
         AIF   ('&INIT'(1,1) NE 'Y').A$YY  BYPASS IF NOT INITIALISE
&XC1ST   SETB  0
&XNAME   SETC  'XC'.'&SYSNDX'
&XCBAL   SETC  '&XNAME'.'06'
&XCLOOP  SETC  '&XNAME'.'07'
&XCBYPAS SETC  '&XNAME'.'08'
&XCRETRN SETC  '&XNAME'.'EX'
.A$YY    ANOP
.*--------------------------------------------------------------------*
         AIF   (&REGSFLG).A$RS
&REGSAVR SETC  'GB'.'&SYSNDX'.'#'
&REGSMCR SETC  'HEXCHMAC'
&REGSFLG SETB  1
.A$RS    ANOP
.*--------------------------------------------------------------------*
         AIF   (&XC1NAME).A$$0
&XNAME   SETC  'XC'.'&SYSNDX'
&XCRETAD SETC  '&XNAME'.'01'
&XCTABLE SETC  '&XNAME'.'02'
&XCBYTES SETC  '&XNAME'.'03'
&XCBYTE1 SETC  '&XNAME'.'04'
&XCBYTE2 SETC  '&XNAME'.'05'
&XCBAL   SETC  '&XNAME'.'06'
&XCLOOP  SETC  '&XNAME'.'07'
&XCBYPAS SETC  '&XNAME'.'08'
&XCRETRN SETC  '&XNAME'.'EX'
&XC1NAME SETB  1
         AGO   .A$$0
.*--------------------------------------------------------------------*
.A$$0    ANOP
&XCRETRN SETC  'XC'.'&SYSNDX'.'EX'
.A$$1    ANOP
         AIF   ('&MF' EQ 'L').RENT1    IF MF=L PARAMETER PASSED BYPASS
         AIF   (T'&SOURCE EQ 'O').E1   IF PARM 1 NOT PASSED ERROR
         AIF   (T'&TARGET EQ 'O').E2   IF PARM 2 NOT PASSED ERROR
         AIF   (T'&LENGTH EQ 'O').E3   IF PARM 3 NOT PASSED ERROR
         AIF   ('&SOURCE'(1,1) EQ '(').A$01
&#SOURCE SETC  '&SOURCE'
         AGO   .A$02
.A$01    ANOP
&#SOURCE SETC  '0(&SOURCE(1))'
.A$02    ANOP
         AIF   ('&TARGET'(1,1) EQ '(').A$03
&#TARGET SETC  '&TARGET'
         AGO   .A$04
.A$03    ANOP
&#TARGET SETC  '0(&TARGET(1))'
.A$04    ANOP
         AIF   (&XC1ST).A$11           IF NOT 1ST. TIME THRU
         AIF   (T'&MF EQ 'O').NONR1    IF NON-RE PROGRAM BYPASS
*  EXEC FORM OF MACRO 'HEXCHMAC'                                      *
*---------------------------------------------------------------------*
.*       MVC   &XCTABLE.(16),=C'0123456789ABCDEF'
         B     &XCBYPAS                BYPASS COMMON CODE
         AGO   .RENT2                  BYPASS NON-RE PROCESS
.NONR1   ANOP
*  NORMAL FORM OF MACRO 'HEXCHMAC'                                    *
*---------------------------------------------------------------------*
         B     &XCBYPAS                BYPASS DATA + COMMON CODE
*---------------------------------------------------------------------*
         AGO   .NONR2                  BYPASS RE-ENT PROCESS
.RENT1   ANOP
*---------------------------------------------------------------------*
*  LIST FORM OF MACRO 'HEXCHMAC'                                      *
*---------------------------------------------------------------------*
.NONR2   ANOP
         AIF   (T'&MF EQ 'O').LABON1
         AIF   ('&LABEL'(1,1) EQ 'Y').LABON1
         DS    0F                      WORD ALIGN
         DS    F                       RETURNN ADDRESS SAVE AREA
         AIF   (T'&DSECT EQ 'O').DCTT1
         AIF   ('&DSECT'(1,1) EQ 'N').DCTT1
         DS    CL16                    TRANSLATE TABLE
         AGO   .DCTT1D
.DCTT1   ANOP
         DC    C'0123456789ABCDEF'     TRANSLATE TABLE
.DCTT1D  ANOP
         DS    0CL2                    BYTE SAVE AREA
         DS    CL1                     1ST. BYTE
         DS    CL1                     2ND. BYTE
         AGO   .LABDONE
.LABON1  ANOP
         DS    0F                      WORD ALIGN
&XCRETAD DS    F                       RETURNN ADDRESS SAVE AREA
         AIF   (T'&DSECT EQ 'O').DCTT2
         AIF   ('&DSECT'(1,1) EQ 'N').DCTT2
&XCTABLE DS    CL16                    TRANSLATE TABLE
         AGO   .DCTT2D
.DCTT2   ANOP
&XCTABLE DC    C'0123456789ABCDEF'     TRANSLATE TABLE
.DCTT2D  ANOP
&XCBYTES DS    0CL2                    BYTE SAVE AREA
&XCBYTE1 DS    CL1                     1ST. BYTE
&XCBYTE2 DS    CL1                     2ND. BYTE
.LABDONE ANOP
.*--------------------------------------------------------------------*
.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *
.*--------------------------------------------------------------------*
         AIF   (&REGDFLG).A$RD
         AIF   ('&LABEL'(1,1) EQ 'Y').LABON2 BYPASS IF LABEL REQUIRED
         AIF   ('&REGSMCR' NE 'HEXCHMAC').A$RD
         DS    0F                      WORD ALIGN
         DS    16F                     REGISTER SAVE AREA
         AGO   .A$RD                   DO NOT SET FLAG IF LABEL REQD
.LABON2  ANOP
&REGDFLG SETB  1
         DS    0F                      WORD ALIGN
&REGSAVR DS    16F                     REGISTER SAVE AREA
.A$RD    ANOP
.*--------------------------------------------------------------------*
.RENT2   ANOP
*---------------------------------------------------------------------*
         AIF   ('&MF' EQ 'L').EXIT
*                                                                     *
*        CONVERT HEX TO CHARACTERS.                                   *
*                                                                     *
*         R1=SOURCE, R14=TARGET, R15=LENGTH                           *
*                                                                     *
*---------------------------------------------------------------------*
&XCBAL   DS    0H
         XR    0,0                     INITIALISE REGISTER
         AIF   (T'&MF EQ 'O').NONR3    IF NON-RE PROGRAM BYPASS
         MVC   &XCTABLE.(16),=C'0123456789ABCDEF'
.NONR3   ANOP
&XCLOOP  DS    0H
         IC    0,0(1)                  INSERT CHARACTER FOR TRANS'TN
         SRL   0,4                     GET RID OF RIGHT NIBBLE
         STC   0,&XCBYTE1              STORE LEFT NIBBLE
         TR    &XCBYTE1,&XCTABLE       TRANSLATE NIBBLE TO CHATACTER
         MVC   0(1,14),&XCBYTE1        MOVE TO DESTINATION
         MVC   &XCBYTE1,0(1)           MOVE CHARACTER TO WORK AREA
         NI    &XCBYTE1,15             AND WITH X'0F' REMOVE LEFT NIB
         TR    &XCBYTE1,&XCTABLE       TRANSLATE TO CHARACTER
         MVC   1(1,14),&XCBYTE1        MOVE CHAR TO DESTINATION
         LA    1,1(1)                  UP SOURCE BY 1
         LA    14,2(14)                UP DESTINATION BY 2
         BCT   15,&XCLOOP              BRANCH TILL END
         L     14,&XCRETAD             LOAD RETURN ADDRESS
         BR    14                      RETURN TO CALLER
&XCBYPAS DS    0H
.A$11    ANOP
         STM   14,12,&REGSAVR          SAVE REGISTERS
         LA    1,&XCRETRN              LOAD RETURN ADDRESS
         ST    1,&XCRETAD              STORE RETURN ADDRESS
         LA    1,&#SOURCE              SET UP TO SOURCE ADDRESS
         LA    14,&#TARGET             STORE RESULT AT LEFT OF CUR LINE
         AIF   ('&LENGTH'(1,1) NE '(').ACTLEN
&LEN     SETA  K'&LENGTH-2
&#LENGTH SETC  '&LENGTH'(2,&LEN)       REGISTER
         LR    15,&#LENGTH             LENGTH TO BE CONVERTED
         AGO   .FINLMV  ANOP           PASS AROUND
.ACTLEN  ANOP
         LA    15,&LENGTH              LENGTH TO BE CONVERTED
.FINLMV  ANOP
         B     &XCBAL                  GO TO HEX => CHAR ROUTINE
&XCRETRN DS    0H
         LM    14,12,&REGSAVR          RESTORE REGISTERS
*---------------------------------------------------------------------*
&XC1ST   SETB  1
         AGO   .EXIT
.*--------------------------------------------------------------------*
.*       ERROR MESSAGES                                               *
.*--------------------------------------------------------------------*
.E1      MNOTE 8,'HEXCH REQUIRES A SOURCE FIELD'
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E2      MNOTE 8,'HEXCH REQUIRES A TARGET FIELD'
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E3      MNOTE 8,'HEXCH REQUIRES A LENGTH'
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E4      MNOTE 8,'INVALID "MF" PARAMETER PASSED'
         AGO   .EXIT
.*--------------------------------------------------------------------*
.EXIT    ANOP
         AIF   ('&LIST'(1,1) NE 'N').EXIT9
         POP   PRINT
.EXIT9   ANOP
         MEXIT
         MEND
*---------------------------------------------------------------------*
*------- Macro  7. CHHEXMAC ------------------------------------------*
         MACRO
&NAME    CHHEXMAC &SOURCE,&TARGET,&LENGTH,&ERRRTN,&MF=,&LIST=NO,       +
               &LABEL=YES,&HELP=NO
         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'CHHEXMAC' parameter    *
* and it's use pass parameter 'HELP=Yes'.                             *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
*---------------------------------------------------------------------*
*                                                                     *
*   CONVERT CHARACTERS TO HEX.                                        *
*   --------------------------                                        *
*           N O T E - N O T E - N O T E - N O T E - N O T E           *
*                                                                     *
*   This routine saves and uses general registers 1, 14 & 15.         *
*   R14 and R15 will be altered on return from the macro.             *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*   Parameters:-                                                      *
*       1. Source                                                     *
*       2. Target                                                     *
*       3. Length                                                     *
*       4. Error routine in case of error or a one byte (two character*
*          hex value  quoted, ie. 'xx') value to convert invalid      *
*          characters to and then continue.                           *
*          NOTE - An invalid supplied HEX substitution parameter will *
*                 result in X'00' substitution.                       *
*       5. MF=E/L -  Macro format for re-entrant programs             *
*       6. LABEL=YES/NO - Generate data labels. Used for reentrant    *
*                         programs with MF=L and you wish to move the *
*                         constant value from the CSECT over the      *
*                         the getmain'ed DSECT.                       *
*                         The default is 'YES'. the parameter can be  *
*                         ignored if note 2 option is observed.       *
*       7. LIST=YES/NO - Option to generate macro expansion or not    *
*       8. HELP=YES/NO - Option to print these help details. default  *
*                        is 'YES'.                                    *
*                                                                     *
*                                                                     *
*   If "error routine" = 'xx' (quoted) format then on return from     *
*   macro, R15 will be:-                                              *
*       set to - 0 if all conversion OK                               *
*       set to - 8 if conversion error found                          *
*                                                                     *
*   NOTE:-                                                            *
*       1. Parameters may be passed in registers using the (Rn) or    *
*          d(Rn) (for register displacement) notation.                *
*          NOTE - cannot have digits).                                *
*       2. For execute form of the macro (MF=E) the first occurence of*
*          the macro must be the first one executed. If a branch      *
*          causes a initial loop around it, insert a dummy macro to   *
*          perform a conversion into work areas or use the LABEL=NO   *
*          parameter.                                                 *
*                                                                     *
*---------------------------------------------------------------------*
.A$HELPE ANOP
         PUSH  PRINT
         AIF   ('&LIST'(1,1) NE 'N').A$XX
         PRINT NOGEN
.A$XX    ANOP
.*--------------------------------------------------------------------*
         GBLC  &CXBAL,&CXBYPAS,&CXLOOP,&CXBYTES,&CXBYTE1,&CXBYTE2
         GBLC  &CXBADAT,&CXTABLE,&CXIGERR,&CXER1BR,&CXER2BR
         GBLC  &CXER1BS,&CXER2BS,&CXRTADR
         GBLC  &CXCHOK1,&CXERSUB,&CXERRCH,&CXRTCOD,&CXCHXT1,&CXR1SAV
         GBLB  &CX1NAME,&CX1ST
         LCLC  &#LENGTH,&#SOURCE,&#TARGET,&#ERRRTN
         LCLA  &LEN
.*--------------------------------------------------------------------*
         GBLC  &REGSAVR,&REGSMCR
         GBLB  &REGSFLG,&REGDFLG
         AIF   (&REGSFLG).A$RS
&REGSAVR SETC  'GB'.'&SYSNDX'.'#'
&REGSFLG SETB  1
&REGSMCR SETC  'CHHEXMAC'
.A$RS    ANOP
.*--------------------------------------------------------------------*
         AIF   (&CX1NAME).A$$0
         LCLC  &TNAME
&TNAME   SETC  'CX'.'&SYSNDX'
&CXTABLE SETC  '&TNAME'.'01'
&CXBYTES SETC  '&TNAME'.'02'
&CXBYTE1 SETC  '&TNAME'.'03'
&CXBYTE2 SETC  '&TNAME'.'04'
&CXERRCH SETC  '&TNAME'.'05'
&CXR1SAV SETC  '&TNAME'.'06'
&CXER1BS SETC  '&TNAME'.'07'
&CXER2BS SETC  '&TNAME'.'08'
&CXRTADR SETC  '&TNAME'.'09'
&CXRTCOD SETC  '&TNAME'.'10'
&CXBAL   SETC  '&TNAME'.'11'
&CXLOOP  SETC  '&TNAME'.'12'
&CXIGERR SETC  '&TNAME'.'13'
&CXCHOK1 SETC  '&TNAME'.'14'
&CXBADAT SETC  '&TNAME'.'15'
&CXBYPAS SETC  '&TNAME'.'16'
&CXCHXT1 SETC  '&TNAME'.'EX'
&CX1NAME SETB  1
         AGO   .A$$1                    BYPASS 2ND. INVOCATION
.*--------------------------------------------------------------------*
.A$$0    ANOP
&CXCHXT1 SETC  'CX'.'&SYSNDX'.'EX'
.A$$1    ANOP
         AIF   ('&MF' EQ 'L').RENT1     IF MF=L PARM PASSED BYPASS
         AIF   (T'&SOURCE EQ 'O').E1
         AIF   (T'&TARGET EQ 'O').E2
         AIF   (T'&LENGTH EQ 'O').E3
         AIF   (T'&ERRRTN EQ 'O').E4
.*--------------------------------------------------------------------*
         AIF   ('&SOURCE'(1,1) EQ '(').A$01
&#SOURCE SETC  '&SOURCE'
         AGO   .A$02
.A$01    ANOP
&#SOURCE SETC  '0(&SOURCE(1))'
.A$02    ANOP
         AIF   ('&TARGET'(1,1) EQ '(').A$03
&#TARGET SETC  '&TARGET'
         AGO   .A$04
.A$03    ANOP
&#TARGET SETC  '0(&TARGET(1))'
.A$04    ANOP
&CXERSUB SETC  '''00'''                       SET X'00' FOR SUB
&CXER1BR SETC  '&CXBADAT'                     SET ERROR BRANCH ADDRESS
&CXER2BR SETC  '&CXIGERR'                     SET IGNORE BRANCH ADDRESS
         AIF   ('&ERRRTN'(1,1) NE '''').A$07
&CXERSUB SETC  '&ERRRTN'                      SET IGNORE BRANCH ADDRESS
&CXER1BR SETC  '&CXIGERR'                     SET IGNORE BRANCH ADDRESS
         AGO   .A$10
.A$07    ANOP
         AIF   ('&ERRRTN'(1,1) EQ '(').A$08
&#ERRRTN SETC  '&ERRRTN'
         AGO   .A$09
.A$08    ANOP
&#ERRRTN SETC  '0(&ERRRTN(1))'
.A$09    ANOP
&CXER2BR SETC  '&#ERRRTN'                     SET ERROR ROUTINE ADDRESS
.A$10    ANOP
.*--------------------------------------------------------------------*
         AIF   (&CX1ST).A$11           IF NOT 1ST. TIME THRU
         AIF   (T'&MF EQ 'O').NONR1    IF NON-RE PROGRAM BYPASS
*  EXEC FORM OF MACRO 'CHHEXMAC'                                      *
*---------------------------------------------------------------------*
.*       MVI   &CXTABLE,X'00'          HEX FILL FIRST BYTE THEN RIPPLE
.*       MVC   &CXTABLE.+1(192),&CXTABLE  FILL REST
.*       MVC   &CXTABLE.+193(06),=X'0A0B0C0D0E0F'
.*       MVC   &CXTABLE.+199(41),&CXTABLE FILL REST
.*       MVC   &CXTABLE.+240(10),=X'F0010203040506070809'
.*       MVC   &CXTABLE.+250(06),&CXTABLE FILL REST
         B     &CXBYPAS                BYPASS COMMON CODE
         AGO   .RENT2                  BYPASS NON-RE PROCESS
.NONR1   ANOP
*  NORMAL FORM OF MACRO 'CHHEXMAC'                                    *
*---------------------------------------------------------------------*
         B     &CXBYPAS                BYPASS DATA + COMMON CODE
*---------------------------------------------------------------------*
         AGO   .NONR2                  BYPASS RE-ENT PROCESS
.RENT1   ANOP
*---------------------------------------------------------------------*
*  LIST FORM OF MACRO 'CHHEXMAC'                                      *
*---------------------------------------------------------------------*
.NONR2   ANOP
.*--------------------------------------------------------------------*
         AIF   (T'&MF EQ 'O').LABON
         AIF   ('&LABEL'(1,1) EQ 'Y').LABON
         DS    0CL256
         DC    193X'0'
         DC    X'0A0B0C0D0E0F'
         DC    41X'0'
         DC    X'F0010203040506070809' NOTE - AS ZERO IS VALID
*               /|\                    CHAR 'F0' SUBSTITUTED AND
*                                      LATER CHANGED
         DC    6X'0'
         DS    0CL2                    BOTH BYTE
         DS    CL1                     1ST. BYTE
         DS    CL1                     1ST. BYTE
         DS    CL2                     CHARACTER SUBSTITUTION
         DC    4F'0'                   REGISTER 1 SAVE AREA B/C TRT
         DC    F'0'                    ERROR EXIT SAVE ADDRESS
         DC    F'0'                    ERROR ROUTINE SAVE ADDRESS
         DC    F'0'                    RETURN ADDRESS
         DC    H'0'                    RETURN CODE SAVE AREA
         AGO   .LABDONE
.LABON   ANOP
&CXTABLE DS    0CL256
         DC    193X'0'
         DC    X'0A0B0C0D0E0F'
         DC    41X'0'
         DC    X'F0010203040506070809' NOTE - AS ZERO IS VALID
*               /|\                    CHAR 'F0' SUBSTITUTED AND
*                                      LATER CHANGED
         DC    6X'0'
&CXBYTES DS    0CL2                    BOTH BYTE
&CXBYTE1 DS    CL1                     1ST. BYTE
&CXBYTE2 DS    CL1                     1ST. BYTE
&CXERRCH DS    CL2                     CHARACTER SUBSTITUTION
&CXR1SAV DC    4F'0'                   REGISTER 1 SAVE AREA B/C TRT
&CXER1BS DC    F'0'                    ERROR EXIT SAVE ADDRESS
&CXER2BS DC    F'0'                    ERROR ROUTINE SAVE ADDRESS
&CXRTADR DC    F'0'                    RETURN ADDRESS
&CXRTCOD DC    H'0'                    RETURN CODE SAVE AREA
.LABDONE ANOP
.*--------------------------------------------------------------------*
.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *
.*--------------------------------------------------------------------*
         AIF   (&REGDFLG).A$RD
         AIF   ('&LABEL'(1,1) EQ 'Y').LABON2 BYPASS IF LABEL REQUIRED
         AIF   ('&REGSMCR' NE 'CHHEXMAC').A$RD
         DS    16F                     REGISTER SAVE AREA
         AGO   .A$RD                   DO NOT SET FLAG IF LABEL REQD
.LABON2  ANOP
&REGDFLG SETB  1
&REGSAVR DS    16F                     REGISTER SAVE AREA
.A$RD    ANOP
.*--------------------------------------------------------------------*
.RENT2   ANOP
*---------------------------------------------------------------------*
         AIF   ('&MF' EQ 'L').EXIT
*                                                                     *
*        CONVERT CHARACTERS TO HEX.                                   *
*                                                                     *
*         R1=SOURCE, R14=TARGET, R15=LENGTH                           *
*                                                                     *
*---------------------------------------------------------------------*
&CXBAL   DS    0H
         XC    &CXRTCOD,&CXRTCOD       INITIALISE RETURN CODE
         AIF   (T'&MF EQ 'O').NONR3    IF NON-RE PROGRAM BYPASS
         CLC   &CXTABLE.+193(06),=X'0A0B0C0D0E0F' Q. CONSTANTS SET
         BE    &CXLOOP                               Y. BYPASS
         MVI   &CXTABLE,X'00'          HEX FILL FIRST BYTE THEN RIPPLE
         MVC   &CXTABLE.+1(192),&CXTABLE  FILL REST
         MVC   &CXTABLE.+193(06),=X'0A0B0C0D0E0F'
         MVC   &CXTABLE.+199(41),&CXTABLE FILL REST
         MVC   &CXTABLE.+240(10),=X'F0010203040506070809'
         MVC   &CXTABLE.+250(06),&CXTABLE FILL REST
.NONR3   ANOP
&CXLOOP  DS    0H
         MVC   &CXBYTES.(2),0(1)
         STM   14,1,&CXR1SAV           SAVE 1 BECAUSE OF TRT
         MVI   &CXTABLE,X'F0'          SET HEX 00 TO PASS
         L     14,&CXER1BS             LOAD ERROR EXIT ADDRESS
         TRT   &CXBYTE1.(1),&CXTABLE   Q. IS IT IN &CXTABLE
         BZR   14                         N. ERROR
         TRT   &CXBYTE2.(1),&CXTABLE   Q. IS IT IN &CXTABLE
         BZR   14                         N. ERROR
         B     &CXCHOK1                BOTH BYTES OK
&CXIGERR DS    0H
         MVC   &CXRTCOD.(2),=H'8'      SET ERROR CODE
         MVC   &CXBYTES.(2),&CXERRCH   SET ERROR HEX SUBSTITUTION
&CXCHOK1 DS    0H
         MVI   &CXTABLE,X'00'          RESET HEX 00
         TR    &CXBYTES.(2),&CXTABLE   TRANSLATE BOT CHARS
         NC    &CXBYTES.(2),=X'0F0F'   TURN HIGH NIBL OFF FOR 0 => 'F0'
         LM    14,1,&CXR1SAV           RESTORE 1 BECAUSE OF TRT
         PACK  0(1,14),&CXBYTE1        SWAP NIB OF LEFT &CXBYTE AND STO RE
         OC    0(1,14),&CXBYTE2        OVERLAY 2ND &CXBYTE OVER FIRST
         LA    1,2(1)                  UP SOURCE BY TWO
         LA    14,1(14)                UP DESTINATION BY 1
         BCTR  15,0                    DECREMENT LOOP COUNTER
         BCTR  15,0                           BY 2
         LTR   15,15                   Q. REACHED THE END
         BP    &CXLOOP                    N. LOOP
         L     14,&CXRTADR             LOAD RETURN ADDRESS
         BR    14                      RETURN
&CXBADAT DS    0H
         LM    14,12,&REGSAVR          RESTORE REGISTERS
         LH    15,&CXRTCOD             SET RETURN CODE
         L     14,&CXER2BS             LOAD ERROR ROUTINE ADDRESS
         BR    14                      BRANCH TO ERROR ROUTINE
&CXBYPAS DS    0H
.A$11    ANOP
         STM   14,12,&REGSAVR          SAVE REGISTERS
         MVC   &CXERRCH.(2),=C&CXERSUB MOVE HEX ERROR SUBSTITUTE CHAR
         LA    1,&CXER1BR              LOAD EXIT ADDRESS
         ST    1,&CXER1BS              SAVE EXIT ADDRESS
         LA    1,&CXER2BR              LOAD ERROR ROUTINE ADDRESS
         ST    1,&CXER2BS              SAVE ERROR ROUTINE ADDRESS
         LA    1,&CXCHXT1              LOAD RETURN ADDRESS
         ST    1,&CXRTADR              STORE RETURN ADDRESS
         LA    1,&#SOURCE              SET UP TO SOURCE ADDRESS
         LA    14,&#TARGET             STORE RESULT AT LEFT OF CUR LINE
         AIF   ('&LENGTH'(1,1) NE '(').ACTLEN
&LEN     SETA  K'&LENGTH-2
&#LENGTH SETC  '&LENGTH'(2,&LEN)       REGISTER
         LR    15,&#LENGTH             LENGTH TO BE CONVERTED
         AGO   .FINLMV  ANOP           PASS AROUND
.ACTLEN  ANOP
         LA    15,&LENGTH              LENGTH TO BE CONVERTED
.FINLMV  ANOP
         B     &CXBAL                  GO TO HEX => CHAR ROUTINE
&CXCHXT1 DS    0H
         LM    14,12,&REGSAVR          RESTORE REGISTERS
         LH    15,&CXRTCOD             SET RETURN CODE
*---------------------------------------------------------------------*
&CX1ST   SETB  1
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E1      MNOTE 8,'CHHEX REQUIRES A SOURCE FIELD'
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E2      MNOTE 8,'CHHEX REQUIRES A TARGET FIELD'
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E3      MNOTE 8,'CHHEX REQUIRES A LENGTH'
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E4      MNOTE 8,'CHHEX REQUIRES A CONVERSION ERROR ROUTINE ADDRESS'
.EXIT    ANOP
         POP   PRINT
         MEXIT
.*--------------------------------------------------------------------*
         MEND
*---------------------------------------------------------------------*
*------- Macro  8. ISPVDEFX ------------------------------------------*
         MACRO
&NAME    ISPVDEFX &INM=,&ANM=,&FORMAT=,&LEN=,&OPT=,&MF=,&LIST=NO,      x
               &HELP=NO
         PUSH  PRINT
         AIF   ('&LIST' NE 'NO').A$XX
         PRINT NOGEN
.A$XX    ANOP
         AIF   ('&HELP' EQ 'YES').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'ISPVDEFX' parameter    *
* and it's use, pass parameter 'HELP=Yes'.                            *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
*---------------------------------------------------------------------*
*                                                                     *
* This macro is used to define addressability between a program and   *
* ISPF variables.                                                     *
*                                                                     *
* In the normal form:                                                 *
*   It is designed to create common variables the first time thru and *
*   re-use them everytime the macro is invoked.                       *
* In re-entrant form:                                                 *
*   Use the MF=L and MF=E options.                                    *
*                                                                     *
* Parameters (for further details, refer to ISPF DMS manuals):        *
*   1. INM=..... - ISPF variable name, enclosed in brackets ().       *
*   2. ANM=..... - Internal (assembler) varaiable name.               *
*   3. FORMAT=.. - Variable format, valid values are:                 *
*                        CHAR FIXED BIT HEX DBCS USER                 *
*   4. LEN=..... - Length of the variable in numeric bytes or         *
*                  register (2) - (13). If register is used, the      *
*                  length must be loaded ito the register.            *
*   5. OPT=..... - Options, valid values are:                         *
*                        COPY NOBSCAN LIST                            *
*   6. MF=...... - Macro format. Omit for non re-entrant programs.    *
*                  For re-entrant programs:                           *
*                    E - EXEC format of macro                         *
*                    L - LIST format of macro.                        *
*   7. LIST=..... - Generate or suppress macro expansion, (YES/NO).   *
*                                                                     *
* Example of input:                                                   *
*      ISPVDEFX INM=(ISPFname),ANM=int.name,FORMAT=CHAR,LEN=20        *
*          - OR -                                                     *
*      EXEC format:                                                   *
*        ISPVDEFX INM=(ISPFname),ANM=int.name,FORMAT=CHAR,LEN=20,MF=E *
*      LIST format:                                                   *
*        ISPVDEFX MF=L                                                *
*                                                                     *
*---------------------------------------------------------------------*
.A$HELPE ANOP
&NAME    DS    0H
         GBLC  &VNAME
         GBLB  &VDFX1ST,&VMFE1ST,&VNMF1ST
         LCLA  &LL,&VLL
         LCLC  &REGL
&LL      SETA  K'&LEN
&VLL     SETA  K'&ANM
         AIF   (&VDFX1ST).A$00         IF NOT 1ST. BYPASS
&VDFX1ST SETB  1                       SET 1ST. TIME THRU FLAG
&VNAME   SETC  'IVD'.'&SYSNDX'         SET "INDEX"
.A$00    ANOP
         AIF   ('&MF' EQ 'L').A$11     BYPASS IF RE-ENT
         AIF   ('&MF' EQ 'E').A$33     BYPASS IF RE-ENT
         AIF   (T'&MF NE 'O').E1       INVALID FORMAT OF MF PARM
         AIF   (&VNMF1ST).A$55         BYPASS IF NOT 1ST NON-R
&VNMF1ST SETB  1                       SET 1ST. TIME THRU FLAG
         B     &VNAME.L                BYPASS DATA DEFS AFTER 1ST. THRU
         AGO  .A$111
.A$11    ANOP
*---------------------------------------------------------------------*
*    LIST form of macro 'ISPVDEFX'                                    *
*---------------------------------------------------------------------*
.A$111   ANOP
&VNAME.1 DS    F                       VDEFINE
         DS    F                       ISPF NAME
         DS    F                       INTERNAL NAME
         DS    F                       VAR TYPE
         DS    F                       VAR LENGTH
         DS    F                       OPTION
&VNAME.2 DC    C'VDEFINE '             VDEF LITERAL
&VNAME.3 DC    CL10'          '        ISPF DEST (ALLOW FOR "()")
         DC    C' '                    SPACER
&VNAME.4 DC    C'CHAR    '             VDEF FORMAT TYPE
         DC    C' '                    SPACER
&VNAME.5 DS    CL2                     LENGTH SOURCE PRIOR CONVERSION
         DC    C' '                    SPACER
&VNAME.6 DS    F                       R2 SAVEAREA FOR LEN CONVERSION
&VNAME.7 DS    D                       DBL WD LEN CONVERSION WK FLD
&VNAME.8 DS    F                       LENGTH CONVERTED TO FULL WD BIN
&VNAME.9 DC    C'&OPT    '             OPTIONS (NOT USED BY THIS RTN)
&VNAME.V DS    F                       INTERNAL NAME ADDRESS STORE
*-----------------------------------------------------------------*
         AIF   ('&MF' NE 'L').A$22     BYPASS IF NOT MF=L
         POP   PRINT
         MEXIT                         EXIT IF MF=L
.A$22    ANOP
&VNAME.L DS    0H
         AIF   (T'&MF EQ 'O').A$44     BYPASS IF RE-ENT
.A$33    ANOP
*---------------------------------------------------------------------*
*    EXEC form of macro 'ISPVDEFX'                                    *
*---------------------------------------------------------------------*
.EXMFE   ANOP
         AIF   (&VMFE1ST).A$55          IF NOT 1ST. BYPASS
&VMFE1ST SETB  1                        SET 1ST. TIME THRU FLAG
*    Unique code                                                      *
*---------------------------------------------------------------------*
         MVI   &VNAME.2,C' '            SPACE FILL DATA
         MVC   &VNAME.2+1(55),&VNAME.2  USING RIPPLE MOVE
         MVC   &VNAME.2(7),=C'VDEFINE'  MOVE LITERAL
         AGO   .A$441
.A$44    ANOP
*    Unique code                                                      *
*---------------------------------------------------------------------*
.A$441   ANOP
         ST    R2,&VNAME.6             SAVE REG2
         LA    R2,&VNAME.1             R1 DEST VALUE FOR "CALL"
         LA    R1,&VNAME.2             ADDRESS OF PARAMETER
         ST    R1,0(R2)                STORE ADDRESS
         LA    R2,4(R2)                POINT TO NEXT ADDRESS POS
         LA    R1,&VNAME.3             ETC...
         ST    R1,0(R2)                    "
         LA    R2,4(R2)                    "
         LA    R2,4(R2)                <-- " (ALLOW FOR 'INT NAME @')
         LA    R1,&VNAME.4                 "
         ST    R1,0(R2)                    "
         LA    R2,4(R2)                    "
         LA    R1,&VNAME.8                 "
         ST    R1,0(R2)                    "
         LA    R2,4(R2)                    "
         LA    R1,&VNAME.9                 "
         ST    R1,0(R2)                    "
         MVI   0(R2),X'80'                 "
         L     R2,&VNAME.6                RESET R2
.A$55    ANOP
*-----------------------------------------------------------------*
*    Common code                                                      *
*---------------------------------------------------------------------*
         AIF   (T'&MF EQ 'O').A$66
         MVC   &VNAME.4(8),=CL8'&FORMAT' SET UP "(ISPF-FORM)" VALUE
.A$66    ANOP
         MVC   &VNAME.3(10),=CL10'&INM'   SET UP "(ISPF-NAME)" VALUE
.*--------------------------------------------------------------------*
.* Test if length is supplied in a register
.*--------------------------------------------------------------------*
         AIF ('&LEN'(1,1) NE '(').NREGL
&PL      SETA  K'&LEN
&REGL    SETC  '&LEN'(2,&PL-2)            EXTRACT REGISTER
         ST    &REGL.,&VNAME.8            SAVE REGISTER PASSED LENGTH
         AGO   .FINLEN                    .BYPASS NUMERIC LENGTH
.NREGL   ANOP
         MVC   &VNAME.5(&LL),=CL&LL'&LEN' SET UP LENGTH
         PACK  &VNAME.7,&VNAME.5(&LL)     PACK LENGTH FOR CONVERSION
         CVB   R1,&VNAME.7                CONV LEN TO FULL WD BIN
         ST    R1,&VNAME.8                SAVE CONVERTED  LENGTH
.FINLEN  ANOP
.*--------------------------------------------------------------------*
         LA    R1,&ANM                    ADDRESS OF INTERNAL NAME
         ST    R1,&VNAME.1+8              SAVE INT NAME @
         LA    R1,&VNAME.1                LOAD PARAMETER LIST ADDRESS
         L     15,ISPLINK                 LOAD "ISPLINK" ADDRESS
.*       L     15,=V(ISPLINK)             LOAD "ISPLINK" ADDRESS
         BALR  14,15                      BRANCH AND LINK
         POP   PRINT
         MEXIT
.*--------------------------------------------------------------------*
.E1      MNOTE 8,'INVALID "MF" PARAMETER PASSED'
.*--------------------------------------------------------------------*
         POP   PRINT
         MEND
*---------------------------------------------------------------------*
*------- Macro  9. ISPEXEC -------------------------------------------*
         MACRO
&NAME    ISPEXEC &XTEXT,&XLENG,&LIST=NO,&HELP=NO,&LONG=NO,&INIT=NO,    +
               &MF=,&TYPE=VAR
         PUSH  PRINT
         AIF   ('&LIST' NE 'NO').A$XX
         PRINT NOGEN
.A$XX    ANOP
         AIF   ('&HELP' EQ 'YES').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'ISPEXEC' parameter and *
* it's use, pass parameter 'HELP=Yes'.                                *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
*---------------------------------------------------------------------*
*                                                                     *
* Macro to initialise an "ISPF" environment and set up variables to   *
*   facilitate executing ISPEXEC commands.                            *
*                                                                     *
* Format:                                                             *
*   1. ISPEXEC no.parameter/INIT=Y          (Required on first        *
*                                            execution. Requires both *
*                                            MF=L and MF=E for re-    *
*                                            entrant programs.        *
*   2. ISPEXEC 'normal CLIST type text'                               *
*   3. ISPEXEC int.var.name,int.var.length                            *
*                                                                     *
* Parameters:                                                         *
*   1. XTEXT     - a) Quoted literal (follows the normal CLIST syntax *
*                     after the ISPEXEC command).                     *
*                            - OR -                                   *
*                  b) Variable name that contains the normal CLIST    *
*                     syntax following the ISPEXEC command.           *
*   2. XLENG     - Length of the variable if Format '2' used for the  *
*                  'XTEXT' parameter.                                 *
*   3. LONG=.... - Specify long move (MVCL) if Format '2' used.       *
*   4. LIST=.... - Generate or suppress macro expansion, (YES/NO).    *
*   5. INIT=.... - Force initial invocation, (YES/NO).                *
*   6. TYPE=.... - VARiable/CONstant for MF=L. For re-entrant programs*
*                  to copy constant into GETMAINed variable.          *
*   7. MF=....   - Macro format. Only required for re-entrant         *
*                  programs and then ONLY ON the initialisation       *
*                  invocation.                                        *
*                  For re-entrant programs:                           *
*                    E - EXEC format of macro on INIT invocation.     *
*                    L - LIST format of macro.                        *
*                                                                     *
* NOTE:                                                               *
*      1. The first execution must be of the macro WITHOUT the XTEXT  *
*         parameter or WITH the INIT=Y parameter.                     *
*      2. Does not cover "VDEF", "VCOPY", "VDELETE", "VRESET" or      *
*         "VREPLACE".                                                 *
*                                                                     *
*---------------------------------------------------------------------*
.A$HELPE ANOP
         AIF   (T'&NAME EQ 'O').NONAME1    Bypass if NAME missing
&NAME    DS    0H
.NONAME1 ANOP
         GBLB  &ISPI1ST
         GBLC  &ISPNAME,&ISPTYP,&ISPEXEP,&ISPBUFA,&ISPBUFL,&ISPBUFR
         LCLC  &ISPLABB
         AIF   (&ISPI1ST).A$00
&ISPI1ST SETB  1
&ISPNAME SETC  'INI'.'&SYSNDX'
.A$00    ANOP
         AIF   ('&INIT'(1,1) EQ 'Y').INITIL
         AIF   (T'&XTEXT NE 'O').SETEXEC    Bypass if INIT=N + param
.*--------------------------------------------------------------------*
.*   Initialisation form of macro                                     *
.*--------------------------------------------------------------------*
.INITIL  ANOP
&ISPTYP  SETC  'LOAD'
&ISPEXEP SETC  '&ISPNAME'.'1'
&ISPBUFA SETC  '&ISPNAME'.'2'
&ISPBUFL SETC  '&ISPNAME'.'3'
&ISPBUFR SETC  '&ISPNAME'.'4'
&ISPLABB SETC  '&ISPNAME'.'X'
         AIF   (T'&MF NE 'O').A$11   RE-ENTRANT BYPASS
         B     &ISPLABB                PYPASS DATA
.A$11    ANOP
         AIF   ('&MF' EQ 'E').A$22   RE-ENTRANT LIST EXIT
*---------------------------------------------------------------------*
*    LIST form of macro 'ISPEXEC' initialisation                      *
*---------------------------------------------------------------------*
         DS    0F                      FULLWORD ALLIGNMENT
         AIF   ('&TYPE'(1,1) NE 'C').A$12
         DS    A                       A(ISPF LINK INTERFACE)
         DS    A                       A(ISPF EXEC INTERFACE)
         DC    A(0)                    A(COMMAND LENGTH)
         DC    A(0)                    A(COMMAND BUFFER)
         DC    F'0'                    COMMAND LENGTH
         DS    0CL300                  COMMAND BUFFER
         AGO   .A$13
.A$12    ANOP
ISPLINK  DS    A                       A(ISPF LINK INTERFACE)
ISPEXEC  DS    A                       A(ISPF EXEC INTERFACE)
&ISPEXEP DC    A(&ISPBUFL)             A(COMMAND LENGTH)
&ISPBUFA DC    A(&ISPBUFR)             A(COMMAND BUFFER)
&ISPBUFL DC    F'0'                    COMMAND LENGTH
&ISPBUFR DS    0CL300                  COMMAND BUFFER
.A$13    ANOP
         DC    CL250' ',CL50' '        INITIALISED TO SPACES
         AIF   ('&MF' EQ 'L').MEXIT  Re-entrant list, Exit
&ISPLABB DS    0H
.*       AIF   (T'&MF EQ 'O').A$33   Non RE-ENTRANT BYPASS
.A$22    ANOP
*---------------------------------------------------------------------*
*    EXEC form of macro 'ISPEXEC' initialisation                      *
*---------------------------------------------------------------------*
         LA    R1,&ISPBUFL             LOAD ADDRESS OF COMMAND LENGTH
         ST    R1,&ISPEXEP             STORE COMMAND LENGTH ADDRESS
         LA    R1,&ISPBUFR             LOAD ADDRESS OF COMMAND BUFFER
         ST    R1,&ISPBUFA             STORE COMMAND BUFFER ADDRESS
         OI    &ISPBUFA,X'80'          MOVE LAST PARM INDICATOR
*
.A$33    ANOP
*        LOAD  EP=ISPLINK              FETCH ISPF LINK INTERFACE
         LOAD  EP=ISPLINK              FETCH ISPF LINK INTERFACE
         ST    R0,ISPLINK              SAVE ITS ADDRESS
*        LOAD  EP=ISPEXEC              FETCH ISPF EXEC INTERFACE
         LOAD  EP=ISPEXEC              FETCH ISPF EXEC INTERFACE
         ST    R0,ISPEXEC              SAVE ITS ADDRESS
.A$99    ANOP
*---------------------------------------------------------------------*
         AIF   (T'&XTEXT EQ 'O').MEXIT      Exit if no parameter
.*-------------------------------------------------------------------*
.SETEXEC ANOP
         AIF   (T'&XLENG NE 'O').MVX2
         AIF   ('&XTEXT'(1,1) NE '''').E3
.*-------------------------------------------------------------------*
         LCLC  &CHAR,&AMPER
         LCLA  &LC,&QC,&AC
&AMPER   SETC  '&&'
&LC      SETA  K'&XTEXT                     LOOP COUNTER
&QC      SETA  0                            QUOTES COUNTER
&AC      SETA  0                            AMPERSAND COUNTER
&CP      SETA  0                            CHARACTER POINTER
.LOOP1   ANOP
&CP      SETA  &CP+1                        INCREMENT CHARACTER PTR
&CHAR    SETC  '&XTEXT'(&CP,1)
.TQUOT   ANOP
         AIF   ('&CHAR' NE '''').TAMPR
&QC      SETA  &QC+1
         AGO   .NXTCH
.TAMPR   ANOP
         AIF   ('&CHAR.&CHAR' NE '&AMPER').NXTCH
&AC      SETA  &AC+1
.NXTCH   ANOP
         AIF   (&CP LT &LC).LOOP1           LOOP TILL END
&LC      SETA  &LC-2-(((&QC-2)/2)+(&AC/2))
         MVC   &ISPBUFR.(&LC),=C&XTEXT
.*-------------------------------------------------------------------*
         LA    1,&LC                   LOAD LENGTH
         AGO   .LA
.MVX2    ANOP
         AIF   ('&XTEXT'(1,1) EQ '''').E2
         AIF   ('&LONG'(1,1) EQ 'N').MVX4
.MVX3    ANOP
         LA    R0,&ISPBUFR             LOAD ADDRESS OF DESTINATION
         LA    R1,&XLENG               LOAD LENGTH OF MOVE
         LA    R14,&XTEXT              LOAD SOURCE ADDRESS
         LA    R15,&XLENG              LOAD LENGTH OF MOVE
         ICM   R15,B'1000',=C'         '            MOVE PAD CHARACTER
         MVCL  R0,R14                  SET AREA TO ALL SPACES
         AGO   .MVX5
.MVX4    ANOP
         MVC   &ISPBUFR.(&XLENG),&XTEXT
.MVX5    ANOP
         LA    1,&XLENG                LOAD LENGTH
.LA      ANOP
         ST    1,&ISPBUFL              STORE LENGTH
         LA    1,&ISPEXEP              LOAD PARAMETER LIST POINTER
         L     15,ISPEXEC              LOAD 'ISPEXEC' MODULE ADDR
         BALR  14,15                   CALL 'ISPEXEC'
         AGO   .MEXIT                       Exit macro
*---------------------------------------------------------------------*
.E1      MNOTE 12,'ISPEXEC REQUIRES A FUNCTION PARAMETER LIST'
         AGO   .MEXIT                       Exit macro
.E2      MNOTE 12,'VARIABLE NAME MUST NOT BE QUOTED'
         AGO   .MEXIT                       Exit macro
.E3      MNOTE 12,'VARIABLE NAME REQUIRES A LENGTH'
         AGO   .MEXIT                       Exit macro
.*--------------------------------------------------------------------*
.MEXIT   ANOP
         POP   PRINT
         MEND
*---------------------------------------------------------------------*
*------- Macro 12. PDUMPR --------------------------------------------*
         MACRO
&NAME    PDUMPR &ADDR,          Address to display                     X
               &REGP=YES,       Ser REGP= parameter                    X
               &TYPE=VAR,       CONstant/VARiable type for MF=L        X
               &ISPI=YES,       Invoke ISPEXEC INIT=Y explicitly       X
               &X2CE=NO,        HEXCHMAC MF=E required ?               X
               &X2CL=NO,        HEXCHMAC MF=L required ?               X
               &REXX=SHOWSTOR,  REXX EXEC                              X
               &HELP=NO,        Help in expansion                      X
               &MSG=,           Message area for GC009                 X
               &LIST=NO,        List expansion                         X
               &DISPLAY=ASIS,   Process SHOWSTOR display               X
               &DISP=ASIS,      Alias for DISPLAY                      X
               &QUIT=,          R15 set to 'QUIT' branch               X
               &MF=             EXEC/LIST format
.*
         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP   Go full help
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'PDUMPR' parameter and  *
* it's use, pass parameter 'HELP=Yes'.                                *
*---------------------------------------------------------------------*
         AGO .A$HELPE                         Bypass full help
.A$HELP  ANOP
*---------------------------------------------------------------------*
*                                                                     *
* This facility is used to display memory from within a program using *
* the SHOWSTOR memory mapper written in REXX using ISPF services.     *
* Note, this facility cannot be invoked from an authorised program as *
* ISPF services cannot be called from authorised programs.            *
*                                                                     *
* All parameters are keyword parameters except the first which is the *
* only positional parameter for the address to be displayed. The      *
* format is as follows:                                               *
*                                                                     *
*   PDUMPR addr,kw1=..,kw2=..,kwn=...                                 *
*                                                                     *
* The following are permissable parameters:                           *
*   addr          - Address to be displayed. (Register format is not  *
*                   supported. If you let the REGP= parameter default *
*                   and there is no reason not to, you can            *
*                   automatically use the /Rn command in the REXX     *
*                   routine.)                                         *
*   ISPI=Yes/No   - Invoke the ISPEXEC macro with the INIT option in  *
*                   it. Default is Yes. Set to No if you explicitly   *
*                   use the ISPEXEC macro in your program.            *
*   X2CE=Yes/No   - Invoke the HEXCHMAC macro MF=E format. This is    *
*                   only used if the HEXCHMAC with MF=E is explicitly *
*                   used in the same program and will prevents        *
*                   duplicate variable names. If PDUMPR is invoked    *
*                   with MF=E then this feature is automatically      *
*                   enabled. The default is NO.                       *
*   X2CL=Yes/No   - Invoke the HEXCHMAC macro MF=L format. Similar to *
*                   X2CL parameter. Default is No.                    *
*   MSG='....'    - MEssage to display on entering SHOWSTOR. Literal  *
*      =label()     padded/truncated to 256 bytes or a label where    *
*                   256 bytes or length of variable subscripted is    *
*                   moved, eg. MSG=MSGSRCE(80).                       *
*   QUIT=label    - If 'QUIT' is entered in the register display      *
*                   panel (command line or R15+SAVE), control is      *
*                   passed to 'label'.                                *
*   REGP=Yes/No   - Set REGP= parameter on entry. this will enable    *
*                   the use of the /REGS* command. (Refer to SHOWSTOR *
*                   documentation.)                                   *
*   REXX=SHOWSTOR - REXX EXEC to be executed from the macro. This     *
*                   should not be changed.                            *
*   TYPE=Var/Con  - Constatnt/Variable type for MF=L format. VAR is   *
*                   the default.                                      *
*   DISPLAY=Yes/No/Asis                                               *
*                 - Activate or bypass SHOWSTOR displays. Used to     *
*                   control SHOWSTOR displays during looping. Any     *
*                   value other than 'N' or 'Y' will default to 'A'.  *
*                   Use this parameter without an Address to set the  *
*                   condition without a display.                      *
*   HELP=No/Yes   - Help in expansion of this macro.                  *
*   LIST=No/Yes   - List expansion.                                   *
*   MF=           - Exec/List format.                                 *
*                                                                     *
* To use this feature you will also need access to macros ISPEXEC and *
* HEXCHMAC.                                                           *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
* Known GOTCHAs:                                                      *
* - Because the macros used are designed in subroutine format, ensure *
*   that the first physical occurance of this macro (or it's related  *
*   counterparts of ISPEXEC and HEXCHMAC) are the ones actually       *
*   executed first to ensure all variables/settings are initialised.  *
*   This can be a problem in programs with a lot of branching logic.  *
*   To safeguard against this, invoke the macro as early as possible  *
*   in your program without an "addr" parameter to force              *
*   initialisation of all 3 macros (PDUMPR, ISPEXEC and HEXCHMAC).    *
* - Take care when explicitly using ISPEXEC and HEXCHMAC macros       *
*   outside this macro. You may need to fine tune the ISPI= and the   *
*   X2CE= and X2CL= parameters to prevent duplicate names.            *
*                                                                     *
*---------------------------------------------------------------------*
.*
.A$HELPE ANOP
.*
         AIF   ('&LIST'(1,1) EQ 'Y').A$XXX
         PUSH  PRINT
         PRINT NOGEN
.A$XXX   ANOP
.*
         LCLC  &SMXVAR,&L,&#DISP,&#ADR
         GBLB  &SMXFST1,&SMXEXE1,&SMXLST1
         GBLC  &SMXFXD
         GBLB  &XC1ST
.*
.*--------------------------------------------------------------------*
.* Evaluate and set Display requirements                              *
.*--------------------------------------------------------------------*
         AIF   (T'&DISPLAY EQ 'O').A$001 Test for 'alias'
&#DISP   SETC  '&DISPLAY'                Set to parameter
         AGO   .A$002                    GoAround alternate process
.A$001   ANOP
         AIF   (T'&DISP EQ 'O').A$002    Bypass
&#DISP   SETC  '&DISP'                   Set to 'alias' parameter
.A$002   ANOP
.*
.*--------------------------------------------------------------------*
.* Evaluate address if passed as (reg)....                            *
.*--------------------------------------------------------------------*
&#ADR    SETC  '&ADDR'                Set to parameter
         AIF   (T'&#ADR EQ 'O').A$003 Bypass processing
         AIF   ('&#ADR'(1,1) NE '(').A$003 Bypass if 1st char not '('
&#ADR    SETC  '0&#ADR.'              Set to Offset zero
.A$003   ANOP
.*--------------------------------------------------------------------*
.*
         AIF   (&SMXFST1).A$010
.*--------------------------------------------------------------------*
.* Global variables on initial invocation
.*--------------------------------------------------------------------*
&SMXFST1 SETB  1                       Set 1st. time thru  flag
&SMXFXD  SETC  'SMX'.'&SYSNDX'         Set fixed index value
&#DISP   SETC  'YES'                   Force display 1st. time thru
.A$010   ANOP
.*--------------------------------------------------------------------*
.* Local variables on each invocation
.*--------------------------------------------------------------------*
&SMXVAR  SETC  'SMX'.'&SYSNDX'         Set variable index value
.*--------------------------------------------------------------------*
.* Global variables on each invocation
.*--------------------------------------------------------------------*
&SMXLB0  SETC  '&SMXVAR'.'0'           Set variables
&SMXLB1  SETC  '&SMXFXD'.'1'           Set variables
&SMXLB2  SETC  '&SMXVAR'.'2'           Set variables
&SMXLB3  SETC  '&SMXVAR'.'3'           Set variables
&SMXLB4  SETC  '&SMXFXD'.'4'           Set variables
&SMXLB5  SETC  '&SMXFXD'.'5'           Set variables
&SMXLB6  SETC  '&SMXVAR'.'6'           SPARE - NOT USED
&SMXLB7  SETC  '&SMXVAR'.'7'           Set variable
&SMXWK1  SETC  '&SMXFXD'.'8'           Set variables
&SMXWK2  SETC  '&SMXFXD'.'9'           Set variables
&SMXWK3  SETC  '&SMXFXD'.'A'           Set variables
&SMXWK4  SETC  '&SMXFXD'.'B'           Set variables
&SMXWK5  SETC  '&SMXFXD'.'C'           Set variables
&SMXWK6  SETC  '&SMXFXD'.'D'           Set variables
&SMXWK7  SETC  '&SMXFXD'.'E'           Set variables
&SMXWK8  SETC  '&SMXFXD'.'F'           Set variables
&SMXWK9  SETC  '&SMXFXD'.'G'           Set variables
&SMXWK10 SETC  '&SMXFXD'.'H'           Set variables
&SMXWK11 SETC  '&SMXFXD'.'I'           Set variables
.*--------------------------------------------------------------------*
&L       SETC  '&LIST'
         AIF   (T'&NAME EQ 'O').A$YYY  Bypass if label passed
&SMXLB0  SETC  '&NAME'                 Use invocation name fro label
.A$YYY   ANOP
.*
         AIF   ('&MF' EQ 'L').A$200    Process list form of macro
.*
         B     &SMXLB0                 ENSURE FULL WORD BRANCH
         AIF   (T'&MF EQ 'O').A$200    Process list form of macro
.A$020   ANOP
&SMXLB0  DS    0F                      ENSURE FULL WORD ALLIGNMENT
.*
         AIF   (&SMXEXE1).A$050        Bypass if not 1st. MF=E
&SMXEXE1 SETB  1
         STM   R0,R15,&SMXWK9          SAVE ALL REGISTERS
         AIF   ('&ISPI'(1,1) NE 'Y').A$022A Bypass if ISPEXEC not req
         AIF   ('&LIST'(1,1) EQ 'Y').A$021  Process list form yes
         ISPEXEC INIT=Y,MF=E           INITIALISE ISPF ENVIRONMENT
         AGO   .A$022
.A$021   ANOP
         ISPEXEC INIT=Y,MF=E,LIST=&L   INITIALISE ISPF ENVIRONMENT
.A$022   ANOP
         LM    R0,R15,&SMXWK9          RESTORE REGISTERS
.A$022A  ANOP
         B     &SMXLB2                 BRANCH AROUND CODE
&SMXLB1  DS    0H
         ST    R1,&SMXWK8              STORE FOR CONVERSION
         AIF   ('&X2CE'(1,1) EQ 'Y').X2C012 Process MF=E format
         AIF   ('&MF' EQ 'E').X2C011   Process MF=E format
.X2C010  ANOP
         HEXCHMAC &SMXWK8,&SMXWK2,4,LIST=&L HEX TO CHARACTER
         AGO   .X2C012                 Bypass MF=E format
.X2C011  ANOP
         HEXCHMAC &SMXWK8,&SMXWK2,4,LIST=&L,MF=E HEX TO CHARACTER
.X2C012  ANOP
.*
         CLI   &SMXWK7,C'Y'            Q. SETUP REGISTERS
         BE    &SMXLB4                    Y. GO DO IT
         MVI   &SMXWK3,C' '            BLANK FILL (RIPPLE)
         MVC   &SMXWK3.+1(L'&SMXWK3.+L'&SMXWK4.-1),&SMXWK3
         B     &SMXLB5                 BYPASS SETUP REGISTER
&SMXLB4  DS    0H
         MVC   &SMXWK3.(06),=C' REGP=' SET REGISTER
         LA    R1,&SMXWK9              LOAD ADDRESS REGISTER SAVE AREA
         ST    R1,&SMXWK8              STORE FOR CONVERSION
         AIF   ('&X2CE'(1,1) EQ 'Y').X2C022 Process MF=E format
         AIF   ('&MF' EQ 'E').X2C021   Process MF=E format
.X2C020  ANOP
         HEXCHMAC &SMXWK8,&SMXWK4,4,LIST=&L HEX TO CHARACTER
         AGO   .X2C022                 Bypass MF=E format
.X2C021  ANOP
         HEXCHMAC &SMXWK8,&SMXWK4,4,LIST=&L,MF=E HEX TO CHARACTER
.X2C022  ANOP
&SMXLB5  DS    0H
         AIF   ('&LIST'(1,1) EQ 'Y').A$041 Process list form Yes
         ISPEXEC &SMXWK1,&SMXWK6       CALL 'SHOSTOR' REXX EXEC
         AGO   .A$042
.A$041   ANOP
         ISPEXEC &SMXWK1,&SMXWK6.,LIST=&L CALL 'SHOSTOR' REXX EXEC
.A$042   ANOP
         L     R14,&SMXWK8.+4          LOAD RETURN ADDRESS
         BR    R14                     RETURN TO CALLER
.*
.A$050   ANOP
&SMXLB2  DS    0H
.*--------------------------------------------------------------------*
         AIF   (T'&#DISP EQ 'O').A$058 Do not set, just test
         AIF   ('&#DISP'(1,1) EQ 'Y').A$057 Use passed value
         AIF   ('&#DISP'(1,1) NE 'N').A$058 Bypass value setting
.A$057   ANOP
&#DISP   SETC  '&#DISP'(1,1)          Use 1st. byte
         MVI   &SMXWK11,C'&#DISP'      SET DISPLAY REQUIREMENT
         AIF   (T'&#ADR EQ 'O').MEXIT Continue if have an address
         AIF   ('&#DISP'(1,1) EQ 'Y').A$059 Bypass test if set 2 'Y'
         AIF   ('&#DISP'(1,1) EQ 'N').A$090 Bypass all if 'N' req'd
.A$058   ANOP
         AIF   (T'&#ADR EQ 'O').MEXIT Continue if have an address
         CLI   &SMXWK11,C'N'           Q. DISPLAY REQUIRED
         BE    &SMXLB7                    N. BYPASS
.A$059   ANOP
.*--------------------------------------------------------------------*
         STM   R0,R15,&SMXWK9          SAVE ALL REGISTERS
         LA    R0,&SMXLB3              LOAD RETURN ADDRESS
         ST    R0,&SMXWK8.+4           SAVE RETURN ADDRESS
         AIF   ('&REGP'(1,1) EQ 'N').A$060  Bypass if REGP=No
         MVI   &SMXWK7,C'Y'            SETUP REGISTERS REQUEST
         AGO   .A$065                  Branch around negative set
.A$060   ANOP
         MVI   &SMXWK7,C'N'            REGISTERS NOT REQUIRED
.A$065   ANOP
         AIF   (T'&MSG EQ 'O').A$075  Bypass if deliberate omission
         MVI   &SMXWK10,C' '           INITIALISE OUTPUT MESSAGE USING
         MVC   &SMXWK10.+1(L'&SMXWK10.-1),&SMXWK10 ..RIPPLE MOVE
         AIF   ('&MSG'(1,1) EQ '''').A$072 Go process literal message
.*--------------------------------------------------------------------*
.* Establish length of literal and move length                        *
.*--------------------------------------------------------------------*
         LCLA  &APOST
&MSGL    SETA  K'&MSG                     Set length of message
         AIF   ('&MSG'(&MSGL,1) EQ ')').A$071
         MVC   &SMXWK10,&MSGNW         MOVE MESSAGE TO OUTPUT
         AGO   .A$075                       Leave process
.A$071   ANOP
&MSGL1   SETA  &MSGL-1
&APOST   SETA  0
.LOOP1   ANOP
         AIF   (&MSGL1 EQ  0).E4
         AIF   ('&MSG'(&MSGL1,1) EQ ',').LOOP1E
         AIF   ('&MSG'(&MSGL1,1) EQ '(').LOOP2E
&MSGL1   SETA  &MSGL1-1
         AGO   .LOOP1
.LOOP1E  ANOP
&APOST   SETA  &MSGL1
&MSGL1   SETA  &MSGL1-1
.LOOP2   ANOP
         AIF   (&MSGL1 EQ 0).E4
         AIF   ('&MSG'(&MSGL1,1) EQ '(').LOOP2E
&MSGL1   SETA  &MSGL1-1
         AGO   .LOOP2
.LOOP2E  ANOP
         AIF   (&APOST EQ 0).VARMSG
&MSGL3   SETC  '&MSG'(&MSGL1+1,&APOST-(&MSGL1+1))
&MSGNW   SETC  '&MSG'(1,&MSGL1).'&MSG'(&APOST+1,&MSGL-&APOST)
         AGO   .MSGDTOK
.VARMSG  ANOP
&MSGL3   SETC  '&MSG'(&MSGL1+1,&MSGL-(&MSGL1+1))
&MSGNW   SETC  '&MSG'(1,&MSGL1-1)
.MSGDTOK ANOP
         MVC   &SMXWK10.(&MSGL3),&MSGNW MOVE MESSAGE TO OUTPUT
         AGO   .A$075                       Leave process
.*-------------------------------------------------------------------*
.* Establish length of variable and move length                      *
.*-------------------------------------------------------------------*
.A$072   ANOP
         LCLC  &CHAR,&AMPER
         LCLA  &LC,&QC,&AC
&AMPER   SETC  '&&'
&MSGL    SETA  K'&MSG                       Loop counter (message len)
&QC      SETA  0                            Quotes counter
&AC      SETA  0                            Ampersand counter
&CP      SETA  0                            Character pointer
.LOOP3   ANOP
&CP      SETA  &CP+1                        Iincrement char pointer
&CHAR    SETC  '&MSG'(&CP,1)                Set character value
.TQUOT   ANOP
         AIF   ('&CHAR' NE '''').TAMPR      Bypass if char not "'"
&QC      SETA  &QC+1                        Bump quotes counter
         AGO   .NXTCH                       Get nest char
.TAMPR   ANOP
         AIF   ('&CHAR.&CHAR' NE '&AMPER').NXTCH Bypass if not "&"
&AC      SETA  &AC+1                        Bump amper counter
.NXTCH   ANOP
         AIF   (&CP LT &MSGL).LOOP3         Loop till end
&MSGL    SETA  &MSGL-2-(((&QC-2)/2)+(&AC/2)) Get actual length
         MVC   &SMXWK10.(&MSGL),=CL(&MSGL)&MSG
.A$075   ANOP
.*--------------------------------------------------------------------*
         LA    R1,&#ADR                LOAD ADDRESS OF ADDRESS
         B     &SMXLB1                 BRANCH TO COMMON CODE
&SMXLB3  DS    0H
         LM    R0,R15,&SMXWK9          RESTORE ALL REGISTERS
         AIF   (T'&QUIT EQ 'O').A$080  Bypass if no QUIT
         C     R15,=C'QUIT'            Q. QUIT REQUESTED
         BE    &QUIT                      Y. GO TO LABEL
.A$080   ANOP
         C     R15,=C'DOFF'            Q. DISPLAY OFF REQUESTED
         BNE   &SMXLB7                    N. BYPASS
         MVI   &SMXWK11,C'N'           SET DISPLAY OFF
&SMXLB7  DS    0H
.A$090   ANOP
         AGO   .MEXIT                  Exit macro
.*
.A$200   ANOP
         AIF   (T'&MF NE 'O').A$205    Bypass if MF is set
         AIF   (&SMXEXE1).A$020        Return if previously executed
.A$205   ANOP
         AIF   ('&TYPE'(1,1) NE 'C').A$210  Bypass if not constant
&SMXWK1  SETC  ''
&SMXWK2  SETC  ''
&SMXWK3  SETC  ''
&SMXWK4  SETC  ''
&SMXWK5  SETC  ''
&SMXWK6  SETC  ''
&SMXWK7  SETC  ''
&SMXWK8  SETC  ''
&SMXWK9  SETC  ''
&SMXWK10 SETC  ''
&SMXWK11 SETC  ''
.*
.A$210   ANOP
.*
         AIF   ('&ISPI'(1,1) NE 'Y').A$224 Bypass if ISPEXEC not req'd
         AIF   ('&LIST'(1,1) EQ 'Y').A$221 Process list form Yes
         ISPEXEC  MF=L,INIT=Y,TYPE=&TYPE INIT ISPF ENVIRONMENT
         AGO   .A$224
.A$221   ANOP
         AIF   ('&ISPI'(1,1) EQ 'N').A$224 Bypass if INIT=No
.A$222   ANOP
         ISPEXEC  MF=L,INIT=Y,LIST=&L,TYPE=&TYPE INIT ISPF ENVIRONMENT
.A$224   ANOP
         DS    0F                      WORD ALLIGN
&SMXWK8  DS    2F                      WORK AREA
&SMXWK9  DS    16F                     REGISTER SAVE AREA FRO MACRO
&SMXWK1  DC    C'SELECT CMD(%SHOWSTOR ' WHAT WE WANT TO EXECUTE
&SMXWK2  DC    C'        '             ADDRESS WE WANT TO DISPLAY
&SMXWK3  DC    C' REGP='               REGISTER EQUATE LITERAL
&SMXWK4  DC    C'        '             ADDRESS WE WANT TO DISPLAY
         DC    C' '                    FILLER
.*-------------------------------------------------------------------*
.*   NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE    *
.*-------------------------------------------------------------------*
.* Modify the length of the next field to ensure the value (length)  *
.* of variable &SMXWK6 does not exceed 256 as &SMXWK1 and &SMXWK6    *
.* are used in a MVC instruction.                                    *
.*-------------------------------------------------------------------*
&SMXWK10 DC    CL211' '                MESSAGE AREA
.*-------------------------------------------------------------------*
&SMXWK5  DC    C')'                    WHAT WE WANT TO EXECUTE
         AIF   ('&TYPE'(1,1) EQ 'C').A$223  Bypass if constant
&SMXWK6  EQU   *-&SMXWK1               ISPF COMMAND LENGTH
.A$223   ANOP
&SMXWK7  DC    C'Y'                    REGISTER GENERATE FLAG
&SMXWK11 DC    C'Y'                    DISPLAY ON
         AIF   ('&X2CL'(1,1) NE 'Y').X2C030 BYpass MF=L for HEXCHMAC
         HEXCHMAC MF=L
.X2C030  ANOP
         AIF   (T'&MF EQ 'O').A$020    Return
         AGO   .MEXIT                  Exit
.*--------------------------------------------------------------------*
.E0      MNOTE 12,'No Errors at this stage'
         AGO   .MEXIT
.*--------------------------------------------------------------------*
.MEXIT   ANOP
         AIF   ('&LIST'(1,1) EQ 'Y').MEXIT9
         POP   PRINT
.MEXIT9  ANOP
         MEXIT
         MEND
*---------------------------------------------------------------------*
