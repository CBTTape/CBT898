##F$Comvar - Rexx function to save/restore variables in storage for the
##task, pass variables between multiple rexx. Caters for stem variables

*
*Rexx function to save/restore/list the variables currently held in
*storage for the task.
*
*This routine would be used to pass variables between multiple rexx
*execs running in the same address space.
*
*
*   Rc = F$Comvar(Req,Var_Name)
*
*Req = 'PUT' | 'GET' | 'LIST' |'PUTC' |'GETC' |'PUTP' |'GETP'
*      'RELT'| 'RELP'
*
*Return Codes:
*
*      List:
*          4 - Truncation Occured
*
*Var_Name
*
          TITLE   'Rexx function List|Restore|Save vars from storage'
F$Comvar  AMODE    31
F$Comvar  RMODE    ANY
F$Comvar  CSECT
          BAKR     R14,0
          LR       R12,R15
          USING    F$Comvar,R12
          LA       R11,F$Comvar+4095
          USING    F$Comvar+4095,R11
          B        F$Comvar_I
          DC       C'&SYSDATE..&SYSTIME'
*
F$Comvar_I EQU     *
*
          LR       R10,R1                 Save ptrs to rexx vars
          LR       R9,R0
*
*
          Storage  OBTAIN,LENGTH=L'Varstore,LOC=BELOW,COND=NO
*
          LR       R13,R1                 Address storage area
          USING    Save_Area,R13
          MVC      4(4,R1),=C'F1SA'       Signify using the stack
*
*
          ST       R9,Rexx_Env            Save address of rexx env
          Using    Envblock,R9
*
          L        R8,Envblock_Irxexte    Loc external rtn tbl
          Using    IRXEXTE,R8
*
          L        R15,IRXEXCOM           Save addr of var acc rtn
          St       R15,Irxexcom_Addr
          L        R15,IRXSAY             Save addr of say routine
          St       R15,Irxsay_Addr
          Drop     R8,R9
*
*
*   Save the address of external function parameter list, we may
*   will need it later when we process the parms
*
          ST       R10,Efpl_Addr          Save address of EFPL
*
*   All Rexx functions should include this call once Efpl_Addr is
*   known since it checks to see if the first parm is 'VERSION'
*   if it is it exits with the version information
*
          Bas      R14,F$Ver_Info
          LTR      R15,R15              Was version info requested
          BZ       Exit_Ver             Yes,Exit
*
          L        R10,Efpl_Addr
          USING    EFPL,R10
          L        R9,EFPLEVAL          Ptr to a full word that points
          L        R9,0(R9)             to the address of eval block
          USING    EVALBLOCK,R9
*
*   Allocate a block of storage to store the variable data in
*
          L       R0,=F'4096'
*         L       R0,=F'15000'
          ST      R0,Var_Val_Len
          Storage  OBTAIN,LENGTH=(R0),                                 +
               LOC=ANY,COND=NO
          ST      R1,Var_Val_Addr
          OI      Flags,Stg_Blk_Flag
*
*   Setup the ESPIE exit in case we suffer any ABEND0C%
*
          ESPIE   SET,Espie_Rtn,(4,5,6)
          ST      R1,Espie_Token
*
*   Clear counters & Flag words
*
          XC      Put_Cnt,Put_Cnt
          XC      Get_Cnt,Get_Cnt
          XC      Read_Cnt,Read_Cnt
          XC      Put_Flag,Put_Flag
*
*   Get current TCB address ; this will be used for PUTT,GETT,INIT,
*   RELT type requests
*
          L       R0,X'21C'                    Get the value PSATOLD
          ST      R0,Tcb_Addr
*
*
          L       R8,EFPLARG
          ST      R8,REXXARG
          CLC     0(8,R8),=X'FFFFFFFFFFFFFFFF'
          BE      Exit_8
          L       R3,4(R8)              Get length of parm
          ST      R3,Prm_area_len       Save length of parm
          L       R1,0(R8)              Get pointer to parm
          LA      R2,Prm_area
          BCTR    R3,0                  Dec by 1 for MVC operation
          EX      R3,Copy_Str           Copy parm and convert to upper
          EX      R3,Ucase              case
*
          BAS     R14,Cmd_Scan
          B       Exit_Rc
*
Exit_8    EQU      *                    No parms specified
          LA      R0,8
          ST      R0,Retcode
          B       Exit_Rc
Exit_4    EQU      *
          LA      R0,4
          ST      R0,Retcode
          B       Exit_Rc
Exit_Rc   EQU      *
          TM      Flags,Stg_Blk_Flag
          BZ      Exit_X1
          L       R2,Var_Val_Addr
          L       R3,Var_Val_Len
          STORAGE  RELEASE,LENGTH=(R3),ADDR=(R2)
Exit_X1   EQU      *
          BAS     R14,Save_Stats              Create stats vars
          L       R0,Retcode
          BAS     R14,Set_Retcode
Exit_Ver  EQU      *
          STORAGE  RELEASE,LENGTH=L'VARSTORE,ADDR=(R13)
Exit_X    PR
          DROP    R10,R9
*
CLC_CMD       CLC      0(0,R7),0(R4)
Copy_Str      MVC      0(0,R2),0(R1)
Cmp_Str       CLC      0(0,R2),0(R1)
*
**********************************************************************
*        Subroutines start here                                      *
**********************************************************************
*
*   Initialise the name token block
*
Init_Nt_Blk EQU       *
            BAKR      R14,R0
            LA        R0,Msgtxt1
            ST        R0,Msg_Ptr
            L         R15,Irxsay_Addr
            Call    (15),(Irx_WRITE,Msg_Ptr,=A(l'Msgtxt1)),            +
               VL,MF=(E,Call_Rtn)
            LA        R2,Retcode
            CALL      Ieantdl,(Level,Name_Token,(R2)),MF=(E,Call_Rtn)
            CLC       Retcode,=A(Ieant_ok)       Does var blk exist
            BAS       R14,Ntrt_Blk
            PR
*
*   Obtain addr of var/val name tables from storage
*
Ntrt_Blk    EQU       *
            BAKR      R14,R0
            LA        R2,Token
            LA        R3,Retcode
            CALL      Ieantrt,(Level,Name_Token,(R2),(R3)),            +
               MF=(E,Call_Rtn)
            CLC       Retcode,=A(Ieant_ok)       Does var blk exist
            BE        Ntrt_Blk_x                 Yes,Skip create
*
Ntrt_Blk_1  EQU       *
*
*   Allocate a storage block to contain the header information for
*   Variable name / value pairs
*
            Storage  OBTAIN,LENGTH=16,                                 +
               LOC=ANY,COND=NO,SP=131,Key=8
            ST        R1,Token
            XC        0(16,R1),0(R1)             Clear storage obtained
            MVC       0(8,R1),=C'F$ANCHOR'
            LA        R2,Token
            LA        R3,Retcode
            CALL      Ieantcr,(Level,Name_Token,(R2),Persopt,(R3)),    +
               MF=(E,Call_Rtn)
            CLC       Retcode,=A(Ieant_ok)       Did create work
            BE        Ntrt_Blk_X
*
            LA        R0,Msgerr1
            ST        R0,Msg_Ptr
            L         R15,Irxsay_Addr
            Call    (15),(Irx_WRITEERR,Msg_Ptr,=A(l'Msgerr1)),         +
               VL,MF=(E,Call_Rtn)
            LA        R15,200
            ST        R15,Retcode
            B         Ntrt_Blk_X
*
*   Debug code next section Ntrt_Blk_12 -- Ntrt_Blk_X
*
Ntrt_Blk_12 EQU       *
            LA        R0,Msgtxt2
            ST        R0,Msg_Ptr
            L         R15,Irxsay_Addr
            Call    (15),(Irx_WRITEERR,Msg_Ptr,=A(l'Msgtxt2)),         +
               VL,MF=(E,Call_Rtn)
Ntrt_Blk_2  EQU       *
*           Call   R$Outhex,(Token,=A(4)),VL,MF=(E,Call_Rtn)
            L         R1,Token           Addr storage cntl blk
            L         R2,8(R1)
            LTR       R2,R2
            BZ        Ntrt_Blk_X         Yes, Skip storage test
*           WTO 'F$comvar: testing storage'
*         STIMER WAIT,BINTVL==A(1000)
*
*   Test the validity of the storage block by checking its header
*   Bad storage will cause the ESPIE to be fired which will clear
*   the first pointers to the bad storage.
*   The ESPIE will return us to the @Retry address which is past the
*   CLC instr.
*
            L         R1,Token
            L         R2,8(R1)           Get ptr to storage block
            LA        R0,Ntrt_Blk_X
            ST        R0,@Retry
            CLC       0(8,R2),=C'F$COMVAR'
Ntrt_Blk_X  EQU       *
            XR        R15,R15
            PR
**********************************************************************
*  Save the statistics of the run in Rexx variables
**********************************************************************
Save_Stats    EQU      *
              BAKR   R14,R0
*
              LA      R8,Shvblk
              Using   Shvblock,R8
              XC      Shvblk,Shvblk
              MVI     Shvcode,Shvstore
*
*   Create stats variable F$COMVAR_READS ie no of records read
*
              L       R0,Read_Cnt
              BAS     R14,Bin_Char        Input to Bin_Char is in R0
              LA      R0,=C'F$COMVAR_READS'
              ST      R0,Shvnama               Save var name address
              LA      R0,14                    Get  var name len
              ST      R0,Shvnaml Save var name len
              LH      R0,Bin_Char_Str
              ST      R0,Shvvall
              LA      R0,Bin_Char_Str+2
              ST      R0,Shvvala
              L       R15,Irxexcom_Addr
              Call    (15),(Irx_Irxexcom,0,0,Shvblk),                  +
               VL,MF=(E,Call_Rtn)
*
*   Create stats variable F$COMVAR_PUTS ie no of Puts that were matched
*
              L       R0,Put_Cnt
              BAS     R14,Bin_Char     Input to Bin_Char is in R0
              LA      R0,=C'F$COMVAR_PUTS'
              ST      R0,Shvnama               Save var name address
              LA      R0,13                    Get  var name len
              ST      R0,Shvnaml               Save var name len
              LH      R0,Bin_Char_Str
              ST      R0,Shvvall
              LA      R0,Bin_Char_Str+2
              ST      R0,Shvvala
              L       R15,Irxexcom_Addr
              Call    (15),(Irx_Irxexcom,0,0,Shvblk),                  +
               VL,MF=(E,Call_Rtn)
*
*   Create stats variable F$COMVAR_GETS ie no of Gets that were matched
*
              L       R0,Get_Cnt
              BAS     R14,Bin_Char     Input to Bin_Char is in R0
              LA      R0,=C'F$COMVAR_GETS'
              ST      R0,Shvnama               Save var name address
              LA      R0,13                    Get  var name len
              ST      R0,Shvnaml               Save var name len
              LH      R0,Bin_Char_Str
              ST      R0,Shvvall
              LA      R0,Bin_Char_Str+2
              ST      R0,Shvvala
              L       R15,Irxexcom_Addr
              Call    (15),(Irx_Irxexcom,0,0,Shvblk),                  +
               VL,MF=(E,Call_Rtn)
*
*   Create info variable F$COMVAR_TCBADDR ie current task control blk
*
              LA      R0,=C'F$COMVAR_TCBADDR'
              ST      R0,Shvnama               Save var name address
              LA      R0,16                    Get  var name len
              ST      R0,Shvnaml               Save var name len
              LA      R0,4
              ST      R0,Shvvall
              LA      R0,Tcb_Addr
              ST      R0,Shvvala
              L       R15,Irxexcom_Addr
              Call    (15),(Irx_Irxexcom,0,0,Shvblk),                  +
               VL,MF=(E,Call_Rtn)
              PR
**********************************************************************
*  Set Retcode code
**********************************************************************
Set_Retcode   EQU      *
              BAKR   R14,R0
*
              L       R10,Efpl_Addr
              Using   Efpl,R10
              L       R9,Efpleval            Ptr to a full word that
              L       R9,0(R9)               points to the address
              Using   Evalblock,R9
*
              LA      R8,Shvblk
              Using   Shvblock,R8
              XC      Shvblk,Shvblk
              MVI     Shvcode,Shvstore

              BAS     R14,Bin_Char     Input to Bin_Char is in R0
              LA      R0,=C'F$COMVAR_RETCODE'
              ST      R0,Shvnama               Save var name address
              LA      R0,16                    Get  var name len
              ST      R0,Shvnaml Save var name len
              LH      R0,Bin_Char_Str
              ST      R0,Shvvall
              LA      R0,Bin_Char_Str+2
              ST      R0,Shvvala
              L       R15,Irxexcom_Addr
              Call    (15),(Irx_Irxexcom,0,0,Shvblk),                  +
               VL,MF=(E,Call_Rtn)
              LA      R1,Bin_Char_Str+2
              LH      R3,Bin_Char_Str
              ST      R3,Evalblock_Evlen       Setup the return code
              BCTR    R3,0
              EX      R3,Copy_Evalblock
              PR
Copy_Evalblock MVC    Evalblock_Evdata(0),0(R1)
              Drop    R10,R9,R8
*
UCASE         OC      0(0,R2),BLANKS
*
CPYINDEX      MVC     0(0,R1),Bin_Char_STR+2    Copy index to variable
*
*   Convert a binary number supplied in register 1 to a character
*   String.
*
Bin_Char  EQU       *
          BAKR      R14,R0
          CVD       R0,PL8                Convert input to packed dec
          MVC       VAR_TMP,=X'40202020202020202020202020202120'
          ED        VAR_TMP,PL8           Receive pl8 into edit string
*
          LA        R2,L'VAR_TMP          Get length of input str
          LA        R3,Bin_Char_STR+2     Get a pointer to output str
          LA        R4,VAR_TMP            Get pointer to input str
          LA        R5,0                  Zero counter
Bin_Char1 EQU       *
          CLI       0(R4),C' '            Is the first char a space
          BE        Bin_Char2             Yes; get next character
          MVC       0(1,R3),0(R4)         Copy char to output str
          LA        R3,1(R3)              Incr output str pointer
          LA        R5,1(R5)              Incr output char count
Bin_Char2 EQU       *
          LA        R4,1(R4)
          BCT       R2,Bin_Char1          Loop back till end of string
          STH       R5,Bin_Char_STR
          PR
CopyParm     MVC       0(0,R2),0(R1)
***********************************************************************
*      Scan the command table and select the appropriate cmd          *
***********************************************************************
Cmd_Scan      DS      0H
              BAKR    R14,0
*
              LH      R6,Cmdtable       Get length of first command
              LA      R1,Cmdtable+2     Ptr to Cmdtable
              LA      R5,Cmdtblen       No of commands in table
*
*   Scan comand table for specific entries
*
Compare       LA      R3,8
              LA      R2,Prm_Area
              L       R7,Prm_Area_Len
*
Chkchar       CLI     0(R1),C' '        All chars following are valid
              BE      Cmd_Valid
              CLC     0(1,R2),0(R1)     Do the compare for characters
              BE      Charok            Character valid check next
              B       Nxtentry          Character invalid try next
*                                       entry.
Charok        LA      R1,1(R1)          Point at next char in cmdtable
              LA      R2,1(R2)          Point at next char in Parm
              BCT     R3,Chkchar        Have we done all characters
              B       Cmd_Valid         Valid entry found
Nxtentry      LA      R1,4(R3,R1)       Skip past routine address
              LH      R6,0(R1)          Get len of next command
              LA      R1,2(R1)          Skip past len field
              BCT     R5,COMPARE
              LA      R0,8
              ST      R0,Retcode
              PR
*
*  Valid entry found in cmd table, now load up routine address
*
Cmd_Valid     L       R4,0(R3,R1)       Load address of cmd routine
              BASR    R14,R4
              PR                        Return back to main code
*
**********************************************************************
*   Task variables are requested so init for them                    *
**********************************************************************
Putt        Bakr    R14,0
            MVC     Name_Token,=CL16'F$COMVAR_'
            MVC     Name_Token+9(4),Tcb_Addr
*           L       R15,Irxsay_Addr
*           LA      R2,Name_Token
*           ST      R2,Msg_Ptr
*   Call    (15),(Irx_Write,Msg_Ptr,=A(16)),VL,MF=(E,Call_rtn)
            LA      R0,131
            ST      R0,Sub_Pool
            BAS     R14,Ntrt_Blk             Retrieve name token pair
            LTR     R15,R15
            BNZ     Putt_Exit
            BAS     R14,PUT
Putt_Exit   EQU     *
            PR
**********************************************************************
*   Update variables in this TCB storage pool                        *
**********************************************************************
Updt        OI      Put_Flag,Upd_Var_Req
            B       Putt
Updc        OI      Put_Flag,Upd_Var_Req
            B       Putc
Updp        OI      Put_Flag,Upd_Var_Req
            B       Putp
**********************************************************************
*   Task variables are requested so init for them                    *
**********************************************************************
Gett        Bakr    R14,0
            MVC     Name_Token,=CL16'F$COMVAR_Task'
            MVC     Name_Token,=CL16'F$COMVAR_'
            MVC     Name_Token+9(4),Tcb_Addr
            LA      R0,131
            ST      R0,Sub_Pool
            BAS     R14,Ntrt_Blk             Retrieve name token pair
            LTR     R15,R15
            BNZ     Gett_Exit
            BAS     R14,GET
Gett_Exit   EQU     *
            PR
**********************************************************************
*   Init of Task Name token block requested                          *
**********************************************************************
Initt       Bakr    R14,0
            MVC     Name_Token,=CL16'F$COMVAR_Task'
            MVC     Name_Token,=CL16'F$COMVAR_'
            MVC     Name_Token+9(4),Tcb_Addr
            LA      R0,131
            ST      R0,Sub_Pool
            BAS     R14,Init_Nt_Blk
            PR
**********************************************************************
*   Release the storage associated with task variables               *
**********************************************************************
Relt        Bakr    R14,0
            MVC     Name_Token,=CL16'F$COMVAR_Task'
            MVC     Name_Token,=CL16'F$COMVAR_'
            MVC     Name_Token+9(4),Tcb_Addr
            LA      R2,Token
            LA      R3,Retcode
            CALL    Ieantrt,(Level,Name_Token,(R2),(R3)),              +
               MF=(E,Call_Rtn)
            CLC       Retcode,=A(Ieant_ok)       Does var blk exist
            BNE       Relt_X                     No; Skip storage rel
Relt_1      EQU     *
            LA      R0,131
            ST      R0,Sub_Pool
            BAS     R14,Release
Relt_X      EQU     *
            XR      R15,R15
            PR
**********************************************************************
*   Common variables are requested so init for them                  *
**********************************************************************
Putc        Bakr    R14,0
            MVC     Name_Token,=CL16'F$COMVAR_Common'
            LA      R0,131
            ST      R0,Sub_Pool
            BAS     R14,Ntrt_Blk             Retrieve name token pair
            LTR     R15,R15
            BNZ     Putt_Exit
            BAS     R14,PUT
            PR
**********************************************************************
*   Common variables are requested so init for them                  *
**********************************************************************
Getc        Bakr    R14,0
            MVC     Name_Token,=CL16'F$COMVAR_Common'
            LA      R0,131
            ST      R0,Sub_Pool
            BAS     R14,Ntrt_Blk             Retrieve name token pair
            LTR     R15,R15
            BNZ     Getc_Exit
            BAS     R14,Get
Getc_Exit   EQU     *
            PR
**********************************************************************
*   Variables are requested from a specific pool                     *
**********************************************************************
Putp        Bakr    R14,0
            L       R8,REXXARG          Get Ptr to parms
            LA      R8,8(R8)            Skip past Cmd parm
            CLC     0(8,R8),=X'FFFFFFFFFFFFFFFF' are we at end of parms
            BE      Putp_X0
            L       R3,4(R8)            Get length of parm
            CH      R3,=X'0000'         Is it zero length
            BE      Putp_X1             Yes,Error
            CH      R3,=X'0008'         Is it longer than 8 chars
            BH      Putp_X2             Yes,Error
            ST      R3,Pool_nam_len     Save length of parm
            L       R1,0(R8)            Get pointer to parm
            LA      R2,Pool_nam
            BCTR    R3,0                Dec by 1 for MVC operation
            EX      R3,Copy_Str         Copy parm and convert to upper
            EX      R3,Ucase            case
*
            MVC     Name_Token,=CL16'F$COMVAR        '
            L       R3,Pool_nam_len     Save length of parm
            LA      R1,Pool_Nam         Get pointer to parm
            LA      R2,Name_Token+8
            BCTR    R3,0                Dec by 1 for MVC operation
            EX      R3,Copy_Str         Copy parm and convert to upper
*
            BAS     R14,Ntrt_Blk             Retrieve name token pair
            LTR     R15,R15
            BNZ     Putp_X
            LA      R0,131
            ST      R0,Sub_Pool
            BAS     R14,PUT
            B       Putp_X
Putp_X0     EQU     *
            LA      R0,300                   PutP Pool name null
            ST      R0,RetCode
            B       Putp_X
Putp_X1     EQU     *
            LA      R0,301                   PutP Pool name to short
            ST      R0,RetCode
            B       Putp_X
Putp_X2     EQU     *
            LA      R0,302                   Putp pool name to long
            ST      R0,RetCode
Putp_X      EQU     *
            PR
**********************************************************************
*   Variables are requested from a specific pool                     *
**********************************************************************
Getp        Bakr    R14,0
            L       R8,REXXARG          Get Ptr to parms
            LA      R8,8(R8)            Skip past Cmd parm
            CLC     0(8,R8),=X'FFFFFFFFFFFFFFFF' are we at end of parms
            BE      Getp_X0
            L       R3,4(R8)            Get length of parm
            CH      R3,=X'0000'         Is it zero length
            BE      Getp_X1             Yes,Error
            CH      R3,=X'0008'         Is it longer than 8 chars
            BH      Getp_X2             Yes,Error
            ST      R3,Pool_nam_len     Save length of parm
            L       R1,0(R8)            Get pointer to parm
            LA      R2,Pool_nam
            BCTR    R3,0                Dec by 1 for MVC operation
            EX      R3,Copy_Str         Copy parm and convert to upper
            EX      R3,Ucase            case
*
            MVC     Name_Token,=CL16'F$COMVAR        '
            L       R3,Pool_nam_len     Get length of parm
            LA      R1,Pool_Nam         Get pointer to parm
            LA      R2,Name_Token+8
            BCTR    R3,0                Dec by 1 for MVC operation
            EX      R3,Copy_Str         Copy parm and convert to upper
*
            BAS     R14,Ntrt_Blk             Retrieve name token pair
            LTR     R15,R15
            BNZ     Getp_X
            LA      R0,131
            ST      R0,Sub_Pool
            BAS     R14,Get
            B       Putp_X
Getp_X0     EQU     *
            LA      R0,400                   PutP Pool name null
            ST      R0,RetCode
            B       Getp_X
Getp_X1     EQU     *
            LA      R0,401                   PutP Pool name to short
            ST      R0,RetCode
            B       Getp_X
Getp_X2     EQU     *
            LA      R0,402                   Putp pool name to long
            ST      R0,RetCode
Getp_X      EQU     *
            PR
**********************************************************************
*   Release the storage associated with the pool name if it exists   *
**********************************************************************
Relp        Bakr    R14,0
            L       R8,REXXARG          Get Ptr to parms
            LA      R8,8(R8)            Skip past Cmd parm
            CLC     0(8,R8),=X'FFFFFFFFFFFFFFFF' are we at end of parms
            BE      Relp_X0
            L       R3,4(R8)            Get length of parm
            CH      R3,=X'0000'         Is it zero length
            BE      Relp_X1             Yes,Error
            CH      R3,=X'0008'         Is it longer than 8 chars
            BH      Relp_X2             Yes,Error
            ST      R3,Pool_nam_len     Save length of parm
            L       R1,0(R8)            Get pointer to parm
            LA      R2,Pool_nam
            BCTR    R3,0                Dec by 1 for MVC operation
            EX      R3,Copy_Str         Copy parm and convert to upper
            EX      R3,Ucase            case
*
            MVC     Name_Token,=CL16'F$COMVAR        '
            L       R3,Pool_nam_len     Get length of parm
            LA      R1,Pool_Nam         Get pointer to parm
            LA      R2,Name_Token+8
            BCTR    R3,0                Dec by 1 for MVC operation
            EX      R3,Copy_Str         Copy parm and convert to upper
            LA      R2,Token
            LA      R3,Retcode
            CALL    Ieantrt,(Level,Name_Token,(R2),(R3)),              +
               MF=(E,Call_Rtn)
            CLC       Retcode,=A(Ieant_ok)       Does var blk exist
            BNE       Relp_X3                    No; Skip storage rel
Relp_1      EQU     *
*           LA      R2,Retcode
*           CALL    Ieantdl,(Level,Name_Token,(R2)),MF=(E,Call_Rtn)
*           CLC     Retcode,=A(Ieant_ok)       Did delete work
            LA      R0,131
            ST      R0,Sub_Pool
            BAS     R14,Release
            B       Relp_X
Relp_X0     EQU     *
            LA      R0,500                   RelP Pool name null
            ST      R0,RetCode
            B       Relp_X
Relp_X1     EQU     *
            LA      R0,501                   RelP Pool name to short
            ST      R0,RetCode
            B       Relp_X
Relp_X2     EQU     *
            LA      R0,502                   RelP Pool name to long
            ST      R0,RetCode
            B       Relp_X
Relp_X3     EQU     *
            LA      R0,4                     RelP Pool name unknown
            ST      R0,RetCode
            B       Relp_X
Relp_X      EQU     *
            XR      R15,R15
            PR
**********************************************************************
*   Init of Common Name token block requested                        *
**********************************************************************
Initc       Bakr    R14,0
            MVC     Name_Token,=CL16'F$COMVAR_Common'
            LA      R0,131
            ST      R0,Sub_Pool
            BAS     R14,Init_Nt_Blk
            PR
*
**********************************************************************
*
Put         Bakr    R14,0
*
            LA      R9,Shvblk
            Using   Shvblock,R9
            XC      Shvblk,Shvblk
            LA      R0,250
            ST      R0,Shvuser              Length of fetch buffer
            MVI     Shvcode,Shvnextv
            L       R0,Var_Val_Len
            ST      R0,Shvbufl
            LA      R0,Var_Nam_Str
            ST      R0,Shvnama
            L       R0,Var_Val_Addr
            ST      R0,Shvvala
            XR      R6,R6                   Clear Read counter
            XR      R7,R7                   Clear Put  counter
*
Put_1       Equ     *
            L       R15,Irxexcom_Addr
            Call    (15),(Irx_Irxexcom,0,0,Shvblk),                    +
               VL,MF=(E,Call_Rtn)
            TM      Shvret,Shvlvar         Last variable arrived
            BO      Put_Exit
            LA      R7,1(R7)               Incr Read counter
            TM      Shvret,Shvtrunc        Last variable arrived
            BZ      Put_2
            WTO   'F$comvar: truncation occured'
*
*   Truncation occured during IRX get processing so resize the
*   variable data block
*
            L       R2,Var_Val_Addr
            L       R3,Var_Val_Len
            Storage RELEASE,LENGTH=(R3),ADDR=(R2)
*
            L       R3,Shvvall
            ST      R3,Var_Val_Len
            Storage OBTAIN,LENGTH=(R3),                                +
               LOC=ANY,COND=NO
            ST      R1,Var_Val_Addr
            OI      Flags,Stg_Blk_Flag
*
            ST      R1,Shvvala
            ST      R3,Shvbufl                Set new buffer len
            MVI     Shvcode,Shvfetch
            L       R15,Irxexcom_Addr
            Call    (15),(Irx_Irxexcom,0,0,Shvblk),                    +
               VL,MF=(E,Call_Rtn)
            MVI     Shvcode,Shvnextv          Restart fetch next
Put_2       Equ     *
*
*   Check the variable names returned with the arguments specified
*   in the call to the function. Where a match is found perform the
*   put.
*
            BAS     R14,Check_Var             Check variable name
            LTR     R15,R15
            BNZ     Put_5                     Variable name not valid
            LA      R6,1(R6)                  Count no of matched ents
*
*   Search the current Variable name block chain to see if
*   this variable already exists; if it does then update its value
*   else create a new control block and chain it in
*
            TM      Put_Flag,Upd_Var_Req      Should we update vars
            BZ      Put_21                    No,Skip Srch/upd rtn
            BAS     R14,Srch_Chain
            LTR     R15,R15                   Check return code
            BZ      Put_5                     If 0 then exit
Put_21      Equ     *
*           L       R15,Irxsay_Addr
*           Call    (15),(Irx_Write,Shvnama,Shvnaml),VL,MF=(E,Call_rtn)
*
*   Curent Variable is valid and must now be chained onto the name
*   token blk structure.
*
*        0 +--------------+
*          |   Block      |
*          |   Header     |
*        8 |--------------|
*          |    Fptr      |
*        12|--------------|
*          |    Bptr      |
*        16|--------------|
*          | Var Name len |
*        20|--------------|
*          | Var Value len|
*        24|--------------|
*          |              |
*          |  Var Name    |
*          |              |
*          |--------------|
*          |              |
*          |              |
*          |  Var Value   |
*          |              |
*          |              |
*          +--------------+
*
*   First calculate the amount of storage required
*
            LA      R3,24                     Space for Blk_Hdr
*                                             + Fptr + Bptr
*                                             + Shvnaml
*                                             + Shvvall
            A       R3,Shvnaml                + Length of var name
            A       R3,ShvVall                + Length of var value
            L       R4,Sub_Pool
            Storage  OBTAIN,LENGTH=(R3),ADDR=(R8),                     +
               LOC=ANY,COND=NO,SP=(R4),KEY=8
            Using   Chain_Blk_Hdr,R8          Address the chain blk
            MVC     Chain_Hdr,=C'F$COMVAR'
            L       R1,Token                  Get ptr to head of chain
            L       R2,8(R1)                  Get addr 1st blk inchain
            LTR     R2,R2                     Is this firt time through
            BNZ     Put_3                     no; skip setting
            ST      R8,8(R1)                  Set first block
            ST      R8,12(R1)                 Set last  block
            LA      R0,0                      Clear starting block
            ST      R0,Chain_Fptr
            ST      R0,Chain_Bptr
            B       Put_4
Put_3       EQU     *
            LA      R0,0
            ST      R8,8(R1)                  Save Fptr to chain blk
            ST      R8,12(R2)                 Save Bptr to chain blk
            ST      R2,Chain_Fptr             Chain blks together
            ST      R0,Chain_Bptr             Chain blks together
Put_4       EQU     *
*
*   Copy in the variable name
*
            L       R0,Shvnama                Chain_Blk
            L       R1,Shvnaml
            ST      R1,16(R8)
            LA      R2,24(R8)
            LR      R3,R1
            MVCL    R2,R0
*
*   Copy in the variable Value
*
            L       R0,Shvvala
            L       R1,Shvvall
            ST      R1,20(R8)
            LR      R3,R1
            MVCL    R2,R0
*
            B       Put_1
Put_5       EQU     *
            B       Put_1
*
Put_Exit    EQU     *
            ST      R7,Read_Cnt
            ST      R6,Put_Cnt
            Pr
            Drop    R9,R8
*
*   Read all the chainded blocks of VAR/VALUE pairs to see if the
*   current Var name already exists.
*
Srch_Chain  Bakr    R14,0

            LA        R0,Msgtxt3
            ST        R0,Msg_Ptr
*           L         R15,Irxsay_Addr
*           Call    (15),(Irx_WRITE,Msg_Ptr,=A(l'Msgtxt3)),
*              VL,MF=(E,Call_Rtn)

            L       R10,Token           Get pointer to Anchor block
            Using   Anchor_Blk,R10      Address the Anchor_blk

            LA      R9,Shvblk           Get pointer to irx var blk
            Using   Shvblock,R9

            L       R8,Anchor_FBlk            Get ptr to 1st chain blk
            Using   Chain_Blk_Hdr,R8          Map Chain block

Srch_Chain_1 EQU    *

            LTR     R8,R8
            BZ      Srch_Chain_X8
            L       R3,16(R8)                 Get ptr to Var nam len
            LA      R2,24(R8)                 Get ptr to Var nam data
*
            CL      R3,Shvnaml                Are the lengths equal
            BNE     Srch_Chain_4              No, go on to next entry
            L       R1,Shvnama                Get addr of variable
            Bctr    R3,0                      Dec by 1 for CLC instr
            EX      R3,Cmp_Str
            BNE     Srch_Chain_4
*
*   Following lines are Debug code
*
            L       R3,16(R8)                 Get ptr to Var nam len
            LA      R2,24(R8)                 Get ptr to Var nam data

*
*   Variable located so now create an new var/val block and replace
*   the current one with this new one
*
            LA      R3,24
            A       R3,Shvnaml                + Length of var name
            A       R3,ShvVall                + Length of var value
            L       R4,Sub_Pool
            Storage  OBTAIN,LENGTH=(R3),ADDR=(R7),                     +
               LOC=ANY,COND=NO,SP=(R4),KEY=8

            MVC     0(8,R7),=C'F$COMVAR'      Init new control block
*
*   Copy in the variable name
*
            L       R0,Shvnama                Chain_Blk
            L       R1,Shvnaml
            ST      R1,16(R7)
            LA      R2,24(R7)
            LR      R3,R1
            MVCL    R2,R0
*
*   Copy in the variable Value
*
            L       R0,Shvvala
            L       R1,Shvvall
            ST      R1,20(R7)
            LR      R3,R1
            MVCL    R2,R0
*
*   New control block created so setup the Fptr/Bptr to pass through
*   this control block and replace the current block with this one
*
            LM      R5,R6,Chain_Fptr
            STM     R5,R6,8(R7)

*
*   Update Forward/Backward pointers
*
            LTR     R5,R5                   If Fptr 0 then last Blk
            BZ      Srch_Chain_2 Yes;Update Anchor Blk
            ST      R7,12(R5)               Update Bptr of Next Blk
            B       *+8

Srch_Chain_2  EQU    *

            ST      R7,Anchor_LBlk

Srch_Chain_21 EQU    *

            LTR     R6,R6                   Is Bptr 0 then first Blk
            BZ      Srch_Chain_3            Yes;Update Anchor Blk
            ST      R7,8(R6)                Update Fptr of Prev Blk
            B       *+8

Srch_Chain_3  EQU    *

            ST      R7,Anchor_FBlk

*
*   Now release the storage associated with the old control block
*
*           ST     R8,Temp
*           Call   R$Outhex,(Temp,=A(4)),VL,MF=(E,Call_Rtn)
            LA      R3,24
            A       R3,Chain_Var_Len
            A       R3,Chain_Val_Len
            L       R4,Sub_Pool
            Storage RELEASE,LENGTH=(R3),ADDR=(R8),SP=(R4),KEY=8
            B       Srch_Chain_X0

Srch_Chain_4 EQU    *

            L       R8,Chain_Fptr       Get pointer to next block
            B       Srch_Chain_1        Loop back to process next ent

Srch_Chain_X8 EQU   *

            LA      R15,8
            B       Srch_Chain_X
Srch_Chain_X0 EQU   *
            XR      R15,R15
            B       Srch_Chain_X
Srch_Chain_X  EQU   *
            Pr
            Drop    R10,R9,R8
*
*   List all the variables stored in the TCB pool chain
*
Listt       Bakr    R14,0

            MVC     Name_Token,=CL16'F$COMVAR_'
            MVC     Name_Token+9(4),Tcb_Addr
            LA      R0,131
            ST      R0,Sub_Pool
            BAS     R14,Ntrt_Blk             Retrieve name token pair
            LTR     R15,R15                  Did we get token ok
            BNZ     Listt_X                  No;Exit

            LA        R0,Msgtxt4
            ST        R0,Msg_Ptr
            L         R15,Irxsay_Addr
            Call    (15),(Irx_WRITE,Msg_Ptr,=A(l'Msgtxt4)),            +
               VL,MF=(E,Call_Rtn)
            BAS     R14,List_Chain
Listt_X     EQU     *
            PR
*
*   List all the variables stored in the Common pool chain
*
Listc       Bakr    R14,0

            MVC     Name_Token,=CL16'F$COMVAR_Common'
            LA      R0,131
            ST      R0,Sub_Pool
            BAS     R14,Ntrt_Blk             Retrieve name token pair
            LTR     R15,R15                  Did we get token ok
            BNZ     Listc_X                  No;Exit

            LA        R0,Msgtxt5
            ST        R0,Msg_Ptr
            L         R15,Irxsay_Addr
            Call    (15),(Irx_WRITE,Msg_Ptr,=A(l'Msgtxt5)),            +
               VL,MF=(E,Call_Rtn)
            BAS     R14,List_Chain
Listc_X     EQU     *
            PR
*
*   List all the variables stored in the Chain pointed to by Token
*   the token could be TCB,COMMON or POOL
*
List_Chain  Bakr    R14,0
*
*   Setup the message line pointer and output the initial header
*
            LA      R2,Msg_Line
            ST      R2,Msg_Ptr
            MVC     Msg_Line(40),=CL40'Variable Name'
            MVC     Msg_Line+40(40),=CL40'Variable Value'
            L       R15,Irxsay_Addr
            Call    (15),(Irx_WRITE,Msg_Ptr,=A(79)),                   +
               VL,MF=(E,Call_Rtn)
*
            L       R10,Token           Get pointer to Anchor block
            Using   Anchor_Blk,R10      Address the Anchor_blk

            L       R9,Anchor_FBlk      Get ptr to 1st chain blk
            Using   Chain_Blk_Hdr,R9    Map Chain block

List_Chain_1 EQU    *

            LTR     R9,R9
            BZ      List_Chain_X
            XC      Msg_Line,Msg_Line
*
*   Format the output to perform a listed display of
*   Variable name             |          Variable Value
*
            LA      R1,Chain_Var_Len+8
            L       R3,Chain_Var_Len
            BCTR    R3,0
            EX      R3,Var_Line
*
*   Address of variables VALUE is equal to Address of Variable name
*   plus length of Variable name
*
            LA      R1,Chain_Val_len+4       Get Addr of Value start
            A       R1,Chain_Var_len         Calc Addr of Value addr
*
            L       R3,Chain_Val_Len
            BCTR    R3,0
            EX      R3,Val_Line
*
            L       R15,Irxsay_Addr
            Call    (15),(Irx_WRITE,Msg_Ptr,=A(79),Rexx_Env),          +
               VL,MF=(E,Call_Rtn)
*
            L       R9,Chain_Fptr       Get pointer to next block
            B       List_Chain_1        Loop back to process next ent

List_Chain_X  EQU   *
            Pr
            Drop    R10,R9
*
*   Read all the chainded blocks of VAR/VALUE pairs and create
*   Rexx vars for the ones that match the pattern
*
Get         Bakr    R14,0
            LA      R9,Shvblk
            Using   Shvblock,R9
            XC      Shvnext,Shvnext           Clear Irx chain ptr
            MVI     Shvcode,shvstore          Set code to store
            XR      R6,R6                     Clear Read counter
            XR      R7,R7                     Clear Put  counter
            L       R1,Token                  Get ptr to cntl block
            L       R8,12(R1)                 Get ptr to 1st chain blk
            Using   Chain_Blk_Hdr,R8          Map Chain block
Get_1       EQU     *
            LTR     R8,R8
            BZ      Get_Exit_0
            LA      R7,1(R7)                  Count number of reads
            LA      R1,16(R8)                 Get ptr to Var nam len
            L       R2,0(R1)                  Get Var nam len
            ST      R2,Shvnaml                Set Var Name Length
            LA      R2,24(R8)                 Get ptr to Var nam data
            ST      R2,Shvnama                Set Var Name data addr
*
            L       R1,Shvnama
            A       R1,Shvnaml
            ST      R1,Shvvala                Var Value Address
*
            L       R2,20(R8)
            ST      R2,Shvvall                Var Value Length
*
*
            BAS     R14,Check_Var             Check variable name
            LTR     R15,R15
            BNZ     Get_2                     Variable name not valid
            LA      R6,1(R6)                  Count no of matched ents
*
*           L       R15,Irxsay_Addr
*           Call   (15),(Irx_Write,Shvnama,Shvnaml),VL,MF=(E,Call_rtn)
            L       R15,Irxexcom_Addr
            Call    (15),(Irx_Irxexcom,0,0,Shvblk),                    +
               VL,MF=(E,Call_Rtn)
            LTR     R15,R15
            BNZ     Get_Exit_8
Get_2       EQU     *
            L       R8,Chain_Bptr       Get pointer to next block
            B       Get_1               Loop back to process next ent
Get_Exit_8  EQU     *
            ST      R15,Retcode
            B       Get_Exit
Get_Exit_0  LA      R15,0
            B       Get_Exit
Get_Exit    EQU     *
            ST      R7,Read_Cnt
            ST      R6,Get_Cnt
            Pr
            Drop    R9,R8
*
*   Read all the chainded blocks of VAR/VALUE pairs and release the
*   storage allocated to them
*
Release     Bakr    R14,0
*
*   First thing is to delete the name token
*
            LA      R2,Retcode
            CALL    Ieantdl,(Level,Name_Token,(R2)),MF=(E,Call_Rtn)
            CLC     Retcode,=A(Ieant_ok)       Did delete work
            BNE     Rel_Exit
*
            L       R1,Token                  Get ptr to cntl block
            L       R8,8(R1)                  Get ptr to 1st chain blk
            Using   Chain_Blk_Hdr,R8          Map Chain block
            XC      0(16,R1),0(R1)            Clear the token ptr
Rel_1       EQU     *
*           ST      R8,Temp
*           Call   R$Outhex,(Temp,=A(4)),VL,MF=(E,Call_Rtn)
            LTR     R8,R8
            BZ      Rel_Exit
            LA      R3,24
            A       R3,16(R8)
            A       R3,20(R8)
            L       R2,Chain_Fptr
            L       R4,Sub_Pool
            STORAGE  RELEASE,LENGTH=(R3),ADDR=(R8),SP=(R4),KEY=8
            LR      R8,R2               Get pointer to next block
            B       Rel_1               Loop back to process next ent
Rel_Exit    EQU     *
            Pr
*
Check_Var   Bakr    R14,0
*
            LA      R9,Shvblk           Get pointer to irx var blk
            Using   Shvblock,R9
            L       R7,REXXARG          Get pointer to parms
            LA      R15,8               Set not valid rc code
Check_Var_1 EQU     *
            LA      R7,8(R7)            Point at parm
            CLC     0(8,R7),=X'FFFFFFFFFFFFFFFF' End of parms
            BE      Check_Var_X
            CLC     0(8,R7),=X'0000000000000000' Null parm
            BE      Check_Var_X
            L       R1,0(R7)            Point at argument
            L       R3,4(R7)            Get length of argument
            L       R2,Shvnama          Point at Variable name
            L       R4,Shvnaml          Get length of variable name
Check_Var_2 EQU     *
            CLI     0(R1),C'*'          Does this include all chars
            BE      Check_Valid
            OI      0(R1),X'40'         Convert to upper case
            LTR     R4,R4               Check at end of varname
            BZ      Check_Inval         Yes; Invalid match
            CLC     0(1,R2),0(R1)       Compare strings char by char
            BNE     Check_Inval         Not Equal ; Exit
            LA      R1,1(R1)            Incr by 1
            LA      R2,1(R2)            Incr by 1
            BCTR    R4,0                Decr by 1
            BCT     R3,Check_Var_2
            LTR     R4,R4               If R4 and R3 eq 0 then Var
            BZ      Check_Valid         must be valid
            BCTR    R1,0                Decr by 1 to check for stem
            CLI     0(R1),C'.'          Was this a stem variable
            BE      Check_valid         Yes, All stems are valid
Check_Inval EQU     *
            LA      R15,4               Set not valid rc code
            B       Check_Var_1
Check_Valid EQU     *
            XR      R15,R15             Clear return code
Check_Var_X EQU     *
            PR
            Drop    R9
*
List        Bakr    R14,0
*
            LA      R9,Shvblk
            Using   Shvblock,R9
            XC      Shvblk,Shvblk
            LA      R0,250
            ST      R0,Shvuser              Len of fetch buff name
            MVI     Shvcode,Shvnextv
            L       R0,Var_Val_Len          Len of fetch buff value
            ST      R0,Shvbufl
            LA      R0,Var_Nam_Str
            ST      R0,Shvnama
            L       R0,Var_Val_Addr
            ST      R0,Shvvala
*
*   Setup the message line pointer and output the initial header
*
            LA      R2,Msg_Line
            ST      R2,Msg_Ptr
            MVC     Msg_Line(40),=CL40'Variable Name'
            MVC     Msg_Line+40(40),=CL40'Variable Value'
            L       R15,Irxsay_Addr
            Call    (15),(Irx_WRITE,Msg_Ptr,=A(79)),                   +
               VL,MF=(E,Call_Rtn)
*
List_1      Equ     *
*
*   Call Rexx Variable access services to retrieve the variables
*
*           L        R0,Rexx_Env
            L       R15,Irxexcom_Addr
            Call    (15),(Irx_Irxexcom,0,0,Shvblk,Rexx_Env),           +
               VL,MF=(E,Call_Rtn)
            CLI     Shvret,Shvlvar         Last variable arrived
            BE      List_X                 Yes; then exit
            CLI     Shvret,ShvTrunc        Did truncation occur
            BNE     List_2
            ST      R15,RetCode            R15 will have val of 4
            B       List_3
*
List_2      Equ     *
            LTR     R15,R15                Check for any other error
            BNZ     List_X8                if yes then exit
*
List_3      Equ     *
*
            BAS     R14,Check_Var          Does this var match pattern
            CH      R15,=X'0008'           Was a pattern to match spec
            BE      List_4                 No; all vars are valid
            LTR     R15,R15                Ret code of 0 = Match
            BZ      List_4                 Yes; Output its value
            B       List_1
List_4      Equ     *
            XC      Msg_Line,Msg_Line
*
*   Format the output to perform a listed display of
*   Variable name             |          Variable Value
*
            L       R1,Shvnama
            L       R3,Shvnaml
            BCTR    R3,0
            EX      R3,Var_Line
*
            L       R1,Shvvala
            L       R3,Shvvall
            LTR     R3,R3
            BZ      List_5
            BCTR    R3,0
            EX      R3,Val_Line
*
List_5      Equ     *
*
            L       R15,Irxsay_Addr
            Call    (15),(Irx_WRITE,Msg_Ptr,=A(79),Rexx_Env),          +
               VL,MF=(E,Call_Rtn)
*
            B       List_1
List_X8     Equ     *
            ST      R15,Retcode
            WTO    'F$Comvar: Error during fetch next processing'
List_X      Equ     *
            Pr
            Drop    R9
Var_Line    MVC     Msg_line(0),0(R1)
Val_Line    MVC     Msg_line+40(0),0(R1)
*
*
*  This routine checks to see if version information has been
*  requested and if it has returns that information to the caller
*
F$Ver_Info    EQU    *
              BAKR   R14,R0
*
              L       R10,Efpl_Addr
              Using   Efpl,R10
              L       R9,Efpleval            Ptr to a full word that
              L       R9,0(R9)               points to the address
              Using   Evalblock,R9
              L       R8,Efplarg
              CLC     0(8,R8),=X'FFFFFFFFFFFFFFFF' Check for null
              BE      F$Ver_Info_x4     Exit Rc=4
              L       R3,4(R8)          Get length of parm
              CH      R3,=X'0007'       Check for length 7
              BNE     F$Ver_Info_x4     Exit Rc=4
              L       R1,0(R8)          Get Ptr to parm
              CLC     0(7,R1),=C'Version'                               er
              BNE     F$Ver_Info_x4     Exit Rc=4
              LA      R0,3
              St      R0,Evalblock_Evlen
              MVC     Evalblock_Evdata(3),F$Version
              XR      R15,R15
              B       F$Ver_Info_X
F$Ver_Info_x4 EQU     *
              LA      R15,4
F$Ver_Info_X  EQU     *
              PR
              Drop    R10,R9
*
***********************************************************************
*        End of subroutine entries                                    *
***********************************************************************
*
Espie_Rtn     EQU      *
              WTO      'F$comvar severe error Espie routine entered'
            LA        R0,Msgerr2
            ST        R0,Msg_Ptr
            L         R15,Irxsay_Addr
            Call    (15),(Irx_WRITEERR,Msg_Ptr,=A(l'Msgerr2)),         +
               VL,MF=(E,Call_Rtn)
            LA        R0,Prm_Area
            ST        R0,Msg_Ptr
            L         R15,Irxsay_Addr
            Call    (15),(Irx_WRITEERR,Msg_Ptr,Prm_Area_Len),          +
               VL,MF=(E,Call_Rtn)
              L        R1,Token                  Addr Header cntl blk
              XC       0(16,R1),0(R1)            Clear block
              L        R14,@Retry                Setup return address
              BR       R14
*
*
F$Comvar      CSECT
Cmdtable      DC    AL2(4),CL8'PUTT    ',AL4(Putt)
              DC    AL2(4),CL8'PUTC    ',AL4(Putc)
              DC    AL2(4),CL8'PUTP    ',AL4(Putp)
              DC    AL2(3),CL8'PUT     ',AL4(Putt)
              DC    AL2(3),CL8'UPDT    ',AL4(Updt)
              DC    AL2(3),CL8'UPDC    ',AL4(Updc)
              DC    AL2(3),CL8'UPDP    ',AL4(Updp)
              DC    AL2(3),CL8'UPD     ',AL4(Updt)
              DC    AL2(4),CL8'GETT    ',AL4(Gett)
              DC    AL2(4),CL8'GETC    ',AL4(Getc)
              DC    AL2(4),CL8'GETP    ',AL4(Getp)
              DC    AL2(3),CL8'GET     ',AL4(Gett)
              DC    AL2(4),CL8'LISTT   ',AL4(Listt)
              DC    AL2(4),CL8'LISTC   ',AL4(Listc)
              DC    AL2(4),CL8'LIST    ',AL4(List)
              DC    AL2(4),CL8'INIT    ',AL4(Initt)
              DC    AL2(5),CL8'INITT   ',AL4(Initt)
              DC    AL2(5),CL8'INITC   ',AL4(Initc)
              DC    AL2(3),CL8'RELT    ',AL4(Relt)
              DC    AL2(3),CL8'RELP    ',AL4(Relp)
Cmdtblen      EQU   (*-Cmdtable)/14
*
              DS       0F
QNAME         DC    CL8'SYSVAR'
RNAME         DC    CL8'ENQ LOCK'
*
Irx_Irxexcom  DC    CL8'IRXEXCOM'
Irx_Write     DC    CL8'WRITE   '
Irx_Writeerr  DC    CL8'WRITEERR'
REXX_PRM1     DC    CL8'IRXEXCOM'
SPACE         DC    CL1' '
SPACES        DC    CL256' '
BLANKS        DC    CL44' '
F$Version     DC    CL3'1.0'
*
              DS    0F
*
Level         DC    A(Ieant_Home_Level)
Name          DC    CL16'F$Comvar_Token'
Persopt       DC    A(Ieant_Nopersist)
*
Msgtxt1       DC    C'F$COMVAR: Reseting name token blk'
Msgtxt2       DC    C'F$COMVAR: Name token block created'
Msgtxt3       DC    C'F$COMVAR: Searching storage blocks'
Msgtxt4       DC    C'F$COMVAR: Listing TCB Pool storage blocks'
Msgtxt5       DC    C'F$COMVAR: Listing Common Pool storage blocks'
Msgerr1       DC    C'F$COMVAR: Error creating name token blk'
Msgerr2       DC    C'F$COMVAR: Espie entered'
Msgerr4       DC    C'F$COMVAR: Name token block does not exist'
*   Local program data definitions
*
              LTORG
*
*   DESCRIPTION OF SAVE AREA
*
SAVE_AREA     DSECT
VARSTORE      DS    0CL4096 Renterable save area
SAVEAREA      DS    0CL72   STANDARD SAVE AREA
PLI_LINK      DS    F       UNUSED
B_PTR         DS    F       BACKWARD SAVE AREA POINTER
F_PTR         DS    F       FORWARD  SAVE AREA POINTER
REG14         DS    F       CONTENTS OF REG 14
REG15         DS    F       CONTENTS OF REG 15
REG0          DS    F       CONTENTS OF REG 0
REG1          DS    F       CONTENTS OF REG 1
REG2          DS    F       CONTENTS OF REG 2
REG3          DS    F       CONTENTS OF REG 3
REG4          DS    F       CONTENTS OF REG 4
REG5          DS    F       CONTENTS OF REG 5
REG6          DS    F       CONTENTS OF REG 6
REG7          DS    F       CONTENTS OF REG 7
REG8          DS    F       CONTENTS OF REG 8
REG9          DS    F       CONTENTS OF REG 9
REG10         DS    F       CONTENTS OF REG 10
REG11         DS    F       CONTENTS OF REG 11
REG12         DS    F       CONTENTS OF REG 12
Rexx_Env      DS    A       Address of the rexx environment
Efpl_Addr     DS    A       Rexx external function parm list
REXXARG       DS    A       Address of Rexx argument list
Irxexcom_addr DS    A       Address of Rexx variable routine
Irxsay_addr   DS    A       Address of Rexx say routine
Msg_Ptr       DS    A       Address of Msg_Line
Msg_Len       DS    F       Length  of Msg_Line
Msg_Line      DS    CL80
Var_Nam_Addr  DS    A
Var_Nam_Len   DS    F
Var_Nam_Str   DS    CL250
*
Var_Val_Addr  DS    F
Var_Val_Len   DS    F
VAR_TMP       DS    CL16
              DS    0H
Bin_Char_STR  DS    AL2
              DS    CL8
REXX_REQUEST  DS    6A
REXX_PRM4     DS    CL32
              DS    0D
PL2           DS    PL2
PL4           DS    PL4
              DS    0D
PL8           DS    PL8
*
Put_Flag      DS    1F                  Flag word controls upd req
Upd_Var_Req   EQU   X'80'               Request that update rtn used
*
FLAGS         DS    1F
Enq_Flag      EQU   X'80'
Stg_Blk_Flag  EQU   X'40'
Cmd_Flag      DS    1F
*
Name_Token    DS    CL16
Sub_Pool      DS    1F
*
              DS    0F
Call_Rtn      CALL  ,(0,0,0,0,0,0,0,0),MF=L
*
Retcode       DS    1F                 Return code
Rsncode       DS    1F                 Reason code
Espie_Token   DS    1F                 The token returned by ESPIE
TEMP          DS    1F                 The token returned by ESPIE
@Retry        DS    1F                 Retry address for ESPIE
Tcb_Addr      DS    1F                 Address of current TCB
Put_Cnt       DS    1F                 Count of number of Puts issued
Get_Cnt       DS    1F                 Count of number of Gets issued
Read_Cnt      DS    1F                 Count of number of Reads issued
Token         DS    0CL16
VarBlk        DS    A
ValBlk        DS    A
              DS    CL8
*
Shvblk        DS    CL32
*Shvnext       DS    A
*Shvuser       DS    F
*Shvcode       DS    CL1
*Shvret        DS    XL1
*              DS    H'0'
*Shvbufl       DS    F
*Shvnama       DS    A
*Shvnaml       DS    F
*Shvvala       DS    A
*Shvvall       DS    F
*Shvblen       Equ   *-Shvblock
*
              DS    0F
Pool_Nam_len  DS    1F                 Pool name length
Pool_Nam      DS    CL8                Pool name

Prm_Area_len  DS    1F                 Length of Request in function
Prm_Area      DS    CL32               Request issued by function
*
              DS    0F
Prm2_Area_len DS    1F                 Length of parm 2
Prm2_Area     DS    CL250              Parm 2 value
*
              DS    0F
*
Val_Name_Len  DS    AL4
Val_Name      DS    CL80
              DS    0F
*
Chain_Blk_Hdr  DSECT
Chain_Hdr      DS      CL8
Chain_Fptr     DS      1F
Chain_Bptr     DS      1F
Chain_Var_Len  DS      1F
Chain_Val_Len  DS      1F
*
Anchor_Blk     DSECT
Anchor_Hdr     DS      CL8
Anchor_Fblk    DS      1F
Anchor_Lblk    DS      1F
*
              DS    H
              IRXEFPL
              IRXEVALB
              IRXSHVB
              IRXENVB
              IRXEXTE
              IEANTASM
*
R0            EQU      0
R1            EQU      1
R2            EQU      2
R3            EQU      3
R4            EQU      4
R5            EQU      5
R6            EQU      6
R7            EQU      7
R8            EQU      8
R9            EQU      9
R10           EQU      10
R11           EQU      11
R12           EQU      12
R13           EQU      13
R14           EQU      14
R15           EQU      15
*
              END
