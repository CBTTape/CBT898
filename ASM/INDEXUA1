//ALEXA JOB (NOT-REQUIRED),'AL-INDEXUFM',MSGCLASS=X,CLASS=B,
//       REGION=4096K,
//       NOTIFY=&SYSUID
/*JOBPARM ROOM=ZTS,LINES=9999
//*
//*
//*    JOB TO ASSEMBLE AND LINK ASSEMBLER SOURCE
//*
//*
//ASM      EXEC  PGM=ASMA90,REGION=1024K,
//         PARM='DECK,NOOBJECT,LIST,NOALIGN,NOXREF'
//SYSLIB   DD DISP=SHR,DSN=AKOS.MACLIB,
//            DCB=BLKSIZE=27920
//         DD DISP=SHR,DSN=SYS1.MACLIB
//*        DD DISP=SHR,DSN=SYS1.AMODGEN
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=AKOS.ASM
//         DD DISP=SHR,DSN=DNPCICS.CICSZOS.V220.SDFHMAC
//SYSUT1   DD UNIT=SYSDA,SPACE=(1700,(900,900))
//SYSUT2   DD UNIT=SYSDA,SPACE=(1700,(900,900))
//SYSUT3   DD UNIT=SYSDA,SPACE=(1700,(900,900))
//SYSLIN   DD DUMMY
//SYSPUNCH DD DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(5,5,0)),
//      DCB=(BLKSIZE=400),DSN=&LOADSET
//SYSPRINT DD SYSOUT=*
//SYSIN    DD *
*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*
*                                                                     *
**  Title:    'Unformatted dataset Index generator'                   *
**  System:   N/A                                                     *
**  Module:   INDEXUFM                                                *
**  Program:  INDEXUFM                                                *
**  Function: Read the '$$$INDEX' member (if it exists) of a PDS with *
**            DSORG=U, pass the details to ISPF's editor interface    *
**            'EDIF', modify the Index under editor using the 'INDEX' *
**            edit-macro and then re-writing the Index so that it can *
**            be readily browsed using ISPF's browse function.        *
**                                                                    *
**  Parms:    Parameter are passed via the ISPF shared variable pool. *
**                                                                    *
**              Input: DSNAME - Fully qualified unquoted dataset name *
**                                                                    *
**                     VOLUME - 6 character volume id. This parm is   *
**                              required to allow for uncatalogued    *
**                              datasets.                             *
**                                                                    *
**                     UNIT   - 8 character unit name (SYSALLDA)      *
**                                                                    *
**             Output: INDEXUB- Flag to indicate to the 'INDEX' macro *
**                              that this is an unformatted dataset   *
**                                                                    *
**                     GC009  - Error message (message set on exit)   *
**                                                                    *
**            This program is NOT re-entrant.                         *
**                                                                    *
**  Author:   ASYSTS Pty. Ltd. (A. Kara).                             *
*                                                                     *
*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*
*        PRINT OFF
*#####################################################################*
*        COPY  @MACROS                 COMMON MACROS
*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*
*                                                                     *
*  General macros used in programs written by ASYSTS Pty. Ltd.        *
*                                                                     *
*  SUMMARY:                                                           *
*  ~~~~~~~~                                                           *
*    1. KICKOFF  - Initial program entry housekeeping.                *
*    2. RACKOFF  - Final program exit housekeeping.                   *
*    3. UNPACK   - Convert HEX numerics to display format             *
*    4. CLEARV   - Move blanks to variable field (> 255 bytes).       *
*    5  AMODECHG - Addressing MODE CHanGe                             *
*    6. HEXCHMAC - Convert HEX to character.                          *
*    7. CHHEXMAC - Convert character to HEX.                          *
*    8. ISPVDEFX - Define ISPF variables (ISPVDEF) to program.        *
*    9. ISPEXEC  - Invoke ISPLINK using 'ISPEXEC' format commands.    *
*   10. PUTL     o Issue a PUTLINE command within a command processor *
*   11. ADYN     - DYNAMIC allocation/deallocation etc...             *
*   12. PDUMPR   - Program dump with REXX/ISPF presentation.          *
*   13. PDUMP    o Program dump with 3270 datastream presentation.    *
*                                                                     *
*   3270 Data Stream macros:                                          *
*   14. CADC     o Character Attribute Define Constant                *
*   15. ICDC     o Insert Character Define Constant                   *
*   16. RADC     o Repeat to Address Define Constant                  *
*   17. SBA      o Set Buffer Address                                 *
*   18. SBADC    o Set Buffer Address Define Constant                 *
*   19. WCCDC    o Write Control Character Define Constant            *
*       --------
*                                                                     *
*  This member can be rebuilt using the MACBUILD edit macro. To make  *
*  a sub-set, change the '-' after the macro name to the optional     *
*  indicator 'o'.  This will leave the entry without including the    *
*  member. Alternatively pass parameter of ALL to MACBUILD to include *
*  all assembler macros.                                              *
*                                                                     *
*  To find the start of the appropriate macro, enter "F 'MACRO n'".   *
*                                                                     *
*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*
*------- Macro  1. KICKOFF -------------------------------------------*
         MACRO
&NAME    KICKOFF &BASE,&GETMAINS,&GETMAINL,&LIST=NO,&HELP=NO,&DREG=,   X
               &AMODE=31,&RMODE=ANY,&SAVE=,&LOC=
         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'KICKOFF' parameters    *
* and it's use, pass parameter of 'HELP=Yes'.                         *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
*---------------------------------------------------------------------*
* Macro to generate all the house keeping etc.. at start of a program,*
* either re-entrant or not.                                           *
* This macro works in conjunction with the 'RACKOFF' macro.           *
*                                                                     *
* PARAMETERS:
* 1. Base register(s) - Format "(Rx,Ry,Rz)" or "Rx". May have up to   *
*                       3 base registers specified. R13 may not be    *
*                       used for re-entrant programs (refer 2 below). *
*                       For non re-entrant programs, if R13 is used   *
*                       as one of the base registers, it will be used *
*                       as the first base regardless of it's position *
*                       in the parameter string, and the initial base *
*                       will be the conventional register save area   *
*                       NOT the start of the program.                 *
*                       Default is "(R11,R12)".                       *
* 2. First variable,s name in the DSECT of a GETMAINEd area.  This    *
*    parameter is optional, however, if it used (eg. re-entrant       *
*    programs), R13 may not be used as a base register and the first  *
*    18 full words must be used for register save and linkage         *
*    conventions.                                                     *
* 3. Length of the GETMAINEd area (must be an "EQU" variable) and must*
*    be supplied if variable name parameter is supplied.              *
* 4. AMODE=..  - Addressing mode '24/31' (default = 31)               *
* 5. DREG=Rn   - Additional DSECT register on GETMAINEd area. (Use    *
*                only if you have addressability problems on the      *
*                GETMAINE'd DSECT. Do not enclose in brackets.)       *
* 6. HELP=...  - Display help comments. 'YES/NO' (default = NO).      *
* 7. LIST=...  - Display code generated. 'YES/NO' (default = YES).    *
* 8. LOC=....  - Optional loaction for the GETMAINed area if that     *
*                option is used. It must be a valid parameter as      *
*                defined by the IBM GETMAIN macro.                    *
* 9. RMODE=..  - Load  mode '24/ANY' (default = ANY)                  *
*10. SAVE=...  - Variable name of register save area if you wish to   *
*                control it's name. (useful if specialised exit       *
*                in-lieu of 'RACKOFF'.                                *
*                                                                     *
* GENERATES:                                                          *
* 1. Inserts a "program_date_time" stamp at start of module.          *
* 2. Sets up all the register equates.                                *
* 3. Saves callers registers R14 thru R12.                            *
* 4. Points R13 to the programs savearea.                             *
* 5. Establishes addresability thru supplied register(s) or default   *
*     base registers R11 + R12.                                       *
* 6. Workarea is GETMAINEd and the conventional linkage pointers,     *
*     registers saved and R13 pointed to the start of the work area.  *
* 7. As R0 + R1 are used as work registers at start, they are restored*
*     from callers savearea.                                          *
*                                                                     *
*---------------------------------------------------------------------*
.A$HELPE ANOP
         AIF   ('&LIST'(1,1) NE 'N').A$XX
         PUSH  PRINT
         PRINT NOGEN
.A$XX    ANOP
         GBLB  &KO1STR1
         GBLC  &R,&GETMADR,&GETMADL,&SAVREGS
         LCLC  &E,&BASE1,&BASE2,&BASE3,&BASE#,&#DREG,&#GMM
         LCLA  &A,&#BASES,&GETMLEN
         AIF   (T'&GETMAINS EQ 'O').NRENT
         AIF   (T'&GETMAINL EQ 'O').ERR2
.NRENT   ANOP
&GETMADR SETC  '&GETMAINS'
&GETMADL SETC  '&GETMAINL'
.*--------------------------------------------------------------------*
         AIF   (T'&SAVE EQ 'O').DEFSRG      BYPASS IF DEFAULT SAVE NAME
&SAVREGS SETC  '&SAVE'
         AGO   .A$$XX                       BYPASS DEFAULT NAME
.DEFSRG  ANOP
&SAVREGS SETC  '$SAV'.'&SYSNDX'
.A$$XX   ANOP
.*--------------------------------------------------------------------*
         LCLC  &TNAME
         AIF   (T'&BASE EQ 'O').DEFAULT
&BASE1   SETC  '&SYSLIST(1,1)'
&BASE2   SETC  '&SYSLIST(1,2)'
&BASE3   SETC  '&SYSLIST(1,3)'
&#BASES  SETA  N'&SYSLIST(1)
         AIF   (T'&GETMAINS EQ 'O').A$00    NON-R BYPASS
         AIF   ('&BASE1' EQ 'R13').ERRR13
         AIF   ('&BASE2' EQ 'R13').ERRR13
         AIF   ('&BASE3' EQ 'R13').ERRR13
         AIF   ('&BASE1' EQ '13').ERRR13
         AIF   ('&BASE2' EQ '13').ERRR13
         AIF   ('&BASE3' EQ '13').ERRR13
.A$00    ANOP
         AIF   ('&BASE2' EQ 'R13').BASE213
         AIF   ('&BASE2' EQ '13').BASE213
         AIF   ('&BASE3' EQ 'R13').BASE313
         AIF   ('&BASE3' EQ '13').BASE313
         AGO   .CONT1
.BASE213 ANOP
&BASE#   SETC  '&BASE1'
&BASE1   SETC  '&BASE2'
&BASE2   SETC  '&BASE#'
         AGO   .CONT1
.BASE313 ANOP
&BASE#   SETC  '&BASE1'
&BASE1   SETC  '&BASE3'
&BASE3   SETC  '&BASE#'
         AGO   .CONT1
.DEFAULT ANOP
&#BASES  SETA  2
&BASE1   SETC  'R11'
&BASE2   SETC  'R12'
.CONT1   ANOP
         AIF   (T'&GETMAINS EQ 'O').NONR0   NON-R BYPASS
         AIF   (T'&DREG EQ 'O').NONR0       NO 2ND.DSECT REG, BYPASS
         AIF   ('&DREG' EQ '&BASE1').ERDREG IF SAME AS BASE 1, ERROR
         AIF   ('&DREG' EQ '&BASE2').ERDREG IF SAME AS BASE 2, ERROR
         AIF   ('&DREG' EQ '&BASE3').ERDREG IF SAME AS BASE 3, ERROR
         AIF   ('&DREG' EQ 'R13').ERDREG    IF R13, ERROR
         AIF   ('&DREG' EQ '13').ERDREG     IF R13, ERROR
         AIF   ('&DREG' EQ 'RD').ERDREG     IF R13, ERROR
&#DREG   SETC  ',&DREG'                     SET SECONDARY DSECT REG
.NONR0   ANOP
.*--------------------------------------------------------------------*
         AIF      ('&NAME' EQ '').NONAME
&E       SETC     '&NAME'
         AGO      .A
.NONAME  ANOP
&E       SETC    'NULL&SYSNDX'
.A       ANOP
&E       CSECT
.TAMODE  ANOP
         AIF ('&AMODE' NE '31').AM24$
&E       AMODE  31                          AMODE OF 31
         AGO    .TRMODE                     Continue
.AM24$   ANOP
&E       AMODE  24                          AMODE OF 24 REQUESTED
&E       RMODE  24                          RMODE OF 24 FORCED
         AGO    .BYP#10                     Continue
.TRMODE  ANOP
         AIF ('&RMODE' NE 'ANY').RM24$$
&E       RMODE  ANY                         RMODE OF ANY
         AGO    .BYP#10                     Continue
.RM24$$  ANOP
&E       RMODE  24                          RMODE OF 24 REQUESTED
.BYP#10  ANOP
&R       SETC     'R'
         AIF ('&BASE1' EQ 'R13').SAVANCH
         AIF ('&BASE1' NE '13').TEST1ST
.SAVANCH ANOP
&E       SETC     '&SAVREGS'                SET REGISTER SAVE AREA BASE
.*--------------------------------------------------------------------*
.TEST1ST ANOP
         AIF   (&KO1STR1).C                 FIRST TIME THRU
&KO1STR1 SETB 1
R0       EQU    0
R1       EQU    1
R2       EQU    2
R3       EQU    3
R4       EQU    4
R5       EQU    5
R6       EQU    6
R7       EQU    7
R8       EQU    8
R9       EQU    9
R10      EQU   10
RA       EQU   10
R11      EQU   11
RB       EQU   11
R12      EQU   12
RC       EQU   12
R13      EQU   13
RD       EQU   13
R14      EQU   14
RE       EQU   14
R15      EQU   15
RF       EQU   15
*---------------------------------------------------------------------*
.C       ANOP
         B     30(&R.15)                    BRANCH AROUND P/D/T STAMP
         DC    CL8'&NAME'                   PROGRAM STAMP
         DC    C'_'                         DELIMITER
         DC    CL8'&SYSDATE'                DATE STAMP
         DC    C'_'                         DELIMITER
         DC    CL8'&SYSTIME'                TIME STAMP
         STM   &R.14,&R.12,12(&R.13)        SAVE REGISTERS
         AIF   (T'&GETMAINS EQ 'O').NONR1   NON-R BYPASS
.*--------------------------------------------------------------------*
.*      RE-ENTRANT PROG                                               *
.*--------------------------------------------------------------------*
         LR    2,15                         LOAD R2 WITH START OF PR
         USING &NAME,2                      USE R2 AS TEMPORARY BASE
.*--------------------------------------------------------------------*
         AIF (T'&LOC EQ 'O').NOGMLOC
*        GETMAIN R,LV=&GETMAINL,&LOC        GETMAIN AREA
         GETMAIN R,LV=&GETMAINL,&LOC        GETMAIN AREA
         AGO   .A$$000
.NOGMLOC ANOP
*        GETMAIN R,LV=&GETMAINL             GETMAIN AREA
         GETMAIN R,LV=&GETMAINL             GETMAIN AREA
.A$$000  ANOP
.*--------------------------------------------------------------------*
         ST    &R.13,4(&R.1)                BACKWARD CHAIN
         ST    &R.1,8(&R.13)                FORWARD CHAIN
.*--------------------------------------------------------------------*
.* The next line does horrible things with 31 bit addressing.         *
.*       NI    12(&R.13),X'00'              CLEAR TRACE BITS
.*--------------------------------------------------------------------*
         LR    &R.13,&R.1                   SAVE AREA @
         AIF   (T'&DREG EQ 'O').NDREG1      NO 2ND.DSECT REG, BYPASS
         LA    &DREG,4095(&R.13)            POINT 2ND. REG 1K PAST
         LA    &DREG,1(&DREG)                 1ST. DSECT BASE
.NDREG1  ANOP
         USING &GETMADR,&R.13&#DREG         ADDRESABILITY TO GETMAIN
         LR    &BASE1,&R.2                  &BASE1 IS 1ST. BASE REG
         DROP  &R.2                         DROP REGISTER 15 AS BASE
         AIF      (&#BASES GT 1).TWOBASE
         USING &E,&BASE1                    USING ONE BASE REGISTER
         AGO      .RESTR0R2
.NONR1   ANOP
.*--------------------------------------------------------------------*
.*      NON RE-ENTRANT PROG                                           *
.*--------------------------------------------------------------------*
         USING &NAME,15                     USE R15 AS TEMPORARY BASE
         ST    &R.13,&SAVREGS.+4            BACKWARD CHAIN
         LA    &R.0,&SAVREGS                OUR SAVEAREA ADDRESS
         ST    &R.0,8(&R.13)                FORWARD CHAIN
.*--------------------------------------------------------------------*
.* The next line does horrible things with 31 bit addressing.         *
.*       NI    12(&R.13),X'00'              CLEAR TRACE BITS
.*--------------------------------------------------------------------*
         LR    13,0                         R13 POINT TO OUR SAVEAREA
         AIF ('&E' EQ '&SAVREGS').NOLOAD1   BUPASS BASE LOAD
         LR    &BASE1,15                    &BASE1 IS 1ST. BASE REG
.NOLOAD1 ANOP
         AIF      (&#BASES GT 1).TWOBASE
         DROP  15                           RELINQUISH ADDRESSABILITY
         USING &E,&BASE1                    USING ONE BASE REGISTER
         AGO      .ADROK
.TWOBASE ANOP
         LA    &BASE2,4095(&BASE1)          POINT 2ND. REG 1K PAST
         LA    &BASE2,1(&BASE2)               1ST. BASE
         AIF      (&#BASES GT 2).THRBASE
         DROP  15                           RELINQUISH ADDRESSABILITY
         USING &E,&BASE1,&BASE2             USING TWO BASE REGISTERS
         AGO      .ADROK
.THRBASE ANOP
         LA    &BASE3,4095(&BASE2)          POINT 3RD. REG 1K PAST
         LA    &BASE3,1(&BASE3)               2ND. BASE
         DROP  15                           RELINQUISH ADDRESSABILITY
         USING &E,&BASE1,&BASE2,&BASE3      USING THREE BASE REGISTERS
.*       AGO      .ADROK
.ADROK   ANOP
         AIF   (T'&GETMAINS NE 'O').RESTR0R2 RE-ENT PROCESSING
         LA    1,&E                         ADDRESS OF CSECT
         LA    0,&SAVREGS                   NEW BASE ADDRESS
         SR    1,0                          SUBTRACT THE DIFFERENCE
         STH   1,KOFFCOMP                   STORE UNDER @ COMPENSATOR
         B     &SAVREGS.+74                 BRANCH AROUND SAVE AREA
&SAVREGS DS    18F
KOFFCOMP DS    H                            KICKOFF BASE @ COMPENSATOR
         XR    &R.0,&R.0                    ZERO REGISTER 0
         ST    &R.0,&SAVREGS.+8             CLEAR FORWARD CHAIN
         L     &R.1,4(&R.13)                LOAD CALLERS SAVEAREA @
         LM    &R.0,&R.1,20(&R.1)           RESTORE PARM REGISTERS
         AGO   .MEXIT1
.*--------------------------------------------------------------------*
.RESTR0R2 ANOP
.*--------------------------------------------------------------------*
.*      RE-ENTRANT PROG                                               *
.*--------------------------------------------------------------------*
         XR    &R.0,&R.0                    ZERO REGISTER 0
         ST    &R.0,8(&R.13)                CLEAR FORWARD CHAIN
         L     &R.1,4(&R.13)                LOAD CALLERS SAVEAREA @
         LM    &R.0,&R.2,20(&R.1)           RESTORE PARM REGISTERS
         AGO   .MEXIT1
.*--------------------------------------------------------------------*
.ERR     MNOTE 8,'MUST SUPPLY WORK-AREA DSECT FOR GETMAIN.'
         AGO   .MEXIT1
.ERR2    MNOTE 8,'MUST SUPPLY WORK-AREA DSECT LENGTH FOR GETMAIN.'
         AGO   .MEXIT1
.ERR3    MNOTE 8,'NO MATCHING RACKOFF FOR PREVIOUS KICKOFF.'
         AGO   .MEXIT1
.ERRR13  MNOTE 8,'R13 CANNOT BE USED AS BASE FOR RE-ENTRANT MACRO.'
         AGO   .MEXIT1
.ERDREG  MNOTE 8,'XTRA DSECT REGISTER MUST NOT BE A BASE OR R13.'
         AGO   .MEXIT1
.MEXIT1  ANOP
         AIF   ('&LIST'(1,1) NE 'N').MEXIT9
         POP PRINT
.MEXIT9  ANOP
*---------------------------------------------------------------------*
         MEXIT
.*--------------------------------------------------------------------*
         MEND
*---------------------------------------------------------------------*
*------- Macro  2. RACKOFF -------------------------------------------*
         MACRO                                                          RAC00010
&NAME    RACKOFF &RC=0,&LIST=NO,&R1=,&HELP=NO                           RAC00020
         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'RACKOFF' parameter     *
* and it's use, pass parameter 'HELP=Yes'.                            *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
*---------------------------------------------------------------------*
* Parameters:                                                         *
*                                                                     *
*        RC=n       - Numeric return code (default = 0)               *
*                             - or -                                  *
*                     RC=(R15) if R15 contains the return code        *
*        LIST=Y/N   - Generate code from macro expansion (def = NO)   *
*        HELP=Y/N   - Display this help box (def = Yes)               *
*        R1=PASS    - 'PASS' infers that R1 contains return parameter *
*                     value to the caller and is to remain as is. Any *
*                     other value will include R1 in the register     *
*                     restoration command 'LM  R14,R12,....'          *
*---------------------------------------------------------------------*
.A$HELPE ANOP
         PUSH  PRINT
         AIF   ('&LIST'(1,1) NE 'N').A$XX
         PRINT NOGEN
.A$XX    ANOP
         AIF   (T'&NAME EQ 'O').NONAME
&NAME    DS    0H                                                       RAC00020
.NONAME  ANOP
         GBLC  &R,&GETMADR,&GETMADL,&SAVREGS
&KO1STR  SETB 0                             TURN 1ST TIME THRU OFF
         AIF   (T'&GETMADL EQ 'O').A$10     NON-R BYPASS
         AIF   (T'&R1 EQ 'O').A$00          DO NOT PASS R1
         AIF   ('&R1' NE 'PASS').A$00       IF R1¬=PASS DO NOT PASS R1
         LR    &R.3,&R.1                    SAVE REGISTER 1 IN CASE
.A$00    ANOP
         LR    &R.1,&R.13                   LOAD GETMAINED AREA ADDRESS
         LR    &R.2,&R.15                   SAVE REGISTER 15 IN CASE
.A$10    ANOP
         L     &R.13,4(&R.13)               LOAD CALLERS SAVEAREA @     RAC00040
         AIF   (T'&GETMADL EQ 'O').A$20     NON-R BYPASS
*        FREEMAIN R,LV=&GETMADL,A=(1)
         FREEMAIN R,LV=&GETMADL,A=(1)
.A$20    ANOP
         AIF   (T'&R1 EQ 'O').A$21          DO NOT PASS R1
         AIF   ('&R1' NE 'PASS').A$21       IF R1¬=PASS DO NOT PASS R1
         LR    &R.1,&R.3                    RESTORE R1
.A$21    ANOP
         AIF   ('&RC' EQ '(R15)').SPEC      R15 CONTAINS RC             RAC00050
         AIF   ('&RC' EQ '(15)').SPEC R15 CONTAINS RC                   RAC00060
         AIF   (T'&R1 EQ 'O').A$22          DO NOT PASS R1
         AIF   ('&R1' NE 'PASS').A$22       IF R1¬=PASS DO NOT PASS R1
         LM    &R.14,&R.0,12(&R.13)         RESTORE REGISTERS 14-0      RAC00070
*                                           LEAVE R1 AS IS
         LM    &R.2,&R.12,28(&R.13)         RESTORE REGISTERS 2-12      RAC00070
         AGO   .A$23                                                    RAC00090
.A$22    ANOP
         LM    &R.14,&R.12,12(&R.13)        RESTORE REGISTERS 14-12     RAC00070
.A$23    ANOP
         LA    &R.15,&RC                    SET RETURN CODE             RAC00080
         AGO   .RET1                                                    RAC00090
.SPEC    ANOP                                                           RAC00100
         AIF   (T'&GETMADL EQ 'O').A$30     NON-R BYPASS
         LR    &R.15,&R.2                   RESTORE R15 FROM ABOVE SAVE RAC00100
.A$30    ANOP
         L     &R.14,12(&R.13)              RESTORE R14                 RAC00100
         AIF   (T'&R1 EQ 'O').A$32          DO NOT PASS R1
         AIF   ('&R1' NE 'PASS').A$32       IF R1¬=PASS DO NOT PASS R1
         L     &R.0,20(&R.13)               RESTORE REGISTER 0          RAC00110
*                                           LEAVE R1 AS IS
         LM    &R.2,&R.12,28(&R.13)         RESTORE REGISTERS 2-12      RAC00110
         AGO   .RET1                                                    RAC00090
.A$32    ANOP
         LM    &R.0,&R.12,20(&R.13)         RESTORE REGISTERS 0-12      RAC00110
.RET1    ANOP                                                           RAC00120
.*--------------------------------------------------------------------*
.* The next line does horrible things with 31 bit addressing.         *
.*       MVI   12(&R.13),X'FF'              SET TRACE BITS ON           RAC00120
.*--------------------------------------------------------------------*
         BR    &R.14                        RETURN                      RAC00130
         POP   PRINT
*---------------------------------------------------------------------*
         MEXIT
.*--------------------------------------------------------------------*
.E1      POP   PRINT
         MNOTE 8,'MACRO KICKOFF MUST BE USED WITH THIS MACRO.'
         MEXIT
.*--------------------------------------------------------------------*
         MEND                                                           KIC00710
*---------------------------------------------------------------------*
*------- Macro  3. UNPACK --------------------------------------------*
         MACRO
&NAME    UNPACK &REG,&PL,&OUT,&MF=,&LIST=NO,&HELP=NO
         AIF   ('&HELP' EQ 'YES').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'UNPACK' parameters     *
* and it's use, pass parameter of 'HELP=Yes'.                         *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
*---------------------------------------------------------------------*
* Macro to unpack a register into a variable.                         *
*                                                                     *
*   PARAMETERS:                                                       *
*       1. Register holding contents                                  *
*       2. Length to unpack                                           *
*       3. Output field (default "upout(8)")                          *
*       4. MF=E/L for re-entrant programs.  (Not required for non     *
*          re-entrant programs.)                                      *
*       5. LIST=YES/NO, to determine generation of macro statements.  *
*                                                                     *
*   NOTE:                                                             *
*       For re-entrant programs the list format only requires the     *
*       MF= parameter,                                                *
*            eg.      UNPACK MF=L                                     *
*                                                                     *
*---------------------------------------------------------------------*
.A$HELPE ANOP
         PUSH  PRINT
         AIF   ('&LIST' NE 'NO').A$XX
         PRINT NOGEN
.A$XX    ANOP
         AIF   (T'&NAME EQ 'O').A$YY
&NAME    DS    0H
.A$YY    ANOP
         AIF   ('&MF' EQ 'L').A$ZZ
         AIF   (T'&REG EQ 'O').E1
         AIF   (T'&PL EQ 'O').E2
.A$ZZ    ANOP
         GBLC  &TNAME
         LCLC  &UPWORK,&UPOUT
         GBLB  &UNPFST1,&UNPFST2
         AIF   (&UNPFST1).A$00
&UNPFST1 SETB  1
&TNAME   SETC  'UPK'.'&SYSNDX'
.A$00    ANOP
&UPWORK  SETC  '&TNAME'.'1'
&UPOUT   SETC  '&TNAME'.'2'
         AIF   ('&MF' EQ 'E').A$99          BYPASS IF EXEC FORM OF MAC
         AIF   ('&MF' EQ 'L').A$11          BYPASS IF LIST FORM OF MAC
         AIF   (&UNPFST2).A$99
&UNPFST2 SETB  1
         B     &TNAME.3                    BRANCH AROUND DATA
.*--------------------------------------------------------------------*
.*       DATA STORAGE                                                 *
.*--------------------------------------------------------------------*
.A$11    ANOP
&UPWORK  DS    D
&UPOUT   DS    CL8
         AIF   ('&MF' EQ 'L').EXIT         BYPASS IF LIST FORM OF MAC
.*--------------------------------------------------------------------*
&TNAME.3 DS    0H
.A$99    ANOP
         CVD   &REG,&UPWORK
         OI    &UPWORK+7,X'0F'
         UNPK  &UPOUT.(8),&UPWORK+8-&PL.(&PL.)
         AIF   (T'&OUT EQ 'O').EXIT
         MVC   &OUT.(&PL.),&UPOUT+8-&PL.
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E1      MNOTE 12,'UNPACK REQUIRES SOURCE A REGISTER'
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E2      MNOTE 12,'UNPACK REQUIRES A LENGTH'
.*--------------------------------------------------------------------*
.EXIT    ANOP
         POP   PRINT
         MEXIT
         MEND
*---------------------------------------------------------------------*
*------- Macro  4. CLEARV --------------------------------------------*
         MACRO
&NAME    CLEARV &OUT,&LENGTH,&PAD=40,&MF=,&LIST=YES,&HELP=NO
         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'CLEARV'  parameters    *
* and it's use, pass parameter of 'HELP=Yes'.                         *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
*---------------------------------------------------------------------*
*                                                                     *
*   Move a particular pad character to any variable. The variable may *
*   be > 256 characters.                                              *
*                                                                     *
*   For variable < 258: uses a ripple move.                           *
*       variable > 257: uses the MVCL instruction.                    *
*                                                                     *
*   NOTE : - All registers are kept in tact by this macro.            *
*                                                                     *
*   PARAMETERS:                                                       *
*     1. Destination variable's name.                                 *
*     2. Length of the variable. To be supplied if the "L'varname"    *
*        function will not return the required length.                *
*     3. PAD=xx - HEX notation of the pad character. The default is   *
*                 X'40' (ie. spaces).                                 *
*     3. MF=E/L - Macro format. For re-entrant programs, MF=L is      *
*                 required as the macro requires a register save area.*
*                 It uses a common save area with other macros,       *
*                 however, the first macro reserves the storage and it*
*                 may be this one.                                    *
*     4. HELP=YES/NO - to generate these comments.                    *
*     5. LIST=YES/NO - to generate a list of commands generated.      *
*                                                                     *
*---------------------------------------------------------------------*
.A$HELPE ANOP
         PUSH  PRINT
         AIF   ('&LIST'(1,1) NE 'N').A$XX
         PRINT NOGEN
.A$XX    ANOP
         LCLC  &CLNAME
         LCLA  &VLENGTH,&LT258L
.*--------------------------------------------------------------------*
         AIF   ('&MF' EQ 'L').A$YY
         AIF   (T'&OUT EQ 'O').E1
         AIF   (T'&LENGTH EQ 'O').NOLEN
.A$YY    ANOP
&VLENGTH SETA  &LENGTH
         AGO   .CONT1
.NOLEN   ANOP
&VLENGTH SETA  L'&OUT
.CONT1   ANOP
         AIF   (&VLENGTH LT 258).A$RD
.*--------------------------------------------------------------------*
         AIF   ('&MF' EQ 'L').A$00
.A$00    ANOP
         GBLB  &CLFIRST
         GBLC  &CLBYP1
.*--------------------------------------------------------------------*
         GBLC  &REGSAVR,&REGSMCR
         GBLB  &REGSFLG,&REGDFLG
         AIF   (&REGSFLG).A$RS
&REGSAVR SETC  'GB'.'&SYSNDX'.'#'
&REGSMCR SETC  'CLEARV'
&REGSFLG SETB  1
.A$RS    ANOP
.*--------------------------------------------------------------------*
         AIF   ('&MF' EQ 'E').A$88
         AIF   (&CLFIRST).A$88
&CLFIRST SETB  1
&CLNAME  SETC  'CL'.'&SYSNDX'
&CLBYP1  SETC  '&CLNAME'.'1'
.*--------------------------------------------------------------------*
.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *
.*--------------------------------------------------------------------*
         AIF   (&REGDFLG).A$RD
&REGDFLG SETB  1
         AIF   ('&MF' EQ 'L').A$77
         B     &CLBYP1                 BRANCH AROUND REGISTER SAVEAREA
.A$77    ANOP
&REGSAVR DS    16F                     REGISTER SAVE AREA
         AIF   ('&MF' EQ 'L').EXIT
&CLBYP1  DS    0H
.A$RD    ANOP
         AIF   ('&MF' EQ 'L').EXIT
.*--------------------------------------------------------------------*
.A$88    ANOP
         AIF   (&VLENGTH GT 257).A$99
*  Ripple move                                                        *
&LT258L  SETA  &VLENGTH-1
         MVI   &OUT,X'&PAD'            MOVE PAD CHARACTER
         MVC   &OUT+1(&LT258L),&OUT    RIPPLE MOVE TO REST OF VARIABLE
         AGO   .EXIT
.A$99    ANOP
*  MVCL instruction move                                              *
         STM   R14,R1,&REGSAVR         SAVE REGISTERS
         LA    R0,&OUT                 LOAD ADDRESS OF VARIABLE
         L     R1,=F'&VLENGTH'         LOAD LENGTH OF VARIABLE
         XR    R14,R14                 CLEAR SOUREC ADDRESS
         XR    R15,R15                 CLEAR SOURCE LENGTH
         ICM   R15,B'1000',=X'&PAD'    MOVE PAD CHARACTER
         MVCL  R0,R14                  SET AREA TO ALL SPACES
         LM    R14,R1,&REGSAVR         RESTORE SAVED REGISTERS
.*--------------------------------------------------------------------*
.EXIT    ANOP
         AGO   .MEXIT1
.*--------------------------------------------------------------------*
.E1      MNOTE 12,'CLEAR BIG REQUIRES A DESTINATION VARIABLE.'
         AGO   .MEXIT1
.E2      MNOTE 12,'CLEAR BIG LONG REQUIRES A LENGTH.'
.MEXIT1  ANOP
         AIF   ('&LIST'(1,1) EQ 'Y').A$ZZ
         POP PRINT
.A$ZZ    ANOP
         MEND
*---------------------------------------------------------------------*
*------- Macro  6. HEXCHMAC ------------------------------------------*
         MACRO
&NAME    HEXCHMAC &SOURCE,&TARGET,&LENGTH,&MF=,&LIST=NO,&LABEL=YES,    +
               &HELP=NO,&INIT=NO,&DSECT=NO
         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'HEXCHMAC' parameter    *
* and it's use, pass parameter 'HELP=Yes'.                            *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
*---------------------------------------------------------------------*
*                                                                     *
* CONVERT HEX TO CHARACTERS.                                          *
* --------------------------                                          *
*           N O T E - N O T E - N O T E - N O T E - N O T E           *
*                                                                     *
*   This routine saves and uses general registers 1, 14 & 15.         *
*   14 will be altered on return from the macro.                      *
*   Do NOT use registers 14 or 15 as addresses for passed parameters. *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*   Parameters:-                                                      *
*       1. Source                                                     *
*       2. Target (the target needs 2 times the length of source)     *
*       3. Length                                                     *
*       4. MF=E/L -  Macro format for re-entrant programs             *
*       5. LABEL=YES/NO - Generate data labels. Used for re-entrant   *
*                         programs with MF=L and you wish to move the *
*                         constant value from the CSECT over the      *
*                         the GETMAIN'ed DSECT.                       *
*                         The default is 'YES'. The parameter can be  *
*                         ignored if NOTE 2 option is observed.       *
*       6. LIST=YES/NO - Option to generate macro expansion or not    *
*       7. HELP=YES/NO - Option to print these help details. Default  *
*                        is 'YES'.                                    *
*       8. INIT=YES/NO - Initialise MF=E macro to repeat common code  *
*                        for multi-DSECT programs. 'NO' is the        *
*                        default.                                     *
*       9. DSECT=Y/N   - If DSECT=Y, the translate table is defided   *
*                        as storage (DS) not constant (DC).           *
*                        Should be used with MF=L.                    *
*                                                                     *
*   NOTE:-                                                            *
*       1. Parameters may be passed in registers using the (Rn)       *
*          notation (Note cannot have digits).                        *
*       2. For execute form of the macro (MF=E) the first occurence of*
*          the macro must be the first one executed. If a branch      *
*          causes a initial loop around it, insert a dummy macro to   *
*          perform a conversion into work areas or use the LABEL=NO   *
*          parameter.                                                 *
*                                                                     *
*---------------------------------------------------------------------*
.A$HELPE ANOP
         AIF   ('&LIST'(1,1) NE 'N').A$XX
         PUSH  PRINT
         PRINT NOGEN
.A$XX    ANOP
&NAME    DS    0H
         LCLC  &#LENGTH,&#SOURCE,&#TARGET
         LCLA  &LEN
         GBLC  &XNAME,&XCBAL,&XCBYPAS,&XCLOOP
         GBLC  &XCBYTES,&XCBYTE1,&XCBYTE2,&XCTABLE,&XCRETAD
         GBLB  &XC1ST,&XC1NAME
.*--------------------------------------------------------------------*
         GBLC  &REGSAVR,&REGSMCR
         GBLB  &REGSFLG,&REGDFLG
         AIF   ('&INIT'(1,1) NE 'Y').A$YY  BYPASS IF NOT INITIALISE
&XC1ST   SETB  0
&XNAME   SETC  'XC'.'&SYSNDX'
&XCBAL   SETC  '&XNAME'.'06'
&XCLOOP  SETC  '&XNAME'.'07'
&XCBYPAS SETC  '&XNAME'.'08'
&XCRETRN SETC  '&XNAME'.'EX'
.A$YY    ANOP
.*--------------------------------------------------------------------*
         AIF   (&REGSFLG).A$RS
&REGSAVR SETC  'GB'.'&SYSNDX'.'#'
&REGSMCR SETC  'HEXCHMAC'
&REGSFLG SETB  1
.A$RS    ANOP
.*--------------------------------------------------------------------*
         AIF   (&XC1NAME).A$$0
&XNAME   SETC  'XC'.'&SYSNDX'
&XCRETAD SETC  '&XNAME'.'01'
&XCTABLE SETC  '&XNAME'.'02'
&XCBYTES SETC  '&XNAME'.'03'
&XCBYTE1 SETC  '&XNAME'.'04'
&XCBYTE2 SETC  '&XNAME'.'05'
&XCBAL   SETC  '&XNAME'.'06'
&XCLOOP  SETC  '&XNAME'.'07'
&XCBYPAS SETC  '&XNAME'.'08'
&XCRETRN SETC  '&XNAME'.'EX'
&XC1NAME SETB  1
         AGO   .A$$0
.*--------------------------------------------------------------------*
.A$$0    ANOP
&XCRETRN SETC  'XC'.'&SYSNDX'.'EX'
.A$$1    ANOP
         AIF   ('&MF' EQ 'L').RENT1    IF MF=L PARAMETER PASSED BYPASS
         AIF   (T'&SOURCE EQ 'O').E1   IF PARM 1 NOT PASSED ERROR
         AIF   (T'&TARGET EQ 'O').E2   IF PARM 2 NOT PASSED ERROR
         AIF   (T'&LENGTH EQ 'O').E3   IF PARM 3 NOT PASSED ERROR
         AIF   ('&SOURCE'(1,1) EQ '(').A$01
&#SOURCE SETC  '&SOURCE'
         AGO   .A$02
.A$01    ANOP
&#SOURCE SETC  '0(&SOURCE(1))'
.A$02    ANOP
         AIF   ('&TARGET'(1,1) EQ '(').A$03
&#TARGET SETC  '&TARGET'
         AGO   .A$04
.A$03    ANOP
&#TARGET SETC  '0(&TARGET(1))'
.A$04    ANOP
         AIF   (&XC1ST).A$11           IF NOT 1ST. TIME THRU
         AIF   (T'&MF EQ 'O').NONR1    IF NON-RE PROGRAM BYPASS
*  EXEC FORM OF MACRO 'HEXCHMAC'                                      *
*---------------------------------------------------------------------*
.*       MVC   &XCTABLE.(16),=C'0123456789ABCDEF'
         B     &XCBYPAS                BYPASS COMMON CODE
         AGO   .RENT2                  BYPASS NON-RE PROCESS
.NONR1   ANOP
*  NORMAL FORM OF MACRO 'HEXCHMAC'                                    *
*---------------------------------------------------------------------*
         B     &XCBYPAS                BYPASS DATA + COMMON CODE
*---------------------------------------------------------------------*
         AGO   .NONR2                  BYPASS RE-ENT PROCESS
.RENT1   ANOP
*---------------------------------------------------------------------*
*  List form of macro 'HEXCHMAC'                                      *
*---------------------------------------------------------------------*
.NONR2   ANOP
         AIF   (T'&MF EQ 'O').LABON1
         AIF   ('&LABEL'(1,1) EQ 'Y').LABON1
         DS    0F                      WORD ALIGN
         DS    F                       RETURNN ADDRESS SAVE AREA
         AIF   (T'&DSECT EQ 'O').DCTT1
         AIF   ('&DSECT'(1,1) EQ 'N').DCTT1
         DS    CL16                    TRANSLATE TABLE
         AGO   .DCTT1D
.DCTT1   ANOP
         DC    C'0123456789ABCDEF'     TRANSLATE TABLE
.DCTT1D  ANOP
         DS    0CL2                    BYTE SAVE AREA
         DS    CL1                     1ST. BYTE
         DS    CL1                     2ND. BYTE
         AGO   .LABDONE
.LABON1  ANOP
         DS    0F                      WORD ALIGN
&XCRETAD DS    F                       RETURNN ADDRESS SAVE AREA
         AIF   (T'&DSECT EQ 'O').DCTT2
         AIF   ('&DSECT'(1,1) EQ 'N').DCTT2
&XCTABLE DS    CL16                    TRANSLATE TABLE
         AGO   .DCTT2D
.DCTT2   ANOP
&XCTABLE DC    C'0123456789ABCDEF'     TRANSLATE TABLE
.DCTT2D  ANOP
&XCBYTES DS    0CL2                    BYTE SAVE AREA
&XCBYTE1 DS    CL1                     1ST. BYTE
&XCBYTE2 DS    CL1                     2ND. BYTE
.LABDONE ANOP
.*--------------------------------------------------------------------*
.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *
.*--------------------------------------------------------------------*
         AIF   (&REGDFLG).A$RD
         AIF   ('&LABEL'(1,1) EQ 'Y').LABON2 BYPASS IF LABEL REQUIRED
         AIF   ('&REGSMCR' NE 'HEXCHMAC').A$RD
         DS    0F                      WORD ALIGN
         DS    16F                     REGISTER SAVE AREA
         AGO   .A$RD                   DO NOT SET FLAG IF LABEL REQD
.LABON2  ANOP
&REGDFLG SETB  1
         DS    0F                      WORD ALIGN
&REGSAVR DS    16F                     REGISTER SAVE AREA
.A$RD    ANOP
.*--------------------------------------------------------------------*
.RENT2   ANOP
*---------------------------------------------------------------------*
         AIF   ('&MF' EQ 'L').EXIT
*                                                                     *
*        Convert HEX to characters.                                   *
*                                                                     *
*         R1=source, R14=target, R15=length                           *
*                                                                     *
*---------------------------------------------------------------------*
&XCBAL   DS    0H
         XR    0,0                     INITIALISE REGISTER
         AIF   (T'&MF EQ 'O').NONR3    IF NON-RE PROGRAM BYPASS
         MVC   &XCTABLE.(16),=C'0123456789ABCDEF'
.NONR3   ANOP
&XCLOOP  DS    0H
         IC    0,0(1)                  INSERT CHARACTER FOR TRANS'TN
         SRL   0,4                     GET RID OF RIGHT NIBBLE
         STC   0,&XCBYTE1              STORE LEFT NIBBLE
         TR    &XCBYTE1,&XCTABLE       TRANSLATE NIBBLE TO CHATACTER
         MVC   0(1,14),&XCBYTE1        MOVE TO DESTINATION
         MVC   &XCBYTE1,0(1)           MOVE CHARACTER TO WORK AREA
         NI    &XCBYTE1,15             AND WITH X'0F' REMOVE LEFT NIB
         TR    &XCBYTE1,&XCTABLE       TRANSLATE TO CHARACTER
         MVC   1(1,14),&XCBYTE1        MOVE CHAR TO DESTINATION
         LA    1,1(1)                  UP SOURCE BY 1
         LA    14,2(14)                UP DESTINATION BY 2
         BCT   15,&XCLOOP              BRANCH TILL END
         L     14,&XCRETAD             LOAD RETURN ADDRESS
         BR    14                      RETURN TO CALLER
&XCBYPAS DS    0H
.A$11    ANOP
         STM   14,12,&REGSAVR          SAVE REGISTERS
         LA    14,&XCRETRN             LOAD RETURN ADDRESS
         ST    14,&XCRETAD             STORE RETURN ADDRESS
         LA    14,&#TARGET             SET UP DESTINATION ADDRESS
         AIF   ('&LENGTH'(1,1) NE '(').ACTLEN
&LEN     SETA  K'&LENGTH-2
&#LENGTH SETC  '&LENGTH'(2,&LEN)       REGISTER
         LR    15,&#LENGTH             LENGTH TO BE CONVERTED
         AGO   .FINLMV  ANOP           PASS AROUND
.ACTLEN  ANOP
         LA    15,&LENGTH              LENGTH TO BE CONVERTED
.FINLMV  ANOP
         LA    1,&#SOURCE              SET UP TO SOURCE ADDRESS
         B     &XCBAL                  GO TO HEX => CHAR ROUTINE
&XCRETRN DS    0H
         LM    14,12,&REGSAVR          RESTORE REGISTERS
*---------------------------------------------------------------------*
&XC1ST   SETB  1
         AGO   .EXIT
.*--------------------------------------------------------------------*
.*       ERROR MESSAGES                                               *
.*--------------------------------------------------------------------*
.E1      MNOTE 8,'HEXCHMAC requires a SOURCE field'
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E2      MNOTE 8,'HEXCHMAC requires a TARGET field'
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E3      MNOTE 8,'HEXCHMAC requires a LENGTH'
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E4      MNOTE 8,'Invalid "MF" parameter passed'
         AGO   .EXIT
.*--------------------------------------------------------------------*
.EXIT    ANOP
         AIF   ('&LIST'(1,1) NE 'N').EXIT9
         POP   PRINT
.EXIT9   ANOP
         MEXIT
         MEND
*---------------------------------------------------------------------*
*------- Macro  7. CHHEXMAC ------------------------------------------*
         MACRO
&NAME    CHHEXMAC &SOURCE,&TARGET,&LENGTH,&ERRRTN,&MF=,&LIST=NO,       +
               &LABEL=YES,&HELP=NO
         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'CHHEXMAC' parameter    *
* and it's use pass parameter 'HELP=Yes'.                             *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
*---------------------------------------------------------------------*
*                                                                     *
*   CONVERT CHARACTERS TO HEX.                                        *
*   --------------------------                                        *
*           N O T E - N O T E - N O T E - N O T E - N O T E           *
*                                                                     *
*   This routine saves and uses general registers 1, 14 & 15.         *
*   R14 and R15 will be altered on return from the macro. Do NOT use  *
*   these two registers to as parameter addresses.                    *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*   Parameters:-                                                      *
*       1. Source                                                     *
*       2. Target                                                     *
*       3. Length                                                     *
*       4. Error routine in case of error or a one byte (two character*
*          hex value  quoted, ie. 'xx') value to convert invalid      *
*          characters to and then continue.                           *
*          NOTE - An invalid supplied HEX substitution parameter will *
*                 result in X'00' substitution.                       *
*       5. MF=E/L -  Macro format for re-entrant programs             *
*       6. LABEL=YES/NO - Generate data labels. Used for reentrant    *
*                         programs with MF=L and you wish to move the *
*                         constant value from the CSECT over the      *
*                         the getmain'ed DSECT.                       *
*                         The default is 'YES'. the parameter can be  *
*                         ignored if note 2 option is observed.       *
*       7. LIST=YES/NO - Option to generate macro expansion or not    *
*       8. HELP=YES/NO - Option to print these help details. default  *
*                        is 'YES'.                                    *
*                                                                     *
*                                                                     *
*   If "error routine" = 'xx' (quoted) format then on return from     *
*   macro, R15 will be:-                                              *
*       set to - 0 if all conversion OK                               *
*       set to - 8 if conversion error found                          *
*                                                                     *
*   NOTE:-                                                            *
*       1. Parameters may be passed in registers using the (Rn) or    *
*          d(Rn) (for register displacement) notation.                *
*          NOTE - cannot have digits).                                *
*       2. For execute form of the macro (MF=E) the first occurence of*
*          the macro must be the first one executed. If a branch      *
*          causes a initial loop around it, insert a dummy macro to   *
*          perform a conversion into work areas or use the LABEL=NO   *
*          parameter.                                                 *
*                                                                     *
*---------------------------------------------------------------------*
.A$HELPE ANOP
         PUSH  PRINT
         AIF   ('&LIST'(1,1) NE 'N').A$XX
         PRINT NOGEN
.A$XX    ANOP
.*--------------------------------------------------------------------*
         GBLC  &CXBAL,&CXBYPAS,&CXLOOP,&CXBYTES,&CXBYTE1,&CXBYTE2
         GBLC  &CXBADAT,&CXTABLE,&CXIGERR,&CXER1BR,&CXER2BR
         GBLC  &CXER1BS,&CXER2BS,&CXRTADR
         GBLC  &CXCHOK1,&CXERSUB,&CXERRCH,&CXRTCOD,&CXCHXT1,&CXR1SAV
         GBLB  &CX1NAME,&CX1ST
         LCLC  &#LENGTH,&#SOURCE,&#TARGET,&#ERRRTN
         LCLA  &LEN
.*--------------------------------------------------------------------*
         GBLC  &REGSAVR,&REGSMCR
         GBLB  &REGSFLG,&REGDFLG
         AIF   (&REGSFLG).A$RS
&REGSAVR SETC  'GB'.'&SYSNDX'.'#'
&REGSFLG SETB  1
&REGSMCR SETC  'CHHEXMAC'
.A$RS    ANOP
.*--------------------------------------------------------------------*
         AIF   (&CX1NAME).A$$0
         LCLC  &TNAME
&TNAME   SETC  'CX'.'&SYSNDX'
&CXTABLE SETC  '&TNAME'.'01'
&CXBYTES SETC  '&TNAME'.'02'
&CXBYTE1 SETC  '&TNAME'.'03'
&CXBYTE2 SETC  '&TNAME'.'04'
&CXERRCH SETC  '&TNAME'.'05'
&CXR1SAV SETC  '&TNAME'.'06'
&CXER1BS SETC  '&TNAME'.'07'
&CXER2BS SETC  '&TNAME'.'08'
&CXRTADR SETC  '&TNAME'.'09'
&CXRTCOD SETC  '&TNAME'.'10'
&CXBAL   SETC  '&TNAME'.'11'
&CXLOOP  SETC  '&TNAME'.'12'
&CXIGERR SETC  '&TNAME'.'13'
&CXCHOK1 SETC  '&TNAME'.'14'
&CXBADAT SETC  '&TNAME'.'15'
&CXBYPAS SETC  '&TNAME'.'16'
&CXCHXT1 SETC  '&TNAME'.'EX'
&CX1NAME SETB  1
         AGO   .A$$1                    BYPASS 2ND. INVOCATION
.*--------------------------------------------------------------------*
.A$$0    ANOP
&CXCHXT1 SETC  'CX'.'&SYSNDX'.'EX'
.A$$1    ANOP
         AIF   ('&MF' EQ 'L').RENT1     IF MF=L PARM PASSED BYPASS
         AIF   (T'&SOURCE EQ 'O').E1
         AIF   (T'&TARGET EQ 'O').E2
         AIF   (T'&LENGTH EQ 'O').E3
         AIF   (T'&ERRRTN EQ 'O').E4
.*--------------------------------------------------------------------*
         AIF   ('&SOURCE'(1,1) EQ '(').A$01
&#SOURCE SETC  '&SOURCE'
         AGO   .A$02
.A$01    ANOP
&#SOURCE SETC  '0(&SOURCE(1))'
.A$02    ANOP
         AIF   ('&TARGET'(1,1) EQ '(').A$03
&#TARGET SETC  '&TARGET'
         AGO   .A$04
.A$03    ANOP
&#TARGET SETC  '0(&TARGET(1))'
.A$04    ANOP
&CXERSUB SETC  '''00'''                       SET X'00' FOR SUB
&CXER1BR SETC  '&CXBADAT'                     SET ERROR BRANCH ADDRESS
&CXER2BR SETC  '&CXIGERR'                     SET IGNORE BRANCH ADDRESS
         AIF   ('&ERRRTN'(1,1) NE '''').A$07
&CXERSUB SETC  '&ERRRTN'                      SET IGNORE BRANCH ADDRESS
&CXER1BR SETC  '&CXIGERR'                     SET IGNORE BRANCH ADDRESS
         AGO   .A$10
.A$07    ANOP
         AIF   ('&ERRRTN'(1,1) EQ '(').A$08
&#ERRRTN SETC  '&ERRRTN'
         AGO   .A$09
.A$08    ANOP
&#ERRRTN SETC  '0(&ERRRTN(1))'
.A$09    ANOP
&CXER2BR SETC  '&#ERRRTN'                     SET ERROR ROUTINE ADDRESS
.A$10    ANOP
.*--------------------------------------------------------------------*
         AIF   (&CX1ST).A$11           IF NOT 1ST. TIME THRU
         AIF   (T'&MF EQ 'O').NONR1    IF NON-RE PROGRAM BYPASS
*  EXEC FORM OF MACRO 'CHHEXMAC'                                      *
*---------------------------------------------------------------------*
.*       MVI   &CXTABLE,X'00'          HEX FILL FIRST BYTE THEN RIPPLE
.*       MVC   &CXTABLE.+1(192),&CXTABLE  FILL REST
.*       MVC   &CXTABLE.+193(06),=X'0A0B0C0D0E0F'
.*       MVC   &CXTABLE.+199(41),&CXTABLE FILL REST
.*       MVC   &CXTABLE.+240(10),=X'F0010203040506070809'
.*       MVC   &CXTABLE.+250(06),&CXTABLE FILL REST
         B     &CXBYPAS                BYPASS COMMON CODE
         AGO   .RENT2                  BYPASS NON-RE PROCESS
.NONR1   ANOP
*  NORMAL FORM OF MACRO 'CHHEXMAC'                                    *
*---------------------------------------------------------------------*
         B     &CXBYPAS                BYPASS DATA + COMMON CODE
*---------------------------------------------------------------------*
         AGO   .NONR2                  BYPASS RE-ENT PROCESS
.RENT1   ANOP
*---------------------------------------------------------------------*
*  LIST FORM OF MACRO 'CHHEXMAC'                                      *
*---------------------------------------------------------------------*
.NONR2   ANOP
.*--------------------------------------------------------------------*
         AIF   (T'&MF EQ 'O').LABON
         AIF   ('&LABEL'(1,1) EQ 'Y').LABON
         DS    0CL256
         DC    193X'0'
         DC    X'0A0B0C0D0E0F'
         DC    41X'0'
         DC    X'F0010203040506070809' NOTE - AS ZERO IS VALID
*               /|\                    CHAR 'F0' SUBSTITUTED AND
*                                      LATER CHANGED
         DC    6X'0'
         DS    0CL2                    BOTH BYTE
         DS    CL1                     1ST. BYTE
         DS    CL1                     1ST. BYTE
         DS    CL2                     CHARACTER SUBSTITUTION
         DC    4F'0'                   REGISTER 1 SAVE AREA B/C TRT
         DC    F'0'                    ERROR EXIT SAVE ADDRESS
         DC    F'0'                    ERROR ROUTINE SAVE ADDRESS
         DC    F'0'                    RETURN ADDRESS
         DC    H'0'                    RETURN CODE SAVE AREA
         AGO   .LABDONE
.LABON   ANOP
&CXTABLE DS    0CL256
         DC    193X'0'
         DC    X'0A0B0C0D0E0F'
         DC    41X'0'
         DC    X'F0010203040506070809' NOTE - AS ZERO IS VALID
*               /|\                    CHAR 'F0' SUBSTITUTED AND
*                                      LATER CHANGED
         DC    6X'0'
&CXBYTES DS    0CL2                    BOTH BYTE
&CXBYTE1 DS    CL1                     1ST. BYTE
&CXBYTE2 DS    CL1                     1ST. BYTE
&CXERRCH DS    CL2                     CHARACTER SUBSTITUTION
&CXR1SAV DC    4F'0'                   REGISTER 1 SAVE AREA B/C TRT
&CXER1BS DC    F'0'                    ERROR EXIT SAVE ADDRESS
&CXER2BS DC    F'0'                    ERROR ROUTINE SAVE ADDRESS
&CXRTADR DC    F'0'                    RETURN ADDRESS
&CXRTCOD DC    H'0'                    RETURN CODE SAVE AREA
.LABDONE ANOP
.*--------------------------------------------------------------------*
.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *
.*--------------------------------------------------------------------*
         AIF   (&REGDFLG).A$RD
         AIF   ('&LABEL'(1,1) EQ 'Y').LABON2 BYPASS IF LABEL REQUIRED
         AIF   ('&REGSMCR' NE 'CHHEXMAC').A$RD
         DS    16F                     REGISTER SAVE AREA
         AGO   .A$RD                   DO NOT SET FLAG IF LABEL REQD
.LABON2  ANOP
&REGDFLG SETB  1
&REGSAVR DS    16F                     REGISTER SAVE AREA
.A$RD    ANOP
.*--------------------------------------------------------------------*
.RENT2   ANOP
*---------------------------------------------------------------------*
         AIF   ('&MF' EQ 'L').EXIT
*                                                                     *
*        CONVERT CHARACTERS TO HEX.                                   *
*                                                                     *
*         R1=SOURCE, R14=TARGET, R15=LENGTH                           *
*                                                                     *
*---------------------------------------------------------------------*
&CXBAL   DS    0H
         XC    &CXRTCOD,&CXRTCOD       INITIALISE RETURN CODE
         AIF   (T'&MF EQ 'O').NONR3    IF NON-RE PROGRAM BYPASS
         CLC   &CXTABLE.+193(06),=X'0A0B0C0D0E0F' Q. CONSTANTS SET
         BE    &CXLOOP                               Y. BYPASS
         MVI   &CXTABLE,X'00'          HEX FILL FIRST BYTE THEN RIPPLE
         MVC   &CXTABLE.+1(192),&CXTABLE  FILL REST
         MVC   &CXTABLE.+193(06),=X'0A0B0C0D0E0F'
         MVC   &CXTABLE.+199(41),&CXTABLE FILL REST
         MVC   &CXTABLE.+240(10),=X'F0010203040506070809'
         MVC   &CXTABLE.+250(06),&CXTABLE FILL REST
.NONR3   ANOP
&CXLOOP  DS    0H
         MVC   &CXBYTES.(2),0(1)
         STM   14,1,&CXR1SAV           SAVE 1 BECAUSE OF TRT
         MVI   &CXTABLE,X'F0'          SET HEX 00 TO PASS
         L     14,&CXER1BS             LOAD ERROR EXIT ADDRESS
         TRT   &CXBYTE1.(1),&CXTABLE   Q. IS IT IN &CXTABLE
         BZR   14                         N. ERROR
         TRT   &CXBYTE2.(1),&CXTABLE   Q. IS IT IN &CXTABLE
         BZR   14                         N. ERROR
         B     &CXCHOK1                BOTH BYTES OK
&CXIGERR DS    0H
         MVC   &CXRTCOD.(2),=H'8'      SET ERROR CODE
         MVC   &CXBYTES.(2),&CXERRCH   SET ERROR HEX SUBSTITUTION
&CXCHOK1 DS    0H
         MVI   &CXTABLE,X'00'          RESET HEX 00
         TR    &CXBYTES.(2),&CXTABLE   TRANSLATE BOT CHARS
         NC    &CXBYTES.(2),=X'0F0F'   TURN HIGH NIBL OFF FOR 0 => 'F0'
         LM    14,1,&CXR1SAV           RESTORE 1 BECAUSE OF TRT
         PACK  0(1,14),&CXBYTE1        SWAP NIB OF LEFT &CXBYTE AND STO RE
         OC    0(1,14),&CXBYTE2        OVERLAY 2ND &CXBYTE OVER FIRST
         LA    1,2(1)                  UP SOURCE BY TWO
         LA    14,1(14)                UP DESTINATION BY 1
         BCTR  15,0                    DECREMENT LOOP COUNTER
         BCTR  15,0                           BY 2
         LTR   15,15                   Q. REACHED THE END
         BP    &CXLOOP                    N. LOOP
         L     14,&CXRTADR             LOAD RETURN ADDRESS
         BR    14                      RETURN
&CXBADAT DS    0H
         LM    14,12,&REGSAVR          RESTORE REGISTERS
         LH    15,&CXRTCOD             SET RETURN CODE
         L     14,&CXER2BS             LOAD ERROR ROUTINE ADDRESS
         BR    14                      BRANCH TO ERROR ROUTINE
&CXBYPAS DS    0H
.A$11    ANOP
         STM   14,12,&REGSAVR          SAVE REGISTERS
         MVC   &CXERRCH.(2),=C&CXERSUB MOVE HEX ERROR SUBSTITUTE CHAR
         LA    14,&CXER1BR             LOAD EXIT ADDRESS
         ST    14,&CXER1BS             SAVE EXIT ADDRESS
         LA    14,&CXER2BR             LOAD ERROR ROUTINE ADDRESS
         ST    14,&CXER2BS             SAVE ERROR ROUTINE ADDRESS
         LA    14,&CXCHXT1             LOAD RETURN ADDRESS
         ST    14,&CXRTADR             STORE RETURN ADDRESS
         LA    14,&#TARGET             SET UP DESTINATION ADDRESS
         AIF   ('&LENGTH'(1,1) NE '(').ACTLEN
&LEN     SETA  K'&LENGTH-2
&#LENGTH SETC  '&LENGTH'(2,&LEN)       REGISTER
         LR    15,&#LENGTH             LENGTH TO BE CONVERTED
         AGO   .FINLMV                 PASS AROUND
.ACTLEN  ANOP
         LA    15,&LENGTH              LENGTH TO BE CONVERTED
.FINLMV  ANOP
         LA    1,&#SOURCE              SET UP TO SOURCE ADDRESS
         B     &CXBAL                  GO TO HEX => CHAR ROUTINE
&CXCHXT1 DS    0H
         LM    14,12,&REGSAVR          RESTORE REGISTERS
         LH    15,&CXRTCOD             SET RETURN CODE
*---------------------------------------------------------------------*
&CX1ST   SETB  1
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E1      MNOTE 8,'CHHEX REQUIRES A SOURCE FIELD'
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E2      MNOTE 8,'CHHEX REQUIRES A TARGET FIELD'
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E3      MNOTE 8,'CHHEX REQUIRES A LENGTH'
         AGO   .EXIT
.*--------------------------------------------------------------------*
.E4      MNOTE 8,'CHHEX REQUIRES A CONVERSION ERROR ROUTINE ADDRESS'
.EXIT    ANOP
         POP   PRINT
         MEXIT
.*--------------------------------------------------------------------*
         MEND
*---------------------------------------------------------------------*
*------- Macro  8. ISPVDEFX ------------------------------------------*
         MACRO
&NAME    ISPVDEFX &INM=,&ANM=,&FORMAT=,&LEN=,&OPT=,&MF=,&LIST=NO,      x
               &TYPE=VAR,&HELP=NO
         PUSH  PRINT
         AIF   ('&LIST' NE 'NO').A$XX
         PRINT NOGEN
.A$XX    ANOP
         AIF   ('&HELP' EQ 'YES').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'ISPVDEFX' parameter    *
* and it's use, pass parameter 'HELP=Yes'.                            *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
*---------------------------------------------------------------------*
*                                                                     *
* This macro is used to define addressability between a program and   *
* ISPF variables.                                                     *
*                                                                     *
* In the normal form:                                                 *
*   It is designed to create common variables the first time thru and *
*   re-use them everytime the macro is invoked.                       *
* In re-entrant form:                                                 *
*   Use the MF=L and MF=E options.                                    *
*                                                                     *
* Parameters (for further details, refer to ISPF DMS manuals):        *
*   1. INM=..... - ISPF variable name, enclosed in brackets ().       *
*   2. ANM=..... - Internal (assembler) varaiable name.               *
*   3. FORMAT=.. - Variable format, valid values are:                 *
*                        CHAR FIXED BIT HEX DBCS USER                 *
*   4. LEN=..... - Length of the variable in numeric bytes or         *
*                  register (2) - (13). If register is used, the      *
*                  length must be loaded ito the register.            *
*   5. OPT=..... - Options, valid values are:                         *
*                        COPY NOBSCAN LIST                            *
*   6. MF=...... - Macro format. Omit for non re-entrant programs.    *
*                  For re-entrant programs:                           *
*                    E - EXEC format of macro                         *
*                    L - LIST format of macro.                        *
*   7. TYPE=.... - VARiable/CONstant for MF=L. For re-entrant programs*
*                  to copy constant into GETMAINed variable.          *
*   8. LIST=..... - Generate or suppress macro expansion, (YES/NO).   *
*                                                                     *
* Example of input:                                                   *
*      ISPVDEFX INM=(ISPFname),ANM=int.name,FORMAT=CHAR,LEN=20        *
*          - OR -                                                     *
*      EXEC format:                                                   *
*        ISPVDEFX INM=(ISPFname),ANM=int.name,FORMAT=CHAR,LEN=20,MF=E *
*      LIST format:                                                   *
*        ISPVDEFX MF=L           (default ,TYPE=VAR)                  *
*          - or -                                                     *
*        ISPVDEFX MF=L,TYPE=CONS (and move CONS to VAR)               *
*                                                                     *
*---------------------------------------------------------------------*
.A$HELPE ANOP
&NAME    DS    0H
         GBLC  &VNAME
         GBLB  &VDFX1ST,&VMFE1ST,&VNMF1ST
         LCLA  &LL,&VLL
         LCLC  &REGL
&LL      SETA  K'&LEN
&VLL     SETA  K'&ANM
         AIF   (&VDFX1ST).A$00         IF NOT 1ST. BYPASS
&VDFX1ST SETB  1                       SET 1ST. TIME THRU FLAG
&VNAME   SETC  'IVD'.'&SYSNDX'         SET "INDEX"
.A$00    ANOP
         AIF   ('&MF' EQ 'L').A$11     BYPASS IF RE-ENT
         AIF   ('&MF' EQ 'E').A$33     BYPASS IF RE-ENT
         AIF   (T'&MF NE 'O').E1       INVALID FORMAT OF MF PARM
         AIF   (&VNMF1ST).A$55         BYPASS IF NOT 1ST NON-R
&VNMF1ST SETB  1                       SET 1ST. TIME THRU FLAG
         B     &VNAME.L                BYPASS DATA DEFS AFTER 1ST. THRU
         AGO  .A$111
.A$11    ANOP
.*--------------------------------------------------------------------*
.*   LIST form of macro 'ISPVDEFX'                                    *
.*--------------------------------------------------------------------*
.A$111   ANOP
*---------------------------------------------------------------------*
*    LIST form of macro 'ISPVDEFX' (constant).                        *
*---------------------------------------------------------------------*
         AIF   ('&TYPE'(1,1) NE 'C').A$112
         DS    F                       VDEFINE
         DS    F                       ISPF NAME
         DS    F                       INTERNAL NAME
         DS    F                       VAR TYPE
         DS    F                       VAR LENGTH
         DS    F                       OPTION
         DC    C'VDEFINE '             VDEF LITERAL
         DC    CL10'          '        ISPF DEST (ALLOW FOR "()")
         DC    C' '                    SPACER
         DC    C'CHAR    '             VDEF FORMAT TYPE
         DC    C' '                    SPACER
         DS    CL2                     LENGTH SOURCE PRIOR CONVERSION
         DC    C' '                    SPACER
         DS    F                       R2 SAVEAREA FOR LEN CONVERSION
         DS    D                       DBL WD LEN CONVERSION WK FLD
         DS    F                       LENGTH CONVERTED TO FULL WD BIN
         DC    C'&OPT    '             OPTIONS (NOT USED BY THIS RTN)
         DS    F                       INTERNAL NAME ADDRESS STORE
         AGO   .A$113
.*--------------------------------------------------------------------*
.A$112   ANOP
*---------------------------------------------------------------------*
*    LIST form of macro 'ISPVDEFX' (modifiable).                      *
*---------------------------------------------------------------------*
&VNAME.1 DS    F                       VDEFINE
         DS    F                       ISPF NAME
         DS    F                       INTERNAL NAME
         DS    F                       VAR TYPE
         DS    F                       VAR LENGTH
         DS    F                       OPTION
&VNAME.2 DC    C'VDEFINE '             VDEF LITERAL
&VNAME.3 DC    CL10'          '        ISPF DEST (ALLOW FOR "()")
         DC    C' '                    SPACER
&VNAME.4 DC    C'CHAR    '             VDEF FORMAT TYPE
         DC    C' '                    SPACER
&VNAME.5 DS    CL2                     LENGTH SOURCE PRIOR CONVERSION
         DC    C' '                    SPACER
&VNAME.6 DS    F                       R2 SAVEAREA FOR LEN CONVERSION
&VNAME.7 DS    D                       DBL WD LEN CONVERSION WK FLD
&VNAME.8 DS    F                       LENGTH CONVERTED TO FULL WD BIN
&VNAME.9 DC    C'&OPT    '             OPTIONS (NOT USED BY THIS RTN)
&VNAME.V DS    F                       INTERNAL NAME ADDRESS STORE
.A$113   ANOP
*-----------------------------------------------------------------*
         AIF   ('&MF' NE 'L').A$22     BYPASS IF NOT MF=L
         POP   PRINT
         MEXIT                         EXIT IF MF=L
.A$22    ANOP
&VNAME.L DS    0H
         AIF   (T'&MF EQ 'O').A$44     BYPASS IF RE-ENT
.A$33    ANOP
*---------------------------------------------------------------------*
*    EXEC form of macro 'ISPVDEFX'                                    *
*---------------------------------------------------------------------*
.EXMFE   ANOP
         AIF   (&VMFE1ST).A$55          IF NOT 1ST. BYPASS
&VMFE1ST SETB  1                        SET 1ST. TIME THRU FLAG
*    Unique code                                                      *
*---------------------------------------------------------------------*
         MVI   &VNAME.2,C' '            SPACE FILL DATA
         MVC   &VNAME.2+1(55),&VNAME.2  USING RIPPLE MOVE
         MVC   &VNAME.2(7),=C'VDEFINE'  MOVE LITERAL
         AGO   .A$441
.A$44    ANOP
*    Unique code                                                      *
*---------------------------------------------------------------------*
.A$441   ANOP
         ST    R2,&VNAME.6             SAVE REG2
         LA    R2,&VNAME.1             R1 DEST VALUE FOR "CALL"
         LA    R1,&VNAME.2             ADDRESS OF PARAMETER
         ST    R1,0(R2)                STORE ADDRESS
         LA    R2,4(R2)                POINT TO NEXT ADDRESS POS
         LA    R1,&VNAME.3             ETC...
         ST    R1,0(R2)                    "
         LA    R2,4(R2)                    "
         LA    R2,4(R2)                <-- " (ALLOW FOR 'INT NAME @')
         LA    R1,&VNAME.4                 "
         ST    R1,0(R2)                    "
         LA    R2,4(R2)                    "
         LA    R1,&VNAME.8                 "
         ST    R1,0(R2)                    "
         LA    R2,4(R2)                    "
         LA    R1,&VNAME.9                 "
         ST    R1,0(R2)                    "
         MVI   0(R2),X'80'                 "
         L     R2,&VNAME.6                RESET R2
.A$55    ANOP
*-----------------------------------------------------------------*
*    Common code                                                      *
*---------------------------------------------------------------------*
         AIF   (T'&MF EQ 'O').A$66
         MVC   &VNAME.4(8),=CL8'&FORMAT' SET UP "(ISPF-FORM)" VALUE
.A$66    ANOP
         MVC   &VNAME.3(10),=CL10'&INM'   SET UP "(ISPF-NAME)" VALUE
.*--------------------------------------------------------------------*
.* Test if length is supplied in a register
.*--------------------------------------------------------------------*
         AIF ('&LEN'(1,1) NE '(').NREGL
&PL      SETA  K'&LEN
&REGL    SETC  '&LEN'(2,&PL-2)            EXTRACT REGISTER
         ST    &REGL.,&VNAME.8            SAVE REGISTER PASSED LENGTH
         AGO   .FINLEN                    .BYPASS NUMERIC LENGTH
.NREGL   ANOP
         MVC   &VNAME.5(&LL),=CL&LL'&LEN' SET UP LENGTH
         PACK  &VNAME.7,&VNAME.5(&LL)     PACK LENGTH FOR CONVERSION
         CVB   R1,&VNAME.7                CONV LEN TO FULL WD BIN
         ST    R1,&VNAME.8                SAVE CONVERTED  LENGTH
.FINLEN  ANOP
.*--------------------------------------------------------------------*
         LA    R1,&ANM                    ADDRESS OF INTERNAL NAME
         ST    R1,&VNAME.1+8              SAVE INT NAME @
         LA    R1,&VNAME.1                LOAD PARAMETER LIST ADDRESS
         L     15,ISPLINK                 LOAD "ISPLINK" ADDRESS
.*       L     15,=V(ISPLINK)             LOAD "ISPLINK" ADDRESS
         BALR  14,15                      BRANCH AND LINK
         POP   PRINT
         MEXIT
.*--------------------------------------------------------------------*
.E1      MNOTE 8,'INVALID "MF" PARAMETER PASSED'
.*--------------------------------------------------------------------*
         POP   PRINT
         MEND
*---------------------------------------------------------------------*
*------- Macro  9. ISPEXEC -------------------------------------------*
         MACRO
&NAME    ISPEXEC &XTEXT,&XLENG,&LIST=NO,&HELP=NO,&LONG=NO,&INIT=NO,    +
               &MF=,&TYPE=VAR
         PUSH  PRINT
         AIF   ('&LIST' NE 'NO').A$XX
         PRINT NOGEN
.A$XX    ANOP
         AIF   ('&HELP' EQ 'YES').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'ISPEXEC' parameter and *
* it's use, pass parameter 'HELP=Yes'.                                *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
*---------------------------------------------------------------------*
*                                                                     *
* Macro to initialise an "ISPF" environment and set up variables to   *
*   facilitate executing ISPEXEC commands.                            *
*                                                                     *
* Format:                                                             *
*   1. ISPEXEC no.parameter/INIT=Y          (Required on first        *
*                                            execution. Requires both *
*                                            MF=L and MF=E for re-    *
*                                            entrant programs.        *
*   2. ISPEXEC 'normal CLIST type text'                               *
*   3. ISPEXEC int.var.name,int.var.length                            *
*                                                                     *
* Parameters:                                                         *
*   1. XTEXT     - a) Quoted literal (follows the normal CLIST syntax *
*                     after the ISPEXEC command).                     *
*                            - OR -                                   *
*                  b) Variable name that contains the normal CLIST    *
*                     syntax following the ISPEXEC command.           *
*   2. XLENG     - Length of the variable if Format '2' used for the  *
*                  'XTEXT' parameter.                                 *
*   3. LONG=.... - Specify long move (MVCL) if Format '2' used.       *
*   4. LIST=.... - Generate or suppress macro expansion, (YES/NO).    *
*   5. INIT=.... - Force initial invocation, (YES/NO).                *
*   6. TYPE=.... - VARiable/CONstant for MF=L. For re-entrant programs*
*                  to copy constant into GETMAINed variable.          *
*   7. MF=....   - Macro format. Only required for re-entrant         *
*                  programs and then ONLY ON the initialisation       *
*                  invocation.                                        *
*                  For re-entrant programs:                           *
*                    E - EXEC format of macro on INIT invocation.     *
*                    L - LIST format of macro.                        *
*                                                                     *
* NOTE:                                                               *
*      1. The first execution must be of the macro WITHOUT the XTEXT  *
*         parameter or WITH the INIT=Y parameter.                     *
*      2. Does not cover "VDEF", "VCOPY", "VDELETE", "VRESET" or      *
*         "VREPLACE".                                                 *
*                                                                     *
*---------------------------------------------------------------------*
.A$HELPE ANOP
         AIF   (T'&NAME EQ 'O').NONAME1    Bypass if NAME missing
&NAME    DS    0H
.NONAME1 ANOP
         GBLB  &ISPI1ST
         GBLC  &ISPNAME,&ISPTYP,&ISPEXEP,&ISPBUFA,&ISPBUFL,&ISPBUFR
         LCLC  &ISPLABB
         AIF   (&ISPI1ST).A$00
&ISPI1ST SETB  1
&ISPNAME SETC  'INI'.'&SYSNDX'
.A$00    ANOP
         AIF   ('&INIT'(1,1) EQ 'Y').INITIL
         AIF   (T'&XTEXT NE 'O').SETEXEC    Bypass if INIT=N + param
.*--------------------------------------------------------------------*
.*   Initialisation form of macro                                     *
.*--------------------------------------------------------------------*
.INITIL  ANOP
&ISPTYP  SETC  'LOAD'
&ISPEXEP SETC  '&ISPNAME'.'1'
&ISPBUFA SETC  '&ISPNAME'.'2'
&ISPBUFL SETC  '&ISPNAME'.'3'
&ISPBUFR SETC  '&ISPNAME'.'4'
&ISPLABB SETC  '&ISPNAME'.'X'
         AIF   (T'&MF NE 'O').A$11   RE-ENTRANT BYPASS
         B     &ISPLABB                PYPASS DATA
.A$11    ANOP
         AIF   ('&MF' EQ 'E').A$22   RE-ENTRANT LIST EXIT
*---------------------------------------------------------------------*
*    LIST form of macro 'ISPEXEC' initialisation                      *
*---------------------------------------------------------------------*
         DS    0F                      FULLWORD ALLIGNMENT
         AIF   ('&TYPE'(1,1) NE 'C').A$12
         DS    A                       A(ISPF LINK INTERFACE)
         DS    A                       A(ISPF EXEC INTERFACE)
         DC    A(0)                    A(COMMAND LENGTH)
         DC    A(0)                    A(COMMAND BUFFER)
         DC    F'0'                    COMMAND LENGTH
         DS    0CL300                  COMMAND BUFFER
         AGO   .A$13
.A$12    ANOP
ISPLINK  DS    A                       A(ISPF LINK INTERFACE)
ISPEXEC  DS    A                       A(ISPF EXEC INTERFACE)
&ISPEXEP DC    A(&ISPBUFL)             A(COMMAND LENGTH)
&ISPBUFA DC    A(&ISPBUFR)             A(COMMAND BUFFER)
&ISPBUFL DC    F'0'                    COMMAND LENGTH
&ISPBUFR DS    0CL300                  COMMAND BUFFER
.A$13    ANOP
         DC    CL250' ',CL50' '        INITIALISED TO SPACES
         AIF   ('&MF' EQ 'L').MEXIT  Re-entrant list, Exit
&ISPLABB DS    0H
.*       AIF   (T'&MF EQ 'O').A$33   Non RE-ENTRANT BYPASS
.A$22    ANOP
*---------------------------------------------------------------------*
*    EXEC form of macro 'ISPEXEC' initialisation                      *
*---------------------------------------------------------------------*
         LA    R1,&ISPBUFL             LOAD ADDRESS OF COMMAND LENGTH
         ST    R1,&ISPEXEP             STORE COMMAND LENGTH ADDRESS
         LA    R1,&ISPBUFR             LOAD ADDRESS OF COMMAND BUFFER
         ST    R1,&ISPBUFA             STORE COMMAND BUFFER ADDRESS
         OI    &ISPBUFA,X'80'          MOVE LAST PARM INDICATOR
*
.A$33    ANOP
*        LOAD  EP=ISPLINK              FETCH ISPF LINK INTERFACE
         LOAD  EP=ISPLINK              FETCH ISPF LINK INTERFACE
         ST    R0,ISPLINK              SAVE ITS ADDRESS
*        LOAD  EP=ISPEXEC              FETCH ISPF EXEC INTERFACE
         LOAD  EP=ISPEXEC              FETCH ISPF EXEC INTERFACE
         ST    R0,ISPEXEC              SAVE ITS ADDRESS
.A$99    ANOP
*---------------------------------------------------------------------*
         AIF   (T'&XTEXT EQ 'O').MEXIT      Exit if no parameter
.*-------------------------------------------------------------------*
.SETEXEC ANOP
         AIF   (T'&XLENG NE 'O').MVX2
         AIF   ('&XTEXT'(1,1) NE '''').E3
.*-------------------------------------------------------------------*
         LCLC  &CHAR,&AMPER
         LCLA  &LC,&QC,&AC
&AMPER   SETC  '&&'
&LC      SETA  K'&XTEXT                     LOOP COUNTER
&QC      SETA  0                            QUOTES COUNTER
&AC      SETA  0                            AMPERSAND COUNTER
&CP      SETA  0                            CHARACTER POINTER
.LOOP1   ANOP
&CP      SETA  &CP+1                        INCREMENT CHARACTER PTR
&CHAR    SETC  '&XTEXT'(&CP,1)
.TQUOT   ANOP
         AIF   ('&CHAR' NE '''').TAMPR
&QC      SETA  &QC+1
         AGO   .NXTCH
.TAMPR   ANOP
         AIF   ('&CHAR.&CHAR' NE '&AMPER').NXTCH
&AC      SETA  &AC+1
.NXTCH   ANOP
         AIF   (&CP LT &LC).LOOP1           LOOP TILL END
&LC      SETA  &LC-2-(((&QC-2)/2)+(&AC/2))
         MVC   &ISPBUFR.(&LC),=C&XTEXT
.*-------------------------------------------------------------------*
         LA    1,&LC                   LOAD LENGTH
         AGO   .LA
.MVX2    ANOP
         AIF   ('&XTEXT'(1,1) EQ '''').E2
         AIF   ('&LONG'(1,1) EQ 'N').MVX4
.MVX3    ANOP
         LA    R0,&ISPBUFR             LOAD ADDRESS OF DESTINATION
         LA    R1,&XLENG               LOAD LENGTH OF MOVE
         LA    R14,&XTEXT              LOAD SOURCE ADDRESS
         LA    R15,&XLENG              LOAD LENGTH OF MOVE
         ICM   R15,B'1000',=C'         '            MOVE PAD CHARACTER
         MVCL  R0,R14                  SET AREA TO ALL SPACES
         AGO   .MVX5
.MVX4    ANOP
         MVC   &ISPBUFR.(&XLENG),&XTEXT
.MVX5    ANOP
         LA    1,&XLENG                LOAD LENGTH
.LA      ANOP
         ST    1,&ISPBUFL              STORE LENGTH
         LA    1,&ISPEXEP              LOAD PARAMETER LIST POINTER
         L     15,ISPEXEC              LOAD 'ISPEXEC' MODULE ADDR
         BALR  14,15                   CALL 'ISPEXEC'
         AGO   .MEXIT                       Exit macro
*---------------------------------------------------------------------*
.E1      MNOTE 12,'ISPEXEC REQUIRES A FUNCTION PARAMETER LIST'
         AGO   .MEXIT                       Exit macro
.E2      MNOTE 12,'VARIABLE NAME MUST NOT BE QUOTED'
         AGO   .MEXIT                       Exit macro
.E3      MNOTE 12,'VARIABLE NAME REQUIRES A LENGTH'
         AGO   .MEXIT                       Exit macro
.*--------------------------------------------------------------------*
.MEXIT   ANOP
         POP   PRINT
         MEND
*---------------------------------------------------------------------*
*------- Macro 11. ADYN ----------------------------------------------*
         MACRO
&NAME    ADYN  &ACTION=INFO,                                           +
               &BASE=,                                                 +
               &BLKSIZE=,                                              +
               &BUFNO=,                                                +
               &CCP=YES,                                               +
               &COPIES=,                                               +
               &DATA=,                                                 +
               &DD=,                                                   +
               &DDC=,                                                  +
               &DDR=NO,                                                +
               &DEST=,                                                 +
               &DISP=,                                                 +
               &DSN=,                                                  +
               &DSNR=NO,                                               +
               &DSORG=,                                                +
               &ERROR=,                                                +
               &FCB=,                                                  +
               &HELP=NO,                                               +
               &LIST=YES,                                              +
               &LRECL=,                                                +
               &MEMBER=,                                               +
               &MF=,                                                   +
               &PARMT=PARM,                                            +
               &PDUMP=NO,                                              +
               &PDUMPX=,                                               +
               &PERMA=YES,                                             +
               &RECFM=,                                                +
               &REGR=YES,                                              +
               &REUSE=NO,                                              +
               &RLSE=,                                                 +
               &R1=R1,                                                 +
               &R4=R4,                                                 +
               &R5=R5,                                                 +
               &R6=R6,                                                 +
               &R7=R7,                                                 +
               &SPACE=,                                                +
               &SYSOUT=,                                               +
               &UCLOSE=NO,                                             +
               &UNIT=,                                                 +
               &VOLR=NO,                                               +
               &VOLSER=
*--------------------------START OF ADYN------------------------------*
&NAME    DS    0H
         PUSH  PRINT
         AIF   ('&LIST' NE 'NO').A$XX
         PRINT NOGEN
.A$XX    ANOP
         AIF   ('&HELP' EQ 'YES').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'ADYN' parameters and   *
* use pass parameter 'HELP=YES'.                                      *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
***********************************************************************
*                                                                     *
* DYNAMIC ALLOCATION MACRO.      Written by A. Kara.                  *
* -------------------------                                           *
*           N O T E - N O T E - N O T E - N O T E - N O T E           *
*                                                                     *
*   This routine saves and uses the following general registers:      *
*      R1, R4, R5, R6, R7, R14 and R15.                               *
*   If any of these registers are used as base registers or anchors   *
*   for the DSECT containing the DATA format of the macro (if used),  *
*   either substitute with an unused one (refer parameter 'Rn') or do *
*   not use this macro.                                               *
*                                                                     *
*   This macro is only applicable to DASD and cannot be used for      *
*   tapes.                                                            *
*                                                                     *
*---------------------------------------------------------------------*
* Macro to generate code to dynamically Allocate/Info/Delete/         *
*  Unallocate|Free/Deconcatenate/Concatenate/Reallocate               *
*                                                                     *
*   Parameters:                                                       *
*       1. ACTION  - valid actions are:                               *
*                    'Info'    - advise if dataset is allocated.      *
*                                Requires the following minimum       *
*                                parameters:                          *
*                                  DD and DSN.                        *
*                    'Alloc'   - allocate datest (basically pass jcl  *
*                                format parameters).                  *
*                                To reallocate, pass parameter of     *
*                                REUSE=YES.                           *
*                    'Unalloc'/'Free'/'DEConc'                        *
*                              - any one of these command will        *
*                                unallocate the dataset/concatenations*
*                    'DELete'  - delete allocates the DSN with        *
*                                'DISP=(OLD,DELETE,DELETE)' then frees*
*                                it.                                  *
*                    'Conc'    - concatenates the dd name defined on  *
*                                the 'DDC' parameter to the 'DD' parm.*
*                                                                     *
*       2. BASE    - Register to be used as a base register for the   *
*                    SVC 99 DSECT 'S99RBP'. This register must be     *
*                    loaded with the address of the area where the    *
*                    SVC 99 parameter list may be built. Also used to *
*                    invoke the 'DYNALLOC' routine automatically.     *
*                    (Do not enclose in brackets.)                    *
*                    If the base parameter is not passed, the         *
*                    following will need to be explicitly coded:      *
*                    1. Before the invocation of the 'ADYN' macro:    *
*                                                                     *
*                         USING S99RBP,Rn  establish addresability    *
*                                                                     *
*                    2. On return from the macro:                     *
*                                                                     *
*                         LR    R1,Rn  req blk ptr in R1 for dynalloc *
*                                      (both Rn must be same register)*
*                         DYNALLOC                                    *
*                                                                     *
*       3. BLKSIZE - Block size. (Same restrictions as 'LRECL').      *
*                                                                     *
*       4. CCP     - Wheteher to make concatenation permanent.        *
*                    Valid values are YES/NO with YES as default.     *
*                                                                     *
*       5. COPIES  - Number of copies to print (for SYSOUT DD's)      *
*                                                                     *
*       6. DATA    - Valid values are 'VARiable'/'CONstant'/'IBM'.    *
*                    Set up the data fields if you use the parameter  *
*                    'PARMT=DATA' in your program:                    *
*                    Set to 'VARiable' if you want a map of the data  *
*                    fields used for variable parameter passing. This *
*                    is required in your getmained DSECT for re-      *
*                    entrant programs.                                *
*                    You may initialise this area by coding a macro   *
*                    with 'DATA=CONstant' in your constant data area  *
*                    and on the macro pass all the parameters as      *
*                    though you were coding a macro with 'PARMT=PARM' *
*                    and moving it over the variable part. The max    *
*                    length of the data is 123 bytes.  If the program *
*                    is not re-entrant you only need to code the macro*
*                    with the parameter of 'DATA=VARiable'.           *
*                    In all cases supply a macro with 'DATA=IBM' to   *
*                    define the IBM required macros. If this is not   *
*                    defined in your program, you must explicitly     *
*                    define the following ibm macros in your program  *
*                          'IEFZB4D0'                                 *
*                          'IEFZB4D2'                                 *
*                    There should only be 1 macro with DATA=IBM/VAR   *
*                    however you may have as many DATA=CON as you     *
*                    like. DATA=IBM/VAR generate labels while 'CON'   *
*                    does not.                                        *
*                                                                     *
*       7. DD      - DD name to be allocated. In case of a 'Conc'     *
*                    action, concatenate the 'DDC' parm to this.      *
*                    If parameter 'DDR=YES' is used with 'PARMT=PARM' *
*                    this paramater must point to a variable name in  *
*                    the data area.                                   *
*                                    - or -                           *
*                    DD=(varname) if the DDname is to be taken from   *
*                    a variable.                                      *
*                    For DDR=Yes, allign the DD variable on a full-   *
*                    word boundary to eliminate allignament warning   *
*                    assembly messages.                               *
*                                                                     *
*       8. DDC     - DD name to concatenate to DD name with 'Conc'.   *
*                                                                     *
*       9. DDR     - DD name to be returned and placed in the variable*
*                    specified for the 'DD' parameter after an        *
*                    'Alloc' request without a DD parm. Set to either *
*                    YSE/NO ('NO' is the default).                    *
*                    If 'PARMT=DATA' is used, the DD name is returned *
*                    in the variable 'YDD' which would have been      *
*                    defined by the ADYN macro with 'PARMT=VAR'.      *
*      10. DEST    - Printer-id destination with 'SYSOUT'             *
*                                                                     *
*      11. DISP    - Standard JCL type DISP parameter, eg.            *
*                    'DISP=(NEW,CATLG,DELETE)'                        *
*                    (default of 'OLD' for 'Allocate' action.)        *
*                    For new dataset allocation without a 'DSN='      *
*                    but rather a 'DSNR=' parameter, the 2nd. and 3rd.*
*                    disposition parameter will be automatically      *
*                    changed to '(....,DELETE,DELETE)'.               *
*                                                                     *
*      12. DSN     - DSNAME (unquoted of course) or '*' for terminal. *
*                                    - or -                           *
*                    Variable name to return the DSN name in, after an*
*                    'Info' request. (If 'PARMT=DATA' is used the DSN *
*                    will be returned in the variable 'YDSN' which    *
*                    would have been defined by the ADYN macro with   *
*                    'PARMT=VAR'.)                                    *
*                                    - or -                           *
*                    If the action is ALLOC and the dataset name is   *
*                    stored in a variable and PARMT=PARM is required, *
*                    indicate the variable's name by specifying       *
*                    'DSN=(varname)'.                                 *
*                    NOTE - This variable must be specified if the    *
*                    'DSNR=Yes' parameter is used. Use 'DSN=YDSN' for *
*                    'PARMT=VAR'.                                     *
*                    For DSNR=Yes, allign the DSN variable on a full- *
*                    word boundary to eliminate allignament warning   *
*                    assembly messages.                               *
*                                                                     *
*      13. DSNR    - DSN name to be returned and placed in the        *
*                    variable specified for the 'DSN' parameter after *
*                    an 'Alloc' request without a DSN parm. Set to    *
*                    either YES/NO ('NO' is the default).             *
*                    If 'PARMT=DATA' is used, the DSN name is returned*
*                    in the variable 'YDSN' which would have been     *
*                    defined by the ADYN macro with 'PARMT=VAR'.      *
*                    >>>>>>>>>>>>>>>>>>>> NOTE <<<<<<<<<<<<<<<<<<<<<< *
*                    Will force 'DISP=(...,DELETE,DELETE)' to prevent *
*                    allocations of datasets with variable names all  *
*                    over the place........                           *
*                    >>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<< *
*                                                                     *
*      14. ERROR   - Label to branch to in case of error. If this     *
*                    parameter is not passed you will have to code    *
*                    your own return code test:                       *
*                          LTR  R15,R15                               *
*                          BNZ  ERROR01                               *
*                                                                     *
*      15. FCB     - Forms Control Buffer image id                    *
*                                                                     *
*      16. HELP    - Set to YES/NO to include these parameter comments*
*                    into the assembly listings. The default is 'NO'. *
*                                                                     *
*      17. LIST    - Set to YES/NO to generate macro expansion.       *
*                    Default is 'YES'.                                *
*                                                                     *
*      18. LRECL   - Logical record size. As a keyword, pass as an    *
*                    integer < 32760. As data pass as a halfword.     *
*                                                                     *
*      19. MEMBER  - Member name or GDG generation. The GDG generation*
*                    must be numeric an can take the format -n, 0, n  *
*                    or +n.                                           *
*                                    - or -                           *
*                    MEMBER=(member) if the member name is to be      *
*                    taken from a variable and PARMT=PARM.            *
*                                                                     *
*      20. MF      - Macro format. Must be coded as MF=E to generate  *
*                    code and MF=L either in a GETMAINed DSECT and/or *
*                    data area. MF=L defines 16 full words as a       *
*                    register save area (will not be defined if the   *
*                    area has already been defined by a prior macro). *
*                    These 16 full words are appended to both the     *
*                    DATA=VAR/CON areas if used.                      *
*                                                                     *
*      21. PARMT   - Parameter type.                                  *
*               'PARM'    - Keyword parameters passed (default) on    *
*                           the EXEC form of the macro.               *
*               'DATA'    - Parameters passed as data from the 'ADYN' *
*                           DSECT. If parameters are passed as        *
*                           variable data, a keyword entry of 'DATA'  *
*                           is required to tell the macro to process  *
*                           that parameter from the data area (in     *
*                           this case the data area must be set up as *
*                           required).                                *
*                           (Default is 'PARM'.)                      *
*                                                                     *
*      22. PERMA   - 'Permanent allocate' attribute. Prevents         *
*                    datasets from being automatically dealocated when*
*                    closed (in on-line environments).                *
*                    valid values are YES/NO with 'YES' as default.   *
*                                                                     *
*      23. PDUMP   - Invoke the PDUMP utility just prior to issuing   *
*                    the DYNALLOC SVC.                                *
*                                                                     *
*      24. PDUMPX  - This parameter is used with the PDUMP parameter  *
*                    and you may specify an exit point address to     *
*                    branch to by entering the 'QUIT' command in      *
*                    PDUMP thereby bypassing execution of DYNALLOC.   *
*                                                                     *
*      25. RECFM   - Record format.                                   *
*                                                                     *
*      26. REGR    - Set to YES/NO to restore registers on return     *
*                    from macro, default is 'YES'.                    *
*                    (Refer note "A" below.)                          *
*                                                                     *
*      27. REUSE   - Use this parameter if you wany to reallocate the *
*                    DD name without having to free it.  The macro    *
*                    will generate the Free statements prior to       *
*                    Allocation. Set to YES/NO ('NO' is the default). *
*                                                                     *
*      28. RLSE    - Release unused space indicator. Not required for *
*                    keyword parameters as would be passed on the     *
*                    SPACE= keyword. However, is required if data     *
*                    passed as there is no equivalent data area.      *
*                    Valid values are YES/NO with 'NO' as default.    *
*                                                                     *
*      29. Rn      - Substitute specified register for the nominated  *
*                    register in this routine. Registers that may be  *
*                    substituted are:                                 *
*                       R1, R4, R5, R6 and R7.                        *
*                    NOTE - You may use R14 and R15 as substitute     *
*                           registers.                                *
*                                                                     *
*      30. SPACE   - Standard JCL type space parameter, eg.           *
*                    'SPACE=(TRK,(2,2,1),RLSE)'                       *
*                    NOTE - In DATA format of the macro, RLSE is      *
*                           ignored and you must specify the RLSE=YES *
*                           paremeter.                                *
*                                                                     *
*      31. SYSOUT  - SYSOUT class and writer-name:                    *
*                    eg. SYSOUT=X, SYSOUT=(A,INTRDR),                 *
*                        SYSOUT=(A,FREDWRTR)                          *
*                                                                     *
*      32. UCLOSE  - Unalloc dataset on closing. If this option is to *
*                    be effective, it must be coded as UCLOSE=YES for *
*                    both types of parameter passing as there is no   *
*                    equivalent data area.                            *
*                    Valid values are YES/NO with 'NO' as default.    *
*                                                                     *
*      33. UNIT    - Device unit type. Any valid device unit as would *
*                    be accepted on JCL.                              *
*                                                                     *
*      34. VOLSER  - Volume serial.                                   *
*                                    - or -                           *
*                    VOLSER=(volser) if the member name is to be      *
*                    taken from a variable and PARMT=PARM.            *
*                    For VOLR=Yes, allign the VOLSER variable on a    *
*                    full-word boundary to eliminate allignament      *
*                    warning assembly messages.                       *
*                                                                     *
*      35. VOLR    - VOLSER name to be returned and placed in the     *
*                    variable specified for the 'VOLSER' parameter    *
*                    after an 'Alloc' request without a VOLSER value. *
*                    Set to either YES/NO ('NO' is the default).  If  *
*                    'PARMT=DATA' is used, the VOLSER name is returned*
*                    in the variable 'YVOLSER' which would have been  *
*                    defined by the ADYN macro with 'PARMT=VAR'.      *
*                                                                     *
*   NOTES -                                                           *
*      A) Macro format parameter of 'MF=.' Is mandatory.              *
*         A macro with 'MF=L' is required in your program to generate *
*         a register save area as registers R1,R4,R5,R6,R7,R14,R15 are*
*         used in the program. All registers except R15 will be       *
*         reset on return from the macro. R15 will contain the return *
*         code from the 'DYNALLOC' routine.                           *
*                                                                     *
*      B) If parameter 'PARMT=DATA' is used:                          *
*         Must issue an 'ADYN' macro with 'DATA=VARiable'. For re-    *
*         entrant programs, suggest you initialise the data area in   *
*         your DSECT by copying over it data initialised in your      *
*         constant area from an 'ADYN' macro using 'DATA=CONstant'.   *
*                                                                     *
*      C) Must have 'DATA=IBM' to include the IBM DSECTs needed for   *
*         SVC 99.                                                     *
*                                                                     *
*      D) Space requirements:                                         *
*         Allow 300 bytes for SVC 99 parameter list, (ie. data area   *
*         pointer to by the 'BASE' parameter).                        *
*         Allow 123 bytes for both constant and variable data area    *
*         created by the 'DATA=CON/VAR' parameter. Add 64 (16 x 4)    *
*         bytes if this expansion stores the register save areas      *
*         (refer to the MF parameter).                                *
*                                                                     *
*      E) On the EXEC form of the macro, R15 contains the return code *
*         from the 'DYNALLOC' routine.  R0 contains the error code in *
*         the high 2 order bytes and the information reason code in   *
*         the low 2 order bytes.  All the other registers wiil be     *
*         reset to their initial value on entering the macro.         *
*         NOTE - Note the comment about register usage in this macro  *
*                versus your program's register usage.                *
*                                                                     *
***********************************************************************
.A$HELPE ANOP
         LCLC  &#DISP,&#DISP1,&#DISP2,&#DISP3,&#ACTION,&#PRIM,&#SECOND
         LCLC  &#RLSE,&#DSORG,&#BUFNO,&#DIRB,&#SPACET,&#DDC
         LCLC  &#MEMBER,&#DD,&#DDR,&#DSN,&#RECFM,&#LRECL,&#BLKSZ
         LCLC  &#UNIT,&#VOLSER,&#CLASS,&#WRTR,&#DEST,&#FCB,&#COPIES
         LCLC  &@DSNR,&@DDR,&#DSNR,&#DSNV,&#REUSEF
         LCLC  &#1,&#4,&#5,&#6,&#7
         LCLC  &#PERMA,&#CHDISP
         LCLC  &#VOLR,&#VOLV,&@VOLR,&VARNM
         GBLC  &REGSMC1,&REGSMC2
.*
.*--------------------------------------------------------------------*
.*
         LCLC  &INDEX,&DELLAB
.*
         LCLA  &PL,&TUS
.*--------------------------------------------------------------------*
         GBLC  &REGSAVR,&REGSMCR
         GBLB  &REGSFLG,&REGDFLG,&ADYNFL0,&ADYNFL1
         AIF   (&REGSFLG).A$RS
&REGSAVR SETC  'GB'.'&SYSNDX'.'#'
&REGSMCR SETC  'ADYN'
&REGSMC1 SETC  'ADYN'
&REGSMC2 SETC  'ADYN'
&REGSFLG SETB  1
.A$RS    ANOP
&#CHDISP SETC  'NO'
         AIF   (&ADYNFL0).A$RT
&ADYNFL0 SETB  1
.*-------------- ADYN EQUATES FOR MEANINGFULL VALUES -----------------*
$SHR     EQU X'08'
$NEW     EQU X'04'
$MOD     EQU X'02'
$OLD     EQU X'01'
$UNCATLG EQU X'01'
$CATLG   EQU X'02'
$DELETE  EQU X'04'
$KEEP    EQU X'08'
$FBA     EQU X'94'
$VBA     EQU X'54'
$FB      EQU X'90'
$VB      EQU X'50'
$U       EQU X'C0'
$F       EQU X'80'
$V       EQU X'40'
$POU     EQU X'03'
$PSU     EQU X'41'
$DAU     EQU X'21'
$PO      EQU X'02'
$PS      EQU X'40'
$DA      EQU X'20'
.A$RT    ANOP
.*--------------------------------------------------------------------*
.*  INITIALISE SYSLIST TYPE VARIABLES                                 *
.*--------------------------------------------------------------------*
&#1      SETC  '&R1.'
&#4      SETC  '&R4.'
&#5      SETC  '&R5.'
&#6      SETC  '&R6.'
&#7      SETC  '&R7.'
&#ACTION SETC  '&ACTION'
&#DISP1  SETC  '&DISP(1)'
&#DISP2  SETC  '&DISP(2)'
&#DISP3  SETC  '&DISP(3)'
         AIF   (T'&DISP EQ 'O').BYPDP3        BYPASS IF DISP OMITTED
         AIF   ('&#DISP1'(1,1) NE 'N').BYPDP3 BYPASS IF DISP NOT 'NEW'
         AIF   (T'&#DISP2 NE 'O').BYPDP2      BYP IF DISP2 PRESENT
&#DISP2  SETC  'CATLG'
.BYPDP2  ANOP
         AIF   (T'&#DISP3 NE 'O').BYPDP3      BYP IF DISP3 PRESENT
&#DISP3  SETC  'DELETE'
.BYPDP3  ANOP
&#SPACET SETC  '&SPACE(1)'
&#PRIM   SETC  '&SPACE(2,1)'
&#SECOND SETC  '&SPACE(2,2)'
&#DIRB   SETC  '&SPACE(2,3)'
&#CLASS  SETC  '&SYSOUT(1)'
&#WRTR   SETC  '&SYSOUT(2)'
&#RLSE   SETC  '&SPACE(3)'
         AIF (T'&#RLSE EQ 'O').TPARMT1     BYPASS IF NO 'RLSE' PARM
&#RLSE   SETC '&#RLSE'(1,1)                EXTRACT 1ST. CHAR
.TPARMT1 ANOP
         AIF ('&PARMT'(1,1) EQ 'P').GRELSE IF NON-VAR RLSE IN SPACE
         AIF (T'&#RLSE NE 'YES').GRELSE    BYPASS IF 'RLSE=YES' NOT REQ
&#RLSE   SETC  'R'                         SET 'RLSE' PARM
.GRELSE  ANOP
&#DSORG  SETC  '&DSORG'                    SET 'DSORG' WORK PARM
         AIF (T'&#DSORG NE 'O').DSORGE     IF DSORG PARM SUPPLIED BYP
         AIF (T'&#SPACET EQ 'O').DSORGE    IF NO SPACE TYPE BYPASS
         AIF (T'&#DIRB EQ 'O').DSORGPS     IF DIRB NOT SUPPLIED PS ORG
&#DSORG  SETC  'PO'
         AGO .DSORGE
.DSORGPS ANOP
&#DSORG  SETC  'PS'
.DSORGE  ANOP
.*-------------------------------------------------------------------*
.*     INITIALISE VARIABLES SO THEY MAY BE MANIPULATED               *
.*-------------------------------------------------------------------*
&#DD     SETC '&DD'
&#DDC    SETC '&DDC'
&#DDR    SETC '&DDR'
&#DSNR   SETC '&DSNR'
&#DSN    SETC '&DSN'
&#MEMBER SETC '&MEMBER'
&#VOLSER SETC '&VOLSER'
&#VOLR   SETC '&VOLR'
&#UNIT   SETC '&UNIT'
&#DEST   SETC '&DEST'
&#FCB    SETC '&FCB'
&#COPIES SETC '&COPIES'
&#BUFNO  SETC '&BUFNO'
&#RECFM  SETC '&RECFM'
&#LRECL  SETC '&LRECL'
&#BLKSZ  SETC '&BLKSIZE'
.*--------------------------------------------------------------------*
         AIF  (T'&DATA NE 'O').DATAMAP   GO PROCESS DATA TYPE
         AIF  ('&MF' EQ 'L').MFELIST     GO PROCESS LIST FORM
.*--------------------------------------------------------------------*
.MFEEXEC ANOP
.*--------------------------------------------------------------------*
&#PERMA  SETC '&PERMA'
         AIF ('&#ACTION'(1,1) NE 'A').BPREAL1  NOT REALLOC BYPASS'
         AIF ('&REUSE'(1,1) NE 'Y').BPREAL1    REUSE NOT REQUIRED
         AIF ('&#REUSEF' EQ 'Y').BPREAL1       REUSE RESET BYPASS
&#ACTION SETC 'FREE'
         AGO .ISFREE1                          GO FREE IT
.*--------------------------------------------------------------------*
.BPREAL1 ANOP
         AIF ('&#ACTION'(1,1) EQ 'U').ISFREE1  PROCESS 'UNALLOC'
         AIF ('&#ACTION'(1,1) NE 'F').TSTINF1 BYPASS IF NOT 'FREE'
.ISFREE1 ANOP     ENSURE ALL APPROPRIATE FIELDS ARE BLANK FOR FREE
         AIF (T'&#DD EQ 'O').LVFREE  BYPASS IF DD NOT SUPPLIED
&#DSN    SETC ''
&#DSNR   SETC 'NO'
&#MEMBER SETC ''
.LVFREE  ANOP
.* &#DD     SETC ''
.* &#DDR    SETC 'NO'
.* &#DSNR   SETC 'NO'
.* &#DSN    SETC ''
.* &#MEMBER SETC ''
&#DISP1  SETC ''
&#DISP2  SETC ''
&#DISP3  SETC ''
&#SPACET SETC ''
&#PRIM   SETC ''
&#SECOND SETC ''
&#DIRB   SETC ''
&#RLSE   SETC ''
&#UNIT   SETC ''
&#VOLSER SETC ''
&#VOLR   SETC 'NO'
&#RECFM  SETC ''
&#LRECL  SETC ''
&#BLKSZ  SETC ''
&#BUFNO  SETC ''
&#DSORG  SETC ''
&#CLASS  SETC ''
&#DEST   SETC ''
&#FCB    SETC ''
&#COPIES SETC ''
&#WRTR   SETC ''
&#PERMA  SETC 'NO'
         AGO .NOTDELT
.*--------------------------------------------------------------------*
.TSTINF1 ANOP
         AIF ('&#ACTION'(1,1) NE 'I').TSTCON1 BYPASS IF NOT 'INFO'
.* &#DD     SETC ''
.* &#DDR    SETC 'NO'
.* &#DSNR   SETC 'NO'
.* &#VOLR   SETC 'NO'
&#ACTION SETC 'INFO'
&#DSN    SETC '&DSN'
&#MEMBER SETC ''
&#DISP1  SETC ''
&#DISP2  SETC ''
&#DISP3  SETC ''
&#SPACET SETC ''
&#PRIM   SETC ''
&#SECOND SETC ''
&#DIRB   SETC ''
&#RLSE   SETC ''
&#UNIT   SETC ''
&#VOLSER SETC ''
&#RECFM  SETC ''
&#LRECL  SETC ''
&#BLKSZ  SETC ''
&#BUFNO  SETC ''
&#DSORG  SETC ''
&#CLASS  SETC ''
&#DEST   SETC ''
&#FCB    SETC ''
&#COPIES SETC ''
&#WRTR   SETC ''
&#PERMA  SETC 'NO'
         AGO .NOTDELT
.*--------------------------------------------------------------------*
.TSTCON1 ANOP
         AIF ('&#ACTION'(1,1) NE 'C').TSTDEC1 BYPASS IF NOT 'CONCAT'
&#ACTION SETC 'CONCAT'
&#DDC    SETC '&DDC'
&#DSN    SETC ''
&#MEMBER SETC ''
&#DISP1  SETC ''
&#DISP2  SETC ''
&#DISP3  SETC ''
&#SPACET SETC ''
&#PRIM   SETC ''
&#SECOND SETC ''
&#DIRB   SETC ''
&#RLSE   SETC ''
&#UNIT   SETC ''
&#VOLSER SETC ''
&#RECFM  SETC ''
&#LRECL  SETC ''
&#BLKSZ  SETC ''
&#BUFNO  SETC ''
&#DSORG  SETC ''
&#CLASS  SETC ''
&#DEST   SETC ''
&#FCB    SETC ''
&#COPIES SETC ''
&#WRTR   SETC ''
&#PERMA  SETC 'NO'
         AGO .NOTDELT
.*--------------------------------------------------------------------*
.TSTDEC1 ANOP
         AIF ('&#ACTION'(1,3) NE 'DEC').TSTDLT1 BYP IF NOT 'DECONCAT'
&#ACTION SETC 'DECONCAT'
&#DDC    SETC '&DDC'
&#DSN    SETC ''
&#MEMBER SETC ''
&#DISP1  SETC ''
&#DISP2  SETC ''
&#DISP3  SETC ''
&#SPACET SETC ''
&#PRIM   SETC ''
&#SECOND SETC ''
&#DIRB   SETC ''
&#RLSE   SETC ''
&#UNIT   SETC ''
&#VOLSER SETC ''
&#RECFM  SETC ''
&#LRECL  SETC ''
&#BLKSZ  SETC ''
&#BUFNO  SETC ''
&#DSORG  SETC ''
&#CLASS  SETC ''
&#DEST   SETC ''
&#FCB    SETC ''
&#COPIES SETC ''
&#WRTR   SETC ''
&#PERMA  SETC 'NO'
         AGO .NOTDELT
.*--------------------------------------------------------------------*
.TSTDLT1 ANOP
         AIF ('&#ACTION'(1,3) NE 'DEL').NOTDELT  BYP IF NOT 'DELETE'
*---------------------------------------------------------------------*
*  FOR 'DELETE', ALLOCATING DATASET WITH A STATUS OF:                 *
*     DISP=(OLD,DELETE,DELETE)                                        *
*---------------------------------------------------------------------*
&#ACTION SETC 'ALLOC'
&#DISP1  SETC 'OLD'
&#DISP2  SETC 'DELETE'
&#DISP3  SETC 'DELETE'
&#MEMBER SETC ''
&#VOLSER SETC ''
&#DEST   SETC ''
&#FCB    SETC ''
&#COPIES SETC ''
&#SPACET SETC ''
&#PRIM   SETC ''
&#SECOND SETC ''
&#DIRB   SETC ''
&#BUFNO  SETC ''
&#UNIT   SETC ''
&#RECFM  SETC ''
&#LRECL  SETC ''
&#BLKSZ  SETC ''
&#PERMA  SETC ''
&#PERMA  SETC 'NO'
.NOTDELT ANOP
.*--------------------------------------------------------------------*
.*--------------------------------------------------------------------*
.*    EXEC FORM OF MACRO
.*--------------------------------------------------------------------*
         AIF   ('&REGR' EQ 'NO').NORSAV1 BYPASS IF REGS NOT 2 BE REST'D
         STM   R0,R14,&REGSAVR      SAVE REGISTERS
.NORSAV1 ANOP
         AIF   (T'&BASE EQ 'O').NOBASE   BYPASS IF NO 'BASE' PASSED
         USING S99RBP,&BASE         ESTABLISH ADDRESABILITY
.NOBASE  ANOP
         LA    &#4,S99RBPTR+4       POINT PAST RBPTR
         USING S99RB,&#4            EST ADDRESABILITY FOR "RB" DSECT
         ST    &#4,S99RBPTR         MAKE "RBPTR" TO "RB"
         OI    S99RBPTR,S99RBPND    TURN ON HIGH ORDER BIT OF "RBPTR"
         XC    S99RB(S99RBEND-S99RB),S99RB INITIALISE "RB" ENTIRELY
         MVI   S99RBLN,S99RBEND-S99RB      PUT LEN OF "RB" IN ITS FLD
         LA    &#5,S99RB+(S99RBEND-S99RB)  POINT 20 BYTES PAST 'RB'
         USING S99TUPL,&#5          EST ADDRESABILITY TO TEXT UNIT PTRS
         ST    &#5,S99TXTPP         INIT TEXT POINTER IN 'RB'
.*--------------------------------------------------------------------*
.*    TEST ACTION AND SET VERB ACCORDINGLY                            *
.*--------------------------------------------------------------------*
&DELLAB  SETC  'AY'.'&SYSNDX'.'E'   SET LABEL FOR DELETE ERROR BYPASS
&TUS     SETA  0                    SET UNALLOCATE # TEXT UNITS
         AIF ('&#ACTION'(1,1) NE 'A').A1DD
         MVI   S99VERB,S99VRBAL     SET VERB FOR INFO ALLOCATION
         AIF ('&#DDR'(1,1) EQ 'Y').A1DDR
         LA    &#7,DALDDNAM         SET KEY FOR DDNAME SPECIFICATION
         AGO   .A1DD
.A1DDR   ANOP
         LA    &#7,DALRTDDN         SET KEY FOR DDNAME RETURN
         AIF ('&#ACTION'(1,1) EQ 'A').A1DDR1 BYPASS IF ACTION ADD
         MNOTE 12,'DD NAME RETURN ONLY APPLICABLE TO ALLOCATIONS.'
         AGO .MEXIT
.A1DDR1  ANOP
         AIF (T'&#DD NE 'O').A1DD   BYPASS IF DD SPECIFIED
         AIF ('&PARMT'(1,1) EQ 'D').A1DD
         MNOTE 12,'DD NAME RETURN MUST SPECIFY VARIABLE FOR PARMT=PARM'
         AGO .MEXIT
.A1DD    ANOP
         AIF ('&#DDR'(1,1) EQ 'Y').A1DDFC DD RETURN REQUESTED
         AIF (T'&#DD EQ 'O').A1DSNR1
.A1DDFC  ANOP
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR DDNAME                                             *
.A1DSNR1 ANOP
         AIF ('&#ACTION'(1,1) EQ 'C').CONC11
         AIF ('&#ACTION'(1,1) EQ 'F').A1DSN
         AIF ('&#ACTION'(1,1) EQ 'D').A1DSN
         AIF ('&#ACTION'(1,1) EQ 'U').A1DSN
         AIF (T'&#DSN NE 'O').A1DSN  BYPASS IF DSNAME SPECIFIED
         AIF (T'&SYSOUT NE 'O').A1DSN  BYPASS IF SYSOUT SPECIFIED
         AIF ('&PARMT'(1,1) EQ 'D').A1DSN
         MNOTE 12,'DSNAME RETURN MUST SPECIFY VARIABLE FOR PARMT=PARM'
         AGO .MEXIT
.A1DSN   ANOP
         AIF ('&#DSNR'(1,1) EQ 'Y').A1DSNFC DSN RETURN REQUESTED
         AIF (T'&#DSN EQ 'O').A1DISP1
.A1DSNFC ANOP
&TUS     SETA  &TUS+1
*  1 TEXT UNIT FOR DSNAME                                             *
         AIF ('&#ACTION'(1,1) EQ 'I').INFO11
.A1DISP1 ANOP
         AIF (T'&#DISP1 NE 'O').A1DIS11       PROCESS IF NOT OMITTED
         AIF ('&#ACTION'(1,1) NE 'A').A1MEMBR BYPASS IF NOT ALLOCATE
         AIF (T'&#CLASS NE 'O').A1MEMBR       BYPASS IF SYSOUT CLASS
&#DISP1  SETC 'OLD'                           SET STATUS AS OLD
*        DEFAULT STATUS OF 'OLD' ASSIGNED                             *
.A1DIS11 ANOP
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR STATUS                                             *
.A1MEMBR ANOP
         AIF (T'&#MEMBER EQ 'O').A1VOLS
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR MEMBER                                             *
.A1VOLS  ANOP
         AIF ('&#VOLR'(1,1) EQ 'Y').A1VOLSR
         AIF (T'&#VOLSER EQ 'O').A1DEST
.A1VOLSR ANOP
         AIF ('&PARMT'(1,1) EQ 'D').A1VOLS1
         AIF (T'&#VOLSER NE 'O').A1VOLS1
         MNOTE 12,'VOLSER RETURN MUST SPECIFY VARIABLE FOR PARMT=PARM'
         AGO .MEXIT
.A1VOLS1 ANOP
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR VOLSER                                             *
.A1DEST  ANOP
         AIF (T'&#DEST EQ 'O').A1FCB
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR SYSOUT DESTINATION                                 *
.A1FCB   ANOP
         AIF (T'&#FCB EQ 'O').A1COPYS
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR FCB                                                *
.A1COPYS ANOP
         AIF (T'&#COPIES EQ 'O').A1T1
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR COPIES                                             *
.A1T1    ANOP
         AIF (T'&#DISP2 EQ 'O').A1DISP3
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR NORMAL DISPOSITION                                 *
.A1DISP3 ANOP
         AIF (T'&#DISP3 EQ 'O').A1BLK
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR CONDITIONAL/ABNORMAL TERMINATION                   *
.A1BLK   ANOP
         AIF (T'&#BLKSZ EQ 'O').A1LREC
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR BLKSIZE                                            *
.A1LREC  ANOP
         AIF (T'&#LRECL EQ 'O').A1RECFM
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR LRECL                                              *
.A1RECFM ANOP
         AIF (T'&#RECFM EQ 'O').A1DSORG
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR RECFM                                              *
.A1DSORG ANOP
         AIF (T'&#DSORG EQ 'O').A1SPACE
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR DSORG                                              *
.A1SPACE ANOP
         AIF (T'&#SPACET EQ 'O').A1PRIM
&TUS     SETA  &TUS+2               SET UNALLOCATE # TEXT UNITS
*  2 TEXT UNIT FOR ALLOCATION UNITS (CYL, TRK or block size)          *
.A1PRIM  ANOP
         AIF (T'&#PRIM EQ 'O').A1SECON
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR PRIMARY ALLOCATION                                 *
.A1SECON ANOP
         AIF (T'&#SECOND EQ 'O').A1DIRB
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR SECONDARY ALLOCATION                               *
.A1DIRB  ANOP
         AIF ('&#PERMA'(1,1) NE 'Y').A1PERMA
&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS
*  1 TEXT UNIT FOR PERMANENT ALLOCATE ATTRIBUTE                       *
.A1PERMA ANOP
         AIF (T'&#DIRB EQ 'O').A1BUFNO
&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS
*  1 TEXT UNIT FOR DIRECTORY BLOCKS                                   *
.A1BUFNO ANOP
         AIF (T'&#BUFNO EQ 'O').A1UNIT
&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS
*  1 TEXT UNIT FOR BUFFER COUNT/DCB                                   *
.A1UNIT  ANOP
         AIF (T'&#UNIT NE 'O').A1UNI11   PROCESS IF NOT OMITTED
         AIF ('&#DISP1' NE 'NEW').A1WRTR BYPASS IF OMMITED AND NOT NEW
&#UNIT   SETC 'SYSALLDA'                 SET UNIT AS 'SYSALLDA'
*        DEFAULT DEVICE UNIT OF 'SYSALLDA' ASSIGNED                   *
.A1UNI11 ANOP
&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS
*  1 TEXT UNIT FOR DEVICE UNIT                                        *
.A1WRTR  ANOP
         AIF (T'&#WRTR EQ 'O').A1CLASS
&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS
*  1 TEXT UNIT FOR SYSOUT WRITER-NAME/INTERNAL-READER                 *
.A1CLASS ANOP
         AIF (T'&#CLASS EQ 'O').A1RLSE
&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS
*  1 TEXT UNIT FOR SYSOUT CLASS                                       *
.A1RLSE  ANOP
         AIF (T'&#RLSE EQ 'O').A1UCLOS
&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS
*  1 TEXT UNIT FOR RLSE
.A1UCLOS ANOP
         AIF ('&#ACTION'(1,1) NE 'A').A$OPTE  BYPASS IF NOT 'ALLOACTE'
         AIF ('&UCLOSE' NE 'YES').A$OPTE
&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS
*  1 TEXT UNIT FOR UCLOSE                                             *
.A$OPTE  ANOP
         AIF ('&#ACTION'(1,1) EQ 'A').CON#000
.UNAL1   ANOP
         AIF ('&#ACTION'(1,1) EQ 'U').UNAL11
         AIF ('&#ACTION'(1,1) NE 'F').INFO1
.UNAL11  ANOP
         MVI   S99VERB,S99VRBUN     SET VERB FOR UNALLOCATION
         LA    &#7,DUNDDNAM         GET THE KEY FOR DDNAME
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR REMOVE 'IN-USE' ATTRIBUTE (UNALLOCATE)             *
.*  1 TEXT UNIT FOR UNALLOCATE ATTRIBUTE
         AGO .CON#000
.INFO1   ANOP
         AIF ('&#ACTION'(1,1) NE 'I').CONC1
.INFO11  ANOP
         MVI   S99VERB,S99VRBIN     SET VERB FOR INFO RETRIEVAL
         LA    &#7,DINDDNAM         GET THE KEY FOR DDNAME
         AIF ('&PARMT'(1,1) EQ 'P').CON#000
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR DSNAME RETURN                                      *
         AGO .CON#000
.CONC1   ANOP
         AIF ('&#ACTION'(1,1) NE 'C').DEAL1
         AIF (T'&#DDC NE 'O').CONC11
         MNOTE 12,'CONCATENATION MUST HAVE A "DDC" PARAMETER.'
         AGO .MEXIT
.CONC11  ANOP
         MVI   S99VERB,S99VRBCC     SET VERB FOR INFO CONCATENATE
         LA    &#7,DCCDDNAM         GET THE KEY FOR DDNAME
         AIF ('&CCP'(1,1) EQ 'N').CON#000
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR PERMANENT CONCATENATION
         AGO .CON#000
.DEAL1   ANOP
         AIF ('&#ACTION'(1,3) NE 'DEC').CON#000
         AIF (T'&#DDC NE 'O').DEAL11
         MNOTE 12,'DECONCATENATION MUST HAVE A "DDC" PARAMETER.'
         AGO .MEXIT
.DEAL11  ANOP
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
         MVI   S99VERB,S99VRBDC     SET VERB FOR INFO DECONCATENATE
         LA    &#7,DDCDDNAM         GET THE KEY FOR DDNAME
.CON#000 ANOP
         LA    &#6,S99TUPL+(&TUS*4) POINT JUST PAST THE TEXT UNIT PTRS
         USING S99TUNIT,&#6         ADDRESABILITY FOR 1ST TEXT UNIT
&TUS     SETA  0                    SET TEXT UNITS PTR INCREMENT
.*-------------------------------------------------------------------*
.A2DDC   ANOP
         AIF ('&#ACTION'(1,1) NE 'C').A2DEC
*--------------------------------------------------------------------*
*   ADYN-SET UP DDNAME TO CONCATENATE                                *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT
         ST    &#6,S99TUPTR         POINT 1ST TXT UNIT PTR TO 1ST TXT U
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,2                BECAUSE THE DSNAME KEY REQUIRES 2
         STH   &#7,S99TUNUM           PARM, STORE 2 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2DDC#
         LA    &#7,8                MAXIMUM LENGTH OF DATASET
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         STH   &#7,S99TULNG+10      STORE TEXT UNIT LENGTH TO CONCAT
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99DDN          MOVE DDNAME
         EX    &#7,MV99DDCN         MOVE DDNAME TO CONCATENATE
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         AIF ('&CCP'(1,1) EQ 'N').A$END
         LA    &#6,4(&#6)           POINT PAST KEY, # (NOT LENGTH)
         LA    &#7,3(&#7)           BACK TO NORMAL LENGTH + LENGTH FLD
         AR    &#6,&#7              POINT PAST DDNAME
         AR    &#6,&#7              POINT PAST DDNAME CONCATENATION
         AGO   .A2DDC#0             EXIT PROCESS
.A2DDC#  ANOP
&PL      SETA  K'&#DD
&PLC     SETA  K'&#DDC
         LA    &#7,&PL              LENGTH OF DDNAME
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#7,&PLC             LENGTH OF CONCAT DDNAME
         STH   &#7,S99TULNG+&PL+2   STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PL),=C'&#DD' MOVE DDNAME
         MVC   S99TUPAR+&PL+2(&PLC),=C'&#DDC' MOVE DDNAME TO CONCAT
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         AIF ('&CCP'(1,1) EQ 'N').A$END
         LA    &#6,4(&#6)           POINT PAST KEY, # (NOT LENGTH)
         LA    &#7,&PL+2            LENGTH OF DDNAME + LENGTH FIELD
         LA    &#7,&PLC+2(&#7)      LENGTH OF DDNAME + LENGTH FIELD
         AR    &#6,&#7              POINT PAST DSNAME
.A2DDC#0 ANOP
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DCCPERMC         GET THE KEY FOR PERMANENT CONCAT
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,0                BECAUSE THE PERMCON KEY REQUIRES 0
         STH   &#7,S99TUNUM           PARM, STORE 0 IN NUMBER FIELD
         AGO   .A$END
.*-------------------------------------------------------------------*
.A2DEC   ANOP
         AIF ('&#ACTION'(1,3) NE 'DEC').A2DD
*--------------------------------------------------------------------*
*   ADYN-SET UP DDNAME TO DECONCATENATE                              *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT
         ST    &#6,S99TUPTR         POINT 1ST TXT UNIT PTR TO 1ST TXT U
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2DEC#
         LA    &#7,8                MAXIMUM LENGTH OF DATASET
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99DDCN         MOVE DDNAME TO DECONCATENATE
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         AGO   .A2DEC#0             EXIT PROCESS
.A2DEC#  ANOP
&PLC     SETA  K'&#DDC
         LA    &#7,&PLC             LENGTH OF CONCAT DDNAME
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PLC),=C'&#DDC' MOVE DDNAME TO DECONCATENATE
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
.A2DEC#0 ANOP
         AGO   .A$END
.*-------------------------------------------------------------------*
.A2DD    ANOP
&@DDR    SETC  ''
         AIF ('&#DDR'(1,1) EQ 'Y').A2DDRIY
         AIF (T'&#DD  EQ 'O').A2DSN
         AGO   .A2DDACT
.A2DDRIY ANOP
         AIF ('&PARMT'(1,1) EQ 'P').A2DDRIP
&@DDR    SETC  'YDD'
         AGO   .A2DDACT
.A2DDRIP ANOP
&@DDR    SETC  '&#DD'
.A2DDACT ANOP
*--------------------------------------------------------------------*
*   ADYN-SET UP DDNAME                                               *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT
         ST    &#6,S99TUPTR         POINT 1ST TXT UNIT PTR TO 1ST TXT U
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         LA    &#7,8                MAXIMUM LENGTH OF DATASET
         AIF ('&#DDR'(1,1) EQ 'Y').A2DDR0 IF DD RETURN REQ'D BYPASS
         AIF ('&PARMT'(1,1) EQ 'P').A2DD#
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99DDN          MOVE DDNAME
         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH
         AGO   .A2DDR1
.A2DDR0  ANOP
         LA    &#1,S99TUPAR         LOAD DDNAME VARIABLE ADDRESS
&VARNM   SETC  '&#DD'               SET VARIABLE NAME
         AIF ('&#DD'(1,1) NE '(').NDDVAR1
&PL      SETA  K'&#DD
&VARNM   SETC  '&#DD'(2,&PL-2)      SET VARIABLE NAME
.NDDVAR1 ANOP
         ST    &#1,&VARNM           SAVE FOR LATER USE
.A2DDR1  ANOP
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST DSNAME
         AGO   .A2DD#0              EXIT PROCESS
.A2DD#   ANOP
&PL      SETA  K'&#DD
         AIF ('&#DD'(1,1) NE '(').NDDVAR2
&VARNM   SETC  '&#DD'(2,&PL-2)      SET VARIABLE NAME
         MVC   S99TUPAR(L'&VARNM),&VARNM  MOVE VARIABLE NAME
         LA    &#7,L'&VARNM         MAXIMUM LENGTH OF VARIABLE
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,L'&VARNM.(&#6)   POINT PAST DSNAME
         AGO   .A2DD#0  ANOP
.NDDVAR2 ANOP
         LA    &#7,&PL              MAXIMUM LENGTH OF DATASET
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PL),=C'&#DD'
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,&PL.(&#6)        POINT PAST DDNAME
.A2DD#0  ANOP
*--------------------------------------------------------------------*
*   ADYN-SET UP DSNAME                                               *
*--------------------------------------------------------------------*
.*--------------------------------------------------------------------*
.A2DSN   ANOP
         AIF ('&#ACTION'(1,1) EQ 'I').INFO2
         AIF ('&#DSN' EQ 'DUMMY').A2DUMMY
         AIF ('&#DSN' EQ '*').A2TERML
&@DSNR   SETC  ''
&#DSNV   SETC  'DALDSNAM'
         AIF ('&#DSNR'(1,1) EQ 'Y').A2DSRIY
         AIF (T'&#DSN EQ 'O').A2MEMBR
         AGO  .A2DSACT
.A2DSRIY ANOP
&#DSNV   SETC  'DALRTDSN'
&#DISP2  SETC  'DELETE'
&#DISP3  SETC  'DELETE'
         AIF ('&PARMT'(1,1) EQ 'P').A2DSRIP
&@DSNR   SETC  'YDSN'
         AGO   .A2DSACT
.A2DSRIP ANOP
&@DSNR   SETC  '&#DSN'
.A2DSACT ANOP
.*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,&#DSNV           GET THE KEY FOR DSNAME
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         LA    &#7,44               MAXIMUM LENGTH OF DATASET NAME
         AIF ('&#DSNR'(1,1) EQ 'Y').A2DSNR0 IF DSN RETURN REQ'D BYPASS
         AIF ('&PARMT'(1,1) EQ 'P').A2DSN#
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99DSN          MOVE DSNAME
         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH
         AGO   .A2DSNR1
.A2DSNR0 ANOP
         LA    &#1,S99TUPAR         LOAD DSNAME VARIABLE ADDRESS
&VARNM   SETC  '&#DSN'              SET VARIABLE NAME
         AIF (T'&#DSN EQ 'O').NDSNVA1
         AIF ('&#DSN'(1,1) NE '(').NDSNVA1
&PL      SETA  K'&#DSN
&VARNM   SETC  '&#DSN'(2,&PL-2)     SET VARIABLE NAME
.NDSNVA1 ANOP
.*       ST    &#1,&VARNM           SAVE FOR LATER USE
         ST    &#1,&@DSNR           SAVE FOR LATER USE
.A2DSNR1 ANOP
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST DSNAME
         AGO   .A2DSN#0             EXIT PROCESS
.A2DSN#  ANOP
&PL      SETA  K'&#DSN
         AIF ('&#DSN'(1,1) NE '(').NDSNVA2
&VARNM   SETC  '&#DSN'(2,&PL-2)     SET VARIABLE NAME
         MVC   S99TUPAR(L'&VARNM),&VARNM     MOVE VARIABLE NAME
         LA    &#7,L'&VARNM         MAXIMUM LENGTH OF VARIABLE
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,L'&VARNM.(&#6)   POINT PAST DSNAME
         AGO   .A2DSN#0             EXIT PROCESS
.NDSNVA2 ANOP
         MVC   S99TUPAR(&PL),=C'&#DSN'
         LA    &#7,&PL              LENGTH OF DATASET
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,&PL.(&#6)        POINT PAST DSNAME
.A2DSN#0 ANOP
         AGO   .A2MEMBR
.*--------------------------------------------------------------------*
.A2DUMMY ANOP
*--------------------------------------------------------------------*
*   ADYN-SET UP DUMMY DSNAME                                         *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALDUMMY         GET THE KEY FOR DUMMY DSNAME
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
         AGO   .A2MEMBR
.A2TERML ANOP
*--------------------------------------------------------------------*
*   ADYN-OUTPUT TO A TERMINAL FOR ON-LINE SESSIONS                   *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALTERM          GET KEY FOR TERMINAL OUTPUT
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,0                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
         AGO   .A2MEMBR
.A2MEMBR ANOP
         AIF (T'&#MEMBER EQ 'O').A2VOLS
*--------------------------------------------------------------------*
*   ADYN-SET UP MEMBER                                               *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALMEMBR         GET THE KEY FOR DSNAME
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2MEM#
         LA    &#7,8                MAXIMUM LENGTH OF MEMBER NAME
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99MEMB         MOVE MEMBER
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH
         AR    &#6,&#7              POINT PAST DSNAME
         AGO   .A2VOLS
.A2MEM#  ANOP
&PL      SETA  K'&MEMBER
         AIF ('&MEMBER'(1,1) NE '(').NMEMVAR
&VARNM   SETC  '&MEMBER'(2,&PL-2)   SET VARIABLE NAME
         MVC   S99TUPAR(L'&VARNM),&VARNM     MOVE VARIABLE NAME
         LA    &#7,L'&VARNM         MAXIMUM LENGTH OF VARIABLE
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,L'&VARNM.(&#6)   POINT PAST DSNAME
         AGO   .A2VOLS              EXIT PROCESS
.NMEMVAR ANOP
&PL      SETA  K'&MEMBER
         LA    &#7,&PL              MAXIMUM LENGTH OF MEMBER NAME
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PL),=C'&MEMBER'
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,&PL.(&#6)        POINT PAST DSNAME
.A2VOLS  ANOP
         AIF ('&#VOLR'(1,1) EQ 'Y').A2VOLSF
         AIF (T'&#VOLSER EQ 'O').A2DEST
*--------------------------------------------------------------------*
*   ADYN-SET UP VOLSER                                               *
*--------------------------------------------------------------------*
.A2VOLSF ANOP
&@VOLR   SETC  ''
&#VOLV   SETC  'DALVLSER'
         AIF ('&#VOLR'(1,1) NE 'Y').A2VOACT
&#VOLV   SETC  'DALRTVOL'
.A2VORIY ANOP
         AIF ('&PARMT'(1,1) EQ 'P').A2VORIP
&@VOLR   SETC  'YVOLSER'
         AGO   .A2VOACT
.A2VORIP ANOP
&@VOLR   SETC  '&#VOL'
.A2VOACT ANOP
.*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,&#VOLV           GET THE KEY FOR VOLSER
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         LA    &#7,6                MAXIMUM LENGTH OF DATASET NAME
         AIF ('&#DSNR'(1,1) EQ 'Y').A2VOLR0 IF VOL RETURN REQ'D BYPASS
         AIF ('&PARMT'(1,1) EQ 'P').A2VOL#
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99VOLS         MOVE VOLSER
         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH
         AGO   .A2VOLR1
.A2VOLR0 ANOP
         LA    &#1,S99TUPAR         LOAD VOLSER VARIABLE ADDRESS
&VARNM   SETC  '&#VOLSER'           SET VARIABLE NAME
         AIF (T'&#VOLSER EQ 'O').NVOLVA1
         AIF ('&#VOLSER'(1,1) NE '(').NVOLVA1
&PL      SETA  K'&#VOLSER
&VARNM   SETC  '&#VOLSER'(2,&PL-2)  SET VARIABLE NAME
.NVOLVA1 ANOP
         ST    &#1,&@VOLR           SAVE FOR LATER USE
.A2VOLR1 ANOP
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST DSNAME
         AGO   .A2VOL#0             EXIT PROCESS
.A2VOL#  ANOP
&PL      SETA  K'&#VOLSER
         AIF ('&#VOLSER'(1,1) NE '(').NVOLVA2
&VARNM   SETC  '&#VOLSER'(2,&PL-2)  SET VARIABLE NAME
         MVC   S99TUPAR(L'&VARNM),&VARNM     MOVE VARIABLE NAME
         LA    &#7,L'&VARNM         MAXIMUM LENGTH OF VARIABLE
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,L'&VARNM.(&#6)   POINT PAST DSNAME
         AGO   .A2VOL#0             EXIT PROCESS
.NVOLVA2 ANOP
         LA    &#7,&PL              MAXIMUM LENGTH OF VOLSER
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PL),=C'&#VOLSER'
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,&PL.(&#6)        POINT PAST DSNAME
.A2VOL#0 ANOP
.*--------------------------------------------------------------------*
.A2DEST  ANOP
         AIF (T'&#DEST EQ 'O').A2FCB
*--------------------------------------------------------------------*
*   ADYN-SET UP PRINTER DESTINATION                                  *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALSUSER         GET THE KEY FOR DESTINATION
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2DEST#
         LA    &#7,8                LENGTH OF DESTINATION
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99DEST         MOVE DESTINATION
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH
         AR    &#6,&#7              POINT PAST DSNAME
         AGO   .A2FCB
.A2DEST# ANOP
&PL      SETA  K'&DEST
         LA    &#7,&PL              LENGTH OF VOLOSER
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PL),=C'&DEST' MOVE PRINTER-ID
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,&PL.(&#6)        POINT PAST DSNAME
.A2FCB   ANOP
         AIF (T'&#FCB EQ 'O').A2COPY
*--------------------------------------------------------------------*
*   ADYN-SET UP FCB                                                  *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALFCBIM         GET THE KEY FOR FCB
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2FCB#
         LA    &#7,4                LENGTH OF FCB
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99FCB          MOVE FCB
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH
         AR    &#6,&#7              POINT PAST DSNAME
         AGO   .A2DISP
.A2FCB#  ANOP
&PL      SETA  K'&FCB
         LA    &#7,&PL              LENGTH OF VOLOSER
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PL),=C'&FCB' MOVE FCB
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,&PL.(&#6)        POINT PAST DSNAME
.A2COPY  ANOP
         AIF (T'&#COPIES EQ 'O').A2DISP
*--------------------------------------------------------------------*
*   ADYN-SET UP COPIES                                               *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALCOPYS         GET KEY FOR # OF COPIES
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE COPYS KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2CPY#
         MVC   S99TUPAR(1),YCOPIES  SET # OF COPIES
         AGO .A2CPY#0
.A2CPY#  ANOP
         MVC   S99TUPAR(1),=AL1(&COPIES) SET # OF COPIES
.A2CPY#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2DISP  ANOP
         AIF (T'&#DISP1 EQ 'O').A2DISP2
*--------------------------------------------------------------------*
*   ADYN-DATASET STATUS DESIRED                                      *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALSTATS         GET KEY FOR STATUS SPECIFICATIONS
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2DIS#
         MVC   S99TUPAR(1),YDISP       SET DISPOSITION
         AGO  .A2DIS#0
.A2DIS#  ANOP
         MVI   S99TUPAR,$&#DISP1    SET DISPOSITION
.A2DIS#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2DISP2 ANOP
         AIF (T'&#DISP2 EQ 'O').A2DISP3
*--------------------------------------------------------------------*
*   ADYN-DATASET DISPOSITION ON NORMAL COMPLETION                    *
         AIF ('&#CHDISP' EQ 'NO').A2DCM12
         AIF ('&#CHDISP' EQ 'YES').A2DCM11
         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN CATALOGUED.'
         AGO   .A2DCM12  ANOP
.A2DCM11  ANOP
         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN FORCED TO ''DELETE'''
.A2DCM12  ANOP
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALNDISP         GET KEY FOR NORMAL DISPOSITION
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2NDS#
         MVC   S99TUPAR(1),YNDISP   SET DISPOSITION
         AGO .A2NDS#0
.A2NDS#  ANOP
         MVI   S99TUPAR,$&#DISP2    SET DISPOSITION
.A2NDS#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2DISP3 ANOP
         AIF (T'&#DISP3 EQ 'O').A2RECFM
*--------------------------------------------------------------------*
*   ADYN-DATASET DISPOSITION ON ABNORMAL COMPLETION                  *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALCDISP         GET KEY FOR CONDITIONAL DISPOSITION
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2CDS#
         MVC   S99TUPAR(1),YCDISP   SET DISPOSITION
         AGO .A2CDS#0
.A2CDS#  ANOP
         MVI   S99TUPAR,$&#DISP3    SET DISPOSITION
.A2CDS#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2RECFM ANOP
         AIF (T'&#RECFM EQ 'O').A2DSORG
*--------------------------------------------------------------------*
*   ADYN-RECORD FORMAT                                               *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALRECFM         GET KEY FOR RECORD FORMAT
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2RFM#
         MVC   S99TUPAR(1),YRECFM   SET RECORD FORMAT
         AGO .A2RFM#0
.A2RFM#  ANOP
         AIF ('&#RECFM' EQ 'FBA').CON#130
         AIF ('&#RECFM' EQ 'VBA').CON#130
         AIF ('&#RECFM' EQ 'VB').CON#130
         AIF ('&#RECFM' EQ 'FB').CON#130
         AIF ('&#RECFM' EQ 'U').CON#130
         AIF ('&#RECFM' EQ 'F').CON#130
         AIF ('&#RECFM' EQ 'V').CON#130
         MNOTE 12,'RECFM OF "&#RECFM" NOT ALLOWED FOR.'
         AGO .MEXIT
.CON#130 ANOP
         MVI   S99TUPAR,$&RECFM     SET RECFM
.A2RFM#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2DSORG ANOP
         AIF (T'&#DSORG EQ 'O').A2LRECL
*--------------------------------------------------------------------*
*   ADYN-DATASET ORGANISATION                                        *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALDSORG         GET KEY FOR DSORG
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#7,2                PARAMETER LENGTH OF 2
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2DSO#
         MVC   S99TUPAR(2),YDSORG   SET DATASET ORGANISATION
         AGO .A2DSO#0
.A2DSO#  ANOP
         AIF ('&#DSORG' EQ 'PO').CON#135
         AIF ('&#DSORG' EQ 'PS').CON#135
         AIF ('&#DSORG' EQ 'DA').CON#135
         AIF ('&#DSORG' EQ 'POU').CON#135
         AIF ('&#DSORG' EQ 'PSU').CON#135
         AIF ('&#DSORG' EQ 'DAU').CON#135
         MNOTE 12,'DSORG OF "&#DSORG" NOT ALLOWED FOR.'
         AGO .MEXIT
.CON#135 ANOP
         XC    S99TUPAR+1(1),S99TUPAR+1 INIT LOW ORDER BYTE OF ORG
         MVI   S99TUPAR,$&#DSORG    SET DATASET ORG
.A2DSO#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2CONVA ANOP
.A2LRECL ANOP
         AIF (T'&#LRECL EQ 'O').A2BLKSZ
*--------------------------------------------------------------------*
*   ADYN-LOGICAL RECORD LENGTH                                       *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALLRECL         GET KEY FOR LOGICAL RECORD LENGTH
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#7,2                BECAUSE THE LRECL PARM REQUIRES 1
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2LRL#
         MVC   S99TUPAR(2),YLRECL   SET RECORD LENGTH
         AGO .A2LRL#0
.A2LRL#  ANOP
         MVC   S99TUPAR(2),=H'&LRECL' SET RECORD LENGTH
.A2LRL#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2BLKSZ ANOP
         AIF (T'&#BLKSZ EQ 'O').A2UNIT
*--------------------------------------------------------------------*
*   ADYN-BLOCK SIZE                                                  *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALBLKSZ         GET KEY FOR BLOCK SIZE
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#7,2                BECAUSE THE LRECL PARM REQUIRES 1
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
         AIF ('&PARMT'(1,1) EQ 'P').A2BLK#
         MVC   S99TUPAR(2),YBLKSIZE SET BLOCK SIZE
         AGO .A2BLK#0
.A2BLK#  ANOP
         MVC   S99TUPAR(2),=H'&BLKSIZE' SET BLOCK SIZE
.A2BLK#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.*--------------------------------------------------------------------*
.A2UNIT  ANOP
         AIF (T'&#UNIT EQ 'O').A2AUNIT
*--------------------------------------------------------------------*
*   ADYN-DEVICE UNIT                                                 *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALUNIT          GET KEY FOR UNIT
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2UNI#
         LA    &#7,8                LENGTH OF VOLOSER
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99UNIT         MOVE VOLUME
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH
         AR    &#6,&#7              POINT PAST DSNAME
         AGO   .A2AUNIT
.A2UNI#  ANOP
&PL      SETA  K'&#UNIT
         LA    &#7,&PL              LENGTH OF VOLOSER
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PL),=C'&#UNIT' MOVE UNIT
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,&PL.(&#6)        POINT PAST DSNAME
.A2AUNIT ANOP
         AIF (T'&#SPACET EQ 'O').A2PRIM
*--------------------------------------------------------------------*
*   ADYN-SPACE ALLOCATION INIT (CYL, TRK or block_size)              *
*--------------------------------------------------------------------*
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS      POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR          POINT 3ND TXT UNIT PTR TO 2ND T.U.
         AIF ('&PARMT'(1,1) EQ 'P').A2ATY#
         MVI   S99TUKEY,X'00'        CLEAR HIGH ORDER BYTE
         MVC   S99TUKEY+1(1),YSPACET MOVE ALLOCATION TYPE TO KEY
         AGO   .A2ATY#0
.A2ATY#  ANOP
         AIF ('&#SPACET' EQ 'TRK').A2TRK
         AIF ('&#SPACET' EQ 'CYL').A2CYL
         MNOTE 12,'ALLOCATION TYPE OF "&#SPACET" NOT ALLOWED FOR.'
         AGO .MEXIT
.A2TRK   ANOP
&#DISP   SETC  'DALTRK'
         AGO .CON#140
.A2CYL   ANOP
&#DISP   SETC  'DALCYL'
.CON#140 ANOP
         LA    &#7,&#DISP           GET KEY FOR ALLOCATION UNITS
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
.A2ATY#0 ANOP
         LA    &#7,0                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
*   ADYN-AR    &#6,&#7              POINT PAST PARAMETER
.A2PRIM  ANOP
         AIF (T'&#PRIM EQ 'O').A2SECND
*--------------------------------------------------------------------*
*   ADYN-PRIMARY ALLOCATION                                          *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALPRIME         GET KEY FOR RECORD PRIMARY ALLOC
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#7,3                BECAUSE THE LRECL PARM REQUIRES 1
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
         MVI   S99TUPAR,X'00'       CLEAR HIGH ORDER BYTE
         AIF ('&PARMT'(1,1) EQ 'P').A2PRI#
         MVC   S99TUPAR+1(2),YPRIM  MOVE PRIMARY ALLOCATION
         AGO .A2PRI#0
.A2PRI#  ANOP
         MVC   S99TUPAR+1(2),=H'&#PRIM' SET PRIMARY ALLOCATION
.A2PRI#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2SECND ANOP
         AIF (T'&#SECOND EQ 'O').A2DIRB
*--------------------------------------------------------------------*
*   ADYN-SECONDARY ALLOCATION                                        *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALSECND         GET KEY FOR RECORD PRIMARY ALLOC
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#7,3                BECAUSE THE LRECL PARM REQUIRES 1
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
         MVI   S99TUPAR,X'00'       CLEAR HIGH ORDER BYTE
         AIF ('&PARMT'(1,1) EQ 'P').A2SEC#
         MVC   S99TUPAR+1(2),YSECOND  MOVE SECONDARY ALLOCATION
         AGO .A2SEC#0
.A2SEC#  ANOP
         MVC   S99TUPAR+1(2),=H'&#SECOND' SET SECONDARY ALLOCATION
.A2SEC#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2DIRB  ANOP
         AIF (T'&#DIRB EQ 'O').A2PERMA
*--------------------------------------------------------------------*
*   ADYN-DIRECTORY BLOCKS                                            *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALDIR           GET KEY FOR RECORD PRIMARY ALLOC
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#7,3                BECAUSE THE LRECL PARM REQUIRES 1
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
         MVI   S99TUPAR,X'00'       CLEAR HIGH ORDER BYTE
         AIF ('&PARMT'(1,1) EQ 'P').A2DIR#
         MVC   S99TUPAR+1(2),YDIRB  MOVE DIRECTORY BLOCKS
         AGO .A2DIR#0
.A2DIR#  ANOP
         MVC   S99TUPAR+1(2),=H'&#DIRB' MOVE DIRECTORY BLOCKS
.A2DIR#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2PERMA ANOP
         AIF ('&#PERMA'(1,1) EQ 'N').A2BUFNO
*--------------------------------------------------------------------*
*   ADYN-PERMANENT ALLOCATED ATTRIBUTE                               *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALPERMA         GET KEY PERMANENT ATTRIBUTE
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,0                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2BUFNO ANOP
         AIF (T'&#BUFNO EQ 'O').A2UCLOS
*--------------------------------------------------------------------*
*   ADYN-NO OF BUFFERS PER DCB                                       *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALBUFNO         GET KEY FOR NUMBER OF BUFFERS
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#7,1                BECAUSE THE LRECL PARM REQUIRES 1
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
         AIF ('&PARMT'(1,1) EQ 'P').A2BUF#
         MVC   S99TUPAR(2),YBUFNO   MOVE NUMBER OF BUFFERS
         AGO .A2BUF#0
.A2BUF#  ANOP
         MVC   S99TUPAR(1),=C'&BUFNO' MOVE NUMBER OF BUFFERS
.A2BUF#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2UCLOS ANOP
         AIF ('&UCLOSE' NE 'YES').A2RLSE
         AIF ('&#ACTION'(1,1) NE 'A').A2RLSE
*--------------------------------------------------------------------*
*   ADYN-UNALLOCATE DATASET ON CLOSING                               *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALCLOSE         GET KEY FOR UNALLOCATE ON CLOSE
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,0                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2RLSE  ANOP
         AIF ('&#RLSE' NE 'R').A2CLASS
*--------------------------------------------------------------------*
*   ADYN-RELEASE ANY UNUSED SPACE AFTRE CLOSING                      *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALRLSE          GET KEY FOR RELEASE
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,0                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2CLASS ANOP
         AIF (T'&#CLASS EQ 'O').A2WRTR
*--------------------------------------------------------------------*
*   ADYN-ALLOCATE SYSOUT CLASS                                       *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALSYSOU         GET KEY FOR CLASS
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
         AIF ('&PARMT'(1,1) EQ 'P').A2CLA#
         MVC   S99TUPAR(1),YCLASS   MOVE SYSOUT CLASS
         AGO .A2CLA#0
.A2CLA#  ANOP
         MVC   S99TUPAR(1),=C'&#CLASS' SET SYSOUT CLASS
.A2CLA#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2WRTR  ANOP
         AIF (T'&#WRTR EQ 'O').A3ALOC
*--------------------------------------------------------------------*
*   ADYN-ALLOCATE SYSOUT WRITER-NAME/INTERNAL-READER                 *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALSPGNM         GET KEY FOR UNIT
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2PRG#
         LA    &#7,8                LENGTH OF VOLOSER
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99WRTR         MOVE WRITER-NAME/INTRDR
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH
         AR    &#6,&#7              POINT PAST WRITER-NAME
         AGO   .A3ALOC
.A2PRG#  ANOP
&PL      SETA  K'&#WRTR
         LA    &#7,&PL              LENGTH OF VOLOSER
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PL),=C'&#WRTR' MOVE WRITER-NAME/INTRDR
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,&PL.(&#6)        POINT PAST WRITER-NAME
.*--------------------------------------------------------------------*
.A3ALOC  ANOP
         AIF ('&#ACTION'(1,1) EQ 'U').UNAL2
         AIF ('&#ACTION'(1,1) EQ 'F').UNAL2
         AGO   .A$END
.*--------------------------------------------------------------------*
.UNAL2   ANOP
*--------------------------------------------------------------------*
*   ADYN-UNALLOCATE/FREE DATASET                                     *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DUNUNALC         GET KEY FOR RETURN DSNAME
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,0                BECAUSE THE UNALLOC KEY REQUIRES 0
         STH   &#7,S99TUNUM           PARM, STORE 0 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   REMOVE IN-USE ATTRIBUTE                                          *
.*--------------------------------------------------------------------*
.*        LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
.*        ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
.*        LA    &#7,DUNREMOV         GET KEY FOR REMOVE IN-USE
.*        STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
.*        LA    &#7,0                BECAUSE THE UNALLOC KEY REQUIRES 0
.*        STH   &#7,S99TUNUM           PARM, STORE 0 IN NUMBER FIELD
.*--------------------------------------------------------------------*
         OI    S99TUPTR,S99TUPLN    TURN ON HIGH ORDER BIT FOR LAST PTR
         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
         AGO   .A$END
.*--------------------------------------------------------------------*
.INFO2   ANOP
&@DSNR   SETC  ''
         AIF ('&PARMT'(1,1) EQ 'D').SETDSNR
         AIF (T'&#DSN EQ 'O').A$END
.SETDSNR ANOP
*--------------------------------------------------------------------*
*   ADYN-INFO/ RETURN DSNAME FROM DDNAME                             *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DINRTDSN         GET KEY FOR RETURN DSNAME
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         LA    &#7,44               MAXIMUM LENGTH OF DATASET
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#1,S99TUPAR         LOAD DDNAME VARIABLE ADDRESS
         AIF ('&PARMT'(1,1) EQ 'P').A2DSNI
         ST    &#1,YDSN             SAVE FOR LATER USE
&@DSNR   SETC  'YDSN'
         AGO   .A$END
.A2DSNI  ANOP
         ST    &#1,&DSN             SAVE FOR LATER USE
&@DSNR   SETC  '&DSN'
         AGO   .A$END
.*--------------------------------------------------------------------*
.CONC2   ANOP
         AGO .CON#0E0
.DEAL2   ANOP
         AGO .CON#0E0
.*--------------------------------------------------------------------*
.A$END   ANOP
         OI    S99TUPTR,S99TUPLN    TURN ON HIGH ORDER BIT FOR LAST PTR
         AIF ('&PARMT'(1,1) EQ 'P').A$NOEXO
         AIF (&ADYNFL1).A$NOEXO
&ADYNFL1 SETB  1
         B     BYPASEX              BYPASS EX STATEMENTS
*---------------------------------------------------------------------*
*  CODE TO BE 'EX'D DURING PARAMETER BUILDING FROM PARAMETERS PASSED  *
*  AS DATA IN FIELD VARIABLES.                                        *
*---------------------------------------------------------------------*
MV99DSN  MVC   S99TUPAR(0),YDSN     MOVE DSNAME
MV99DDN  MVC   S99TUPAR(0),YDD      MOVE DDNAME
MV99DDCN MVC   S99TUPAR+10(0),YDDC  MOVE DDNAME TO CONCATENATE
MV99MEMB MVC   S99TUPAR(0),YMEMBER  MOVE MEMBER
MV99VOLS MVC   S99TUPAR(0),YVOLSER  MOVE VOLSER
MV99UNIT MVC   S99TUPAR(0),YUNIT    MOVE DVICE TYPE
MV99WRTR MVC   S99TUPAR(0),YWRITER  MOVE SYSOUT WRITER-NAME/INTRDR
MV99DEST MVC   S99TUPAR(0),YDEST    MOVE PRINTER-ID DESTINATION
MV99FCB  MVC   S99TUPAR(0),YFCB     MOVE FCB
*---------------------------------------------------------------------*
BYPASEX  DS    0H
.A$NOEXO ANOP
         AIF   ('&REGR' EQ 'NO').NORSAV2 BYPASS IF REGS NOT 2 BE REST'D
         LM    R0,R14,&REGSAVR      RESTORE USED REGISTERS
.NORSAV2 ANOP
         AIF (T'&BASE EQ 'O').UCALLIT
*---------------------------------------------------------------------*
*  IMPLICIT INVOCATION OF THE DYNALLOC COMMAND IF 'BASE' SUPPLIED     *
*---------------------------------------------------------------------*
         AIF ('&#DDR'(1,1) NE 'Y').A$DDR0 IF DD RETURN REQ'D BYPASS
&VARNM   SETC  '&#DD'               SET VARIABLE NAME
         AIF ('&#DD'(1,1) NE '(').NDDVAR3
&PL      SETA  K'&#DD
&VARNM   SETC  '&#DD'(2,&PL-2)      SET VARIABLE NAME
.NDDVAR3 ANOP
         MVC   &REGSAVR.(4),&VARNM  MOVE DDNAME VARIABLE ADDRESS SAVED
.A$DDR0  ANOP
         AIF ('&#DSNR'(1,1) NE 'Y').NODSNR
&VARNM   SETC  '&#DSN'              SET VARIABLE NAME
         AIF (T'&#DSN NE 'O').NDSNOM3
&VARNM   SETC  '&@DSNR'             SET VARIABLE NAME
         AGO   .NDSNVA3
.NDSNOM3 ANOP
         AIF ('&#DSN'(1,1) NE '(').NDSNVA3
&PL      SETA  K'&#DSN
&VARNM   SETC  '&#DSN'(2,&PL-2)     SET VARIABLE NAME
.NDSNVA3 ANOP
         MVC   &REGSAVR.(4),&VARNM  MOVE DSNAME VARIABLE ADDRESS SAVED
.NODSNR  ANOP
         AIF ('&#VOLR'(1,1) NE 'Y').NOVOLR
&VARNM   SETC  '&#VOLSER'           SET VARIABLE NAME
         AIF (T'&#VOLSER NE 'O').NVOLOM3
&VARNM   SETC  '&@VOLR'             SET VARIABLE NAME
         AGO   .NVOLVA3
.NVOLOM3 ANOP
         AIF ('&#VOLSER'(1,1) NE '(').NVOLVA3
&PL      SETA  K'&#VOLSER
&VARNM   SETC  '&#VOLSER'(2,&PL-2)  SET VARIABLE NAME
.NVOLVA3 ANOP
         MVC   &REGSAVR.+4(4),&VARNM  MOVE VOL VARIABLE ADDRESS SAVED
.NOVOLR  ANOP
         AIF ('&PDUMP'(1,1) NE 'Y').DYNALOC
         AIF (T'&PDUMPX EQ 'O').PDUMPWX
         PDUMP (&BASE),MSG='JUST ABOUT TO INVOKE DYNALLOC "&#ACTION". NO
               O EXIT AVAILABLE.'
         AGO   .DYNALOC
.PDUMPWX ANOP
         PDUMP (&BASE),MSG='JUST ABOUT TO INVOKE DYNALLOC "&#ACTION". EX
               XIT AVAILABLE  THRU "QUIT" COMMAND.'
.DYNALOC ANOP
         LR    &#1,&BASE            REQ BLK PTR ADR IN &#1 FOR DYNALLOC
         DYNALLOC
         AIF (T'&ERROR EQ 'O').TSTDELT
         LTR   R15,R15              Q. ZERO RETURN CODE FROM ADYN
         BNZ   &ERROR                  N. GO TO ERROR ROUTINE
.TSTDELT ANOP
         AIF ('&#VOLR'(1,1) NE 'Y').A$DSR1
         L     R14,&REGSAVR+4       LOAD VOLSER VARIABLE ADDRESS SAVED
         AIF (T'&#VOLSER NE 'O').NVOLOM4
&VARNM   SETC  '&@VOLR'             SET VARIABLE NAME
         AGO   .NVOLVA4 ANOP
.NVOLOM4 ANOP
         AIF ('&#VOLSER'(1,1) NE '(').NVOLVA4
&PL      SETA  K'&#VOLSER
&VARNM   SETC  '&#VOLSER'(2,&PL-2)  SET VARIABLE NAME
.NVOLVA4 ANOP
         MVC   &VARNM.(6),0(R14)    MOVE VOLSER RETURNED BY DYNALLOC
.A$DSR1  ANOP
         AIF ('&#DSNR'(1,1) NE 'Y').A$DDR1
         L     R14,&REGSAVR         LOAD DSNAME VARIABLE ADDRESS SAVED
         AIF (T'&#DSN NE 'O').NDSNOM4
&VARNM   SETC  '&@DSNR'             SET VARIABLE NAME
         AGO   .NDSNVA4
.NDSNOM4 ANOP
         AIF ('&#DSN'(1,1) NE '(').NDSNVA4
&PL      SETA  K'&#DSN
&VARNM   SETC  '&#DSN'(2,&PL-2)     SET VARIABLE NAME
.NDSNVA4 ANOP
         MVC   &VARNM.(44),0(R14)   MOVE DSNAME RETURNED BY DYNALLOC
         OC    &VARNM.(44),=CL44' ' CONVERT TRAILING X'00' TO SPACES
*                                          /¦\ <------
         AGO   .A$DDR2
.A$DDR1  ANOP
         AIF ('&#DDR'(1,1) NE 'Y').A$DDR2 IF DD RETURN REQ'D BYPASS
         L     R14,&REGSAVR         LOAD DDNAME VARIABLE ADDRESS SAVED
         AIF ('&#DD'(1,1) NE '(').NDDVAR4
&PL      SETA  K'&#DD
&VARNM   SETC  '&#DD'(2,&PL-2)      SET VARIABLE NAME
.NDDVAR4 ANOP
         MVC   &VARNM.(8),0(R14)    MOVE DDNAME RETURNED BY DYNALLOC
.A$DDR2  ANOP
         AIF ('&#ACTION'(1,1) NE 'F').BPALOC2 BYPASS IF NOT FREE
         AIF ('&ACTION'(1,1) NE 'A').BPALOC2  BYPASS IF NOT ALLOCATE
&#REUSEF SETC 'Y'
         AGO .A$RT                             GO ALLOCATE IT
.BPALOC2 ANOP
         AIF ('&#ACTION' NE 'ALLOC').UCALLIT
         AIF ('&ACTION'(1,3) NE 'DEL').UCALLIT
.*--------------------------------------------------------------------*
.*    CONTROL GETS HERE IF ACTION WAS DELETE AND WE HAVE JUST ALLOC'D *
.*    WITH DISP=(OLD,DELETE,DELETE)                                   *
.*--------------------------------------------------------------------*
         LTR   R15,R15              Q. ZERO RETURN CODE FROM ADYN
         BNZ   &DELLAB                 N. BYPASS FREEING FOR DELETE
&#ACTION SETC 'FREE'                INIT PARMS FOR 'FREE'
&#DISP1  SETC ''
&#DISP2  SETC ''
&#DISP3  SETC ''
*---------------------------------------------------------------------*
*  FOR 'DELETE', RETURNING TO UNALLOCATE DATASET JUST ALLOCATED WITH: *
*     DISP=(OLD,DELETE,DELETE)                                        *
*---------------------------------------------------------------------*
         AGO .NOTDELT               GO SET UP FREE COMMANDS
.UCALLIT ANOP
.*--------------------------------------------------------------------*
.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *
.*--------------------------------------------------------------------*
         AIF   ('&MF' EQ 'E').NOREGSV BYPASS SAVE REGISTERS
         AIF   (&REGDFLG).NOREGSV EXIT IF ALREADY PROCESSED
&REGDFLG SETB  1
         B     &DELLAB       BRANCH AROUND REG SAVE AREA
&REGSAVR DS    16F           GLOBAL REGISTER SAVE AREA
.NOREGSV ANOP
&DELLAB  DS    0H
*------------ END OF ADYN PARAMETER LIST BUILD -----------------------*
         AGO .MEXIT
*---------------------------------------------------------------------*
.MFELIST ANOP
.*--------------------------------------------------------------------*
.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *
.*--------------------------------------------------------------------*
         AIF   (&REGDFLG).MEXIT  EXIT IF ALREADY PROCESSED
&REGDFLG SETB  1
&REGSAVR DS    16F           GLOBAL REGISTER SAVE AREA
         AGO .MEXIT
.*-----------------CONSTANT MAPPING OF ADYN VARIABLES-----------------*
.DATAMAP ANOP
         AIF  ('&DATA'(1,3) EQ 'IBM').DATAIBM
.*-------------------------------------------------------------------*
.*     INITIALISE VARIABLES IF NOT PASSED                            *
.*-------------------------------------------------------------------*
.A2UNITD ANOP
         AIF (T'&#UNIT NE 'O').A2UNI11   PROCESS IF NOT OMITTED
         AIF ('&#DISP1' NE 'NEW').A2UNI11 BYPASS IF OMMITED AND NOT NEW
&#UNIT   SETC 'SYSALLDA'                 SET UNIT AS 'SYSALLDA'
*        DEFAULT DEVICE UNIT OF 'SYSALLDA' ASSIGNED                   *
.A2UNI11 ANOP
.CDDNAME ANOP
&#DDR    SETC '&DDR'
         AIF ('&#DDR'(1,1) EQ 'Y').A$DDR3 IF DD RETURN REQ'D BLANK DD
         AIF (T'&#DD NE 'O').CDDCNAM
.A$DDR3  ANOP
&#DD     SETC ' '
.CDDCNAM ANOP
         AIF (T'&#DDC NE 'O').CDSNAME
&#DDC    SETC ' '
.CDSNAME ANOP
         AIF (T'&#DSN NE 'O').CMEMBER
&#DSN    SETC ' '
.CMEMBER ANOP
         AIF (T'&#MEMBER NE 'O').CVOLSER
&#MEMBER SETC ' '
.CVOLSER ANOP
         AIF (T'&#VOLSER NE 'O').CDEST
&#VOLSER SETC ' '
.CDEST   ANOP
         AIF (T'&#DEST NE 'O').CFCB
&#DEST   SETC ' '
.CFCB    ANOP
         AIF (T'&#FCB NE 'O').CCOPYS
&#FCB    SETC ' '
.CCOPYS  ANOP
         AIF (T'&#COPIES NE 'O').CDISP
&#COPIES SETC '0'
.CDISP   ANOP
         AIF (T'&#DISP1 NE 'O').CDISPV
&#DISP1  SETC '00'
         AGO .CNDISP
.CDISPV  ANOP
         AIF ('&#DISP1' EQ 'NEW').C2NEW
         AIF ('&#DISP1' EQ 'OLD').C2OLD
         AIF ('&#DISP1' EQ 'MOD').C2MOD
         AIF ('&#DISP1' EQ 'SHR').C2SHR
         AGO .CNDISP
.C2SHR   ANOP
&#DISP1  SETC  '08'
         AGO .CNDISP
.C2NEW   ANOP
&#DISP1  SETC  '04'
         AGO .CNDISP
.C2MOD   ANOP
&#DISP1  SETC  '02'
         AGO .CNDISP
.C2OLD   ANOP
&#DISP1  SETC  '01'
.CNDISP  ANOP
         AIF (T'&#DISP2 NE 'O').CNDISPV
&#DISP2  SETC '00'
         AGO .CCDISP
.CNDISPV ANOP
         AIF ('&#DISP2' EQ 'UNCATLG').C2UNC1
         AIF ('&#DISP2' EQ 'CATLG').C2CAT1
         AIF ('&#DISP2' EQ 'DELETE').C2DEL1
         AIF ('&#DISP2' EQ 'KEEP').C2KEP1
         AGO .CCDISP
.C2KEP1  ANOP
&#DISP2  SETC  '08'
         AGO .CCDISP
.C2UNC1  ANOP
&#DISP2  SETC  '01'
         AGO .CCDISP
.C2CAT1  ANOP
&#DISP2  SETC  '02'
         AGO .CCDISP
.C2DEL1  ANOP
&#DISP2  SETC  '04'
.CCDISP  ANOP
         AIF (T'&#DISP3 NE 'O').CCDISPV
&#DISP3  SETC '00'
.CCDISPV ANOP
         AIF ('&#DISP3' EQ 'UNCATLG').C2UNC2
         AIF ('&#DISP3' EQ 'CATLG').C2CAT2
         AIF ('&#DISP3' EQ 'DELETE').C2DEL2
         AIF ('&#DISP3' EQ 'KEEP').C2KEP2
         AGO .CSPACET
.C2KEP2  ANOP
&#DISP3  SETC  '08'
         AGO .CSPACET
.C2UNC2  ANOP
&#DISP3  SETC  '01'
         AGO .CSPACET
.C2CAT2  ANOP
&#DISP3  SETC  '02'
         AGO .CSPACET
.C2DEL2  ANOP
&#DISP3  SETC  '04'
.CSPACET ANOP
         AIF (T'&#SPACET NE 'O').CSPACEV
&#SPACET SETC '00'
         AGO .CPRIM
.CSPACEV ANOP
         AIF ('&#SPACET' NE 'CYL').C2TRK1
&#SPACET SETC  '08'
         AGO .CPRIM
.C2TRK1  ANOP
&#SPACET SETC  '07'
.CPRIM   ANOP
         AIF (T'&#PRIM NE 'O').CSECOND
&#PRIM   SETC '0'
.CSECOND ANOP
         AIF (T'&#SECOND NE 'O').CDIRB
&#SECOND SETC '0'
.CDIRB   ANOP
         AIF (T'&#DIRB NE 'O').CBUFNO
&#DIRB   SETC '0'
.CBUFNO  ANOP
         AIF (T'&#BUFNO NE 'O').CUNIT
&#BUFNO  SETC '0'
.CUNIT   ANOP
         AIF (T'&#UNIT NE 'O').CRECFM
&#UNIT   SETC ' '
.CRECFM  ANOP
         AIF (T'&#RECFM NE 'O').CRECFMV
&#RECFM  SETC '00'
         AGO .CDSORG
.CRECFMV ANOP
         AIF ('&#RECFM' EQ 'FBA').C2FBA
         AIF ('&#RECFM' EQ 'VBA').C2VBA
         AIF ('&#RECFM' EQ 'VB').C2VB
         AIF ('&#RECFM' EQ 'FB').C2FB
         AIF ('&#RECFM' EQ 'U').C2U
         AIF ('&#RECFM' EQ 'F').C2F
         AIF ('&#RECFM' EQ 'V').C2V
         AGO .CDSORG
.C2FBA   ANOP
&#RECFM  SETC  '94'
         AGO .CDSORG
.C2VBA   ANOP
&#RECFM  SETC  '54'
         AGO .CDSORG
.C2FB    ANOP
&#RECFM  SETC  '90'
         AGO .CDSORG
.C2VB    ANOP
&#RECFM  SETC  '50'
         AGO .CDSORG
.C2U     ANOP
&#RECFM  SETC  'C0'
         AGO .CDSORG
.C2F     ANOP
&#RECFM  SETC  '80'
         AGO .CDSORG
.C2V     ANOP
&#RECFM  SETC  '40'
.CDSORG  ANOP
         AIF (T'&#DSORG NE 'O').CDSORGV
&#DSORG  SETC '0000'
         AGO .CLRECL
.CDSORGV ANOP
         AIF ('&#DSORG' EQ 'PO').C2OPO
         AIF ('&#DSORG' EQ 'PS').C2OPS
         AIF ('&#DSORG' EQ 'DA').C2ODA
         AIF ('&#DSORG' EQ 'POU').C2OPOU
         AIF ('&#DSORG' EQ 'PSU').C2OPSU
         AIF ('&#DSORG' EQ 'DAU').C2ODAU
         AGO .CLRECL
.C2OPOU  ANOP
&#DSORG  SETC  '0300'
         AGO .CLRECL
.C2OPSU  ANOP
&#DSORG  SETC  '4100'
         AGO .CLRECL
.C2ODAU  ANOP
&#DSORG  SETC  '2100'
         AGO .CLRECL
.C2OPO   ANOP
&#DSORG  SETC  '0200'
         AGO .CLRECL
.C2OPS   ANOP
&#DSORG  SETC  '4000'
         AGO .CLRECL
.C2ODA   ANOP
&#DSORG  SETC  '2000'
.CLRECL  ANOP
         AIF (T'&#LRECL NE 'O').CBLKSZ
&#LRECL  SETC '0'
.CBLKSZ  ANOP
         AIF (T'&#BLKSZ NE 'O').CCLASS
&#BLKSZ  SETC '0'
.CCLASS  ANOP
         AIF (T'&#CLASS NE 'O').CWRTR
&#CLASS  SETC ' '
.CWRTR   ANOP
         AIF (T'&#WRTR NE 'O').CRLSE
&#WRTR   SETC ' '
.CRLSE   ANOP
         AIF (T'&#RLSE NE 'O').D$0END
&#RLSE   SETC 'N'
         AGO .D$0END
.D$0END  ANOP
.*-------------------------------------------------------------------*
         AIF  ('&DATA'(1,3) EQ 'VAR').DATAVAR
         AIF  ('&DATA'(1,3) EQ 'CON').DATACON
         MNOTE 12,'INVALID 'DATA' PARAMETER OF "&DATA".'
         AGO .MEXIT
.DATACON ANOP
*--------------------------------------------------------------------*
* CONSTANT MAP OF 'ADYN' DATA.                                       *
*--------------------------------------------------------------------*
         DC    CL8'&#DD'     DD NAME
         DC    CL8'&#DDC'    DD NAME TO CONCATENATE
         DC    CL44'&#DSN'   DSN NAME OR '*' FOR TERMINAL
         DC    CL8'&#MEMBER' MEMBER NAME OR GDG GENERATION
         DC    CL6'&#VOLSER' DISK DATASET RESIDES ON
         DC    XL1'&#DISP1'  1ST. BYTE OF STATUS (NEW,OLD,MOD,SHR)
.*-------------------------------------------------------------------*
         AIF ('&#CHDISP' EQ 'NO').A2DCM22
         AIF ('&#CHDISP' EQ 'YES').A2DCM21
         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN CATALOGUED.'
         AGO   .A2DCM22  ANOP
.A2DCM21  ANOP
         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN FORCED TO ''DELETE'''
.A2DCM22  ANOP
.*-------------------------------------------------------------------*
         DC    XL1'&#DISP2'  1ST. BYTE OF NORMAL DISPOSITION
*                              CATLG,UNCATLG,DELETE,KEEP
         DC    XL1'&#DISP3'  1ST. BYTE OF CONDITIONALODISPOSITION
*                              SAME VALUES AS FOR 'ANDISP'
         DC    XL1'&#SPACET' SPACE TYPE TRK OR CYL (BLOCK NOT ALLOWED)
         DC    H'&#PRIM'     PRIMARY SPACE ALLOCATION
         DC    H'&#SECOND'   SECONDARY SPACE ALLOCATION
         DC    H'&#DIRB'     DIRECTORY BLOCKS
         DC    CL1'&#BUFNO'  NUMBER OF BUFFERS
         DC    CL8'&#UNIT'   DEVICE UNIT TYPE (SYSALLDA,SYSDA,ETC...)
         DC    XL1'&#RECFM'  RECFM (RECORD FORMAT VALID EQUATES BELOW)
         DC    XL2'&#DSORG'  DATASET ORGANISATION (VALID EQUATES BELOW)
         DC    H'&#LRECL'    RECORD LENGTH
         DC    H'&#BLKSZ'    BLOCK SIZE
         DC    CL1'&#CLASS'  SYSOUT CLASS (ANY VALID CLASS)
         DC    CL8'&#WRTR'   SYSOUT WRITER-NAME/INTRDR
         DC    CL8'&#DEST'   DESTINATION PRINTER-ID
         DC    CL4'&#FCB'    FCB
         DC    AL1(&#COPIES) NUMBER OF COPIES
         DC    CL1'&#RLSE'   FLAG TO INDICATE RELEASE OF UNUSED SPACE
*                              SET TO NON X'00'
         AIF   ('&REGSMC1' NE 'ADYN').ECONST1
         DS    16F           GLOBAL REGISTER SAVE AREA
&REGSMC1 SETC  '    '
.ECONST1 ANOP
*--------------------END OF ADYN DSECT FORMAT-------------------------*
         AGO   .MEXIT
.*-------------------END OF CONSTANT FORMAT---------------------------*
.*
.*
.*--------------------DSECT MAPPING OF ADYN VARIABLES-----------------*
.DATAVAR ANOP
.*&NAME    DSECT
*--------------------------------------------------------------------*
* DSECT USED TO MOVE VARIABLE DYNAMIC ALLOCATION DATASET DETAILS.    *
*--------------------------------------------------------------------*
YDD      DC    CL8'&#DD'     DD NAME
YDDC     DC    CL8'&#DDC'    DD NAME TO CONCATENATE
YDSN     DC    CL44'&#DSN'   DSN NAME OR '*' FOR TERMINAL
YMEMBER  DC    CL8'&#MEMBER' MEMBER NAME OR GDG GENERATION (-N,0,+N)
YVOLSER  DC    CL6'&#VOLSER' DISK DATASET RESIDES ON
*
YDISP    DC    XL1'&#DISP1'  1ST. BYTE OF STATUS (NEW,OLD,MOD,SHR)
YSHR     EQU   X'08'          - SHARE DISPOSITION (STATUS)
YNEW     EQU   X'04'          - NEW   DISPOSITION (STATUS)
YMOD     EQU   X'02'          - MOD   DISPOSITION (STATUS)
YOLD     EQU   X'01'          - OLD   DISPOSITION (STATUS)
*
.*-------------------------------------------------------------------*
         AIF ('&#CHDISP' EQ 'NO').A2DCM32
         AIF ('&#CHDISP' EQ 'YES').A2DCM31
         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN CATALOGUED.'
         AGO   .A2DCM32  ANOP
.A2DCM31  ANOP
         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN FORCED TO ''DELETE'''
.A2DCM32  ANOP
.*-------------------------------------------------------------------*
YNDISP   DC    XL1'&#DISP2'  1ST. BYTE OF NORMAL DISPOSITION
*                              CATLG,UNCATLG,DELETE,KEEP
YUNCAT   EQU   X'01'           - UNCATALOG
YCATLG   EQU   X'02'           - CATALOG
YDELETE  EQU   X'04'           - DELETE
YKEEP    EQU   X'08'           - KEEP
YCDISP   DC    XL1'&#DISP3'  1ST. BYTE OF CONDITIONALODISPOSITION
*                              SAME VALUES AS FOR 'ANDISP'
YSPACET  DC    XL1'&#SPACET' SPACE TYPE TRK OR CYL (BLOCK NOT ALLOWED)
YTRK     EQU   X'07'           - TRACK MASK
YCYL     EQU   X'08'           - CYLINDER MASK
*
YPRIM    DC    H'&#PRIM'     PRIMARY SPACE ALLOCATION
YSECOND  DC    H'&#SECOND'   SECONDARY SPACE ALLOCATION
YDIRB    DC    H'&#DIRB'     DIRECTORY BLOCKS
YBUFNO   DC    CL1'&#BUFNO'  NUMBER OF BUFFERS
YUNIT    DC    CL8'&#UNIT'   DEVICE UNIT TYPE (SYSALLDA,SYSDA,ETC...)
*
YRECFM   DC    XL1'&#RECFM'  RECFM (RECORD FORMAT VALID EQUATES BELOW)
YFBA     EQU   X'94'           - FBA
YVBA     EQU   X'54'           - VBA
YFB      EQU   X'90'           - FB
YVB      EQU   X'50'           - VB
YU       EQU   X'C0'           - U
YF       EQU   X'80'           - F
YV       EQU   X'40'           - V
*
YDSORG   DC    XL2'&#DSORG'  DATASET ORGANISATION (VALID EQUATES BELOW)
YDSOPOU  EQU   X'0300'         - POU
YDSOPSU  EQU   X'4100'         - PSU
YDSODAU  EQU   X'2100'         - DAU
YDSOPO   EQU   X'0200'         - PO
YDSOPS   EQU   X'4000'         - PS
YDSODA   EQU   X'2000'         - DA
*
YLRECL   DC    H'&#LRECL'    RECORD LENGTH
YBLKSIZE DC    H'&#BLKSZ'    BLOCK SIZE
YCLASS   DC    CL1'&#CLASS'  SYSOUT CLASS (ANY VALID CLASS)
YWRITER DC     CL8'&#WRTR'   SYSOUT WRITER-MAME/INTRDR
YDEST    DC    CL8'&#DEST'   DESTINATION PRINTER-ID
YFCB     DC    CL4'&#FCB'    FCB
YCOPIES  DC    AL1(&#COPIES) NUMBER OF COPIES
YRLSE    DC    CL1'&#RLSE'   FLAG TO INDICATE RELEASE OF UNUSED SPACE
*                              SET TO NON X'00'
         AIF   ('&REGSMC2' NE 'ADYN').EDSECT1
&REGSMC2 SETC  '    '
         AIF   (&REGDFLG).EDSECT1 EXIT IF ALREADY PROCESSED
&REGDFLG SETB  1
&REGSAVR DS    16F           GLOBAL REGISTER SAVE AREA
.EDSECT1 ANOP
*--------------------END OF ADYN DSECT FORMAT-------------------------*
         AGO .MEXIT
.DATAIBM ANOP
*---------------------------------------------------------------------*
*     IBM REQUIRED MACROS                                             *
*---------------------------------------------------------------------*
         IEFZB4D0
         IEFZB4D2
         AGO .MEXIT
*---------------------------------------------------------------------*
.CON#0E0 MNOTE 12,'"&#ACTION" NOT DEFINED YET.'
.MEXIT   ANOP
         MEXIT
         MEND
*---------------------------------------------------------------------*
*------- Macro 12. PDUMPR --------------------------------------------*
         MACRO
&NAME    PDUMPR &ADDR,          Address to display                     X
               &REGP=YES,       Ser REGP= parameter                    X
               &TYPE=VAR,       CONstant/VARiable type for MF=L        X
               &ISPI=YES,       Invoke ISPEXEC INIT=Y explicitly       X
               &X2CE=NO,        HEXCHMAC MF=E required ?               X
               &X2CL=NO,        HEXCHMAC MF=L required ?               X
               &REXX=SHOWSTOR,  REXX EXEC                              X
               &HELP=NO,        Help in expansion                      X
               &MSG=,           Message area for GC009                 X
               &LIST=NO,        List expansion                         X
               &DISPLAY=ASIS,   Process SHOWSTOR display               X
               &DISP=ASIS,      Alias for DISPLAY                      X
               &QUIT=,          R15 set to 'QUIT' branch               X
               &MF=             EXEC/LIST format
.*
         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP   Go full help
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'PDUMPR' parameter and  *
* it's use, pass parameter 'HELP=Yes'.                                *
*---------------------------------------------------------------------*
         AGO .A$HELPE                         Bypass full help
.A$HELP  ANOP
*---------------------------------------------------------------------*
*                                                                     *
* This facility is used to display memory from within a program using *
* the SHOWSTOR memory mapper written in REXX, using ISPF services.    *
*                                                                     *
* All parameters are keyword parameters except the first which is the *
* only positional parameter for the address to be displayed. The      *
* format is as follows:                                               *
*                                                                     *
*   PDUMPR addr,kw1=..,kw2=..,kwn=...                                 *
*                                                                     *
* The following are permissable parameters:                           *
*   addr          - Address to be displayed. May be any relocatable   *
*                   address, a register in parentheses or a displace- *
*                   memt and register in parentheses.                 *
*   ISPI=Yes/No   o Invoke the ISPEXEC macro with the INIT option in  *
*                   it. Default is Yes. Set to No if you explicitly   *
*                   use the ISPEXEC macro in your program.            *
*   X2CE=Yes/No   o Invoke the HEXCHMAC macro MF=E format. This is    *
*                   only used if the HEXCHMAC with MF=E is explicitly *
*                   used in the same program and will prevent         *
*                   duplicate variable names. If PDUMPR is invoked    *
*                   with MF=E then this feature is automatically      *
*                   enabled. The default is NO.                       *
*   X2CL=Yes/No   o Invoke the HEXCHMAC macro MF=L format. Similar to *
*                   X2CE parameter. Default is No.                    *
*   MSG='....'    - MEssage to display on entering SHOWSTOR. Literal  *
*      =label()     padded/truncated to 256 bytes or a label where    *
*                   256 bytes or length of variable subscripted is    *
*                   moved, eg. MSG=MSGSRCE(80).                       *
*   QUIT=label    - Label of the instruction where control is to be   *
*                   passed if SHOWSTOR is terminated using the 'QUIT' *
*                   feature. Refer to SHOWSTOR documentation for      *
*                   further details.                                  *
*   REGP=Yes/No   - Set REGP= parameter on entry. this will enable    *
*                   the use of the /REGS* command. (Refer to SHOWSTOR *
*                   documentation.) Default is Yes and you would be   *
*                   a fool to suppress this handy feature.            *
*   REXX=SHOWSTOR - REXX EXEC to be executed from the macro. This     *
*                   should not be changed.                            *
*   TYPE=Var/Con  - Constatnt/Variable type for MF=L format. VAR is   *
*                   the default.                                      *
*   DISPLAY=Yes/No/Asis                                               *
*                 - Activate or bypass SHOWSTOR displays. Used to     *
*                   control SHOWSTOR displays during looping. Any     *
*                   value other than 'N' or 'Y' will default to 'A'.  *
*                   Use this parameter without an Address to set the  *
*                   condition without a display.                      *
*   HELP=No/Yes   - Help in expansion of this macro.                  *
*   LIST=No/Yes   - List expansion.                                   *
*   MF=           - Exec/List format.                                 *
*                                                                     *
* To use this feature you will also need access to macros ISPEXEC and *
* HEXCHMAC.                                                           *
* Parameters with an 'o' seperator are parameters whose values are    *
* dependant on the requirements of the ISPEXEC or HEXCHMAC macros.    *
* Refer to the actual macros for further details.                     *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
* Known GOTCHAs:                                                      *
* - This facility cannot be invoked from an authorised program        *
*   because of ISPF's limitations with authorised programs.           *
* - Because the macros used are designed in subroutine format, ensure *
*   that the first physical occurance of this macro (or it's related  *
*   counterparts of ISPEXEC and HEXCHMAC) are the ones actually       *
*   executed first to ensure all variables/settings are initialised.  *
*   This can be a problem in programs with a lot of branching logic.  *
*   To safeguard against this, invoke the macro as early as possible  *
*   in your program without an "addr" parameter to force              *
*   initialisation of all 3 macros (PDUMPR, ISPEXEC and HEXCHMAC).    *
* - Take care when explicitly using ISPEXEC and HEXCHMAC macros       *
*   outside this macro. You may need to fine tune the ISPI= and the   *
*   X2CE= and X2CL= parameters to prevent duplicate names.            *
*                                                                     *
*---------------------------------------------------------------------*
.*
.A$HELPE ANOP
.*
         AIF   ('&LIST'(1,1) EQ 'Y').A$XXX
         PUSH  PRINT
         PRINT NOGEN
.A$XXX   ANOP
.*
         LCLC  &SMXVAR,&L,&#DISP,&#ADR
         GBLB  &SMXFST1,&SMXEXE1,&SMXLST1
         GBLC  &SMXFXD
         GBLB  &XC1ST
.*
.*--------------------------------------------------------------------*
.* Evaluate and set Display requirements                              *
.*--------------------------------------------------------------------*
         AIF   (T'&DISPLAY EQ 'O').A$001 Test for 'alias'
&#DISP   SETC  '&DISPLAY'                Set to parameter
         AGO   .A$002                    GoAround alternate process
.A$001   ANOP
         AIF   (T'&DISP EQ 'O').A$002    Bypass
&#DISP   SETC  '&DISP'                   Set to 'alias' parameter
.A$002   ANOP
.*
.*--------------------------------------------------------------------*
.* Evaluate address if passed as (reg)....                            *
.*--------------------------------------------------------------------*
&#ADR    SETC  '&ADDR'                Set to parameter
         AIF   (T'&#ADR EQ 'O').A$003 Bypass processing
         AIF   ('&#ADR'(1,1) NE '(').A$003 Bypass if 1st char not '('
&#ADR    SETC  '0&#ADR.'              Set to Offset zero
.A$003   ANOP
.*--------------------------------------------------------------------*
.*
         AIF   (&SMXFST1).A$010
.*--------------------------------------------------------------------*
.* Global variables on initial invocation
.*--------------------------------------------------------------------*
&SMXFST1 SETB  1                       Set 1st. time thru  flag
&SMXFXD  SETC  'SMX'.'&SYSNDX'         Set fixed index value
&#DISP   SETC  'YES'                   Force display 1st. time thru
.A$010   ANOP
.*--------------------------------------------------------------------*
.* Local variables on each invocation
.*--------------------------------------------------------------------*
&SMXVAR  SETC  'SMX'.'&SYSNDX'         Set variable index value
.*--------------------------------------------------------------------*
.* Global variables on each invocation
.*--------------------------------------------------------------------*
&SMXLB0  SETC  '&SMXVAR'.'0'           Set variables (Full word branch)
&SMXLB1  SETC  '&SMXFXD'.'1'           Set variables
&SMXLB2  SETC  '&SMXVAR'.'2'           Set variables
&SMXLB3  SETC  '&SMXVAR'.'3'           Set variables
&SMXLB4  SETC  '&SMXFXD'.'4'           Set variables
&SMXLB5  SETC  '&SMXFXD'.'5'           Set variables
&SMXLB6  SETC  '&SMXVAR'.'6'           SPARE - NOT USED
&SMXLB7  SETC  '&SMXVAR'.'Z'           Set variable (PDUMPR terminator)
&SMXLB8  SETC  '&SMXVAR'.'X'           Set variable (PDUMPR start)
&SMXWK1  SETC  '&SMXFXD'.'8'           Set variables
&SMXWK2  SETC  '&SMXFXD'.'9'           Set variables
&SMXWK3  SETC  '&SMXFXD'.'A'           Set variables
&SMXWK4  SETC  '&SMXFXD'.'B'           Set variables
&SMXWK5  SETC  '&SMXFXD'.'C'           Set variables
&SMXWK6  SETC  '&SMXFXD'.'D'           Set variables
&SMXWK7  SETC  '&SMXFXD'.'E'           Set variables
&SMXWK8  SETC  '&SMXFXD'.'F'           Set variables
&SMXWK9  SETC  '&SMXFXD'.'G'           Set variables
&SMXWK10 SETC  '&SMXFXD'.'H'           Set variables
&SMXWK11 SETC  '&SMXFXD'.'I'           Set variables
&SMXWK12 SETC  '&SMXFXD'.'J'           Set variables
.*--------------------------------------------------------------------*
&L       SETC  '&LIST'
         AIF   (T'&NAME EQ 'O').A$YYY  Bypass if label passed
&SMXLB0  SETC  '&NAME'                 Use invocation name fro label
.A$YYY   ANOP
.*
         AIF   ('&MF' EQ 'L').A$200    Process list form of macro
.*
&SMXLB8  DS    0H                      START ANCHOR
         B     &SMXLB0                 ENSURE FULL WORD BRANCH
         AIF   (T'&MF EQ 'O').A$200    Process list form of macro
.A$020   ANOP
&SMXLB0  DS    0F                      ENSURE FULL WORD ALLIGNMENT
.*
         AIF   (&SMXEXE1).A$050        Bypass if not 1st. MF=E
&SMXEXE1 SETB  1
         STM   R0,R15,&SMXWK9          SAVE ALL REGISTERS
         AIF   ('&ISPI'(1,1) NE 'Y').A$022A Bypass if ISPEXEC not req
         AIF   ('&LIST'(1,1) EQ 'Y').A$021  Process list form yes
         ISPEXEC INIT=Y,MF=E           INITIALISE ISPF ENVIRONMENT
         AGO   .A$022
.A$021   ANOP
         ISPEXEC INIT=Y,MF=E,LIST=&L   INITIALISE ISPF ENVIRONMENT
.A$022   ANOP
         LM    R0,R15,&SMXWK9          RESTORE REGISTERS
.A$022A  ANOP
         B     &SMXLB2                 BRANCH AROUND CODE
&SMXLB1  DS    0H
         ST    R1,&SMXWK8              STORE FOR CONVERSION
         AIF   ('&X2CE'(1,1) EQ 'Y').X2C012 Process MF=E format
         AIF   ('&MF' EQ 'E').X2C011   Process MF=E format
.X2C010  ANOP
         HEXCHMAC &SMXWK8,&SMXWK2,4,LIST=&L HEX TO CHARACTER
         AGO   .X2C012                 Bypass MF=E format
.X2C011  ANOP
         HEXCHMAC &SMXWK8,&SMXWK2,4,LIST=&L,MF=E HEX TO CHARACTER
.X2C012  ANOP
.*
         CLI   &SMXWK7,C'Y'            Q. SETUP REGISTERS
         BE    &SMXLB4                    Y. GO DO IT
         MVI   &SMXWK3,C' '            BLANK FILL (RIPPLE)
         MVC   &SMXWK3.+1(L'&SMXWK3.+L'&SMXWK4.-1),&SMXWK3
         B     &SMXLB5                 BYPASS SETUP REGISTER
&SMXLB4  DS    0H
         MVC   &SMXWK3.(06),=C' REGP=' SET REGISTER
         LA    R1,&SMXWK9              LOAD ADDRESS REGISTER SAVE AREA
         ST    R1,&SMXWK8              STORE FOR CONVERSION
         AIF   ('&X2CE'(1,1) EQ 'Y').X2C022 Process MF=E format
         AIF   ('&MF' EQ 'E').X2C021   Process MF=E format
.X2C020  ANOP
         HEXCHMAC &SMXWK8,&SMXWK4,4,LIST=&L HEX TO CHARACTER
         AGO   .X2C022                 Bypass MF=E format
.X2C021  ANOP
         HEXCHMAC &SMXWK8,&SMXWK4,4,LIST=&L,MF=E HEX TO CHARACTER
.X2C022  ANOP
*---------------------------------------------------------------------*
&SMXLB5  DS    0H
         AIF   ('&LIST'(1,1) EQ 'Y').A$041 Process list form Yes
         ISPEXEC &SMXWK1,&SMXWK6       CALL 'SHOSTOR' REXX EXEC
         AGO   .A$042
.A$041   ANOP
         ISPEXEC &SMXWK1,&SMXWK6.,LIST=&L CALL 'SHOSTOR' REXX EXEC
.A$042   ANOP
         L     R14,&SMXWK8.+4          LOAD RETURN ADDRESS
         BR    R14                     RETURN TO CALLER
&SMXLB2  DS    0H
.*
.A$050   ANOP
.*--------------------------------------------------------------------*
         AIF   (T'&#DISP EQ 'O').A$058 Do not set, just test
         AIF   ('&#DISP'(1,1) EQ 'Y').A$057 Use passed value
         AIF   ('&#DISP'(1,1) NE 'N').A$058 Bypass value setting
.A$057   ANOP
&#DISP   SETC  '&#DISP'(1,1)          Use 1st. byte
         MVI   &SMXWK11,C'&#DISP'      SET DISPLAY REQUIREMENT
         AIF   (T'&#ADR EQ 'O').SETEXT Continue if have an address
         AIF   ('&#DISP'(1,1) EQ 'Y').A$059 Bypass test if set 2 'Y'
         AIF   ('&#DISP'(1,1) EQ 'N').A$090 Bypass all if 'N' req'd
.A$058   ANOP
         AIF   (T'&#ADR EQ 'O').SETEXT Continue if have an address
         CLI   &SMXWK11,C'N'           Q. DISPLAY REQUIRED
         BE    &SMXLB7                    N. BYPASS
.A$059   ANOP
.*--------------------------------------------------------------------*
*---------------------------------------------------------------------*
* Set up PDUMPR start and end addresses for potential anchor points.  *
*---------------------------------------------------------------------*
         MVC   &SMXWK12.(21),=C'RR=......../........ '
         LA    R1,&SMXLB8              START PDUMPR ADDRESS
         ST    R1,&SMXWK8              STORE FOR CONVERSION
         AIF   ('&X2CE'(1,1) EQ 'Y').X2C032 Process MF=E format
         AIF   ('&MF' EQ 'E').X2C031   Process MF=E format
.X2C030  ANOP
         HEXCHMAC &SMXWK8,&SMXWK12+3,4,LIST=&L HEX TO CHARACTER
         AGO   .X2C032                 Bypass MF=E format
.X2C031  ANOP
         HEXCHMAC &SMXWK8,&SMXWK12+3,4,LIST=&L,MF=E HEX TO CHARACTER
.X2C032  ANOP
.*--------------------------------------------------------------------*
         LA    R1,&SMXLB7              END PDUMPR ADDRESS
         ST    R1,&SMXWK8              STORE FOR CONVERSION
         AIF   ('&X2CE'(1,1) EQ 'Y').X2C042 Process MF=E format
         AIF   ('&MF' EQ 'E').X2C041   Process MF=E format
.X2C040  ANOP
         HEXCHMAC &SMXWK8,&SMXWK12+12,4,LIST=&L HEX TO CHARACTER
         AGO   .X2C042                 Bypass MF=E format
.X2C041  ANOP
         HEXCHMAC &SMXWK8,&SMXWK12+12,4,LIST=&L,MF=E HEX TO CHARACTER
.X2C042  ANOP
.*--------------------------------------------------------------------*
         STM   R0,R15,&SMXWK9          SAVE ALL REGISTERS
         LA    R0,&SMXLB3              LOAD RETURN ADDRESS
         ST    R0,&SMXWK8.+4           SAVE RETURN ADDRESS
         AIF   ('&REGP'(1,1) EQ 'N').A$060  Bypass if REGP=No
         MVI   &SMXWK7,C'Y'            SETUP REGISTERS REQUEST
         AGO   .A$065                  Branch around negative set
.A$060   ANOP
         MVI   &SMXWK7,C'N'            REGISTERS NOT REQUIRED
.A$065   ANOP
         AIF   (T'&MSG EQ 'O').A$075  Bypass if deliberate omission
         MVI   &SMXWK10,C' '           INITIALISE OUTPUT MESSAGE USING
         MVC   &SMXWK10.+1(L'&SMXWK10.-1),&SMXWK10 ..RIPPLE MOVE
&MSGNW   SETC  '&MSG'                 Set message to move from label
         AIF   ('&MSG'(1,1) EQ '''').A$072 Go process literal message
.*--------------------------------------------------------------------*
.* Establish length of literal and move length                        *
.*--------------------------------------------------------------------*
         LCLA  &APOST
&MSGL    SETA  K'&MSG                     Set length of message
         AIF   ('&MSG'(&MSGL,1) EQ ')').A$071
         MVC   &SMXWK10,&MSGNW         MOVE MESSAGE TO OUTPUT
         AGO   .A$075                       Leave process
.A$071   ANOP
&MSGL1   SETA  &MSGL-1
&APOST   SETA  0
.LOOP1   ANOP
         AIF   (&MSGL1 EQ  0).E4
         AIF   ('&MSG'(&MSGL1,1) EQ ',').LOOP1E
         AIF   ('&MSG'(&MSGL1,1) EQ '(').LOOP2E
&MSGL1   SETA  &MSGL1-1
         AGO   .LOOP1
.LOOP1E  ANOP
&APOST   SETA  &MSGL1
&MSGL1   SETA  &MSGL1-1
.LOOP2   ANOP
         AIF   (&MSGL1 EQ 0).E4
         AIF   ('&MSG'(&MSGL1,1) EQ '(').LOOP2E
&MSGL1   SETA  &MSGL1-1
         AGO   .LOOP2
.LOOP2E  ANOP
         AIF   (&APOST EQ 0).VARMSG
&MSGL3   SETC  '&MSG'(&MSGL1+1,&APOST-(&MSGL1+1))
&MSGNW   SETC  '&MSG'(1,&MSGL1).'&MSG'(&APOST+1,&MSGL-&APOST)
         AGO   .MSGDTOK
.VARMSG  ANOP
&MSGL3   SETC  '&MSG'(&MSGL1+1,&MSGL-(&MSGL1+1))
&MSGNW   SETC  '&MSG'(1,&MSGL1-1)
.MSGDTOK ANOP
         MVC   &SMXWK10.(&MSGL3),&MSGNW MOVE MESSAGE TO OUTPUT
         AGO   .A$075                       Leave process
.*-------------------------------------------------------------------*
.* Establish length of variable and move length                      *
.*-------------------------------------------------------------------*
.A$072   ANOP
         LCLC  &CHAR,&AMPER
         LCLA  &LC,&QC,&AC
&AMPER   SETC  '&&'
&MSGL    SETA  K'&MSG                       Loop counter (message len)
&QC      SETA  0                            Quotes counter
&AC      SETA  0                            Ampersand counter
&CP      SETA  0                            Character pointer
.LOOP3   ANOP
&CP      SETA  &CP+1                        Iincrement char pointer
&CHAR    SETC  '&MSG'(&CP,1)                Set character value
.TQUOT   ANOP
         AIF   ('&CHAR' NE '''').TAMPR      Bypass if char not "'"
&QC      SETA  &QC+1                        Bump quotes counter
         AGO   .NXTCH                       Get nest char
.TAMPR   ANOP
         AIF   ('&CHAR.&CHAR' NE '&AMPER').NXTCH Bypass if not "&"
&AC      SETA  &AC+1                        Bump amper counter
.NXTCH   ANOP
         AIF   (&CP LT &MSGL).LOOP3         Loop till end
&MSGL    SETA  &MSGL-2-(((&QC-2)/2)+(&AC/2)) Get actual length
         MVC   &SMXWK10.(&MSGL),=CL(&MSGL)&MSG
.A$075   ANOP
.*--------------------------------------------------------------------*
         LA    R1,&#ADR                LOAD ADDRESS OF ADDRESS
         B     &SMXLB1                 BRANCH TO COMMON CODE
&SMXLB3  DS    0H
         LM    R0,R15,&SMXWK9          RESTORE ALL REGISTERS
         AIF   (T'&QUIT EQ 'O').A$080  Bypass if no QUIT
         C     R15,=C'QUIT'            Q. QUIT REQUESTED
         BE    &QUIT                      Y. GO TO LABEL
.A$080   ANOP
         C     R15,=C'DOFF'            Q. DISPLAY OFF REQUESTED
         BNE   &SMXLB7                    N. BYPASS
         MVI   &SMXWK11,C'N'           SET DISPLAY OFF
&SMXLB7  DS    0H                      EXIT ANCHOR
.A$090   ANOP
         AGO   .MEXIT                  Exit macro
.*
.A$200   ANOP
         AIF   (T'&MF NE 'O').A$205    Bypass if MF is set
         AIF   (&SMXEXE1).A$020        Return if previously executed
.A$205   ANOP
         AIF   ('&TYPE'(1,1) NE 'C').A$210  Bypass if not constant
&SMXWK1  SETC  ''
&SMXWK2  SETC  ''
&SMXWK3  SETC  ''
&SMXWK4  SETC  ''
&SMXWK5  SETC  ''
&SMXWK6  SETC  ''
&SMXWK7  SETC  ''
&SMXWK8  SETC  ''
&SMXWK9  SETC  ''
&SMXWK10 SETC  ''
&SMXWK11 SETC  ''
&SMXWK12 SETC  ''
.*
.A$210   ANOP
.*
         AIF   ('&ISPI'(1,1) NE 'Y').A$224 Bypass if ISPEXEC not req'd
         AIF   ('&LIST'(1,1) EQ 'Y').A$221 Process list form Yes
         ISPEXEC  MF=L,INIT=Y,TYPE=&TYPE INIT ISPF ENVIRONMENT
         AGO   .A$224
.A$221   ANOP
         AIF   ('&ISPI'(1,1) EQ 'N').A$224 Bypass if INIT=No
.A$222   ANOP
         ISPEXEC  MF=L,INIT=Y,LIST=&L,TYPE=&TYPE INIT ISPF ENVIRONMENT
.A$224   ANOP
         DS    0F                      WORD ALLIGN
&SMXWK8  DS    2F                      WORK AREA
&SMXWK9  DS    16F                     REGISTER SAVE AREA FRO MACRO
&SMXWK1  DC    C'SELECT CMD(%SHOWSTOR ' WHAT WE WANT TO EXECUTE
&SMXWK2  DC    C'        '             ADDRESS WE WANT TO DISPLAY
&SMXWK3  DC    C' REGP='               REGISTER EQUATE LITERAL
&SMXWK4  DC    C'        '             ADDRESS WE WANT TO DISPLAY
         DC    C' '                    FILLER
&SMXWK12 DC    CL21'RR=......../........ ' Start and finish
.*-------------------------------------------------------------------*
.*   NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE    *
.*-------------------------------------------------------------------*
.* Modify the length of the next field to ensure the value (length)  *
.* of variable &SMXWK6 does not exceed 256 as &SMXWK1 and &SMXWK6    *
.* are used in a MVC instruction.                                    *
.*-------------------------------------------------------------------*
&SMXWK10 DC    CL190' '                MESSAGE AREA
.*-------------------------------------------------------------------*
&SMXWK5  DC    C')'                    WHAT WE WANT TO EXECUTE
         AIF   ('&TYPE'(1,1) EQ 'C').A$223  Bypass if constant
&SMXWK6  EQU   *-&SMXWK1               ISPF COMMAND LENGTH
.A$223   ANOP
&SMXWK7  DC    C'Y'                    REGISTER GENERATE FLAG
&SMXWK11 DC    C'Y'                    DISPLAY ON
         AIF   ('&X2CL'(1,1) NE 'Y').X2C090 BYpass MF=L for HEXCHMAC
         HEXCHMAC MF=L
.X2C090  ANOP
         AIF   (T'&MF EQ 'O').A$020    Return
         AGO   .MEXIT                  Exit
.*--------------------------------------------------------------------*
.E0      MNOTE 12,'No Errors at this stage'
         AGO   .MEXIT
.*--------------------------------------------------------------------*
.SETEXT  ANOP
&SMXLB7  DS    0H                      EXIT ANCHOR
.MEXIT   ANOP
         AIF   ('&LIST'(1,1) EQ 'Y').MEXIT9
         POP   PRINT
.MEXIT9  ANOP
         MEXIT
         MEND
*---------------------------------------------------------------------*
*#####################################################################*
*        PRINT ON
INDEXUFM KICKOFF (R11,R12),AMODE=31,LIST=NO
         ST    R11,DDATA               SAVE BASE REG IN DIALOG DATAREA
                                                                SPACE 1
*---------------------------------------------------------------------*
* INITIALISE ISPF ENVIRONMENT AND ESTABLISH ADDRESABILITY TO          *
* VARIABLES.                                                          *
*---------------------------------------------------------------------*
         ISPEXEC  INIT=Y,MF=E          INITIALISE ISPF ENVIRONMENT
         ISPVDEFX LIST=YE,FORMAT=CHAR,MF=E,                            +
               INM=(GC009),ANM=GC009,LEN=79
         ISPVDEFX LIST=NO,FORMAT=CHAR,MF=E,                            +
               INM=(DSNAME),ANM=YDSN,LEN=44
         ISPVDEFX LIST=NO,FORMAT=CHAR,MF=E,                            +
               INM=(VOLUME),ANM=YVOLSER,LEN=6
         ISPVDEFX LIST=NO,FORMAT=CHAR,MF=E,                            +
               INM=(UNIT),ANM=YUNIT,LEN=8
         ISPVDEFX LIST=NO,FORMAT=CHAR,MF=E,                            +
               INM=(INDEXUB),ANM=INDEXUB,LEN=1
                                                                SPACE 1
         ISPEXEC 'VGET (DSNAME VOLUME) SHARED'
         ISPEXEC 'VPUT (INDEXUB) SHARED'
                                                                SPACE 1
         MVC   DSNAME,YDSN             MOVE DSNAME
         LA    R8,DSNAME+43            POINT TO LAST CHARACTER POSIT
         LA    R9,44                   MAX LENGTH (LOOP COUNTER)
DSNLOOP1 DS    0H
         CLI   0(R8),C' '              Q. CHARACTER A SPACE
         BNE   DSNLOP1E                   N. EXIT LOOP
         BCTR  R8,0                    POINT TO PREVIOUS CHARACTER
         BCT   R9,DSNLOOP1             LOOP TILL NO MORE SPACES
DSNLOP1E DS    0H
         ST    R9,DSLEN                STORE DATASET LENGTH
                                                                SPACE 1
*
* CALCULATE TIME FOR UNIQUE DDNAME                             *
*
         TIME  DEC                     GET TIME  => IN R0
         ST    R0,AREA1                SAVE TIME IN FULLWORD
         HEXCHMAC AREA1,AREA1+10,3,MF=E CONVERT HEX TO CHARACTER
         MVC   YDD+2(2),AREA1+10       INSERT HH
         MVC   YDD+4(2),AREA1+12       INSERT MM
         MVC   YDD+6(2),AREA1+14       INSERT SS
         MVC   YDD(2),=C'$I'           SET DD PREFIX
                                                                SPACE 1
         LA    R1,DISKFIND             ADDRESS OF DCB
         USING IHADCB,R1               ESTABLISH ADDRESABILITY
         MVC   DCBDDNAM,YDD            MOVE DDNAME TO DCB
         DROP  R1                      RELINQUISH ADDRESABILITY
         LA    R1,DISKIN               ADDRESS OF DCB
         USING IHADCB,R1               ESTABLISH ADDRESABILITY
         MVC   DCBDDNAM,YDD            MOVE DDNAME TO DCB
         DROP  R1                      RELINQUISH ADDRESABILITY
         LA    R1,DISKOUT              ADDRESS OF DCB
         USING IHADCB,R1               ESTABLISH ADDRESABILITY
         MVC   DCBDDNAM,YDD            MOVE DDNAME TO DCB
         DROP  R1                      RELINQUISH ADDRESABILITY
                                                                SPACE 1
*---------------------------------------------------------------------*
* DYNAMICALLY ALLOCATE DATASET, OPEN AS DSORG=PO AND FIND MEMBER      *
* '$$$INDEX'. IF NOT FOUND SET INDEXEX (INDEX EXISTS) FLAG TO 'N'.    *
*---------------------------------------------------------------------*
         MVC   GC009(36),=C'         - ERROR ALLOCATING DATASET.'
         LA    R10,SVC99WRK            ADDRESABILITY TO SVC99 WORK AREA
                                                                SPACE 1
         ADYN  ACTION=ALLOC,                                           +
               DD=$I$TIME,                                             +
               DSN=(DSNAME),                                           +
               DISP=SHR,                                               +
               VOLSER=VOLUME,                                          +
               UNIT=SYSALLDA,                                          +
               REUSE=YES,                                              +
               UCLOSE=YES,                                             +
               BASE=R10,                                               +
               PARMT=DATA,                                             +
               MF=E
                                                                SPACE 1
         LTR   R15,R15                 Q. DATASET ALLOCATED
         BNZ   EXITPR12                   N. EXIT PROGRAM
         MVC   DISK(DISKL),DISKFIND    MOVE TO GENERIC DISK AREA
         OPEN  (DISK,INPUT)            OPEN DATASET TO FIND INDEX
         LTR   R15,R15                 Q. ZERO RETURN CODE FROM OPEN
         BNZ   OPENERR1                   N. PROCESS ERROR
         FIND  DISK,MEMBER,D           Q. FIND MEMBER
         LTR   R15,R15                 Q. MEMBER FOUND
         BZ    CLOSFIND                   Y. CLOSE FILE
         MVI   INDEXEX,C'N'            SET INDEX DOESN'T EXIST FLAG
CLOSFIND DS    0H
         CLOSE (DISK)                  CLOSE DATASET
                                                                SPACE 1
*---------------------------------------------------------------------*
* DYNAMICALLY ALLOCATE DATASET, AND MEMBER '$$$INDEX' AS DSORG=PS AND *
* OPEN FOR INPUT IF THE INDEX EXISTS.                                 *
*---------------------------------------------------------------------*
         MVC   GC009(37),=C'         - ERROR ALLOCATING ''$INDEX''.'
                                                                SPACE 1
         ADYN  ACTION=ALLOC,                                           +
               DD=$I$TIME,                                             +
               DSN=(DSNAME),                                           +
               MEMBER=$$$INDEX,                                        +
               VOLSER=VOLUME,                                          +
               UNIT=SYSALLDA,                                          +
               BASE=R10,                                               +
               PARMT=DATA,                                             +
               MF=E
                                                                SPACE 1
         LTR   R15,R15                 Q. DATASET ALLOCATED
         BNZ   EXITPR12                   N. EXIT PROGRAM
                                                                SPACE 1
OPEN     DS    0H
         MVC   DISK(DISKL),DISKIN      MOVE TO GENERIC DISK AREA
         CLI   INDEXEX,C'Y'            Q. INDEX EXISTS
         BNE   EDIRECI                    N. BYPASS OPEN
         OPEN  (DISK,INPUT)
         LTR   R15,R15                 Q. ZERO RETURN CODE FROM OPEN
         BZ    EDIRECI                    Y. BYPASS
OPENERR1 DS    0H
         MVC   GC009(23),=C'ERROR OPENING ''$INDEX''.'
         B     EXITPR08            EXIT WITH ERROR
                                                                SPACE 1
*---------------------------------------------------------------------*
* INITIALISE EDIT RECOVERY AND CALL EDIF INTERFACE                    *
*---------------------------------------------------------------------*
EDIRECI  DS    0H
         MVI   GC009,C' '              INITIALISE MESSAGE AREA
         MVC   GC009+1(78),GC009       INITIALISE MESSAGE AREA
         L     R9,DSLEN                LOAD DATASET LENGTH
         LA    R8,DSNAME               POINT TO START OF DSNAME
         AR    R8,R9                   POINT TO END OF DSNAME
         MVC   0(10,R8),=C'($$$INDEX)' MOVE INDEX NAME
         LA    R9,10(R9)               ADD MEMBER NAME LENGTH
         ST    R9,DSLEN                STORE DATASET LENGTH
                                                                SPACE 1
         CALL  ISPLINK,(EDIREC,INIT),VL
         LTR   R15,R15                 Q. ZERO RETURN CODE
         BZ    EDIFRN                     Y. GO EDIT W/O RECOVERY
         ISPVDEFX INM=(ZEITDSN),ANM=TDSNAME,FORMAT=CHAR,LEN=44,MF=E
EDIRECQ  DS    0H
         CALL  ISPLINK,(EDIREC,QUERY),VL
         LTR   R15,R15                 Q. NON PENDING RECOVERY
         BZ    EDIFRN                     Y. GO EDIT W/O RECOVERY
         C     R15,RC4                 Q. PENDING RECOVERY
         BE    CKTDSN                     Y. GO CHECK TARGET DSN
         ISPEXEC 'SETMSG MSG(VSAM016)' SET EDIREC SEVERE ERROR MESSAGE
         B     CLOSE                   SEVERE ERROR
CKTDSN   DS    0H
         CLC   DSNAME(54),TDSNAME      Q. SAME DATASET
         BE    SAME                       Y. GO EDIT WITH RECOVERY=YES
         CALL  ISPLINK,(EDIREC,DEFER),VL
         B     EDIRECQ                 CHECK NEXT ENTRY IN RECOV TABLE
SAME     DS    0H
         MVC   GC009(19),=C'''$INDEX'' RECOVERED.'
         ISPEXEC 'SETMSG MSG(GC009)'   DATASET RECOVERED MESSAGE
EDIFRY   DS    0H
         CALL  ISPLINK,(VDEL,ZEITDSN),VL
         CALL  ISPLINK,(EDIF,DSNAME,,RECFM,EDLEN,RADDR,WADDR,,         X
               DDATA,,,,,,YES),VL
         B     CLOSE
EDIFRN   DS    0H
         CALL  ISPLINK,(VDEL,ZEITDSN),VL
         CALL  ISPLINK,(EDIF,DSNAME,PROF,RECFM,EDLEN,RADDR,WADDR,,     X
               DDATA,EDLEN,EXTEPANL),VL
*---------------------------------------------------------------------*
* CLOSE DATASET. IF INDEX JUST CREATED AND EDIT SESSION CANCELLED,    *
* BYPASS CLOSE.                                                       *
*---------------------------------------------------------------------*
CLOSE    DS    0H
         CLI   INDEXEX,C'Y'            Q. INDEX EXISTS/CREATED
         BNE   EXITPR00                   N. BYPASS CLOSE
         CLOSE (DISK)                  CLOSE DATASET
         ADYN  ACTION=FREE,DD=$I$TIME,BASE=R10,PARMT=DATA,MF=E
                                                                SPACE 1
EXITPR00 DS    0H
         XR    R15,R15                 SET RETURN CODE
         B     EXITPROG                GO TO COMMON EXIT
EXITPR08 DS    0H
         LA    R15,8                   SET RETURN CODE
         B     EXITPROG                GO TO COMMON EXIT
EXITPR12 DS    0H
         ST    R0,AREA1                SAVE ADYN RETURN CODE
         HEXCHMAC AREA1,GC009,4,MF=E   CONVERT HEX TO CHARACTER
         LA    R15,12                  SET RETURN CODE
         B     EXITPROG                GO TO COMMON EXIT
EXITPROG DS    0H
         MVI   INDEXUB,C'N'            SET INDEX UNFORMATTED FLAG OFF
         ISPEXEC 'VPUT (INDEXUB) SHARED'
         ISPEXEC 'SETMSG MSG(GC009)'
         RACKOFF RC=(R15),LIST=NO      EXIT PROGRAM
                                                                SPACE 1
*=====================================================================*
*    READ ROUTINE                                                     *
*---------------------------------------------------------------------*
READRTN  DS    0H
         SAVE  (14,12)
         LM    R4,R7,0(R1)
         L     R11,0(R7)               ESTABLISH ADDRESABILITY
         LA    R12,4095(R11)               "          "
         LA    R12,1(R12)                  "          "
         ST    R13,RSAVE+4             STORE EDIF RTN SAVE AREA ADDRESS
         LA    R15,RSAVE
         ST    R15,8(R13)              SAVE NEW SAVE AREA ADDRESS
         LR    R13,R15                 POINT TO NEW SAVE AREA
*---------------------------------------------------------------------*
*        BAL   R14,BELOW               SWITCH TO 24 BIT ADDRESS MODE
         LA    R3,AREA1                LOAD ADDRESS OF INPUT REC AREA
         ST    R3,0(R4)                STORE ADDRESS BACK TO EDIF
         CLI   INDEXEX,C'Y'            Q. INDEX EXISTS/CREATED
         BNE   EODADR                     N. SIMULATE EOF 1ST READ
READNEXT DS    0H
*---------------------------------------------------------------------*
         READ  RDDECB,SF,DISK,AREA1,120
         CHECK RDDECB
         LH    R3,=H'80'               LOAD RECORD LENGTH
         ST    R3,0(R5)                STORE RECORD LENGTH BACK 2 EDIF
         XR    R10,R10                 SET ZERO RETURN CODE
         B     TOEDIFR                 GO BACK TO EDIF
EODADR   DS    0H
         LA    R10,8                   SET RC=8
*---------------------------------------------------------------------*
TOEDIFR  DS    0H
*        BAL   R14,ABOVE               SWITCH TO 31 BIT ADDRESS MODE
         L     R13,RSAVE+4             RESTORE EDIF ROUTINE SAVE AREA @
         L     R14,12(R13)
         LR    R15,R10                 LOAD RETURN CODE
         LM    R0,R12,20(R13)
         BR    R14                     RETURN TO EDIF
                                                                SPACE 1
*=====================================================================*
*    WRITE ROUTINE                                                    *
*---------------------------------------------------------------------*
WRITRTN  DS    0H
         SAVE  (14,12)
         LM    R4,R8,0(R1)
         L     R11,0(R8)               ESTABLISH ADDRESABILITY
         LA    R12,4095(R11)               "          "
         LA    R12,1(R12)                  "          "
         ST    R13,WSAVE+4             STORE EDIF RTN SAVE AREA ADDRESS
         LA    R15,WSAVE
         ST    R15,8(R13)              SAVE NEW SAVE AREA ADDRESS
         LR    R13,R15                 POINT TO NEW SAVE AREA
*---------------------------------------------------------------------*
*        BAL   R14,BELOW               SWITCH TO 24 BIT ADDRESS MODE
         L     R4,0(R4)                R4 HAS ADDRESS OF RECORD
         L     R5,0(R5)                R5 HAS LENGTH  OF RECORD
         L     R6,0(R6)                LOAD FW OF SOURCE AND CHG BITS
         L     R7,0(R7)                LOAD FW BINARY REQUEST CODE
*
         LR    R3,R7
         N     R3,ALLDEL               Q. ALL RECORDS SHOULD BE DELETED
         BNZ   INITLD                     Y. GOTO DELETE PROCESS
         LR    R3,R7
         N     R3,FIRSTW               Q. FIRST ENTRY TO WRITE RTN
         BZ    GOAHEAD                    N. GOAHEAD
INITLD   DS    0H
         CLI   INDEXEX,C'Y'            Q. INDEX EXISTS/CREATED
         BNE   OPEN4WRT                   N. GO OPEN FOR WRITE
         CLOSE (DISK)                  CLOSE DATASET
OPEN4WRT DS    0H
         MVI   INDEXEX,C'Y'            SET INDEX EXISTS/CREATED FLAG
         MVC   DISK(DISKL),DISKOUT     MOVE OUTPUT DEFS
         OPEN  (DISK,OUTPUT)
*---------------------------------------------------------------------*
GOAHEAD  DS    0H
         LR    R3,R7
         N     R3,ALLDEL               Q. ALL RECORDS DELETED
         BNZ   TOEDIFW                    Y. GO BACK TO EDIF
PUTREC01 DS    0H
         STM   R10,R13,BASES#1         STORE MAIN REGISTERS
         LA    R1,TOEDIFW              RETURN ADDRESS
         ST    R1,ESTAERTN             STORE RETURN ADDRESS
         LA    R5,PROCESTA
         ESTAE (5)                     TRAP "ABEND"
         WRITE WRDEC1,SF,DISK,(R4),80  WRITE RECORD
         CHECK WRDEC1                  WAIT FOR WRITE TO COMPLTE
*---------------------------------------------------------------------*
TOEDIFW  DS    0H
         ESTAE 0                       TURN ABEND OFF
         LR    R3,R7
         N     R3,LASTW                Q. LAST ENTRY TO WRITE ROUTINE
         BZ    RETURN                     N. RETURN
SAVEDMSG DS    0H
         MVI   GC009,C''''             MOVE QUOTE TO MESSAGE AREA
         LA    R2,GC009+1              LOAD DESTINATION ADDRESS
         L     R1,DSLEN                LOAD DATASET LENGTH
MOVEDSN  MVC   0(0,R2),DSNAME          MOVE DATASET NAME
         BCTR  R1,0                    LESS 1 FOR 'EX' COMMAND
         EX    R1,MOVEDSN              MOVE DATASET NAME
         AR    R2,R1                   POINT PAST DATASET NAME
         MVI   1(R2),C''''             MOVE DELIMITING QUOTE
         MVC   2(16,R2),=C' HAS BEEN SAVED.'
         ISPEXEC 'SETMSG MSG(GC009)'   DATASET SAVED MESSAGE
*---------------------------------------------------------------------*
RETURN   DS    0H
*        BAL   R14,ABOVE               SWITCH TO 31 BIT ADDRESS MODE
         LA    R15,0                   LOAD RETURN CODE
         L     R13,RSAVE+4             RESTORE EDIF ROUTINE SAVE AREA @
         L     R14,12(R13)
         LM    R0,R12,20(R13)
         BR    R14                     RETURN TO EDIF
*---------------------------------------------------------------------*
                                                                SPACE 1
*=====================================================================*
ABOVE    DS    0H
*                                                                     *
*  --->  CHANGE TO 31 BIT ADDRESSING MODE IN STREAM                   *
*---------------------------------------------------------------------*
         LA    R1,0(R14)           RETURN ADDRESS
         O     R1,=X'80000000'     SET 32ND BIT FOR SWAP TO 31 BIT MODE
         BSM   R0,R1               CHANGE MODE TO 31 BIT
                                                                SPACE 1
*---------------------------------------------------------------------*
BELOW    DS    0H
*                                                                     *
*  --->  CHANGE TO 24 BIT ADDRESSING MODE IN STREAM                   *
*---------------------------------------------------------------------*
         LA    R1,0(R14)           RETURN ADDRESS
         BSM   R0,R1               CHANGE MODE TO 24 BIT
                                                                SPACE 1
*=====================================================================*
* ESTAE ROUTINE TO BE PROCESSED IN CASE OF AN ABEND (NOT USED)        *
*---------------------------------------------------------------------*
PROCESTA DS    0F
         LR    R2,R15                   R1 SET AS BASE
         USING PROCESTA,R2              BASE REGISTER
         LM    R10,R13,12(R15)          RESTORE REGISTERS FROM "BASES1"
         B     MOVEERR                  BYPASS R10 - R13 SAVE AREA
BASES#1  DS    4F
SYSRCODE DS    CL2                      SYSTEM RUTURN CODE SAVE AREA
*---------------------------------------------------------------------*
MOVEERR  DS    0H
         STM   R0,R15,BASES#2           STORE REGISTERS INTO "BASES2"
*---------------------------------------------------------------------*
*                                                                     *
*        CONTROL GETS HERE IF THE AN ABEND OCCURED DURING A MOVE      *
*        FROM SECONDARY TO PRIMARY. USUALLY CAUSED BY AN ADDRESS      *
*        EXCEPTION ERROR.                                             *
*                                                                     *
*---------------------------------------------------------------------*
         LR    R9,R1
         USING SDWA,R9                    SDWA MAPPING
         L     R3,SDWAABCC                LOAD USER/SYSTEM ABEND CODE
         SRL   R3,12                      MOVE OUT USER CODE.
         STCM  R3,3,SYSRCODE              EXTRACT SYSTEM RETURN CODE.
         LM    R0,R15,BASES#2             RESTORE BEFORE 'WTO'
         C     R0,=F'12'                  Q. SDWA CREATED BY RTM2
         BE    MESTAER2                      N. BYPASS PROCESSING
*---------------------------------------------------------------------*
         SETRP FRESDWA=YES,RC=4,RETADDR=MESTAER,DUMP=NO
         BR    R14                       RETURN
MESTAER  DS    0F
         LM    R0,R13,8(R15)             RESTORE REGISTERS
         B     MESTAER2
BASES#2  DS    16F
MESTAER2 DS    0H
*---------------------------------------------------------------------*
         L     R1,ESTAERTN              LOAD ESTAE RETURN ADDRESS
         BR    R1                       CONTINUE
ESTAERTN DS    A                        RETURN ADDRESS FROM ESTAE
*---------------------------------------------------------------------*
                                                                SPACE 1
*=====================================================================*
*    VSAM CONTROL BLOCKS                                              *
*---------------------------------------------------------------------*
DISKFIND DCB   DDNAME=$I$TIME,DSORG=PO,MACRF=(R),EODAD=CLOSFIND
DISKIN   DCB   DDNAME=$I$TIME,DSORG=PS,MACRF=(R),EODAD=EODADR
DISKOUT  DCB   DDNAME=$I$TIME,DSORG=PS,MACRF=(W)
DISK     DCB   DDNAME=$I$TIME,DSORG=PS,MACRF=(R),EODAD=EODADR
DISKL    EQU   *-DISK
                                                                SPACE 1
*=====================================================================*
*    WORK AREAS AND CONSTANTS                                         *
*---------------------------------------------------------------------*
         LTORG
*---------------------------------------------------------------------*
         DS    0D
RSAVE    DC    18F'0'               REGISTER SAVE AREA (READ ROUTINE)
WSAVE    DC    18F'0'               REGISTER SAVE AREA (WRITE ROUTINE)
*
RADDR    DC    AL4(READRTN)         READ ROUTINE ADDRESS
WADDR    DC    AL4(WRITRTN)         WRITE ROUTINE ADDRESS
EDLEN    DC    F'80'
RC4      DC    F'4'
DSLEN    DC    F'54'
DDATA    DC    F'0'
FIRSTW   DC    X'00000001'
LASTW    DC    X'00000002'
ALLDEL   DC    X'00000004'
*
VDEL     DC    CL8'VDELETE'
DSNAME   DC    CL44' '
         DC    CL10' '
VOLUME   DC    CL6' '
ZEITDSN  DC    CL8'ZEITDSN'
TDSNAME  DC    CL54' '
MEMBER   DC    CL8'$$$INDEX'
*
EXTEPANL DC    CL8'EXTEPANL'
EDIREC   DC    CL8'EDIREC'
INIT     DC    CL8'INIT'
QUERY    DC    CL8'QUERY'
DEFER    DC    CL8'DEFER'
*
EDIF     DC    CL8'EDIF'
RECFM    DC    CL2'F'
PROF     DC    CL8'EXTEPROF'
YES      DC    CL8'YES'
*
INDEXEX  DC    C'Y'                  INDEX EXIXTS FLAG
INDEXUB  DC    C'Y'                  INDEX EXIXTS FLAG
GC009    DS    CL79
                                                                SPACE 1
ALLOC1   ADYN  DD=$I$TIME,                                             +
               DSN=DSNAME,                                             +
               MEMBER=$$$INDEX,                                        +
               DISP=SHR,                                               +
               VOLSER=VOLUME,                                          +
               UNIT=SYSALLDA,                                          +
               REUSE=YES,                                              +
               UCLOSE=YES,                                             +
               DATA=VARIABLE,                                          +
               MF=L
                                                                SPACE 1
SVC99WRK DS    CL400
         ISPEXEC  INIT=Y,MF=L
         ISPVDEFX MF=L,LIST=Y
         HEXCHMAC MF=L
*---------------------------------------------------------------------*
         DS    0F
AREA1    DS    CL32760
*---------------------------------------------------------------------*
IHADCB   DCBD    DSORG=PS           DCB MAP
         IHASDWA DSECT=YES          ENTRY : SDWA
         ADYN  DATA=IBM
         END
*=====================================================================*
/*
//*
//*
//LKED     EXEC PGM=IEWL,COND=(5,LT),
//         PARM='MAP,LET,LIST,AMODE=31'
//SYSUT1   DD UNIT=SYSDA,SPACE=(1024,(100,10))
//SYSLMOD  DD DISP=SHR,DSN=AKOS.$LOAD
//SYSPRINT DD SYSOUT=*
//SYSLIB   DD DISP=SHR,DSN=AKOS.$LOAD,
//            DCB=BLKSIZE=27920
//ISPLINK  DD DISP=SHR,DSN=ISP.SISPLOAD
//SYSLIN   DD DISP=(OLD,DELETE),DSN=&LOADSET
//         DD DDNAME=SYSIN
//**************************************************************
//SYSIN    DD *
    INCLUDE ISPLINK(ISPLINK)
    NAME  INDEXUFM(R)
/*
