PRINTOFF TITLE 'CBIPO-SUPPLIED PRINT COMMAND'
*
* NOTE - TO BE ASSEMBLED WITH 'ALIGN' OPTION
*
***********************************************************************
*/* LIB: IPO1.SAMPLIB(PRINTOFF)
*/* GDE: CBIPO MVS CUSTOMIZATION
*/* DOCL THIS IS THE ASSEMBLER SOURCE CODE FOR THE
*/*      SAMPLE MVS CUSTOM-BUILT IPO COMMAND THAT MAY BE
*/*      USED TO PRINT SEQUENTIAL OR PARTITIONED DATA
*/*      SETS.
*/*
*             MODULE NAME = PRINTOFF                                  *
*                                                                     *
*             DESCRIPTIVE NAME =  MVS CUSTOM-BUILT IPO SUPPLIED PRINT *
*                COMMAND FOR TSO FOREGROUND EXECUTION                 *
*                                                                     *
*             FUNCTION =                                              *
*                PRINTS A DATASET(S) WHICH IS SEQUENTIAL OR PARTIONED *
*                ALLOWING THE USER TO SPECIFY OUTPUT CLASS, COPIES,   *
*                DESTINATION AND HOLD/NOHOLD.  ALSO ALLOWS THE USER   *
*                TO SPECIFY LIST/NOLIST, PRINT/NOPRINT, VOLUME,       *
*                FOLD/NOFOLD, SEQ/NOSEQ OR FCB.                       *
*                LIST IF PDS MEMBER NAMES ARE ONLY TO BE LISTED.      *
*                PRINT IF PDS MEMBERS ARE ONLY TO BE PRINTED.         *
*                                                                     *
*                OPERATION =                                          *
*                   BUILD PARS, DAIR, AND PUTLINE PARAMETER LISTS.    *
*                   CALL PARS TO PARSE COMMAND BUFFER.                *
*                   ALLOCATE DATASET AND DETERMINE IF PDS OR          *
*                      SEQUENTIAL.                                    *
*                   DETERMINE WHAT FUNCTIONS WERE TO BE PERFORMED     *
*                      FOR THIS DATASET IF PDS.                       *
*                   ALLOCATE SYSOUT DATASETS WHEN SOMETHING IS        *
*                      FOUND TO BE PRINTED.                           *
*                   PROCESS NEXT DATASET IN LIST.                     *
*                   AT END OF LIST CLOSE DATASETS AND FREE ANY        *
*                      SYSOUT DATASETS.                               *
*                   DATSETS WILL BE PRINTED AS EITHER VBA OR VBM.     *
*                                                                     *
*              NOTES =                                                *
*                                                                     *
*                 DEPENDENCIES = CHARACTER SET IS EBCDIC.  REASSEMBLE *
*                    IF A DIFFERENT CHARACTER SET IS NEEDED.          *
*                                                                     *
*                 RESTRICTIONS = DATASETS MUST NOT HAVE A LOGICAL     *
*                    RECORD LENGTH OF MORE THAN 256.                  *
*                                                                     *
*                                                                     *
*                                                                     *
*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *
*                    REGISTERS 0 TO 10 = WORK REGISTERS               *
*                    REGISTER  11      = UNUSED                       *
*                    REGISTER  12      = ADDRESSABILITY TO PRINTOFF   *
*                                        CSECT                        *
*                    REGISTER  13      = SAVE AREA REGISTER AND       *
*                                        ADDRESSABILITY TO GETMAINED  *
*                                        WORK AREA                    *
*                    REGISTERS 14,15   = WORK REGISTERS               *
*                                                                     *
*                PATCH LABEL = PATCH (UNUSED AND INTIALIZED TO        *
*                   'ZAP*'S)                                          *
*                                                                     *
*                TSO COMMAND SYNTAX = PRINTOFF (DATASET LIST)         *
*                   CLASS(SYSOUT CLASS) DEST(JOBNAME) COPIES(NUMBER)  *
*                   HOLD/NOHOLD LIST/NOLIST PRINT/NOPRINT FOLD/NOFOLD *
*                                                                     *
*             MODULE TYPE = PROCEDURE                                 *
*                                                                     *
*                PROCESSOR = ASM                                      *
*                                                                     *
*                MODULE SIZE = 5K BYTES                               *
*                                                                     *
*                ATTRIBUTES = SCHEDULER KEY 8, REENTRANT,             *
*                   PROBLEM PROGRAM STATE                             *
*                                                                     *
*             ENTRY POINTS = PRINTOFF (ONLY ENTRY POINT)              *
*                                                                     *
*                LINKAGE =                                            *
*                   FROM TERMINAL MONITOR PROGRAM AS A COMMAND        *
*                                                                     *
*             INPUT = REGISTER 1 POINTS TO COMMAND PROCESSOR          *
*                PARAMETER LIST MAPPED BY IKJCPPL MACRO               *
*                                                                     *
*             OUTPUT = NONE                                           *
*                                                                     *
*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *
*                                                                     *
*                OUTPUT = NONE                                        *
*                                                                     *
*                RETURN CODE = ZERO                                   *
*                                                                     *
*             EXIT - ERROR = NONE - PROGRAM WILL DISPLAY DECIMAL      *
*                RETURN CODE AND RETURN VIA BRANCH REGISTER 14        *
*                                                                     *
*                OUTPUT = NONE                                        *
*                                                                     *
*                RETURN CODE = ZERO                                   *
*                                                                     *
*             EXTERNAL REFERENCES =                                   *
*                                                                     *
*                ROUTINES = IKJPARS, DAIRFAIL, GNRLFAIL, PUTLINE      *
*                                                                     *
*                DATA AREAS = NONE                                    *
*                                                                     *
*                CONTROL BLOCKS = CPPL, PPL, DAPL, DCB, DAPB, CVT,    *
*                   S99RBP, S99RB, S99TUPL, S99TUNIT, S99TUFLD,       *
*                   GFPARMS, DFPARMS, IOPL, IOPB                      *
*                                                                     *
*             TABLES = DATA AREA TO BE GETMAINED.  MAPPED BY DSECT    *
*                BEGINNING AT LABEL RDATD.                            *
*                                                                     *
*             MACROS = SAVE, GETMAIN, CALLTSSR, LINK, TPUT, FREEMAIN, *
*                   OPEN, PUT, GET, CLOSE, RDJFCB, IKJRLSA, DYNALLOC, *
*                   DCB, IKJPARM, IKJPOSIT, IKJKEYWD, IKJNAME,        *
*                   IKJSUBF, IKJIDENT, IKJENDP, IKJDAP08, IKJDAP18,   *
*                   IKJDAPL, IKJCPPL, IKJPPL, CVT, IEFZB4D0, IKJIOPL, *
*                   IEFZB4D2, DCBD, IKJEFFGF, IKJEFFDF, PUTLINE       *
*                                                                     *
*             CHANGE ACTIVITY =                                       *
*                                                                     *
*                FREE INPUT DCB PRIOR TO RETURN                  FREEI*
*                                                                     *
*                ISSUE MSG AND EXIT PROGRAM IF DATA SET HAS A    L>256*
*                LRECL > 256                                          *
*                                                                     *
*                CHANGE 'DEST' PARAMETER TO ALLOW FOR 8 CHARACTERS    *
*                                                                DEST8*
*                                                                     *
*             MESSAGES =                                              *
*                                                                     *
*                BOTH THE DARIFAIL AND GNRLFAIL SERVICE ROUTINES ARE  *
*                USED TO ISSUE MESSAGES.                              *
*                THOSE ISSUED BY THE COMMAND ARE FOUND FOLLOWING THE  *
*                LABEL GNRLERR AND ARE ISSUED USING PUTLINE.          *
*                                                                     *
*             ABEND CODES = NONE                                      *
*                                                                     *
***********************************************************************
*                                                                     *
*  MODIFICATION BLOCK # 1: (OBSOLETE - REFER MOD BLOCK #6)            *
*  -----------------------                                            *
*  CHANGED BY =                                                       *
*     ALEX KARA ON 28/03/90.                                          *
*                                                                     *
*  OBJECTIVE =                                                        *
*     1. CHANGE DEFAULT SYSOUT CLASS FROM 'H' TO 'A'.                 *
*     2. RESTRICT QUEABLE CLASSES TO A, F, G, R AND X.                *
*        (IF ANY CHANGES ARE TO BE MADE TO THESES CLASSES, ISSUE      *
*        "F VALCLASS 1" AND CHANGE ACCORDINGLY.)                      *
*                                                                     *
*  MOD BLOCK ID =                                                     *
*     THESE CHANGES ARE IDENTIFIED BY "AK#1" IN COLS 68 - 71 OR IN    *
*     COMMENTS WHERE ABOVE IS INAPPLICABLE.                           *
*                                                                     *
***********************************************************************
*                                                                     *
*  MODIFICATION BLOCK # 2:                                            *
*  -----------------------                                            *
*  CHANGED BY =                                                       *
*     ALEX KARA ON 28/03/90.                                          *
*                                                                     *
*  OBJECTIVE =                                                        *
*     CHANGE THE BANNER TO THE FOLLOWING FORMAT;                      *
*                                                                     *
*        *---------------------------------------------------*        *
*        *                                                   *        *
*        *         **** TSO FOREGROUND HARDCOPY ****         *        *
*        *         TIME= ..:..:..    DATE= ../../..          *        *
*        *                                                   *        *
*        *---------------------------------------------------*        *
*                                                                     *
*  MOD BLOCK ID =                                                     *
*     THESE CHANGES ARE IDENTIFIED BY "AK#2" IN COLS 68 - 71 OR IN    *
*     COMMENTS WHERE ABOVE IS INAPPLICABLE.                           *
*                                                                     *
***********************************************************************
*                                                                     *
*  MODIFICATION BLOCK # 3:                                            *
*  -----------------------                                            *
*  CHANGED BY =                                                       *
*     ALEX KARA ON 28/03/90.                                          *
*                                                                     *
*  OBJECTIVE =                                                        *
*     PROCESSING STARTED FOR '............'                           *
*     ........ RECORDS SENT TO SYSOUT CLASS '.'                       *
*                                                                     *
*  MOD BLOCK ID =                                                     *
*     THESE CHANGES ARE IDENTIFIED BY "AK#3" IN COLS 68 - 71 OR IN    *
*     COMMENTS WHERE ABOVE IS INAPPLICABLE.                           *
*                                                                     *
***********************************************************************
*                                                                     *
*  MODIFICATION BLOCK # 4:                                            *
*  -----------------------                                            *
*  CHANGED BY =                                                       *
*     ALEX KARA ON 16/07/90.                                          *
*                                                                     *
*  OBJECTIVE =                                                        *
*     PERMIT SUPPRESSION OF SEQUENCE NUMBERS BY ENTERING PARAMETER    *
*     NOSEQ/SEQ (SEQ IS THE DEFAULT)                                  *
*                                                                     *
*  MOD BLOCK ID =                                                     *
*     THESE CHANGES ARE IDENTIFIED BY "AK#4" IN COLS 68 - 71 OR IN    *
*     COMMENTS WHERE ABOVE IS INAPPLICABLE.                           *
*                                                                     *
***********************************************************************
*                                                                     *
*  MODIFICATION BLOCK # 5:                                            *
*  -----------------------                                            *
*  CHANGED BY =                                                       *
*     ALEX KARA ON 15/08/90.                                          *
*                                                                     *
*  OBJECTIVE =                                                        *
*     PERMIT SUPPRESSION OF HEADINGS PRECEEDING DATASETS/MEMBERS.     *
*     THE HEADING WILL PRECEED THE MEMBER LIST IF LIST IS REQUESTED.  *
*     NOHEAD/HEAD (HEAD IS THE DEFAULT)                               *
*                                                                     *
*  MOD BLOCK ID =                                                     *
*     THESE CHANGES ARE IDENTIFIED BY "AK#5" IN COLS 68 - 71 OR IN    *
*     COMMENTS WHERE ABOVE IS INAPPLICABLE.                           *
*                                                                     *
***********************************************************************
*                                                                     *
*  MODIFICATION BLOCK # 6: (SUPERSEDES MOD BLOCK #1)                  *
*  -----------------------                                            *
*  CHANGED BY =                                                       *
*     ALEX KARA ON 16/08/90.                                          *
*                                                                     *
*  OBJECTIVE =                                                        *
*     PROCESS THE TEST FOR VAID PRINT CLASSES THROUGH A LOOP COMPARING*
*     WITH DATA PASSED THROUGH A LOAD MODULE.                         *
*     THE LOAD MODULE IS 'PRINTCLS'. THIS MODULE NEEDS TO BE MODIFIED *
*     TO REFLECT ALL THE VALID PRINT CLASSES AT THE SITE AND ASSEMBLED*
*     LINK EDITTED INTO THE SAME LOAD LIBRARY THAT 'PRINTOFF' RESIDES *
*     IN. 'PRINTOFF' DOES A RUNTIME LOAD OF THE MODULE TO ESTABLISH   *
*     VALIDITY OF PRINT CLASSES.                                      *
*                                                                     *
*  MOD BLOCK ID =                                                     *
*     THESE CHANGES ARE IDENTIFIED BY "AK#6" IN COLS 68 - 71 OR IN    *
*     COMMENTS WHERE ABOVE IS INAPPLICABLE.                           *
*                                                                     *
***********************************************************************
*                                                                     *
*  MODIFICATION BLOCK # 7:                                            *
*  -----------------------                                            *
*  CHANGED BY =                                                       *
*     ALEX KARA ON 06/02/91.                                          *
*                                                                     *
*  OBJECTIVE =                                                        *
*     PERMIT PRINTING OF HEX VALUES .                                 *
*     PRINTS THE ORIGINAL LINE WITH THE NEXT LINE BEING THE FIRST     *
*     NIBBLE AND THE NEXT LINE BEING THE SECOND NIBBLE. A SUBSEQUENT  *
*     SEPERATOR LINE WIH COLUMN MARKINGS IS PRINTED.                  *
*                                                                     *
*  MOD BLOCK ID =                                                     *
*     THESE CHANGES ARE IDENTIFIED BY "AK#7" IN COLS 68 - 71 OR IN    *
*     COMMENTS WHERE ABOVE IS INAPPLICABLE.                           *
*                                                                     *
***********************************************************************
*                                                                     *
*  MODIFICATION BLOCK # 8:                                            *
*  -----------------------                                            *
*  CHANGED BY =                                                       *
*     ALEX KARA ON 29/10/92.                                          *
*                                                                     *
*  OBJECTIVE =                                                        *
*     ADDED USERID TO IDENTIFICATION BLOCK                            *
*     THE ROUTINE WAS REMOVED TO AN EXECUTION ROUTINE WITH ITS OWN    *
*     BASE REGISTER BECAUSE OF ADDRESABILITY PROBLEMS.                *
*                                                                     *
*  MOD BLOCK ID =                                                     *
*     THESE CHANGES ARE IDENTIFIED BY "AK#8" IN COLS 68 - 71 OR IN    *
*     COMMENTS WHERE ABOVE IS INAPPLICABLE.                           *
*                                                                     *
***********************************************************************
*
PRINTOFF CSECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SAVE  (14,12),,HARDCOPY.IPO.&SYSTIME._&SYSDATE SAVE REGISTERS
         LR    R12,R15                 LOAD REGISTER 12 WITH ENTRY
*                                      ADDRESS
         USING PRINTOFF,R12            ESTABLISH ADDRESSABILITY TO
*                                      PROGRAM CSECT
         LA    R11,4095(R12)           LOAD REGISTER 11 WITH ENTRY
*                                      ADDRESS 4095
         USING PRINTOFF+4095,R11       ESTABLISH ADDRESSABILITY TO THE
*                                      REST OF THE PROGRAM CSECT
         LR    R8,R1                   LOAD REGISTER 8 TO PRESERVE
*                                      POINTER TO COMMAND PROCESSOR
*                                      PARAMETER LIST
         GETMAIN R,LV=LDYNAMIC         GETMAIN DYNAMIC WORKAREA
         LR    R10,R1                  LOAD REGISTER 10 TO PRESERVE
*                                      POINTER TO WORKAREA
         ST    R13,4(R10)              STORE ADDRESS OF PREVIOUS
*                                      SAVEAREA
         ST    R10,8(,R13)             STORE ADDRESS OF CURRENT
*                                      SAVEAREA IN PREVIOUS SAVEAREA
         LR    R13,R10                 LOAD REGISTER 13 WITH ADDRESS OF
*                                      CURRENT SAVEAREA
         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY TO
*                                      DYNAMIC WORKAREA
*
***********************************************************************
*                                                                     *
*        BUILD PARSE AND DAIR PARAMETER LISTS USING COMMAND           *
*           PROCESSOR PARAMETER LIST                                  *
*        INITIALIZE OUTPUT DATA CONTROL BLOCKS IN WORKAREA            *
*                                                                     *
***********************************************************************
*
         USING CPPL,R8                 ESTABLISH ADDRESSABILITY TO CPPL
         LA    R4,PPLSECT              LOAD ADDRESS OF PARSE PARAMETER
*                                      LIST
         USING PPL,R4                  ESTABLISH ADDRESSABILITY TO PPL
         LA    R6,DAPLSECT             LOAD ADDRESS OF DAIR PARAMETER
*                                      LIST
         USING DAPL,R6                 ESTABLISH ADDRESSABILITY TO DAPL
         LA    R5,IOPLSECT             LOAD ADDRESS OF PUTLINE
*                                      PARAMETER LIST
         USING IOPL,R5                 ESTABLISH ADDRESSABILITY TO IOPL
         L     R1,CPPLUPT              LOAD POINTER TO USER PROFILE
*                                      TABLE FROM CPPL
         L     R2,CPPLECT              LOAD POINTER TO ENVIRONMENT
*                                      CONTROL TABLE FROM CPPL
         SLR   R3,R3                   ZERO REGISTER 3
         ST    R3,ECB                  STORE REGISTER AS ECB FOR PPL
         LA    R3,ECB                  LOAD ADDRESS OF ECB
         STM   R1,R3,PPLSECT           STORE ADDRESS OF UPT, ECT, AND
*                                      ECB IN PPL
         STM   R1,R3,DAPLSECT          STORE ADDRESS OF UPT, ECT, AND
*                                      ECB IN DAPL
         STM   R1,R3,IOPLSECT          STORE ADDRESS OF UPT, ECT, AND
*                                      ECB IN IOPL
         LA    R3,IOPB                 LOAD ADDRESS OF PUTLINE
*                                      PARAMETER BLOCK
         ST    R3,IOPLIOPB             STORE IOPB ADDRESS IN IOPL
         MVC   PPLPCL,PCLADDR          MOVE POINTER TO PARAMETER
*                                      CONTROL LIST INTO PPL
         LA    R2,PARSBACK             LOAD ADDRESS OF FULLWORD TO
*                                      CONTAIN ADDRESS OF PDE RETURNED
*                                      BY PARS
         ST    R2,PPLANS               STORE POINTER TO RETURN ADDRESS
         MVC   PPLCBUF,CPPLCBUF        MOVE POINTER TO COMMAND BUFFER
*                                      INTO PPL
         LA    R2,PPLUWA               LOAD ADDRESS OF USER WORK AREA
         ST    R2,PPLUWA               STORE ADDRESS IN PPL
         MVC   DAPLPSCB,CPPLPSCB       MOVE POINTER TO PSCB INTO DAPL
         DROP  R4,R5,R6,R8             DROP ADDRESSABILITY TO CPPL,
*                                      IOPL, DAPL, AND PPL
         MVC   OUTPUTA(OUTPUTAL),OUTPUTAC  MOVE ASA DCB CONSTANT INTO
*                                      ASA DCB IN WORKAREA
         MVC   OUTPUTM(OUTPUTML),OUTPUTMC  MOVE MACHINE DCB CONSTANT
*                                      INTO MACHINE DCB IN WORKAREA
*
***********************************************************************
*                                                                     *
*        CALLTSSR TO PARSE (ENTRY NAME IKJPARS)                       *
*        ON RETURN PARSBACK -> PDL                                    *
*        HANDLE ALL ERROR CODES RETURNED BY PARS                      *
*        IF NECESSARY CALL GENERAL FAIL SERVICE ROUTINE               *
*                                                                     *
***********************************************************************
*
         CALLTSSR  EP=IKJPARS,MF=(E,PPLSECT)
*                                      CALL PARS TO PARSE COMMAND
         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO
         BZ    GOODPARS                YES....GO TO GOOD PARS ROUTINE
         C     R15,FULL4               SEE IF RETURN CODE IS FOUR
         BE    RETURN                  YES....PARS ISSUED ERROR
*                                      MESSAGE.  GO CLEANUP AND RETURN
         C     R15,FULL20              SEE IF RETURN CODE IS TWENTY
         BE    RETURN                  YES....VALIDITY CHECKING
*                                      ROUTINE ISSUED ERROR MESSAGE.
*                                      GO CLEANUP AND RETURN
         XC    GFPARMS(GFLENGF),GFPARMS  INITIALIZE PARMLIST FOR
*                                      GENERAL FAIL TO ZEROS
         LA    R1,GFPARMS              LOAD ADDRESS OF PARMLIST
         ST    R1,GFPARMP              STORE ADDRESS AS POINTER TO
*                                      PARMLIST
         ST    R15,GFRCODE             STORE RETURN CODE IN PARMLIST
         LA    R1,GFPARSE              LOAD CALLER ID FOR PARS
         STH   R1,GFCALLID             STORE CALLER ID IN PARMLIST
         L     R1,SAVEAREA+4           LOAD ADDRESS OF PEVIOUS
*                                      SAVEAREA
         L     R1,24(R1)               LOAD POINTER TO CPPL
         ST    R1,GFCPPLP              STORE POINTER TO CPPL IN
*                                      PARMLIST
         LA    R1,ECB                  LOAD ADDRESS OF OPTIONAL ECB
         ST    R1,GFECBP               STORE POINTER TO ECB IN
*                                      PARMLIST
         SLR   R1,R1                   ZERO REGISTER 1
         ST    R1,ECB                  SET OPTIONAL ECB TO ZERO
         LINK  EP=IKJEFF19,MF=(E,GFPARMP)  LINK TO GENERAL FAIL SERVICE
*                                      ROUTINE TO HANDLE RETURN CODE
         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO
         BZ    RETURN                  YES....GO CLEANUP AND RETURN
         LR    R8,R15                  LOAD REGISTER 8 WITH RETURN
*                                      CODE
         BAL   R14,SETCODE             GO CONVERT CODE TO DECIMAL
         PUTLINE OUTPUT=(GNRLERR,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      GENERAL FAIL ERROR MESSAGE
         PUTLINE OUTPUT=(RETNCD,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DECIMAL RETURN CODE
         B     RETURN                  GO CLEANUP AND RETURN
*
***********************************************************************
*                                                                     *
*        SET UP ADDRESSABILITY TO PDL                                 *
*           AND LOAD REGISTER 6 WITH ADDRESS OF DSNAME PDE            *
*                                                                     *
***********************************************************************
*
GOODPARS DS    0H
         L     R9,PARSBACK             LOAD POINTER TO PARS ANSWER
         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL
         LA    R6,DSNAMES              LOAD POINTER TO DSNAME LIST
         MVI   VOLBIT,BLANK            BLANK OUT THE VOLUME WORK AREA
         MVC   VOLUME,VOLBIT           CONTINUE BLANKING THE VOLUME
         CLC   PVOL(2),HALF1           SEE IF VOLUME SPECIFIED
         BNE   CHKFOLD                 NO.....GO SEE IF FOLD IS DESIRED
         L     R7,SVOL                 LOAD POINTER TO VOLUME
         LH    R8,SVOL+4               LOAD LENGTH OF VOLUME
         BCTR  R8,0                    DECREMENT LENGTH FOR EXECUTE OF
*                                      MOVE
         EX    R8,MOVEVOL              MOVE VOLUME INTO WORK AREA
         OI    VOLBIT,HIGH             INDICATE VOLUME PRESENT
CHKFOLD  DS    0H
         CLC   PFOLD(2),HALF1          SEE IF FOLD SPECIFIED
         BNE   CHKNOSEQ                NO.....GO SEE IF NOSEQ DESIRED
         OI    VOLBIT,LOW              INDICATE FOLD PRESENT
CHKNOSEQ DS    0H                                                  AK#4
         XC    SEQREQ,SEQREQ           INIT SEQUENCE REQUEST FLAG  AK#4
         CLC   PSEQ(2),HALF2           SEE IF NOSEQ SPECIFIED      AK#4
         BNE   CHKHEX                  NO.....GO SEE IF HEX REQ    AK#7
         OI    SEQREQ,NOSEQ            INDICATE NO SEQUENCING REQD AK#4
CHKHEX   DS    0H                                                  AK#7
         XC    HEXREQ,HEXREQ           INIT HEX REQUEST FLAG       AK#7
         CLC   PHEX(2),HALF1           SEE IF HEX SPECIFIED        AK#7
         BNE   CHKHEAD                 NO.....GO SEE IF NOHEAD REQ AK#7
         OI    HEXREQ,HEXPRNT          INDICATE NO HEX PRINTG REQD AK#7
CHKHEAD  DS    0H                                                  AK#4
         XC    HEADREQ,HEADREQ         INIT HEADING REQUEST FLAG   AK#5
         CLC   PHEAD(2),HALF2          SEE IF NOHEAD SPECIFIED     AK#5
         BNE   NEXT                    NO.....GO LOOP THRU DSNAMES AK#5
         OI    HEADREQ,NOHEAD          INDICATE NO HEADING REQD    AK#5
         DROP  R9                      DROP ADDRESSABILITY TO PDL
*
***********************************************************************
*                                                                     *
*        LOOP THROUGH DSNAME LIST RETURNED BY PARS                    *
*                                                                     *
***********************************************************************
*
NEXT     DS    0H
         ZAP   #OFLINES,=P'0'          CLEAR NUMBER OF LINES PRNTD AK#3
         LA    R1,PRINTI               LOAD POINTER TO DDNAME TO BE
*                                      FREED
         BAL   R2,FREEDD               BRANCH TO FREE ROUTINE
         LTR   R8,R8                   SEE IF RETURN CODE FROM FREE IS
*                                      ZERO
         BNZ   CLOSDCBS                NO.....GO CLOSE DCBS AND RETURN
         L     R5,0(R6)                LOAD POINTER TO DSNAME
         LH    R4,4(R6)                LOAD LENGTH OF DSNAME
         STCM  R4,3,DSNLEN             STORE LENGTH OF DSNAME
         MVC   DSNLEN#(2),DSNLEN       LOAD LENGTH OF DSNAME       AK#2
*                                         MESSAGE                  AK#2
         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF
*                                      MOVE
         LA    R8,DAP08                LOAD ADDRESS OF DAPB FOR 08
         USING DAPB08,R8               ESTABLISH ADDRESSABILITY TO DAPB
         MVC   DAPB08(DAPB08L),DAPB08C MOVE CONSTANTS INTO DAPB
         LA    R1,DSNLEN               LOAD POINTER TO DSN BUFFER
         ST    R1,DA08PDSN             STORE POINTER TO DSN BUFFER IN
*                                      DAPB
         MVI   DSNBUF,BLANK            BLANK OUT THE DSNAME BUFFER
         MVC   DSNBUF+1(43),DSNBUF     FINISH BLANKING OUT THE BUFFER
         EX    R4,MOVEDSN              MOVE IN THE DSNAME
         TM    14(R6),HIGH             SEE IF MEMBER NAME IS PRESENT
         BNO   CHKPASS                 NO.....GO CHECK IF THERE IS A
*                                      PASSWORD
         L     R5,8(R6)                LOAD POINTER TO THE MEMBER NAME
         LH    R4,12(R6)               LOAD LENGTH OF MEMBER NAME
         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF
*                                      MOVE
         EX    R4,MOVEMEM              MOVE IN THE MEMBER NAME
CHKPASS  DS    0H
         MVC   MEMNAME,DA08MNM         MOVE MEMBER NAME INTO HEADER 2
         TM    22(R6),HIGH             SEE IF PASSWORD IS PRESENT
         BNO   CHKVOL                  NO.....GO SEE IF VOLUME PRESENT
         L     R5,16(R6)               LOAD POINTER TO THE PASSWORD
         LH    R4,20(R6)               LOAD LENGTH OF PASSWORD
         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF
*                                      MOVE
         EX    R4,MOVEPASS             MOVE IN THE PASSWORD
CHKVOL   DS    0H
         TM    VOLBIT,HIGH             SEE IF VOLUME IS PRESENT
         BNO   ALLOCDD                 NO.....GO ALLOCATE DATA SET
         MVC   DA08SER,VOLUME          MOVE IN THE VOLUME SERIAL
ALLOCDD  DS    0H
         SLR   R4,R4                   ZERO REGISTER 4
         ST    R4,ECB                  STORE REGISTER 4 AS ECB
         LA    R1,DAPLSECT             LOAD ADDRESS OF DAPL
         USING DAPL,R1                 ESTABLISH ADDRESSABILITY TO DAPL
         ST    R8,DAPLDAPB             STORE ADDRESS OF DAPB IN DAPL
         DROP  R1                      DROP ADDRESSABILITY TO DAPL
         CALLTSSR EP=IKJDAIR           CALL DAIR TO ALLOCATE DATASET
         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO
         BZ    OUTPUT                  YES....GO PRINT DATASET
         MVI   DFID+1,DFDAIR           SET DAIRFAIL ID TO INDICATE DAIR
         BAL   R2,DAIRFAIL             GO TO DAIRFAIL ROUTINE TO HAVE
*                                      ERROR MESSAGE PUT OUT
NOTPMESS DS    0H
         PUTLINE OUTPUT=(DSNNOTP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED MESSAGE
         B     EXITMSG                 GO PUT OUT DATASET AND MEMBER
*                                      NAMES
*
***********************************************************************
*                                                                     *
*        DETERMINE DATASET TYPE AND CALL PRINT ROUTINE                *
*                                                                     *
***********************************************************************
*
OUTPUT   DS    0H
         MVC   HEADER,DSNMSG1          MOVE MESSAGE TO PRINT LINE  AK#3
         LA    R14,HEADER+28           LOAD START OF DATASET NAME  AK#3
         MVC   0(56,R14),DSNBUF        MOVE MAX DSNLENGTH          AK#3
         AH    R14,DSNLEN#             ADD DATASET LENGTH          AK#3
         MVI   4(R14),C' '             MOVE BLANK                  AK#2
         MVC   5(7,R14),4(R14)         CLEAR FOR SHORT MEMBER NAME AK#2
         CLI   MEMNAME,BLANK           SEE IF MEMBER NAME IS BLANK AK#3
         BE    NOMEM0                  Y. NO NEED TO PUT IN PARENS AK#3
         MVI   0(R14),C'('             MOVE OPEN PAREN INTO DSNAME AK#3
         MVC   1(8,R14),MEMNAME        MOVE MEBER NAME             AK#3
         LA    R14,8(R14)              PT TO LAST CHAR ON MEM NAME AK#3
         LA    R1,7                    LOOP COUNTER                AK#3
MEMLOP#0 DS    0H                                                  AK#3
         CLI   0(R14),C' '             Q. CHARACTER SPACE          AK#3
         BNE   MEMELP#0                   N. EXIT LOOP             AK#3
         BCTR  R14,0                   POINT TO PREVIOUS CHARACTER AK#3
         BCT   R1,MEMLOP#0             LOOP TILL END               AK#3
MEMELP#0 DS    0H                                                  AK#3
         MVI   1(R14),C')'             MOVE END PAREN              AK#3
         LA    R14,2(R14)              POINT PAST PAREN            AK#3
NOMEM0   DS    0H                                                  AK#3
         MVI   0(R14),C''''            CLOSE OFF MEMBER            AK#3
         LA    R14,1(R14)              ADD ' TO LENGTH             AK#3
         LA    R15,HEADER              LOAD START OF XTRA DATA     AK#3
         SR    R14,R15                 GET LENGTH OF DATA          AK#3
         STH   R14,HEADER              STORE NEW LENGTH OF ALL     AK#3
PUTHDR20 DS    0H                                                  AK#3
         PUTLINE OUTPUT=(HEADER,SINGLE,DATA),MF=(E,IOPLSECT)  PUT  AK#3
*                                       PROCESSING DSN MESSAGE     AK#3
         TM    DA08DSO,DSOPS           X'40' PHYSICAL SEQUENTIAL
         BO    PRINTIT                 YES....GO PRINT DATASET
         CLC   DA08MNM,BLANKS          SEE IF MEMBER NAME IS BLANK
         BNE   PRINTIT                 NO.....GO TREAT AS SEQUENTIAL
         TM    DA08DSO,DSOPO           X'02' PARTITIONED
         BO    SCROLLIT                YES....GO SCROLL DIRECTORY
         DROP  R8                      DROP ADDRESSABILITY TO DAPB
         PUTLINE OUTPUT=(NOTPSPO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      NOT PARTITIONED OR SEQUENTIAL
*                                      MESSAGE
         B     NOTPMESS                GO PUT NOT PRINTED MESSAGE
*
***********************************************************************
*                                                                     *
*        READS RECORDS USING GET MOVE                                 *
*           AND ATTRIBUTES OF GIVEN DATASET                           *
*        WRITES THESE SAME RECORDS USING PUT MOVE                     *
*           AND THE INPUT DATASET ATTRIBUTES                          *
*                                                                     *
***********************************************************************
*
PRINTIT  DS    0H
         LA    R8,INPUT                LOAD POINTER TO INPUT DCB
         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB
         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO
*                                      INPUT DCB IN WORKAREA
         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO OPEN LIST IN WORKAREA
         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN INPUT DCB
PRINTS   DS    0H                      BRANCH ADDRESS FOR PRINTING
*                                      MEMBERS
         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY
         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED
*                                      MESSAGE
         TM    DCBRECFM,DCBRECU        SEE IF RECFM IS UNDEFINED
         BO    ERRORU                  NO.....GO PUT OUT ERROR MESSAGE
         BZ    ERRORU                  ZERO...NOT FIXED OR VARIABLE SO
*                                      GO PUT OUT ERROR MESSAGE
         CLC   DCBLRECL,HALF256        SEE IF LRECL IS GREATER THAN 256
         BH    ERRORL                  YES....GO PUT OUT RECORD LENGTH
*                                      MESSAGE
         LA    R9,LINE                 LOAD ADDRESS FOR INPUT
         SLR   R4,R4                   ZERO OUT REGISTER 4
         ST    R4,LENGTH               STORE ZERO IN LENGTH (PLUS 2
*                                      RESERVED BYTES) FIELD
         TM    DCBRECFM,DCBRECV        SEE IF RECFM IS VARIABLE
         BO    CHKCNTRL                YES....GO PUT OUT DSNAME
*                                      NO.....RECFM MUST BE FIXED
*                                      SO CONTINUE
         A     R9,FULL4                SET TO HAVE FIXED LENGTH
         LH    R4,DCBLRECL             LOAD LOGICAL RECORD LENGTH
         A     R4,FULL4                ADD 4 FOR LENGTH FIELD PREFIX
         STH   R4,LENGTH               STORE IN LENGTH FIELD
         CLC   DCBLRECL,HALF251        IS LRECL GREATER THAN 251 L>256
         BH    ERRORLF                 YES-TOO BIG - SEND MSG    L>256
CHKCNTRL DS    0H
         MVC   HEADER,HEADERC          MOVE HEADER INTO DATA AREA
         TM    DCBRECFM,DCBRECCM       SEE IF CONTROL IS MACHINE
         BNO   USEA                    NO.....GO TO USE ASA CONTROL
         LA    R5,OUTPUTM              LOAD ADDRESS OF OUTPUT DCB FOR
*                                      MACHINE CODE
         LA    R4,EJECTM               LOAD ADDRESS OF EJECT DATA
         MVI   HDRCNTL,SKIPM           MOVE INTO HEADER MACHINE CODE
*                                      FOR SPACE
         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN
         BO    PUTDSN                  YES....GO PUT OUT HEADERS
         LA    R3,PRINTM               LOAD POINTER TO PRINTM
         LA    R14,PUTDSN              LOAD ADDRESS FROM RETURN FROM
*                                      SYSOUT ALLOCATION
         B     ALLOCOUT                GO TO ALLOCATE SYSOUT
USEA     DS    0H
         TM    DCBRECFM,DCBRECCA       SEE IF CONTROL IS ASA
         BO    GOODLENA                YES....GO SEE IF DCB IS OPEN
         A     R9,FULL1                SET GET AREA TO ALLOW FOR NO
*                                      CONTROL
         A     R4,FULL1                ADD ONE FOR A CONTROL BYTE
         STH   R4,LENGTH               STORE LENGTH IN PUT AREA
GOODLENA DS    0H
         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR
*                                      ASA CODE
         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA
         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN
         BO    PUTDSN                  YES....GO PUT OUT HEADERS
         LA    R3,PRINTA               LOAD POINTER TO PRINTA
         BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO
*                                      DO SYSOUT ALLOCATION
PUTDSN   DS    0H
         PUT   (R5),(R4)               PUT OUT PAGE EJECT
         AP    #OFLINES,=P'1'          ADD NUMBER OF HEADINGS      AK#5
         TM    HEADREQ,NOHEAD          NO HEAING REQUESTED         AK#5
         BO    NOHEADRQ                YES - BYPASS HEADINGS       AK#5
         AP    #OFLINES,=P'9'          ADD NUMBER OF HEADINGS      AK#5
         MVC   HEADER,HEADERB1         MOVE BANNER INTO DATA AREA  AK#2
         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER       AK#2
         MVC   HEADER,HEADERB2         MOVE BANNER INTO DATA AREA  AK#2
         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER       AK#2
         MVC   HEADER,HEADERC          MOVE HEADER INTO DATA AREA  AK#2
         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER       AK#2
         LA    R1,4                    LOAD USERLINE PROCESSING ID AK#8
         BAL   R14,XTRARTN             GO PERFORM XTRARTN          AK#8
         MVC   HEADER,HEADERT          MOVE TIME/DATE TO DATA AREA AK#2
         BAL   R14,DATERTN1            GO PERFORM DATE ROUTINE     AK#2
         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER       AK#2
         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME='   AK#2
*                                      INTO SECOND HEADER          AK#2
         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE        AK#2
         LA    R14,DSNAME              LOAD START OF DATASET NAME  AK#2
         AH    R14,DSNLEN#             ADD DATASET LENGTH          AK#2
         MVI   4(R14),C' '             MOVE BLANK                  AK#2
         MVC   5(7,R14),4(R14)         CLEAR FOR SHORT MEMBER NAME AK#2
         CLI   MEMNAME,BLANK           SEE IF MEMBER NAME IS BLANK AK#2
         BE    NOMEM2                  Y. NO NEED TO PUT IN PARENS AK#2
         MVI   0(R14),C'('             MOVE OPEN PAREN INTO DSNAME AK#2
         MVC   1(8,R14),MEMNAME        MOVE MEBRE NAME             AK#2
         LA    R14,8(R14)              PT TO LAST CHAR ON MEM NAME AK#2
         LA    R1,7                    LOOP COUNTER                AK#2
MEMLOP#2 DS    0H                                                  AK#2
         CLI   0(R14),C' '             Q. CHARACTER SPACE          AK#2
         BNE   MEMELP#2                   N. EXIT LOOP             AK#2
         BCTR  R14,0                   POINT TO PREVIOUS CHARACTER AK#2
         BCT   R1,MEMLOP#2             LOOP TILL END               AK#2
MEMELP#2 DS    0H                                                  AK#2
         MVI   1(R14),C')'             MOVE END PAREN              AK#2
         LA    R14,2(R14)              POINT PAST PAREN            AK#2
NOMEM2   DS    0H                                                  AK#2
         MVI   0(R14),C''''            CLOSE OFF MEMBER            AK#2
         LA    R14,1(R14)              ADD ' TO LENGTH             AK#2
         LA    R15,HEADER2             LOAD START OF HEADER        AK#2
         SR    R14,R15                 GET LENGTH OF DATA          AK#2
         CH    R14,=H'68'              Q. EXTEND PAST BANNER '*'   AK#2
         BNL   PUTHDR2A                   Y. BYPASS                AK#2
         LH    R14,=H'68'              SET LENGTH OF DATA          AK#2
         AR    R15,R14                 POINT PAST END OF DATA      AK#2
         BCTR  R15,0                   POINT TO LAST BYTE POSITION AK#2
         MVI   0(R15),C'*'             CLOSE OFF BANNER            AK#2
PUTHDR2A DS    0H                                                  AK#2
         STH   R14,HEADER2             STORE LENGTH OF DATA        AK#2
         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2     AK#2
         MVC   HEADER,HEADERB2         MOVE BANNER 2 INTO DATA AREAAK#2
         PUT   (R5),HEADER             PUT OUT BANNER 2 HEADER     AK#2
         MVC   HEADER,HEADERB1         MOVE BANNER 1 INTO DATA AREAAK#2
         PUT   (R5),HEADER             PUT OUT BANNER 1 HEADER     AK#2
         MVC   HEADER2(4),SPACE        CHANGE HEADER 2 FOR PUT OF BLANK
*                                      LINE
         PUT   (R5),HEADER2            PUT OUT BLANK LINE
NOHEADRQ DS    0H                                                  AK#5
         MVC   CNTLBYTE,HDRCNTL        MOVE IN SPACE AS CONTROL
*                                      CHARACTER
         TM    VOLBIT,LOW              SEE IF FOLD IS REQUESTED
         BO    FOLDIT                  YES....GO FOLD OUTPUT
         TM    DCBRECFM,DCBRECV        SEE IF RECFM IS VARIABLE
         BNO   COPYF                   NO.....GO HANDLE FIXED INPUT
         TM    DCBRECFM,DCBRECCC       SEE IF THERE IS A CONTROL BYTE
         BZ    COPYVNO                 NO.....GO TO ADD CONTROL FOR
*                                      VARIABLE
COPYV    DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD
         PUT   (R5),LINE               PUT OUT OUTPUT LINE
         AP    #OFLINES,=P'1'          INCREMENT LINES PRINTERD    AK#3
         B     COPYV                   GO GET NEXT RECORD
*
COPYVNO  DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD
         SLR   R15,R15                 ZERO REGISTER 15 FOR INSERT
         ICM   R15,7,LENGTH+1          INSERT LENGTH AND RESERVED BYTE
         A     R15,FULL256             ADD 1 TO LENGTH
         STCM  R15,7,LENGTH            STORE LENGTH AND RESERVED BYTE
         MVC   CNTLBYTE,HDRCNTL        MOVE IN CONTROL SAVED IN HEADER
         PUT   (R5),LINE               PUT OUT LINE
         LA    R1,2                    SET HEX PROCESSING ID       AK#8
         BAL   R14,XTRARTN             GO AND PRINT HEX LINE       AK#7
         AP    #OFLINES,=P'1'          INCREMENT LINES PRINTERD    AK#3
         B     COPYVNO                 GO GET NEXT INPUT RECORD
*
COPYF    DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD
*-----------------------------------------------------------------*AK#4
         MVC   HEXRECL(2),DCBLRECL     SET UP HEX CONVERSION LENGHTAK#7
         TM    SEQREQ,NOSEQ            NO SEQUENCE NUMBER REQUEST  AK#4
         BNO   NOSEQRQ1                YES - BYPASS NOSEQUENCING   AK#4
         LH    R1,DCBLRECL             ADD RECORD LENGTH           AK#4
         SH    R1,HALF8                SUBTRACT LENGTH OF SEQ#S    AK#4
         STH   R1,HEXRECL              SET UP HEX CONVERSION LENGHTAK#7
         CLC   DCBLRECL,HALF252        IF LRECL GREATER THAN 251   AK#4
         BNL   COPYF1                  YES - BYPASS NOSEQUENCING   AK#4
         LR    R1,R9                   POINT R1 TO INPUT DATA      AK#4
         AH    R1,DCBLRECL             ADD RECORD LENGTH           AK#4
         SH    R1,HALF8                SUBTRACT LENGTH OF SEQ#S    AK#4
         MVC   0(8,R1),BLANKS          BLANK OUT SEQUENCE NUMBER   AK#4
         B     COPYF2                  GO AND PRINT IT             AK#4
NOSEQRQ1 DS    0H                                                  AK#4
*-----------------------------------------------------------------*AK#4
         CLC   DCBLRECL,HALF252        IF LRECL GREATER THAN 251 L>256
         BL    COPYF2                  NO - THEN PRINT IT        L>256
COPYF1   DS    0H
         MVC   LENGTH,HALF255          ELSE PRINT ONLY 255 CHARS L>256
COPYF2   DS    0H
         PUT   (R5),LINE               PUT OUT OUTPUT LINE       L>256
         LA    R1,2                    SET HEX PROCESSING ID       AK#8
         BAL   R14,XTRARTN             GO AND PRINT HEX LINE       AK#7
         AP    #OFLINES,=P'1'          INCREMENT LINES PRINTERD    AK#3
         B     COPYF                   GO GET NEXT RECORD
*
FOLDIT   DS    0H
         TM    DCBRECFM,DCBRECV        SEE IF RECFM IS VARIABLE
         BNO   FOLDF                   NO.....GO HANDLE FIXED INPUT
         TM    DCBRECFM,DCBRECCC       SEE IF THERE IS A CONTROL BYTE
         BZ    FOLDVNO                 NO.....GO TO ADD CONTROL FOR
*                                      VARIABLE
FOLDV    DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD
         LH    R15,LENGTH              LOAD LENGTH OF LINE
         SH    R15,HALF6               DECREMENT FOR EXECUTE
         EX    R15,FOLDLINE            EXECUTE FOLD OF LINE
         PUT   (R5),LINE               PUT OUT OUTPUT LINE
         LA    R1,2                    SET HEX PROCESSING ID       AK#8
         BAL   R14,XTRARTN             GO AND PRINT HEX LINE       AK#7
         AP    #OFLINES,=P'1'          INCREMENT LINES PRINTERD    AK#3
         B     FOLDV                   GO GET NEXT RECORD
*
FOLDVNO  DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD
         SLR   R15,R15                 ZERO REGISTER 15 FOR INSERT
         ICM   R15,7,LENGTH+1          INSERT LENGTH AND RESERVED BYTE
         A     R15,FULL256             ADD 1 TO LENGTH
         STCM  R15,7,LENGTH            STORE LENGTH AND RESERVED BYTE
         MVC   CNTLBYTE,HDRCNTL        MOVE IN CONTROL SAVED IN HEADER
         LH    R15,LENGTH              LOAD LENGTH OF LINE
         SH    R15,HALF6               DECREMENT FOR EXECUTE
         EX    R15,FOLDLINE            EXECUTE FOLD OF LINE
         PUT   (R5),LINE               PUT OUT LINE
         LA    R1,2                    SET HEX PROCESSING ID       AK#8
         BAL   R14,XTRARTN             GO AND PRINT HEX LINE       AK#7
         AP    #OFLINES,=P'1'          INCREMENT LINES PRINTERD    AK#3
         B     FOLDVNO                 GO GET NEXT INPUT RECORD
*
FOLDF    DS    0H
         LH    R4,LENGTH               LOAD LENGTH INTO REGISTER 4
         SH    R4,HALF6                SUBTRACT TO SET UP FOR EXECUTE
FOLDFLP  DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD
*-----------------------------------------------------------------*AK#4
         TM    SEQREQ,NOSEQ            NO SEQUENCE NUMBER REQUEST  AK#4
         BNO   NOSEQRQ2                YES - BYPASS NOSEQUENCING   AK#4
         LR    R1,R9                   POINT R1 TO INPUT DATA      AK#4
         AH    R1,DCBLRECL             ADD RECORD LENGTH           AK#4
         SH    R1,HALF8                SUBTRACT LENGTH OF SEQ#S    AK#4
         MVC   0(8,R1),BLANKS          BLANK OUT SEQUENCE NUMBER   AK#4
NOSEQRQ2 DS    0H                                                  AK#4
*-----------------------------------------------------------------*AK#4
         EX    R4,FOLDLINE             FOLD DATA
         PUT   (R5),LINE               PUT OUT OUTPUT LINE
         LA    R1,2                    SET HEX PROCESSING ID       AK#8
         BAL   R14,XTRARTN             GO AND PRINT HEX LINE       AK#7
         AP    #OFLINES,=P'1'          INCREMENT LINES PRINTERD    AK#3
         B     FOLDFLP                 GO GET NEXT RECORD
FOLDLINE OC    DATA(0),BLANKS          OC INSTRUCTION TO BE EXECUTED
*
EXIT     DS    0H
         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS OPEN
         BNO   EXITMSG                 NO....GO PUT OUT DATASET AND
*                                      MEMBER NAMES
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST IN WORKAREA
         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB
EXITMSG  DS    0H
*        PUTLINE OUTPUT=(DSNMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATA SET NAME MESSAGE
*        LH    R4,4(R6)                LOAD LENGTH OF DSNAME
*        A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE
*        SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES
*        STCM  R4,15,DSNLENP           STORE LENGTH OF PUTLINE
*        PUTLINE OUTPUT=(DSNLENP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATA SET NAME MESSAGE
*        TM    14(R6),HIGH             SEE IF MEMBER NAME IS PRESENT
*        BNO   CONTINUE                NO.....GO CHECK FOR ANOTHER
*                                      DATASET NAME
*        PUTLINE OUTPUT=(MEMMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATA SET NAME MESSAGE
*        LH    R4,12(R6)               LOAD LENGTH OF MEMBER NAME
*        A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE
*        SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES
*        STCM  R4,15,MEMNAMEL          STORE LENGTH OF PUTLINE
*        PUTLINE OUTPUT=(MEMNAMEL,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      MEMBER NAME
         MVC   HEADER,DSNMSG9          MOVE MESSAGE                AK#3
         MVC   HEADER+4(8),EDPAT1      MOVE PATTERN TO OUTPUT AREA AK#3
         ED    HEADER+4(8),#OFLINES    EDIT OVER PATTERN # OF LINESAK#3
         MVC   HEADER+43(1),OUTCLASS   MOVE OUTPUT CLASS           AK#3
         PUTLINE OUTPUT=(HEADER,SINGLE,DATA),MF=(E,IOPLSECT)       AK#3
         B     CONTINUE                GO CONTINUE WITH NEXT DATASET
         DROP  R8                      DROP ADDRESSABILITY TO INPUT DCB
ERRORL   DS    0H
         PUTLINE OUTPUT=(DSNISL,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED DUE TO
*                                      RECORD LENGTH TOO LONG MESSAGE
         B     EXIT                    GO SEE IF INPUT DCB IS OPEN
ERRORLF  DS    0H                                                L>256
         PUTLINE OUTPUT=(DSNISLF,SINGLE,DATA),MF=(E,IOPLSECT)    L>256
         B     CHKCNTRL                                          L>256
ERRORU   DS    0H
         PUTLINE OUTPUT=(DSNISU,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED DUE TO
*                                      UNDEFINED RECORD FORMAT MESSAGE
         B     EXIT                    GO SEE IF INPUT DCB IS OPEN
ERRI     DS    0H
         PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED DUE TO SYNAD
*                                      ERROR ON INPUT DATASET MESSAGE
         B     EXIT                    GO SEE IF INPUT DCB IS OPEN
ERRO     DS    0H
         PUTLINE OUTPUT=(SYNADO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED DUE TO
*                                      UNDEFINED RECORD FORMAT MESSAGE
         B     CLOSDCBS                GO CLOSE OPEN DCBS AND RETURN
*                                                                     *
***********************************************************************
*                                                                     *
*        READ THE DIRECTORY OF A PDS                                  *
*           THEN EITHER LIST MEMBER NAMES,                            *
*           PRINT MEMBERS,                                            *
*           OR LIST MEMBER NAMES AND PRINT MEMBERS                    *
*                                                                     *
***********************************************************************
*
SCROLLIT DS    0H
         ST    R6,SAVER6               SAVE REGISTER 6
         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER
         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL
         CLC   PLIST,HALF2             SEE IF NOLIST SPECIFIED
         BL    CONTSCR                 LOW....CONTINUE WITH SCROLL
         CLC   PPRINT,HALF2            SEE IF NOPRINT SPECIFIED
         BE    CONTINUE                YES....SKIP SCROLL
         DROP  R9                      DROP ADDRESSABILITY TO PDL
CONTSCR  DS    0H
         LA    R8,DIRECT               LOAD POINTER TO DIRECTORY DCB
         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB
         MVC   DIRECT(DIRECTL),DIRECTC MOVE DIRECTORY DCB CONSTANT INTO
*                                      DIRECTORY DCB IN WORKAREA
         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO OPEN LIST IN WORKAREA
         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN DIRECTORY DCB
         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY
         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED
*                                      MESSAGE
         DROP  R8                      DROP ADDRESSABILITY TO DCB
*                                                                     *
***********************************************************************
*                                                                     *
*        GETMAIN MEMBER TABLE FOR STORAGE OF DIRECTORY NAMES, ETC.    *
*           INITIALIZE TABLE                                          *
*                                                                     *
***********************************************************************
*
         L     R0,MEMDATL              LOAD LENGTH OF GETMAIN FOR
*                                      MEMBER TABLE
         LR    R2,R0                   SAVE IN REGISTER 2
         GETMAIN R,LV=(0)              GETMAIN MEMBER TABLE STORAGE
         ST    R1,MEMTABLE             SAVE ADDRESS OF MEMBER TABLE
         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE
*                                      IN USE
         LA    R3,0(R2,R1)             LOAD ADDRESS OF END OF TABLE
         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END
         SLR   R4,R4                   ZERO REGISTER 4
         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER
*                                      TABLE
         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO
*                                      THE FIRST ENTRY
         USING MEMDSECT,R4             ESTABLISH ADDRESSABILITY TO
*                                      MEMBER TABLE DSECT
         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO
*                                                                     *
***********************************************************************
*                                                                     *
*        READ DIRECTORY AND BUILD MEMBER TABLE                        *
*                                                                     *
***********************************************************************
*
GETDIR   EQU   *
         GET   (R8),DATA               GET A DIRECTORY BLOCK
         CLC   DATA,HALF12             SEE IF BLOCK IS UNUSED
         BL    FREEBLK                 YES....GO HANDLE DIRECTORY END
         LA    R9,DATA+2               LOAD POINTER TO FIRST DIRECTORY
*                                      ENTRY
         SLR   R7,R7                   ZERO REGISTER 7 FOR INSERT
         ICM   R7,3,DATA               INSERT LENGTH USED OF THIS BLOCK
         LA    R7,DATA-1(R7)           LOAD LAST USED BYTE OF BLOCK
UNBLOCK  DS    0H
         MVC   MEMNTTR,0(R9)           PUT NAME AND TTR IN TABLE
         MVC   CFIELD,11(R9)           PUT C FIELD IN TABLE
         CLI   MEMBER,HEXFF            SEE IF LAST MEMBER
         BE    FREEBLK                 YES....GO HANDLE DIRECTORY END
         IC    R6,CFIELD               INSERT CFIELD INTO REGISTER 6
         SLL   R6,27                   SHIFT OUT HIGH ORDER BITS
         SRL   R6,26                   SHIFT RIGHT TO GET LENGTH OF
*                                      USER DATA
         LA    R6,12(R6)               ADD STANDARD ENTRY LENGTH
         LA    R4,MEMSECTN             LOAD PINTER TO NEXT TABLE ENTRY
         LA    R5,1(R5)                INCREMENT NUMBER OF MEMBERS IN
*                                      TABLE
         C     R4,ENDTABLE             SEE IF END OF TABLE
         BL    NEXTNTRY                LOW.....GO PROCESS NEXT ENTRY
         LR    R0,R2                   LOAD LENGTH OF TABLE FOR GETMAIN
         GETMAIN R,LV=(0)              GET NEXT TABLE
         L     R14,PRESENT             LOAD REGISTER 14 WITH ADDRESS OF
*                                      LAST TABLE
         ST    R1,0(R14)               CHAIN MEMBER TABLES TOGETHER
         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE
*                                      IN USE
         LA    R3,0(R2,R1)             LOAD ADDRESS OF TABLE END
         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END
         SLR   R4,R4                   ZERO REGISTER 4
         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER
*                                      TABLE
         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO
*                                      THE FIRST ENTRY
         STH   R5,4(R14)               STORE MEMBER COUNT IN OLD TABLE
         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO
NEXTNTRY DS    0H
         BXLE  R9,R6,UNBLOCK           INCREMENT REGISTER 9 WITH
*                                      REGISTER 6 AND BRANCH
*                                      LESS THAN OR EQUAL TO
*                                      REGISTER 7 TO UNBLOCK
         B     GETDIR                  NO.....GO GET NEXT DIRECTORY
*                                      BLOCK
         DROP  R4                      DROP ADDRESSABILITY TO TABLE
*
***********************************************************************
*                                                                     *
*        LIST MEMBERS IF:                                             *
*           LIST SPECIFIED OR                                         *
*           BOTH PRINT AND NOLIST WERE NOT SPECIFIED                  *
*                                                                     *
***********************************************************************
*
FREEBLK  DS    0H
         MVC   OPENLST,OPENCLOS        MOVE CONSTANT INTO CLOSE LIST
         CLOSE ((R8),),MF=(E,OPENLST)  CLOSE DIRECTORY DCB
         L     R2,PRESENT              LOAD POINTER TO LAST TABLE
         STH   R5,4(R2)                STORE COUNT OF MEMBERS
         L     R4,MEMTABLE             LOAD POINTER TO FIRST TABLE
         CLC   4(2,R4),HALF0           SEE IF THERE WERE ANY MEMBERS
         BE    ENDMEMB                 ZERO...GO FREE MEMBER TABLE
         LA    R8,INPUT                LOAD POINTER TO INPUT DCB
         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB
         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO
*                                      INPUT DCB IN WORKAREA
         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO OPEN LIST IN WORKAREA
         LA    R1,XLIST                LOAD ADDRESS OF EXIT LIST
         ST    R1,DCBEXLST             STORE ADDRESS OF EXIT LIST IN
*                                      DCB
         LA    R1,SEXIT                LOAD ADDRESS OF EODAD EXIT
         ST    R1,DCBEODAD             STORE ADDRESS EODAD IN DCB
         LA    R2,JFCBAREA             LOAD ADDRESS OF JFCBAREA
         ST    R2,XLIST                STORE ADDRESS IN EXIT LIST
         MVI   XLIST,X'87'             SET END OF LIST AND JFCB BYTE
         MVC   RDJL,OPENCLOS           MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO READJFCB LIST IN
*                                      WORKAREA
         RDJFCB (INPUT,),MF=(E,RDJL)   READ JFCB INTO JFCBAREA
         MVC   JFCBELNM,8(R4)          MOVE MEMBER NAME INTO JFCB
         OI    JFCBIND1,JFCPDS         SET JFCB TO INDICATE PDS MEMBER
         MVI   JFCDSRG1,HEX00          SET JFCB TO REMOVE OTHER DSORG
*                                      INDICATORS
         OPEN  ((R8),INPUT),TYPE=J,MF=(E,OPENLST)  OPEN INPUT DCB
         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER
         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL
         CLC   PLIST,HALF2             SEE IF NOLIST SPECIFIED
         BE    NOLIST                  YES....SKIP LISTING
         CLC   PLIST,HALF1             SEE IF LIST SPECIFIED
         BE    LISTIT                  YES....GO LISTIT
         CLC   PPRINT,HALF1            SEE IF PRINT SPECIFIED
         BE    NOLIST                  YES....SKIP LISTING
         DROP  R9                      DROP ADDRESSABILITY TO PDL
LISTIT   DS    0H
         MVC   HEADER,HEADERM          MOVE HEADER INTO DATA AREA
         TM    DCBRECFM,DCBRECCM       SEE IF CONTROL IS MACHINE
         DROP  R8                      DROP ADDRESSABILITY TO DCB
         BNO   SUSEA                   NO.....GO TO USE ASA CONTROL
         LA    R5,OUTPUTM              LOAD ADDRESS OF OUTPUT DCB FOR
*                                      MACHINE CODE
         LA    R4,EJECTM               LOAD ADDRESS OF EJECT DATA
         MVI   HDRCNTL,SKIPM           MOVE INTO HEADER MACHINE CODE
*                                      FOR SPACE
         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN
         BO    SPUTDSN                 YES....GO PUT OUT HEADERS
         LA    R3,PRINTM               LOAD POINTER TO PRINTM
         LA    R14,SPUTDSN             LOAD ADDRESS FOR RETURN FROM
*                                      SYSOUT ALLOCATION
         B     ALLOCOUT                GO TO ALLOCATE SYSOUT
SUSEA    DS    0H
         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR
*                                      ASA CODE
         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA
         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN
         BO    SPUTDSN                 YES....GO PUT OUT HEADERS
         LA    R3,PRINTA               LOAD POINTER TO PRINTA
         BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO
*                                      DO SYSOUT ALLOCATION
SPUTDSN  DS    0H
         PUT   (R5),(R4)               PUT OUT PAGE EJECT
         AP    #OFLINES,=P'9'          ADD NUMBER OF HEADINGS      AK#3
         MVC   HEADER,HEADERB1         MOVE BANNER INTO DATA AREA  AK#2
         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER       AK#2
         MVC   HEADER,HEADERB2         MOVE BANNER INTO DATA AREA  AK#2
         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER       AK#2
         MVC   HEADER,HEADERM          MOVE HEADER INTO DATA AREA  AK#2
         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER       AK#2
         LA    R1,4                    LOAD USERLINE PROCESSING ID AK#8
         BAL   R14,XTRARTN             GO PERFORM XTRARTN          AK#8
         MVC   HEADER,HEADERT          MOVE TIME/DATE TO DATA AREA AK#2
         BAL   R14,DATERTN1            GO PERFORM DATE ROUTINE     AK#2
         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER       AK#2
         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME='   AK#2
*                                      INTO SECOND HEADER          AK#2
         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE        AK#2
         LA    R14,DSNAME              LOAD START OF DATASET NAME  AK#2
         AH    R14,DSNLEN#             ADD DATASET LENGTH          AK#2
         MVI   4(R14),C' '             MOVE BLANK                  AK#2
         MVC   5(7,R14),4(R14)         CLEAR FOR SHORT MEMBER NAME AK#2
         CLI   MEMNAME,BLANK           SEE IF MEMBER NAME IS BLANK AK#2
         MVI   0(R14),C''''            CLOSE OFF MEMBER            AK#2
         LA    R14,1(R14)              ADD ' TO LENGTH             AK#2
         LA    R15,HEADER2             LOAD START OF HEADER        AK#2
         SR    R14,R15                 GET LENGTH OF DATA          AK#2
         CH    R14,=H'68'              Q. EXTEND PAST BANNER '*'   AK#2
         BNL   PUTHDR2B                   Y. BYPASS                AK#2
         LH    R14,=H'68'              SET LENGTH OF DATA          AK#2
         AR    R15,R14                 POINT PAST END OF DATA      AK#2
         BCTR  R15,0                   POINT TO LAST BYTE POSITION AK#2
         MVI   0(R15),C'*'             CLOSE OFF BANNER            AK#2
PUTHDR2B DS    0H                                                  AK#2
         STH   R14,HEADER2             STORE LENGTH OF DATA        AK#2
         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2     AK#2
         MVC   HEADER,HEADERB2         MOVE BANNER 2 INTO DATA AREAAK#2
         PUT   (R5),HEADER             PUT OUT BANNER 2 HEADER     AK#2
         MVC   HEADER,HEADERB1         MOVE BANNER 1 INTO DATA AREAAK#2
         PUT   (R5),HEADER             PUT OUT BANNER 1 HEADER     AK#2
         L     R2,MEMTABLE             LOAD ADDRESS OF FIRST TABLE
         MVC   LENGTH,HALF85           SET LENGTH TO 85 BYTES
         MVC   LENGTH+2,HALF0          ZERO RESERVED BYTES
         MVC   CNTLBYTE,HDRCNTL        MOVE IN HEADER CONTROL BYTE
*
***********************************************************************
*                                                                     *
*        LIST MEMBER NAMES                                            *
*                                                                     *
***********************************************************************
*
SCROLLER DS    0H
         LA    R10,LINECNT             LOAD LINE COUNT
         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE
         LH    R7,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE
         LTR   R7,R7                   SEE IF THERE ARE ENTRIES
         BZ    NOLIST                  NO.....GO PRINT MEMBERS
         LA    R2,8(R2)                LOAD ADDRESS OF FIRST MEMBER
         USING MEMDSECT,R2             ESTABLISH ADDRESSABILITY TO
*                                      MEMBER TABLE ENTRY
LOOP1    DS    0H
         LA    R6,DATA                 LOAD ADDRESS OF OUTPUT BUFFER
         MVI   DATA,BLANK              BLANK OUT OUTPUT BUFFER
         MVC   DATA+1(79),DATA         FINISH BLANKING BUFFER
         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS
         BZ    NOTALIAS                NO.....CONTINUE WITH MAIN NAME
         BAL   R14,LOOKLOOP            GO LOOK FOR MAIN NAME
NOTALIAS DS    0H
         MVC   2(8,R6),MEMBER          PUT MEMBER NAME IN OUTPUT BUFFER
         ST    R2,SAVER2               SAVE REGISTER 2
         LA    R3,2                    LOAD NUMBER OF COLUMNS LEFT
         LA    R8,1                    LOAD ENTRY NUMBER
LOOP2    LA    R8,LINECNT(R8)          LOAD POINTER TO NEXT COLUMN
*                                      ENTRY
         CR    R8,R7                   SEE IF VALID ENTRY
         BH    END2                    NO.....GO PRINT LINE
         LA    R2,LINECNT*12(R2)       LOAD POINTER TO MEMBER NAME
         LA    R6,30(R6)               LOAD POINTER TO NEXT OUTPUT
*                                      BUFFER LOCATION
         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS
         BZ    NOTAL2                  NO.....CONTINUE WITH MAIN NAME
         BAL   R14,LOOKLOOP            GO LOOK FOR MAIN NAME
NOTAL2   DS    0H
         MVC   2(8,R6),MEMBER          PUT MEMBER NAME IN OUTPUT BUFFER
         BCT   R3,LOOP2                DECREMENT COLUMN COUNT
END2     DS    0H
         PUT   (R5),LINE               PUT OUT OUTPUT LINE
         AP    #OFLINES,=P'1'          INCREMENT LINES PRINTERD    AK#3
         L     R2,SAVER2               RELOAD REGISTER 2
         LA    R2,MEMSECTN             LOAD POINTER TO NEXT MEMBER NAME
         BCT   R10,MOREROW             DECREMENT ROW COUNT
         PUT   (R5),(R4)               PUT OUT PAGE EJECT WHEN ZERO
         AP    #OFLINES,=P'1'          INCREMENT LINES PRINTERD    AK#3
         B     LOOP3                   RESET COUNTERS
MOREROW  DS    0H
         BCT   R7,LOOP1                DECREMENT MEMBER COUNT FOR
*                                      CURRENT TABLE
LOOP3    L     R2,PRESENT              LOAD POINTER TO CURRENT TABLE
         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE
         LTR   R2,R2                   SEE IF IT WAS THE LAST TABLE
         BNZ   SCROLLER                NO.....GO LIST OUT NEXT TABLE
*
***********************************************************************
*                                                                     *
*        PRINT MEMBERS IF:                                            *
*           PRINT SPECIFIED OR                                        *
*           BOTH LIST AND NOPRINT WERE NOT SPECIFIED                  *
*                                                                     *
***********************************************************************
*
NOLIST   DS    0H
         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER
         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL
         CLC   PPRINT,HALF2            SEE IF NOPRINT SPECIFIED
         BE    ENDMEMB                 YES....GO SKIP PRINT
         CLC   PPRINT,HALF1            SEE IF PRINT SPECIFIED
         BE    CONTPRT                 YES....GO PRINT MEMBERS
         CLC   PLIST,HALF1             SEE IF LIST SPECIFIED
         BE    ENDMEMB                 YES....GO SKIP PRINT
         DROP  R9                      DROP ADDRESSABILITY TO PDL
CONTPRT  DS    0H
         L     R6,SAVER6               RESTORE REGISTER 6
         LA    R8,INPUT                LOAD ADDRESS OF INPUT DCB
         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB
         TM    DCBRECFM,DCBRECU        SEE IF RECFM IS UNDEFINED
         BO    ERRORU                  NO.....GO PUT OUT ERROR MESSAGE
         BZ    ERRORU                  ZERO...NOT FIXED OR VARIABLE SO
*                                      GO PUT OUT ERROR MESSAGE
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST IN WORKAREA
         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB
         DROP  R8                      DROP ADDRESSABILITY TO INPUT DCB
*        PUTLINE OUTPUT=(PRTMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET PRINT MESSAGE
*        LH    R4,4(R6)                LOAD LENGTH OF DSNAME
*        A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE
*        SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES
*        STCM  R4,15,DSNLENP           STORE LENGTH OF PUTLINE
*        PUTLINE OUTPUT=(DSNLENP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATA SET NAME MESSAGE
         L     R2,MEMTABLE             LOAD ADDRESS OF FIRST MEMBER
*                                      TABLE
         LH    R3,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE
         LTR   R3,R3                   SEE IF THERE ARE ANY MEMBERS
         BZ    ENDMEMB                 NO.....GO TO END OF SCROLLER
         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE
         LA    R2,8(R2)                LOAD POINTER TO MEMBER NAME
NEXTMEMB DS    0H
         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS ENTRY
         BO    AGAIN                   YES....DO NOT PRINT IT
PRINTMEM DS    0H
         MVC   MEMNAME,MEMBER          MOVE MEMBER NAME INTO HEADER
         MVC   JFCBELNM,MEMBER         MOVE MEMBER NAME INTO JFCBAREA
         MVC   OPENLST,OPENCLOS        MOVE CONSTANT INTO OPEN LIST
         OPEN  ((R8),INPUT),TYPE=J,MF=(E,OPENLST)
*                                      OPEN INPUT DCB
         STM   R2,R3,SAVER2            SAVE REGISTERS 2 AND 3
         B     PRINTS                  GO PRINT MEMBER
SEXIT    DS    0H
         LM    R2,R3,SAVER2            RESTORE REGISTERS 2 AND 3
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST IN WORKAREA
         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB
AGAIN    DS    0H
         LA    R2,MEMSECTN             LOAD ADDRESS OF NEXT MEMBER
         BCT   R3,NEXTMEMB             BRANCH TO HANDLE NEXT MEMBER
         L     R14,PRESENT             ZERO...LOAD CURRENT TABLE
*                                      ADDRESS
         L     R2,0(R14)               LOAD ADDRESS OF NEXT TABLE
         LTR   R2,R2                   SEE IF ZERO, LAST TABLE
         BZ    ENDMEMB                 NO.....GO HANDLE END OF MEMBERS
         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE
         LH    R3,4(R2)                LOAD NUMBER OF MEMBERS IN NEXT
*                                      TABLE
         LTR   R3,R3                   SEE IF ANY MEMBERS IN TABLE
         BZ    ENDMEMB                 NO.....GO HANDLE END OF MEMBERS
         LA    R2,8(R2)                LOAD POINTER TO MEMBER NAME
         B     NEXTMEMB                GO GET NEXT MEMBER
ENDMEMB  DS    0H
         L     R2,MEMTABLE             LOAD POINTER TO FIRST TABLE
FREETABS DS    0H
         LR    R1,R2                   LOAD AREA TO BE FREED
         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE
         L     R0,MEMDATL              LOAD SIZE OF AREA TO BE FREED
         FREEMAIN R,LV=(0),A=(1)       FREE STORAGE GETMAINED FOR TABLE
         LTR   R2,R2                   SEE IF THERE WAS ANOTHER TABLE
         BNZ   FREETABS                YES....GO FREE NEXT TABLE
         L     R6,SAVER6               RESTORE REGISTER 6
         LA    R8,INPUT                LOAD POINTER TO INPUT DCB
         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB
         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN
         BNO   EXITMSG                 NO.....GO HANDLE NEXT DATASET
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST IN WORKAREA
         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB
         DROP  R8                      DROP ADDRESSABILITY TO DCB
         B     EXITMSG                 GO HANDLE NEXT DATASET
*                                                                     *
***********************************************************************
*                                                                     *
*        PUT OUT SYNAD ERROR MESSAGE,                                 *
*           GO FREE MEMBER TABLES, AND                                *
*           CONTINUE WITH NEXT DATASET                                *
*                                                                     *
***********************************************************************
*
SERRI    DS    0H
         PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED DUE TO SYNAD
*                                      ERROR ON INPUT DATASET MESSAGE
         B     ENDMEMB                 GO FREE MEMBER TABLES
*                                                                     *
***********************************************************************
*                                                                     *
*        SEARCH FOR MAIN NAME,                                        *
*           SAME TTR AND NOT AN ALIAS                                 *
*                                                                     *
***********************************************************************
*
LOOKLOOP DS    0H
         STM   R3,R4,SAVER3            SAVE REGISTERS 3 AND 4
         L     R3,MEMTABLE             LOAD ADDRESS OF FIRST TABLE
         USING MEMDSECT,R3             ESTABLISH ADDRESSABILITY TO
*                                      MEMBER ENTRY
LOOP4    DS    0H
         ST    R3,CURRENT              SAVE ADDRESS OF PRESENT TABLE
         LH    R4,4(R3)                LOAD NUMBER OF ELEMENTS IN TABLE
         LTR   R4,R4                   SEE IF THERE ARE ZERO ELEMENTS
         BZ    NOMAIN                  YES....GO HANDLE MAIN NOT FOUND
         LA    R3,8(R3)                LOAD ADDRESS OF FIRST MEMBER
LOOP5    DS    0H
         CLC   MEMTTR,8(R2)            SEE IF TTRS ARE THE SAME
         BE    SAMETTR                 YES....GO SEE IF IT IS AN ALIAS
ENDLP5   DS    0H
         LA    R3,MEMSECTN             LOAD ADDRESS OF NEXT MEMBER
         BCT   R4,LOOP5                DECREMENT MEMBER COUNT
         L     R3,CURRENT              LOAD ADDRESS OF THIS TABLE
         L     R3,0(R3)                LOAD ADDRESS OF NEXT TABLE
         LTR   R3,R3                   SEE IF IT WAS THE LAST TABLE
         BNZ   LOOP4                   NO.....GO CHECK NEXT TABLE
         B     NOMAIN                  GO HANDLE MAIN NOT FOUND
SAMETTR  DS    0H
         TM    CFIELD,HIGH             SEE IF THIS IS ALSO AN ALIAS
         BO    ENDLP5                  YES....GO LOOK FOR ANOTHER TTR
         MVC   11(8,R6),MEMBER         MOVE MEMBER NAME INTO OUTPUT
         B     ENDLOOK                 GO TO RETURN TO CALLER
NOMAIN   DS    0H
         MVC   11(8,R6),ALIAS          INDICATE THIS IS AN ALIAS
ENDLOOK  DS    0H
         LM    R3,R4,SAVER3            RESTORE REGISTERS 3 AND 4
         BR    R14                     RETURN TO CALLER
         DROP  R3                      DROP ADDRESSABILITY TO TABLE
*
CONTINUE DS    0H
         L     R6,24(R6)               LOAD POINTER TO NEXT DSNAME ON
*                                      CHAIN
         C     R6,ENDCHAIN             SEE IF END OF CHAIN IS REACHED
         BNE   NEXT                    NO.....GO DO NEXT DATASET NAME
CLOSDCBS DS    0H
         TM    INPUT+48,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN
         BNO   FREEI                   NO.....GO FREE INPUT DCB   FREEI
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST WORKAREA
         LA    R5,INPUT                LOAD POINTER TO INPUT DCB
         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE INPUT DCB
FREEI    DS    0H                                                 FREEI
         LA    R1,PRINTI               LOAD ADDRESS OF INPUT DDNAME
         BAL   R2,FREEDD               GO FREE INPUT DDNAME       FREEI
         TM    OUTPUTA+48,DCBOFOPN     SEE IF OUTPUT DCB FOR ASA WAS
*                                      OPENED
         BNO   CHKOUTM                 NO.....GO CHECK DCB FOR MACHINE
*                                      CODE
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST WORKAREA
         LA    R5,OUTPUTA              LOAD POINTER TO ASA CODE DCB
         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE ASA CODE OUTPUT DCB
         LA    R1,PRINTA               LOAD ADDRESS OF PRINT DDNAME
         BAL   R2,FREEDD               GO FREE ASA CODE OUTPUT DDNAME
CHKOUTM  DS    0H
         TM    OUTPUTM+48,DCBOFOPN     SEE IF OUTPUT DCB FOR MACHINE
*                                      CODE WAS OPENED
         BNO   RETURN                  NO.....GO FREE GETMAINED AREAS
*                                      AND RETURN
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST WORKAREA
         LA    R5,OUTPUTM              LOAD POINTER TO MACHINE CODE DCB
         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE MACHINE CODE OUTPUT DCB
         LA    R1,PRINTM               LOAD ADDRESS OF PRINT DDNAME
         BAL   R2,FREEDD               GO FREE MACHINE CODE OUTPUT
*                                      DDNAME
*
***********************************************************************
*                                                                     *
*        CLEANUP AREAS GETMAINED BY PARS,                             *
*           SET RETURN CODE, RESTORE REGISTERS AND                    *
*           RETURN TO CALLER                                          *
*                                                                     *
***********************************************************************
*
RETURN   DS    0H
         IKJRLSA PARSBACK              RELEASE AREAS GETMAINED BY PARS
         LR    R1,R13                  LOAD ADDRESS OF GETMAINED AREA
         L     R13,4(,R13)             RELOAD ADDRESS OF PREVIOUS SAVE
*                                      AREA
         LA    R0,LDYNAMIC             LOAD LENGTH OF GETMAINED AREA
         FREEMAIN R,LV=(0),A=(1)       FREE GETMINED AREA
         SLR   R15,R15                 ZERO REGISTER 15.  RETURN CODE
*                                      CODE WILL ALWAYS BE ZERO
         L     R14,12(,R13)            LOAD REGISTER 14 WITH RETURN
*                                      ADDRESS
         LM    R0,R12,20(R13)          RESTORE REGISTERS
         BR    R14                     RETURN
*
***********************************************************************
*                                                                     *
*        ROUTINE TO CONVERT NONZERO RETURN CODES TO DECIMAL           *
*           FOR DISPLAY                                               *
*                                                                     *
***********************************************************************
*
SETCODE  DS    0H
         CVD   R8,DEC                  CONVERT RETURN CODE TO DECIMAL
         UNPK  CONV(8),DEC(8)          UNPACK RETURN CODE
         MVZ   CONV+1(7),CONV          MOVE ZONES IN CONVERTED RETURN
*                                      CODE
         MVC   RETNCD(2),HALF12        MOVE LENGTH OF DATA FOR PUTLINE
         MVC   RETNCD+2(2),HALF0       MOVE IN ZEROES FOR PUTLINE
         BR    R14                     RETURN
*
***********************************************************************
*                                                                     *
*        FREE AND REALOCATE PRINTX FILE AS SYSOUT                     *
*                                                                     *
***********************************************************************
*
ALLOCOUT DS    0H
         STM   14,9,ALCSAVE            SAVE WORK REGISTERS
         LR    R1,R3                   LOAD POINTER TO DDNAME
         BAL   R2,FREEDD               BRANCH TO FREE ROUTINE
         LTR   R8,R8                   SEE IF RETURN CODE FROM FREE IS
*                                      ZERO
         BNZ   OPENFAIL                NO.....GO PUT OUT OPEN FAILED
         LA    R8,REQBLK               LOAD POINTER TO REQUEST BLOCK
         ST    R8,RBPTR                INITIALIZE REQUEST BLOCK POINTER
         MVI   RBPTR,S99RBPND          INDICATE END OF PARAMETER LIST
         USING S99RB,R8                ESTABLISH ADDRESSABILITY TO
*                                      REQUEST BLOCK
         MVC   S99RBLN(RBLEN),REQBLKC  INITALIZE RB
         LA    R1,TEXTPTRS             LOAD POINTER TO TEXT POINTERS
         ST    R1,S99TXTPP             STORE POINTER IN RB
         DROP  R8                      DROP ADDRESSABILITY TO RB
         USING S99TUPL,R1              ESTABLISH ADDRESSABILITY TO
*                                      TEXT UNIT POINTER LIST
         LA    R2,TEXTA                LOAD POINTER TO FIRST TEXT UNIT
         ST    R2,S99TUPTR             STORE POINTER IN TUPL
         USING S99TUNIT,R2             ESTABLISH ADDRESSABILITY TO
*                                      TEXT UNIT
         MVC   S99TUKEY(TEXTALEN),TEXTAC  INITIALIZE TEXT UNIT A
         MVC   S99TUPAR(8),0(R3)       MOVE IN PARAMETER (DDNAME)
         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT
*                                      POINTER
         LA    R2,TEXTB                LOAD POINTER TO TEXT UNIT B
         ST    R2,S99TUPTR             STORE POINTER IN TUPL
         MVC   S99TUKEY(TEXTBLEN),TEXTBC  INITIALIZE TEXT UNIT B
*
***********************************************************************
*                                                                     *
*        SET UP ADDRESSABILITY TO PDL                                 *
*           AND SEE IF SYSOUT CLASS/DEST ARE PRESENT                  *
*                                                                     *
***********************************************************************
*
         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER
         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL
         CLC   PCLASS(2),HALF1         SEE IF CLASS SPECIFIED
         BNE   NOCLASS2                NO.....GO CHECK FOR DESTINATION
         L     R7,SCLASS               LOAD POINTER TO SYSOUT CLASS
         MVC   S99TUPAR,0(R7)          MOVE CLASS INTO TEXT UNIT B
*--------------------------- AK#1 ------------------------------------*
*                                                                  AK#1
*    MODIFY THIS BLOCK FOR CLASS CHANGES                           AK#1
*                                                                  AK#1
*---------------------------------------------------------------------*
VALCLASS DS    0H                                                  AK#1
*        LA    R15,VCLASSL             LOAD LENGTH OF VALID CLASSESAK#6
*        LA    R14,VCLASS              LOAD START OF VALID CLASSES AK#6
         ST    R1,RETNCD               SAVE R1 POINTER             AK#6
         LOAD  EP=PRINTCLS             LOAD VALID PRINT CLASSES    AK#6
         LR    R15,R0                  LOAD ENTRY POINT TO PROGRAM AK#6
         LA    R14,4(R15)              POINT TO CLASS LIST         AK#6
         L     R15,0(R15)              LOAD NUMBER OF CLASSES AVAILAK#6
         LR    R1,R15                  LOAD LENGTH OF CLASSES      AK#6
         CH    R1,=H'54'               Q. LENGTH LESS THAN 54      AK#6
         BNH   CONTCLMV                   Y. GO AND MOVE           AK#6
         LH    R1,=H'54'               SET MAX LENGTH              AK#6
CONTCLMV DS    0H                                                  AK#6
         BCTR  R1,0                    RELATIVE MOVE LENGTH        AK#6
         EX    R1,MOVEVCLS             MOVE VALID CLASSES          AK#6
         B     VCLASSLP                BRANCH PAST EXECUTE INST    AK#6
MOVEVCLS MVC   INVCLASV(0),0(R14)      MOVE VALID CLASSES          AK#6
VCLASSLP DS    0H                                                  AK#6
         CLC   S99TUPAR(1),0(R14)      Q. CLASS ENTERED IN TABLE   AK#6
         BE    NOCLASS1                   Y...GO CHECK FOR DEST    AK#6
         LA    R14,2(R14)              POINT TO NEXT TABLE ENTRY   AK#6
         BCT   R15,VCLASSLP            LOOP TILL END OF TABLE      AK#6
         DELETE EP=PRINTCLS            DELETE PRINT CLASSES
         PUTLINE OUTPUT=(INVCLAS,SINGLE,DATA),MF=(E,IOPLSECT)  PUT AK#1
*                                      INVALID CLASS               AK#1
*                                      MESSAGE                     AK#1
         PUTLINE OUTPUT=(DSNNOTP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT AK#1
*                                      DATASET NOT PRINTED MESSAGE AK#1
         B     CLOSDCBS                GO CLOSE DCBS AND RETURN    AK#1
*--------------------------- AK#1 ------------------------------------*
NOCLASS1 DS    0H
         DELETE EP=PRINTCLS            DELETE PRINT CLASSES
         L     R1,RETNCD               RESTORE R1 POINTER
NOCLASS2 DS    0H
         MVC   OUTCLASS,S99TUPAR       MOVE CLASS FOR LATER USE    AK#3
         CLC   PDEST(2),HALF1          SEE IF DEST SPECIFIED
         BNE   NODEST                  NO.....GO CHECK FOR HOLD
         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT
*                                      POINTER
         LA    R2,TEXTC                LOAD POINTER TO TEXT UNIT C
         ST    R2,S99TUPTR             STORE POINTER IN TUPL
         MVC   S99TUKEY(TEXTCLEN),TEXTCC  INITIALIZE TEXT UNIT C
         L     R7,SDEST                LOAD POINTER TO DESTINATION
         LH    R6,SDEST+4              LOAD LENGTH OF DESTINATION ID
         STH   R6,S99TULNG             STORE LENGTH OF DEST IN TU
         BCTR  R6,0                    DECREMENT LENGTH FOR EXECUTE OF
*                                      MOVE
         EX    R6,MOVEDEST             MOVE DEST INTO TU
MOVEDEST MVC   S99TUPAR,0(R7)          MOVE TO BE EXECUTED
*
NODEST   DS    0H
         CLC   PHOLD(2),HALF1          SEE IF HOLD SPECIFIED
         BNE   NOHOLD                  NO.....GO CHECK FOR COPIES
         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT
*                                      POINTER
         LA    R2,TEXTDC               LOAD POINTER TO TEXT UNIT C
         ST    R2,S99TUPTR             STORE POINTER IN TUPL
NOHOLD   DS    0H
         CLC   PCOPIES(2),HALF1        SEE IF COPY SPECIFIED
         BNE   NOCOPY                  NO.....GO CHECK FCB         AK#7
         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT
*                                      POINTER
         LA    R2,TEXTE                LOAD POINTER TO TEXT UNIT E
         ST    R2,S99TUPTR             STORE POINTER IN TUPL
         MVC   S99TUKEY(TEXTELEN),TEXTEC  INITIALIZE TEXT UNIT E
         L     R7,SCOPIES              LOAD POINTER TO COPY FIELD
         LH    R6,SCOPIES+4            LOAD LENGTH OF COPY FIELD
         BCTR  R6,0                    DECREMENT REGISTER 6 FOR EXECUTE
*                                      OF PACK INSTRUCTION
         EX    R6,PACKCOPY             EXECUTE PACK TO CONVERT COPIES
*                                      TO ZONED DECIMAL
         CVB   R6,DEC                  CONVERT ZONED TO BINARY
         STCM  R6,1,S99TUPAR           STORE NUMBER OF COPIES IN TU
NOCOPY   DS    0H
         CLC   PFCB(2),HALF1           SEE IF FCB SPECIFIED        AK#7
         BNE   NOFCB                   NO.....GO ZERO ECB          AK#7
         LA    R1,4(R1)                LOAD PTR TO NEXT TEXT UNIT  AK#7
*                                      POINTER                     AK#7
         LA    R2,TEXTF                LOAD POINTER TO TEXT UNIT F AK#7
         ST    R2,S99TUPTR             STORE POINTER IN TUPL       AK#7
         MVC   S99TUKEY(TEXTFLEN),TEXTFC  INITIALIZE TEXT UNIT F   AK#7
         L     R7,SFCB                 LOAD POINTER TO FCB         AK#7
         LH    R6,SFCB+4               LOAD LENGTH OF FCB          AK#7
         STH   R6,S99TULNG             STORE LENGTH OF DEST IN TU  AK#7
         BCTR  R6,0                    DECREMENT LENGTH FOR        AK#7
*                                        EXECUTION OF MOVE         AK#7
         EX    R6,MOVEFCB              MOVE FCB INTO TU            AK#7
         B     NOFCB                   BYPASS 'EX' COMMAND         AK#7
MOVEFCB  MVC   S99TUPAR,0(R7)          MOVE TO BE EXECUTED         AK#7
NOFCB    DS    0H                                                  AK#7
         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT
*                                      POINTER
         LA    R2,TEXTGC               LOAD POINTER TO TEXT UNIT G
*                                      PERMANENTLY ALLOCATED
*                                      ATTRIBUTE
         ST    R2,S99TUPTR             STORE POINTER IN TUPL
         MVI   S99TUPTR,S99TUPLN       INDICATE END OF TEXT UNIT
*                                      POINTER LIST
         DROP  R1,R2,R9                DROP ADDRESSABILITY TO DSECTS
         LA    R1,RBPTR                LOAD ADDRESS OF REQUEST BLOCK
*                                      POINTER
         DYNALLOC                      ISSUE DYNAMIC ALLOCATION SVC
         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO
         BNZ   ALCFAIL                 NO.....GO AND CALL DAIR FAIL
         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO WORKAREA
         OPEN  ((R5),(OUTPUT)),MF=(E,OPENLST)
*                                      OPEN OUTPUT DCB
         TM    48(R5),DCBOFOPN         SEE IF DCB OPENED SUCCESSFULLY
         BNO   OPENFAIL                NO.....GO PUT OUT OUTPUT DCB
*                                      NOT OPENED MESSAGE
         LM    14,9,ALCSAVE            RESTORE REGISTERS
         BR    R14                     RETURN TO CALLER
ALCFAIL  DS    0H
         LA    R1,REQBLK               LOAD ADDRESS OF REQUEST
*                                      BLOCK
         MVI   DFID+1,DFSVC99          SET DAIR FAIL FOR SVC 99 ERROR
         BAL   R2,DAIRFAIL             LOAD ADDRESS OF OPEN FAIL AND
*                                      BRANCH TO DAIRFAIL ROUTINE
OPENFAIL DS    0H
         PUTLINE OUTPUT=(OPENMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      OUTPUT DCB NOT OPEND MESSAGE
         S     R3,FULL4                GET POINTER TO PUTLINE DDNAME
         PUTLINE OUTPUT=((R3),SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DDNAME
         B     CLOSDCBS                GO CLOSE DCBS AND RETURN
*
***********************************************************************
*                                                                     *
*        INVOKE DAIR TO FREE FILENAME VIA CALLTSSR                    *
*           AND CHECK FOR ZERO RETURN CODE                            *
*                                                                     *
***********************************************************************
*
FREEDD   DS    0H
         SLR   R8,R8                   INITIALIZE REGISTER 8 TO ZERO
*                                      RETURN CODE
         MVC   DAP18(DAPB18L),DAPB18C  INITIALIZE DAIR PARAMETER BLOCK
*                                      18 (FREE BY DATASET)
         LA    R4,DAP18                LOAD ADDRESS OF DAPB
         USING DAPB18,R4               ESTABLISH ADDRESSABILITY TO
*                                      DAPB
         MVC   DA18DDN,0(R1)           MOVE DDNAME INTO DAPB
         SLR   R7,R7                   ZERO REGISTER 7
         ST    R7,ECB                  STORE REGISTER 7 AS DUMMY ECB
         LA    R1,DAPLSECT             LOAD ADDRESS OF DAPL
         USING DAPL,R1                 ESTABLISH ADDRESSABILITY TO DAPL
         ST    R4,DAPLDAPB             STORE ADDRESS OF DAPB IN DAPL
         DROP  R1,R4                   DROP ADDRESSABILITY TO DAPL AND
*                                      DAPB
         CALLTSSR EP=IKJDAIR           CALL DAIR TO FREE DDNAME
         C     R15,FULL28              SEE IF RETURN CODE IS 28
*                                      (DDNAME NOT ALLOCATED)
         BER   R2                      YES....GO CONTINUE PROCESSING
         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO
         BZR   R2                      YES....GO CONTINUE PROCESSING
         MVI   DFID+1,DFDAIR           SET DAIRFAIL ID TO INDICATE DAIR
*
***********************************************************************
*                                                                     *
*        INVOKE DAIRFAIL TO DISPLAY AN ERROR MESSAGE                  *
*                                                                     *
***********************************************************************
*
DAIRFAIL XC    DFPARMS(DFLEN),DFPARMS  INITIALIZE PARMLIST FOR DAIR
*                                      FAIL TO ZEROS
         ST    R1,DFDAPLP              STORE POINTER TO DAPL/RB IN
*                                      PARAMETER LIST
         ST    R15,RETCODE             STORE RETURN CODE
         LA    R1,RETCODE              LOAD ADDRESS OF RETURN CODE
         ST    R1,DFRCP                STORE POINTER TO RETURN CODE IN
*                                      PARAMETER LIST
         LA    R1,FULL0                LOAD ADDRESS OF FULLWORD OF
*                                      ZEROS
         ST    R1,DFJEFF02             STORE DUMMY POINTER TO IKJEFF02
*                                      IN PARMLIST
         LA    R1,DFID                 LOAD ADDRESS OF DAIR FAIL ID
*                                      FIELD
         ST    R1,DFIDP                STORE POINTER TO DFID IN
*                                      PARMLIST
         MVI   DFID,NOWTP              SET FOR NO WRITE TO PROGRAMMER
         L     R1,SAVEAREA+4           LOAD ADDRESS OF PEVIOUS
*                                      SAVEAREA
         L     R1,24(R1)               LOAD POINTER TO CPPL
         ST    R1,DFCPPLP              STORE POINTER TO CPPL IN
*                                      PARMLIST
         LINK  EP=IKJEFF18,MF=(E,DFPARMS)  LINK TO DAIR FAIL SERVICE
*                                      ROUTINE TO HANDLE RETURN
*                                      CODE
         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO
         BZR   R2                      YES....GO RETURN TO CALLER
         LR    R8,R15                  LOAD REGISTER 8 WITH RETURN CODE
         BAL   R14,SETCODE             GO CONVERT CODE TO DECIMAL
         PUTLINE OUTPUT=(DRFLERR,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DAIR FAIL ERROR MESSAGE
         PUTLINE OUTPUT=(RETNCD,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DECIMAL RETURN CODE
         BR    R2                      GO RETURN TO CALLER
*
******************** INSERT TIME AND DATE ROUTINE *********************
*--------------------------- AK#2 ---------------------------------AK#2
*                                                                  AK#2
*        CONVERT TIME AND DATE TO APPROPRIATE FORMAT FOR BANNER    AK#2
*        PAGE. TIME => HH:MM:SS, DATE => DD/MM/YY.....             AK#2
*                                                                  AK#2
*------------------------------------------------------------------AK#2
DATERTN1 DS    0H                                                  AK#2
         STM   R0,R14,SAVSUBR1         STORE REGISTERS             AK#2
         TIME  DEC                     GET TIME  => IN R0          AK#2
         ST    R0,TARGET               SAVE TIME IN WORKAREA       AK#2
*------------------------------------------------------------------AK#2
*        CONVERT HEX TO CHARACTERS.                                AK#2
*------------------------------------------------------------------AK#2
         SR    R5,R5                                               AK#2
         LA    R7,TARGET               SET UP TO SOURCE ADDRESS    AK#2
         LA    R8,TARGET+4             SET UP DEST ADDRESS         AK#2
         LA    R9,3                    LENGTH TO BE CONVERTED      AK#2
TDLOOP1  DS    0H                                                  AK#2
         IC    R5,0(R7)                LOAD 1 BYTE INTO REG        AK#2
         SRL   R5,4                    REMOVE RIGHT NIBBLE         AK#2
         STC   R5,TDBYTE1              ST BYTE WITH LEFT NIB RIGHT AK#2
         TR    TDBYTE1,TDTABL1         TRANS LEFT NIB USING TABLE  AK#2
         MVC   0(1,R8),TDBYTE1         MOVE BYTE TO DESTINATION    AK#2
         MVC   TDBYTE1,0(R7)           MOVE BYTE                   AK#2
         NI    TDBYTE1,15              TURN OFF LEFT NIBBLE        AK#2
         TR    TDBYTE1,TDTABL1         TRANS RIGTH NIBBLE          AK#2
         MVC   1(1,R8),TDBYTE1         MOVE TO DEST                AK#2
         LA    R7,1(R7)                POINT TO NEXT SOURCE CHAR   AK#2
         LA    R8,2(R8)                POINT TO NEXT DEST CHAR     AK#2
         BCT   R9,TDLOOP1              LOOP TILL END               AK#2
         MVC   TIMEOUT(2),TARGET+4     INSERT HH                   AK#2
         MVC   TIMEOUT+3(2),TARGET+6   INSERT MM                   AK#2
         MVC   TIMEOUT+6(2),TARGET+8   INSERT SS                   AK#2
*------------------------------------------------------------------AK#2
*    CALCULATE AND MOVE DATE                                       AK#2
*------------------------------------------------------------------AK#2
         MVC   TDDATE1(8),HDRCTLT+45   MOVE DATE TEMPLATE          AK#2
         MVC   TDTABLX,TDTABL2         MOVE LITERAL TO GET MAIN STGAK#2
*                                        AS TABLE IS CHANGED       AK#2
         TIME
         ST    R1,TARGET+4                                         AK#2
         UNPK  TDIDATE(5),TARGET+5(3)  UNPACK DATE                 AK#2
         PACK  TDYEAR,TDIDATE(2)       GET YEAR                    AK#2
         MVC   TDDATE1+6(2),TDIDATE    SET UP YEAR                 AK#2
         DP    TDYEAR,=P'4'            DIVIDE YEAR BY 4            AK#2
         CP    TDYEARR,=P'0'           Q. REMAINDER 0              AK#2
         BNE   TDLAB1                     N. NOT LEAP YEAR         AK#2
         MVC   TDTABLX+2(2),=X'029C'      Y. FEB = 29 DAYS         AK#2
TDLAB1   DS     0H                                                 AK#2
         LA    R9,1(R0)                SET MONTH COUNTER TO 1      AK#2
         LA    R8,TDTABLX              SET REG 8 AS MONTH POINTER  AK#2
         PACK  TDDAYR(2),TDIDATE+2(3)  PACK DAYS INTO DAYS REMAING AK#2
TDLOOP2 DS     0H                                                  AK#2
         MVC   TDDAY(2),TDDAYR         SAVE DAYS REMAINING         AK#2
         SP    TDDAYR(2),0(2,R8)       SUB DAY IN MONTH FROM DAYS  AK#2
         CP    TDDAYR(2),=P'0'         Q. COMPARE IF NEGATIVE      AK#2
         BL    TDXLOP2                    Y. EXIT LOOP             AK#2
         CP    TDDAYR(2),=P'0'         Q. COMPARE IF ZERO          AK#2
         BZ    TDXLOP2                    Y. EXIT LOOP             AK#2
         LA    R8,2(R8)                POINT TO NEXT MONTH         AK#2
         LA    R9,1(R9)                INCREMENT MONTH COUNTER     AK#2
         B     TDLOOP2                 RECALCULATE                 AK#2
TDXLOP2 DS     0H                                                  AK#2
         UNPK  TDDDD(3),TDDAY(2)       SAVE CURRENT DAYS           AK#2
         OI    TDD+1,X'F0'             CHANGE SIGN OF LAST DEC BYTEAK#2
         MVC   TDDATE1(2),TDD          MOVE 2 BYTES OF DAY TO OUT FLD#2
         CVD   R9,TARGET               CONVERT MONTH TO DEC/PACKED AK#2
         UNPK  TDMMM(3),TARGET+6(2)    UNPACK MONTH                AK#2
         OI    TDMM+1,X'F0'            CHG SIGN OF LAST BYTE OF MTHAK#2
         MVC   TDDATE1+3(2),TDMM       MOVE MONTH TO OUT FIELD     AK#2
         MVC   DATEOUT(8),TDDATE1      MOVE TO DESTINATION         AK#2
         LM    R0,R14,SAVSUBR1         RESTORE REGISTERS           AK#2
         BR    R14                     RETURN TO CALLER            AK#2
*--------------------------- AK#2 ---------------------------------AK#2
******************** INSTRUCTIONS TO BE EXECUTED **********************
*
MOVEDSN  MVC   DSNBUF(0),0(R5)
MOVEVOL  MVC   VOLUME(0),0(R7)
PACKCOPY PACK  DEC(8),0(0,R7)
         USING DAPB08,R8
MOVEMEM  MVC   DA08MNM(0),0(R5)
MOVEPASS MVC   DA08PSWD(0),0(R5)
         DROP  R8
*
***************************** LITERALS ********************************
         LTORG
***************************** CONSTANTS *******************************
*
******************** DAIR CONTROL BLOCK CONSTANTS *********************
DAPB08C  DS    0F
         DC    X'0008'                 DA08CD
         DC    H'0'                    DA08FLG
         DC    H'0'                    DA08DARC
         DC    H'0'                    DA08CTRC
         DC    A(0)                    DA08PDSN
         DC    CL8'PRINTI  '           DA08DDN
         DC    CL8' '                  DA08UNIT
         DC    CL8' '                  DA08SER
         DC    F'0'                    DA08BLK
         DC    F'0'                    DA08PQTY
         DC    F'0'                    DA08SQTY
         DC    F'0'                    DA08DQTY
         DC    CL8' '                  DA08MNM
         DC    CL8' '                  DA08PSWD
         DC    X'08'                   DA08DSP1      SHR
         DC    X'08'                   DA08DSP2      KEEP
         DC    X'08'                   DA08DSP3      KEEP
         DC    X'08'                   DA08CTL       PERM
         DC    F'0'                    DA08DSO
         DC    CL8' '                  DA08ALN
DAPB08L  EQU   *-DAPB08C               LENGTH
         SPACE 2
DAPB18C  DS    0F
         DC    X'0018'                 DA18CD
         DC    X'0000'                 DA18FLG
         DC    H'0'                    DA18DARC
         DC    H'0'                    DA18CTRC
         DC    F'0'                    DA18PDSN
         DC    CL8'PRINTI'             DA18DDN
         DC    CL8' '                  DA18MNM
         DC    CL2' '                  DA18SCLS
         DC    X'08'                   DA18DPS2
         DC    X'10'                   DA18CTL
         DC    CL8' '                  DA18JBNM
DAPB18L  EQU   *-DAPB18C               LENGTH
         SPACE 2
INPUTC   DCB   DSORG=PS,MACRF=(GM),EODAD=EXIT,SYNAD=ERRI,DDNAME=PRINTI
INPUTL   EQU   *-INPUTC
*
OUTPUTAC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTA,RECFM=VBA, X
               LRECL=256,BLKSIZE=3120
OUTPUTAL EQU   *-OUTPUTAC
*
OUTPUTMC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTM,RECFM=VBM, X
               LRECL=256,BLKSIZE=3120
OUTPUTML EQU   *-OUTPUTMC
*
DIRECTC  DCB   DDNAME=PRINTI,DSORG=PS,MACRF=(GM),RECFM=U,BLKSIZE=256,  X
               SYNAD=SERRI,EODAD=FREEBLK
DIRECTL  EQU   *-DIRECTC
*
OPENCLOS OPEN  (,),MF=L
         SPACE 2
*-------------\|/----------- AK#2 -------------\|/-----------------AK#2
HEADERB1 DS    0F
         DC    H'68'
         DC    H'0'
HDRCTLB1 DC    C' '
         DC    CL63'          *-----------------------------------------
               -----------*'
HEADERB2 DS    0F
         DC    H'68'
         DC    H'0'
HDRCTLB2 DC    C' '
         DC    CL63'          *                                        X
                          *'
HEADERC  DS    0F
         DC    H'68'
         DC    H'0'
HDRCTLC  DC    C' '
         DC    CL63'          *         **** TSO FOREGROUND HARDCOPY ***
               **         *'
HEADERM  DS    0F
         DC    H'68'
         DC    H'0'
HDRCTLM  DC    C' '
         DC    CL63'          *         ** TSO FOREGROUND MEMBER LIST **
               **         *'
HEADERT  DS    0F
         DC    H'68'
         DC    H'0'
HDRCTLT  DC    C' '
         DC    CL63'          *         TIME= ..:..:..    DATE= ../../..
               .          *'
LDSNAME  DS    0CL33
         ORG   LDSNAME
         DC    H'33'
         DC    H'0'
LDSNCTLC DC    C' '
         DC    CL28'          *         DSNAME='''
EJECTM   DS    0F
         DC    H'5'
         DC    H'0'
         DC    X'8B'
EJECTA   DS    0F
         DC    H'5'
         DC    H'0'
         DC    C'1'
SPACE    EQU   EJECTA
         SPACE 2
FULL0    DC    F'0'
FULL1    DC    F'1'
FULL4    DC    F'4'
FULL20   DC    F'20'
FULL28   DC    F'28'
FULL256  DC    F'256'
PRINTILN DC    H'12',H'0'
PRINTI   DC    CL8'PRINTI'
PRINTALN DC    H'12',H'0'
PRINTA   DC    CL8'PRINTA'
PRINTMLN DC    H'12',H'0'
PRINTM   DC    CL8'PRINTM'
BLANKS   DC    256CL1' '
SPACES   ORG   BLANKS
         ORG
ALIAS    DC    CL8' *ALIAS*'
ENDCHAIN DS    0F
         DC    X'FF000000'
MEMDATL  DC    X'00'                   SUBPOOL NUMBER
         DC    AL3(LINECNT*36+8)       CALC TABLE SPACE
LINECNT  EQU   50                      DEFAULT LINES PER PAGE FOR
*                                      MEMBER NAME LIST.  MODIFY
*                                      ABOVE STATEMENT TO CHANGE
*                                      NUMBER OF LINES PER PAGE
*                                      IN MEMBER NAME LIST.
HALF0    DC    H'0'
HALF1    DC    H'1'
HALF2    DC    H'2'
HALF6    DC    H'6'
HALF8    DC    H'8'
HALF12   DC    H'12'
HALF85   DC    H'85'
HALF251  DC    H'251'
HALF252  DC    H'252'
HALF255  DC    H'255'
HALF256  DC    H'256'
PATCH    DC    8CL4'ZAP*'
EDPAT1   DC    X'4020202020202120'                                 AK#3
TDTABL1  DC    C'0123456789ABCDEF'                                 AK#2
TDTABL2 DS     0CL24              DAYS OF MONTH IN YEAR TABLE      AK#2
         DC    P'31'              J                                AK#2
         DC    P'28'              F                                AK#2
         DC    P'31'              M                                AK#2
         DC    P'30'              A                                AK#2
         DC    P'31'              M                                AK#2
         DC    P'30'              J                                AK#2
         DC    P'31'              J                                AK#2
         DC    P'31'              A                                AK#2
         DC    P'30'              S                                AK#2
         DC    P'31'              O                                AK#2
         DC    P'30'              N                                AK#2
         DC    P'31'              D                                AK#2
HEXFF    EQU   X'FF'
HIGH     EQU   X'80'
BLANK    EQU   X'40'
LOW      EQU   X'01'
NOSEQ    EQU   X'01'
NOHEAD   EQU   X'01'
HEXPRNT  EQU   X'01'
JFCPDS   EQU   X'01'
HEX00    EQU   X'00'
SCLSA    EQU   C'A'
SKIPM    EQU   X'09'
DSOPS    EQU   X'40'
DSOPO    EQU   X'02'
NOWTP    EQU   X'00'
         SPACE 2
****************** POINTER TO PARS PARAMETER CSECT ********************
PCLADDR  DC    A(PARMTAB)
         SPACE 2
************************ PARS PARAMETER LIST **************************
PARMTAB  IKJPARM  DSECT=IKJPARMD
DSNAMES  IKJPOSIT  DSNAME,LIST,USID,                                   X
               PROMPT='DSNAME',                                        X
               HELP='DSNAME TO BE PRINTED'
PCLASS   IKJKEYWD
         IKJNAME 'CLASS',SUBFLD=CLASSUB
PDEST    IKJKEYWD
         IKJNAME 'DEST',SUBFLD=DESTSUB
PFCB     IKJKEYWD
         IKJNAME 'FCB',SUBFLD=FCBSUB
PHOLD    IKJKEYWD
         IKJNAME 'HOLD'
         IKJNAME 'NOHOLD'
PHEX     IKJKEYWD
         IKJNAME 'HEX'
         IKJNAME 'NOHEX '
PSEQ     IKJKEYWD
         IKJNAME 'SEQ'
         IKJNAME 'NOSEQ'
PHEAD    IKJKEYWD
         IKJNAME 'HEAD'
         IKJNAME 'NOHEAD'
PCOPIES  IKJKEYWD
         IKJNAME 'COPIES',SUBFLD=COPYSUB
PPRINT   IKJKEYWD
         IKJNAME 'PRINT'
         IKJNAME 'NOPRINT'
PLIST    IKJKEYWD
         IKJNAME 'LIST'
         IKJNAME 'NOLIST'
PVOL     IKJKEYWD
         IKJNAME 'VOLUME',SUBFLD=VOLSUB
PFOLD    IKJKEYWD
         IKJNAME 'FOLD'
         IKJNAME 'NOFOLD'
*        B E G I N   S U B F I E L D S
CLASSUB  IKJSUBF
SCLASS   IKJIDENT 'CLASSNAME',LIST,FIRST=NONATNUM,MAXLNTH=1,           X
               PROMPT='CLASS NAME'
DESTSUB  IKJSUBF
SDEST    IKJPOSIT JOBNAME,                                       DEST8 X
               PROMPT='REMOTE STATION ID FOR THE DEST KEYWORD'
FCBSUB   IKJSUBF
SFCB     IKJIDENT 'FCB',LIST,FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=4,  X
               PROMPT='1-4 DIGITS FCB NAME'
COPYSUB  IKJSUBF
SCOPIES  IKJIDENT 'COPIES',MAXLNTH=3,                                  X
               FIRST=NUMERIC,OTHER=NUMERIC,                            X
               PROMPT='1-3 DIGITS - NUMBER OF COPIES OF OUTPUT',       X
               HELP=('NUMBER OF COPIES OF PRINTOUT DESIRED')
VOLSUB   IKJSUBF
SVOL     IKJIDENT 'VOLUME',MAXLNTH=8,                                  X
               FIRST=ALPHANUM,OTHER=ALPHANUM,                          X
               PROMPT='VOLUME SERIAL FOR DATA SETS TO BE PRINTED',     X
               HELP=('VOLUME SERIAL WILL BE ASSUMED FOR ALL DATA SETS')
         IKJENDP
         SPACE 2
****************************** MESSAGES *******************************
GNRLERR  DC    AL2(GNRLERRL),AL2(0)
         DC    C'AN ERROR WAS ENCOUNTERED IN THE GENERAL FAIL SERVICE RX
               OUTINE.  THE RETURN CODE FROM GNRLFAIL IS: '
GNRLERRL EQU   *-GNRLERR
*
DRFLERR  DC    AL2(DRFLERRL),AL2(0)
         DC    C'AN ERROR WAS ENCOUNTERED IN THE DAIR FAIL SERVICE ROUTX
               INE.  THE RETURN CODE FROM DAIR FAIL IS: '
DRFLERRL EQU   *-DRFLERR
*
OPENMSG  DC    AL2(OPENMSGL),AL2(0)
         DC    C'OUPUT PROCESSING IS BEING TERMINATED.  AN ERROR WAS ENX
               COUNTERED ATTEMPTING TO OPEN THE OUTPUT DATASET ASSOCIATX
               ED WITH DDNAME: '
OPENMSGL EQU   *-OPENMSG
*
DSNNOTP  DC    AL2(DSNNOTPL),AL2(0)
         DC    C'AN ERROR OCCURRED AND YOUR DATASET WAS NOT PRINTED.'
DSNNOTPL EQU   *-DSNNOTP
*
DSNMSG   DC    AL2(DSNMSGL),AL2(0)
         DC    C'PROCESSING HAS BEEN COMPLETED FOR DATASET: '
DSNMSGL  EQU   *-DSNMSG
DSNMSG1  DC    AL2(DSNMSGL1),AL2(0)                                AK#3
         DC    C'PROCESSING STARTED FOR '''                        AK#3
DSNMSGL1 EQU   *-DSNMSG1                                           AK#3
DSNMSG9  DC    AL2(DSNMSGL9),AL2(0)                                AK#3
         DC    C'........ RECORDS SENT TO SYSOUT CLASS ''.'''      AK#3
DSNMSGL9 EQU   *-DSNMSG9                                           AK#3
*
MEMMSG   DC    AL2(MEMMSGL),AL2(0)
         DC    C' MEMBER: '
MEMMSGL  EQU   *-MEMMSG
*
PRTMSG   DC    AL2(PRTMSGL),AL2(0)
         DC    C'MEMBERS WILL NOW BE PRINTED FOR DATASET: '
PRTMSGL  EQU   *-PRTMSG
*
NOTPSPO  DC    AL2(NOTPSPOL),AL2(0)
         DC    C'DATASET IS NOT SEQUENTIAL OR PARTITIONED AND WAS NOT PX
               RINTED.'
NOTPSPOL EQU   *-NOTPSPO
*
INVCLAS  DC    AL2(INVCLASL),AL2(0)                                AK#1
         DC    C'INVALID CLASS. VALID ARE:'                        AK#1
INVCLASV DC    CL54' '                                             AK#1
INVCLASL EQU   *-INVCLAS                                           AK#1
*                                                                  AK#1
*---------------------------------------------------------------------*
*   VALID PRINT CLASSES                                            AK#6
*---------------------------------------------------------------------*
VCLASS   DC    C'A,E,M,T,X,'      VALID PRINTER CLASSES            AK#6
VCLASSL  EQU   *-VCLASS           VALID PRINTER CLASSES LENGTH     AK#6
*                                 CHANGE CLASS ERROR MESSAGE ALSO  AK#6
*---------------------------------------------------------------------*
*                                                                  AK#6
SYNADI   DC    AL2(SYNADIL),AL2(0)
         DC    C'A SYNAD ERROR OCURRED READING YOU INPUT DATASET AND ONX
               LY PART OF YOUR DATASET MAY HAVE BEEN PRINTED.'
SYNADIL  EQU   *-SYNADI
*
SYNADO   DC    AL2(SYNADOL),AL2(0)
         DC    C'A SYNAD ERROR OCURRED WRITING THE OUTPUT DATASET AND NX
               O MORE DATASETS WILL BE PRINTED.'
SYNADOL  EQU   *-SYNADO
*
DSNISU   DC    AL2(DSNISUL),AL2(0)
         DC    C'DATASET HAS UNDEFINED RECORD LENGTH AND WILL NOT BE PRX
               INTED.'
DSNISUL  EQU   *-DSNISU
*
DSNISL   DC    AL2(DSNISLL),AL2(0)
         DC    C'DATASET HAS LRECL > 256 AND WILL NOT BE PRINTED.'
DSNISLL  EQU   *-DSNISL
*
DSNISLF  DC    AL2(DSNISLLF),AL2(0)                              L>256
         DC    C'FIXED BLOCK DATASET HAS LRECL>251 - TRUNCATION OCCURS.'
               '
DSNISLLF EQU   *-DSNISLF                                         L>256
         SPACE 2
************************ DSECTS (MAPPING MACROS) **********************
MEMDSECT DSECT
MEMNTTR  DS    CL11
         ORG   MEMNTTR
MEMBER   DS    CL8
MEMTTR   DS    CL3
CFIELD   DS    CL1
MEMSECTN EQU   *
         IKJDAP08
DAP08LEN EQU   *-DAPB08
         IKJDAP18
DAP18LEN EQU   *-DAPB18
         IKJDAPL
DAPLLEN  EQU   *-DAPL
         IKJCPPL
CPPLLEN  EQU   *-CPPL
         IKJPPL
PPLLEN   EQU   *-PPL
         IKJIOPL
IOPLLEN  EQU   *-IOPL
         IHADSAB
TIOEDDNM EQU   4           X'1C'(OFFSET) - X'18'(JOB STEP)
         CVT   DSECT=YES
         IHAASCB
         IEFZB4D0
         IEFZB4D2
RBLEN    EQU   S99RBEND-S99RB
*        PRINT NOGEN
         DCBD  DSORG=(PS,PO)
*        PRINT GEN
         EJECT
******************** CONSTANTS FOR DYNAMIC ALLOCATION *****************
PRINTOFF CSECT
REQBLKC  DC    AL1(S99RBEND-S99RB),AL1(S99VRBAL),18AL1(0)
TEXTAC   DC    AL2(DALDDNAM),AL2(1),AL2(8),CL8'PRINT'  DDNAME
TEXTALEN EQU   *-TEXTAC
TEXTBC   DC    AL2(DALSYSOU),AL2(1),AL2(1),C'A' DEFLT SYSOUT CLASS AK#1
TEXTBLEN EQU   *-TEXTBC
TEXTCC   DC    AL2(DALSUSER),AL2(1),AL2(8),CL8'LOCAL'  DESTINATION
TEXTCLEN EQU   *-TEXTCC
TEXTDC   DC    AL2(DALSHOLD),AL2(0)                    SYSOUT HOLD
TEXTDLEN EQU   *-TEXTDC
TEXTEC   DC    AL2(DALCOPYS),AL2(1),AL2(1),AL2(1)      SYSOUT COPIES
TEXTELEN EQU   *-TEXTEC
TEXTFC   DC    AL2(DALFCBIM),AL2(1),AL2(4),CL4'6   '   FCB
TEXTFLEN EQU   *-TEXTFC
TEXTGC   DC    AL2(DALPERMA),AL2(0)                    PERM ALLOCATION
TEXTGLEN EQU   *-TEXTGC
************************* HEX PRINT *******************************AK#7
*--------------------------- AK#7 ---------------------------------AK#7
*                                                                  AK#7
*        CONVERT THE DATA TO HEX AND PRINT 2 LINES BELOW THE DATA  AK#7
*        WITH THE 1ST LINE BEING THE FIRST NIBBLE WHILE THE SECOND AK#7
*        IS THE SECOND NIBBLE. A COLOMN COUNTER IS THEN PRINTED AS AK#7
*        A SEPERATOR.                                              AK#7
*                                                                  AK#7
*        THIS ROUTINE HAS BEEN PLACED HERE BECAUSE OF ADDRESS-     AK#7
*        ABILITY PROBLEMS. ANOTHER BASE REGISTER HAS BEEN USED     AK#7
*        WITH THE HOPE OF NOT CORRUPTING OTHER ADDRESSABILITY.     AK#7
*                                                                  AK#7
*------------------------------------------------------------------AK#7
XTRARTN  DS    0H                                                  AK#7
         STM   R0,R14,SAVSUBR1         STORE REGISTERS             AK#7
         LA    R3,XTRARTN              ADDRES OF SUBROUTINE        AK#7
         USING XTRARTN,R3              ESTABLISH ADDRESABILITY     AK#7
         LA    R14,2                   SET HEX PROCESSING ID       AK#8
         CR    R1,R14                  Q. HEX PROCESSING REQUIRED  AK#8
         BE    HEXLINE                    Y. PROCESS HEX ROUTINE   AK#8
         CLI   HDRUSER+29,C'?'         Q. USERID INITIALISED       AK#8
         BNE   EXITUSER                   N. GO PUT LINE           AK#8
*------------------------------------------------------------------AK#8
*   EXTRACT THE USERID FROM THE CURRENT TCB'S (MINE) TIOT=>ASCB    AK#8
*------------------------------------------------------------------AK#8
         L     R9,16                   CVT X'10' OFFSET FROM PSA   AK#8
         USING CVT,R9                  R9 ON CVT DSECT             AK#8
         L     R9,CVTTCBP              LOAD CURRENT TCB ADDRESS    AK#8
         L     R9,12(R9)               CURRENT ASCB ADDR           AK#8
         USING ASCB,R9                 ADDRESABILITY TO THE ASCB   AK#8
         L     R2,ASCBJBNI             JOBNAME ADDR                AK#8
         CLC   ASCBJBNI,=F'0'          Q. VALUE FOR PROGRAM PTR 0  AK#8
         BNE   GOTUSER                    N. GOT USER              AK#8
         L     R2,ASCBJBNS             STC/TSUNAME ADDR            AK#8
         CLC   ASCBJBNS,=F'0'          Q. VALUE FOR LOGON PTR 0    AK#8
         BNE   GOTUSER                    N. GOT USER              AK#8
         DROP  R9                                                  AK#8
GOTUSER  DS    0H                                                  AK#8
         MVC   HDRUSER+29(7),0(R2)     MOVE USERID                 AK#8
EXITUSER DS    0H                                                  AK#8
         MVC   HEADER,HEADERU          MOVE TIME/DATE TO DATA AREA AK#8
         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER       AK#8
         B     RETHEXPT                EXIT ROUTINE                AK#8
HEXLINE  DS    0H                                                  AK#8
************************* HEX PRINT *******************************AK#7
         TM    HEXREQ,HEXPRNT          HEX PRINT REQUEST           AK#7
         BNO   RETHEXPT                NO - BYPASS HEX OUTPUT      AK#7
         MVC   CNTLSAVE(1),CNTLBYTE    SAVE CONTROL BYTE           AK#7
         MVI   CNTLBYTE,C' '           CLEAR CONTROL BYTE          AK#7
         LH    R2,LENGTH               LOAD DATA LENGTH            AK#7
         BCTR  R2,0                    LESS 1 FOR PRINT CONTROL    AK#7
         HEXCHMAC DATA,HEXDATA1,256,MF=E CONVERT HEX TO CHARACTER  AK#7
         LA    R7,HEXDATA1             SOURCE ADDRESS              AK#7
         LA    R8,HEXDATA2             DESTINATION ADDRESS         AK#7
HEXMLOP1 DS    0H                                                  AK#7
         MVC   0(1,R8),0(R7)           MOVE 1ST NIBBLE TO LINE1    AK#7
         MVC   256(1,R8),1(R7)         MOVE 1ST NIBBLE TO LINE1    AK#7
         LA    R7,2(R7)                NEXT CHAR POSITION SOURCE   AK#7
         LA    R8,1(R8)                NEXT CHAR POSITION DEST     AK#7
         BCT   R2,HEXMLOP1             LOOP TILL END               AK#7
         LH    R2,LENGTH               LOAD DATA LENGTH            AK#7
         BCTR  R2,0                    LESS 1 FOR PRINT CONTROL    AK#7
         BCTR  R2,0                    LESS 1 FOR 'EX' OPERATION   AK#7
         LA    R8,HEXDATA2             1ST. HEX LINE               AK#7
         EX    R2,MOVEDAT1             MOVE LINE OF DATA           AK#7
         PUT   (R5),LINE               PUT OUT LINE                AK#7
         LA    R8,HEXDATA2+256         2ND. HEX LINE               AK#7
         EX    R2,MOVEDAT1             MOVE LINE OF DATA           AK#7
         PUT   (R5),LINE               PUT OUT LINE                AK#7
         EX    R2,MOVECOLS             MOVE COLUMN LINE            AK#7
         PUT   (R5),LINE               PUT OUT LINE                AK#7
         MVC   CNTLBYTE(1),CNTLSAVE    RESTORE CONTROL BYTE        AK#7
RETHEXPT DS    0H                                                  AK#7
         LM    R0,R14,SAVSUBR1         RESTORE REGISTERS           AK#7
         BR    R14                     RETURN TO CALLER            AK#7
*---------------------------------------------------------------------*
MOVEDAT1 MVC   DATA(0),0(R8)           MOVE DATA TO PRINTLIN
MOVECOLS MVC   DATA(0),COLS#           MOVE SEPERATOR
*------------------------------------------------------------------AK#7
*    HEX RECORD SEPERATOR                                          AK#7
COLS#    DC    C'----+----1----+----2----+----3----+----4----+----5----+
               +----6----+----7----+----8----+----9----+----0----+----1-
               ----+----2----+----3----+----4----+----5----+----6----+--
               ---7----+----8----+----9----+----0----+----1----+----2---
               --+----3----+----4----+----5----+-'
*------------------------------------------------------------------AK#7
HEADERU  DS    0F
         DC    H'68'
         DC    H'0'
HDRUSER  DC    C' '
         DC    CL63'          *         USERID= ???????                X
                          *'
         DROP  R3                                                  AK#7
*------------------------------------------------------------------AK#7
*********************** DSECT FOR DYNAMIC WORKAREA ********************
WORKAREA DSECT
SAVEAREA DS    18F
ALCSAVE  DS    12F
HEXRECL  DS    H
SEQREQ   DS    CL1
HEADREQ  DS    CL1
HEXREQ   DS    CL1
FCBREQ   DS    CL4
VOLBIT   DS    CL1
VOLUME   DS    CL8
         DS    0D
DEC      DS    2F
RETNCD   DS    F
CONV     DS    2F
IOPB     PUTLINE MF=L
DAP08    DS    0F
         ORG   DAP08+DAP08LEN
DAP18    DS    0F
         ORG   DAP18+DAP18LEN
DAPLSECT DS    0F
         ORG   DAPLSECT+DAPLLEN
PPLSECT  DS    0F
         ORG   PPLSECT+PPLLEN
IOPLSECT DS    0F
         ORG   IOPLSECT+IOPLLEN
ECB      DS    F
PARSBACK DS    F
LINE     DS    0H
LENGTH   DS    H
         DS    H
CNTLBYTE DS    CL1
DATA     DS    CL256
HEXDATA1 DS    2CL256                                              AK#7
HEXDATA2 DS    2CL256                                              AK#7
CNTLSAVE DS    CL1                                                 AK#7
SAVSUBR1 DS    18F                                                 AK#2
TARGET   DS    2D                                                  AK#2
TDDAY    DS    PL2                                                 AK#2
TDDAYR   DS    PL2                                                 AK#2
TDIDATE  DS    CL5                                                 AK#2
TDRM     DS    CL1                                                 AK#2
TDYEAR   DS    0CL3                                                AK#2
         DS    CL2                                                 AK#2
TDYEARR  DS    CL1                                                 AK#2
TDMMM    DS    0CL3                                                AK#2
         DS    CL1                                                 AK#2
TDMM     DS    CL2                                                 AK#2
TDDDD    DS    0CL3                                                AK#2
         DS    CL1                                                 AK#2
TDD      DS    CL2                                                 AK#2
TDYY     DS    CL2                                                 AK#2
TDDATE1  DS    0CL8                                                AK#2
         DS    CL2                                                 AK#2
         DS    CL1                                                 AK#2
         DS    CL2                                                 AK#2
         DS    CL1                                                 AK#2
         DS    CL2                                                 AK#2
TDBYTES  DS    0CL2                                                AK#2
TDBYTE1  DS    CL1                                                 AK#2
TDBYTE2  DS    CL1                                                 AK#2
TDTABLX  DS    0CL24              DAYS OF MONTH IN YEAR TABLE      AK#2
         DC    P'31'              J                                AK#2
         DC    P'28'              F                                AK#2
         DC    P'31'              M                                AK#2
         DC    P'30'              A                                AK#2
         DC    P'31'              M                                AK#2
         DC    P'30'              J                                AK#2
         DC    P'31'              J                                AK#2
         DC    P'31'              A                                AK#2
         DC    P'30'              S                                AK#2
         DC    P'31'              O                                AK#2
         DC    P'30'              N                                AK#2
         DC    P'31'              D                                AK#2
#OFLINES DS    F                        NO OF LINES OF OUTPUT/DSN  AK#3
DSNLEN#  DS    H                                                   AK#2
OUTCLASS DS    CL1                                                 AK#3
         DS    0H
HEADER2  DS    CL33                                                AK#2
DSNAME   DS    CL58                                                AK#2
OPENPRN  DS    CL1
MEMNAME  DS    CL8
CLOSEPRN DS    CL1
         ORG   DSNAME-4
DSNLENP  DS    CL2
DSNLEN   DS    CL2
DSNBUF   DS    CL58                                                AK#2
         ORG   MEMNAME-4
MEMNAMEL DS    CL2
         ORG
         DS    0H
HEADER   DS    CL80                     ALLOV FOR ALL LENGTHS      AK#3
         ORG   HEADER+4
HDRCNTL  DS    CL1
DFID     DS    CL2
         ORG   HEADER+4                                            AK#2
         DS    CL27                                                AK#2
TIMEOUT  DS    CL8                                                 AK#2
         DS    CL10                                                AK#2
DATEOUT  DS    CL8                                                 AK#2
         ORG
MEMTABLE DS    F
ENDTABLE DS    F
CURRENT  DS    F
PRESENT  DS    F
COLUMN   DS    F
XLIST    DS    F
HEXTOCH  HEXCHMAC   MF=L                                           AK#7
RDJL     RDJFCB (,),MF=L
JFCBAREA DS    44F
         ORG   JFCBAREA+44
JFCBELNM DS    CL8
         ORG   JFCBAREA+86
JFCBIND1 DS    CL1
         ORG   JFCBAREA+98
JFCDSRG1 DS    CL1
         ORG
SAVER6   DS    F
SAVER2   DS    2F
SAVER3   DS    2F
*
         PRINT NOGEN
*
INPUT    DCB   DSORG=PS,MACRF=(GM),EODAD=EXIT,SYNAD=ERRI,DDNAME=PRINTI
*
OUTPUTA  DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTA,RECFM=VBA, X
               LRECL=256,BLKSIZE=3120
*
OUTPUTM  DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTM,RECFM=VBM, X
               LRECL=256,BLKSIZE=3120
*
DIRECT   DCB   DDNAME=PRINTI,DSORG=PS,MACRF=(GM),RECFM=U,BLKSIZE=256,  X
               SYNAD=SERRI,EODAD=FREEBLK
*
OPENLST  OPEN  (,),MF=L
*
CLOSLST  CLOSE (,),MF=L
*
         PRINT GEN
*
RETCODE  DS    F
GFPARMP  DS    F
         IKJEFFGF
         IKJEFFDF
RBPTR    DS    F
REQBLK   DS    5F
TEXTPTRS DS    6F                                   28OCT80 PDD
TEXTA    DS    0F                                   DDNAME
         ORG   TEXTA+TEXTALEN
TEXTB    DS    0F                                   SYSOUT CLASS
         ORG   TEXTB+TEXTBLEN
TEXTC    DS    0F                                   DESTINATION
         ORG   TEXTC+TEXTCLEN
TEXTE    DS    0F                                   SYSOUT COPIES
         ORG   TEXTE+TEXTELEN
TEXTF    DS    0F                                   FCB            AK#7
         ORG   TEXTF+TEXTFLEN                                      AK#7
LDYNAMIC EQU   *-WORKAREA
         END
